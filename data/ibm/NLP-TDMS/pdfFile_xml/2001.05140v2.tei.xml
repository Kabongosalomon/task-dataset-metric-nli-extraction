<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /nfs/home/kabenamualus/Research/task-dataset-metric-extraction/../grobid-0.6.0/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">GRAPH-BERT: Only Attention is Needed for Learning Graph Representations</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jiawei</forename><surname>Zhang</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Haopeng</forename><surname>Zhang</surname></persName>
							<email>haopeng@ifmlab.org</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">⋆</forename></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Congying</forename><surname>Xia</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">University of Illinois at Chicago</orgName>
								<address>
									<region>IL</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Li</forename><surname>Sun</surname></persName>
							<email>l.sun@bupt.edu.cn</email>
							<affiliation key="aff2">
								<orgName type="institution">Beijing University of Posts and Telecommunications</orgName>
								<address>
									<settlement>Beijing</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="laboratory">⋆ IFM Lab</orgName>
								<orgName type="institution">Florida State University</orgName>
								<address>
									<settlement>Tallahassee</settlement>
									<region>FL</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">GRAPH-BERT: Only Attention is Needed for Learning Graph Representations</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>

		<encodingDesc>
			<appInfo>
				<application version="0.6.0" ident="GROBID-SDO" when="2021-06-26T09:02+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid-sdo"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The dominant graph neural networks (GNNs) overrely on the graph links, several serious performance problems with which have been witnessed already, e.g., suspended animation problem and over-smoothing problem. What's more, the inherently inter-connected nature precludes parallelization within the graph, which becomes critical for large-sized graph, as memory constraints limit batching across the nodes. In this paper, we will introduce a new graph neural network, namely GRAPH-BERT (Graph based BERT), solely based on the attention mechanism without any graph convolution or aggregation operators. Instead of feeding GRAPH-BERT with the complete large input graph, we propose to train GRAPH-BERT with sampled linkless subgraphs within their local contexts. GRAPH-BERT can be learned effectively in a standalone mode. Meanwhile, a pre-trained GRAPH-BERT can also be transferred to other application tasks directly or with necessary fine-tuning if any supervised label information or certain application oriented objective is available. We have tested the effectiveness of GRAPH-BERT on several graph benchmark datasets. Based the pretrained GRAPH-BERT with the node attribute reconstruction and structure recovery tasks, we further fine-tune GRAPH-BERT on node classification and graph clustering tasks specifically. The experimental results have demonstrated that GRAPH-BERT can out-perform the existing GNNs in both the learning effectiveness and efficiency.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Graph provides a unified representation for many interconnected data in the real-world, which can model both the diverse attribute information of the node entities and the extensive connections among these nodes. For instance, the human brain imaging data, online social media and bio-medical molecules can all be represented as graphs, i.e., the brain graph , social graph <ref type="bibr">[Ugander et al., 2011]</ref> and molecular graph <ref type="bibr" target="#b6">[Jin et al., 2018]</ref>, respectively. Traditional machine learning models can hardly be applied to the graph data directly, which usually take the feature vectors as the inputs. Viewed in such a perspective, learning the representations of the graph structured data is an important research task.</p><p>In recent years, great efforts have been devoted to designing new graph neural networks (GNNs) for effective graph representation learning. Besides the network embedding models, e.g., node2vec <ref type="bibr" target="#b0">[Grover and Leskovec, 2016]</ref> and deepwalk <ref type="bibr" target="#b12">[Perozzi et al., 2014a]</ref>, the recent graph neural networks, e.g., GCN <ref type="bibr" target="#b9">[Kipf and Welling, 2016]</ref>, <ref type="bibr">GAT [Veličković et al., 2018]</ref> and LOOPYNET <ref type="bibr" target="#b12">[Zhang, 2018]</ref>, are also becoming much more important, which can further refine the learned representations for specific application tasks. Meanwhile, most of these existing graph representation learning models are still based on the graph structures, i.e., the links among the nodes. Via necessary neighborhood information aggregation or convolutional operators along the links, nodes' representations learned by such approaches can preserve the graph structure information.</p><p>However, several serious learning performance problem, e.g., suspended animation problem  and over-smoothing problem <ref type="bibr" target="#b12">[Li et al., 2018]</ref>, with the existing GNN models have also been witnessed in recent years. According to , for the GNNs based on the approximated graph convolutional operators <ref type="bibr" target="#b2">[Hammond et al., 2011]</ref>, as the model architecture goes deeper and reaches certain limit, the model will not respond to the training data and suffers from the suspended animation problem. Meanwhile, the node representations obtained by such deep models tend to be over-smoothed and also become indistinguishable <ref type="bibr" target="#b12">[Li et al., 2018]</ref>. Both of these two problems greatly hinder the applications of GNNs for deep graph representation learning tasks. What's more, the inherently interconnected nature precludes parallelization within the graph, which becomes critical for large-sized graph input, as memory constraints limit batching across the nodes.</p><p>To address the above problems, in this paper, we will propose a new graph neural network model, namely GRAPH-BERT (Graph based BERT). Inspired by , model GRAPH-BERT will be trained with sampled nodes together with their context (which are called linkless subgraphs in this paper) from the input large-sized graph data. Distinct from the existing GNN models, in the representation learning process, GRAPH-BERT utilizes no links in such sampled batches, which will be purely based on the attention mechanisms instead <ref type="bibr">[Vaswani et al., 2017;</ref><ref type="bibr" target="#b0">Devlin et al., 2018]</ref>. Therefore, GRAPH-BERT can get rid of the aforementioned learning effectiveness and efficiency problems with existing GNN models promisingly.</p><p>What's more, compared with computer vision <ref type="bibr" target="#b3">[He et al., 2018]</ref> and natural language processing <ref type="bibr" target="#b0">[Devlin et al., 2018]</ref>, graph neural network pre-training and fine-tuning are still not common practice by this context so far. The main obstacles that prevent such operations can be due to the diverse input graph structures and the extensive connections among the nodes. Also the different learning task objectives also prevents the transfer of GNNs across different tasks. Since GRAPH-BERT doesn't really rely on the graph links at all, in this paper, we will investigate the transfer of pre-trained GRAPH-BERT on new learning tasks and other sequential models (with necessary fine-tuning), which will also help construct the functional pipeline of models in graph learning.</p><p>We summarize our contributions of this paper as follows:</p><p>• New GNN Model: In this paper, we introduce a new GNN model GRAPH-BERT for graph data representation learning. GRAPH-BERT doesn't rely on the graph links for representation learning and can effectively address the suspended animation problems aforementioned. Also GRAPH-BERT is trainable with sampled linkless subgraphs (i.e., target node with context), which is more efficient than existing GNNs constructed for the complete input graph. To be more precise, the training cost of GRAPH-BERT is only decided by (1) training instance number, and (2) sampled subgraph size, which is uncorrelated with the input graph size at all.</p><p>• Unsupervised Pre-Training: Given the input unlabeled graph, we will pre-train GRAPH-BERT based on to two common tasks in graph studies, i.e., node attribute reconstruction and graph structure recovery. Node attribute recovery ensures the learned node representations can capture the input attribute information; whereas graph structure recovery can further ensure GRAPH-BERT learned with linkless subgraphs can still maintain both the graph local and global structure properties.</p><p>• Fine-Tuning and Transfer: Depending on the specific application task objectives, the GRAPH-BERT model can be further fine-tuned to adapt the learned representations to specific application requirements, e.g., node classification and graph clustering. Meanwhile, the pretrained GRAPH-BERT can also be transferred and applied to other sequential models, which allows the construction of functional pipelines for graph learning.</p><p>The remaining parts of this paper are organized as follows. We will introduce the related work in Section 2. Detailed information about the GRAPH-BERT model will be introduced in Section 3, whereas the pre-training and finetuning of GRAPH-BERT will be introduced in Section 4 in detail. The effectiveness of GRAPH-BERT will be tested in Section 5. Finally, we will conclude this paper in Section 6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Related Work</head><p>To make this paper self-contained, we will introduce some related topics here on GNNs, TRANSFORMER and BERT.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Graph Neural Network:</head><p>Representative examples of GNNs proposed by present include GCN <ref type="bibr" target="#b9">[Kipf and Welling, 2016]</ref>, GraphSAGE <ref type="bibr" target="#b1">[Hamilton et al., 2017]</ref> and LOOPYNET <ref type="bibr" target="#b12">[Zhang, 2018]</ref>, based on which various extended models <ref type="bibr" target="#b12">[Veličković et al., 2018;</ref><ref type="bibr" target="#b12">Sun et al., 2019;</ref><ref type="bibr" target="#b10">Klicpera et al., 2018]</ref> have been introduced as well. As mentioned above, GCN and its variant models are all based on the approximated graph convolutional operator <ref type="bibr" target="#b2">[Hammond et al., 2011]</ref>, which may lead to the suspended animation problem  and over-smoothing problem <ref type="bibr" target="#b12">[Li et al., 2018]</ref> for deep model architectures. Theoretic analyses of the reasons are provided in <ref type="bibr" target="#b12">[Li et al., 2018;</ref><ref type="bibr" target="#b0">Gürel et al., 2019]</ref>. To handle such problems,  generalizes the graph raw residual terms in <ref type="bibr" target="#b12">[Zhang, 2018]</ref> and proposes a method based on graph residual learning; <ref type="bibr" target="#b12">[Li et al., 2018]</ref> proposes to adopt residual/dense connections and dilated convolutions into the GCN architecture. Several other works <ref type="bibr" target="#b12">[Sun et al., 2019;</ref><ref type="bibr" target="#b5">Huang and Carley, 2019]</ref> seek to involve the recurrent network for deep graph representation learning instead.</p><p>BERT and TRANSFORMER: In NLP, the dominant sequence transduction models are based on complex recurrent <ref type="bibr" target="#b4">[Hochreiter and Schmidhuber, 1997;</ref><ref type="bibr" target="#b0">Chung et al., 2014]</ref> or convolutional neural networks <ref type="bibr" target="#b8">[Kim, 2014]</ref>. However, the inherently sequential nature precludes parallelization within training examples. Therefore, in <ref type="bibr">[Vaswani et al., 2017]</ref>, the authors propose a new network architecture, the TRANSFORMER, based solely on attention mechanisms, dispensing with recurrence and convolutions entirely. With TRANSFORMER, <ref type="bibr" target="#b0">[Devlin et al., 2018]</ref> further introduces BERT for deep language understanding, which obtains new state-of-the-art results on eleven natural language processing tasks. In recent years, TRANS-FORMER and BERT based learning approaches have been used extensively in various learning tasks <ref type="bibr" target="#b0">[Dai et al., 2019;</ref><ref type="bibr" target="#b11">Lan et al., 2019;</ref><ref type="bibr" target="#b12">Shang et al., 2019]</ref>.</p><p>Readers may also refer to page 1 and page 2 for more information on the state-of-the-art work on these topics.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Method</head><p>In this section, we will introduce the detailed information about the GRAPH-BERT model. As illustrated in <ref type="figure" target="#fig_2">Figure 1</ref>, GRAPH-BERT involves several parts: (1) linkless subgraph batching, (2) node input embedding, (3) graph-transformer based encoder, (4) representation fusion, and (5) the functional component. The results learned by the the graphtransformer model will be fused as the representation for the target nodes. In this section, we will introduce these key parts in great detail, whereas the pre-training and fine-tuning of GRAPH-BERT will be introduced in the following section.   </p><formula xml:id="formula_0">M Q L o E 3 i r U g N V m i P 3 K / h O K Z p x K S h g m g 9 8 H B i / I w o w 6 l g e X m Y a p Y Q O i M T N r B U k o h p P 1 t k z 9 G F V c Y o j J V 9 0 q C F + n s j I 5 H W 8 y i w k 0 V Q v e 4 V 4 n / e I D X h j Z 9 x m a S G S b o 8 F K Y C m R g V R a A x V 4 w a M b e E U M V t V k S n R B F q b F 1 l W 4 K 3 / u V N 0 r 1 q e r j p 3 W M o w R m c Q w M 8 u I Z b a E E b O k D h G V 7 g D d 6 d 3 H l 1 P p Z 1 b T m r 3 q r w B 8 7 n D 1 d + k i Y = &lt; / l a t e x i t &gt; &lt; l a</formula><formula xml:id="formula_1">V i o X i X s 8 j O g z w R D C f E a y N N L L L 1 U G A 9 d T z k 2 b 6 k N T Q R V o d 2 R V U R w s 4 6 8 T N S Q V y t E b 2 1 2 A c k j i g Q h O O l e q 7 K N L D B E v N C K d p a R A r G m E y w x P a N 1 T g g K p h s s i e O u d G G T t + K M 0 T 2 l m o v z c S H C g 1 D z w z m Q V V q 1 4 m / u f 1 Y + 1 f D x M m o l h T Q Z a H / J g 7 O n S y I p w x k 5 R o P j c E E 8 l M V o d M s c R E m 7 p K p g R 3 9 c v r p H N Z d 1 H d v U O V x m 1 e R x F O 4 Q x q 4 M I V N K A J L W g D g S d 4 h l d 4 s 1 L r x X q 3 P p a j B S v f O Y E / s D 5 / A L H F k 4 8 = &lt; / l a t e x i t &gt; &lt; l a t e x i t s h a 1 _ b a s e 6 4 = " v D 5 a a F O u a D m q Z 1 m w s T 2 D S / u U D B o = " &gt; A A A B + 3 i c b V C 7 T s M w F L 3 h W c o r l J H F o k U q S 5 V 0 g b E S S 9 m K R B 9 S W y r H d V q r j h P Z D q K K 8 i s s D C D E y o + w 8 T c 4 b Q Z o O Z K l o 3 P u 1 T 0 + X s S Z 0 o 7 z b W 1 s b m 3 v 7 B b 2 i v s H h 0 f H 9 k m p o 8 J Y E t o m I Q 9 l z 8 O K c i Z o W z P N a S + S F A c e p 1 1 v d p P 5 3 U c q F Q v F v Z 5 H d B j g i W A + I 1 g b a W S X K o M A 6 6 n n J 8 3 0 I a k 6 l 2 l l Z J e d m r M A W i d u T s q Q o z W y v w b j k M Q B F Z p w r F T f d S I 9 T L D U j H C a F g e x o h E m M z y h f U M F D q g a J o v s K b o w y h j 5 o T R P a L R Q f 2 8 k O F B q H n h m M g u q V r 1 M / M / r x 9 q / H i Z M R L G m g i w P + T F H O k R Z E W j M J C W a z w 3 B R D K T F Z E p l p h o U 1 f R l O C u f n m d d O o 1 1 6 m 5 d / V y 4 z a v o w B n c A 5 V c O E K G t C E F r S B w B M 8 w y u 8 W a n 1 Y r 1 b H 8 v R D S v f O Y U / s D 5 / A L J l k 5 E = &lt; / l a t e x i t &gt; &lt; l a t e x i t s h a 1 _ b a s e 6 4 = " v D 5 a a F O u a D m q Z 1 m w s T 2 D S / u U D B o = " &gt; A A A B + 3 i c b V C 7 T s M w F L 3 h W c o r l J H F o k U q S 5 V 0 g b E S S 9 m K R B 9 S W y r H d V q r j h P Z D q K K 8 i s s D C D E y o + w 8 T c 4 b Q Z o O Z K l o 3 P u 1 T 0 + X s S Z 0 o 7 z b W 1 s b m 3 v 7 B b 2 i v s H h 0 f H 9 k m p o 8 J Y E t o m I Q 9 l z 8 O K c i Z o W z P N a S + S F A c e p 1 1 v d p P 5 3 U c q F Q v F v Z 5 H d B j g i W A + I 1 g b a W S X K o M A 6 6 n n J 8 3 0 I a k 6 l 2 l l Z J e d m r M A W i d u T s q Q o z W y v w b j k M Q B F Z p w r F T f d S I 9 T L D U j H C a F g e x o h E m M z y h f U M F D q g a J o v s K b o w y h j 5 o T R P a L R Q f 2 8 k O F B q H n h m M g u q V r 1 M / M / r x 9 q / H i Z M R L G m g i w P + T F H O k R Z E W j M J C W a z w 3 B R D K T F Z E p l p h o U 1 f R l O C u f n m d d O o 1 1 6 m 5 d / V y 4 z a v o w B n c A 5 V c O E K G t C E F r S B w B M 8 w y u 8 W a n 1 Y r 1 b H 8 v R D S v f O Y U / s D 5 / A L J l k 5 E = &lt; / l a t e x i t &gt; &lt; l a t e x i t s h a 1 _ b a s e 6 4 = " v D 5 a a F O u a D m q Z 1 m w s T 2 D S / u U D B o = " &gt; A A A B + 3 i c b V C 7 T s M w F L 3 h W c o r l J H F o k U q S 5 V 0 g b E S S 9 m K R B 9 S W y r H d V q r j h P Z D q K K 8 i s s D C D E y o + w 8 T c 4 b Q Z o O Z K l o 3 P u 1 T 0 + X s S Z 0 o 7 z b W 1 s b m 3 v 7 B b 2 i v s H h 0 f H 9 k m p o 8 J Y E t o m I Q 9 l z 8 O K c i Z o W z P N a S + S F A c e p 1 1 v d p P 5 3 U c q F Q v F v Z 5 H d B j g i W A + I 1 g b a W S X K o M A 6 6 n n J 8 3 0 I a k 6 l 2 l l Z J e d m r M A W i d u T s q Q o z W y v w b j k M Q B F Z p w r F T f d S I 9 T L D U j H C a F g e x o h E m M z y h f U M F D q g a J o v s K b o w y h j 5 o T R P a L R Q f 2 8 k O F B q H n h m M g u q V r 1 M / M / r x 9 q / H i Z M R L G m g i w P + T F H O k R Z E W j M J C W a z w 3 B R D K T F Z E p l p h o U 1 f R l O C u f n m d d O o 1 1 6 m 5 d / V y 4 z a v o w B n c A 5 V c O E K G t C E F r S B w B M 8 w y u 8 W a n 1 Y r 1 b H 8 v R D S v f O Y U / s D 5 / A L J l k 5 E = &lt; / l a t e x i t &gt; &lt; l a t e x i t s h a 1 _ b a s e 6 4 = " v D 5 a a F O u a D m q Z 1 m w s T 2 D S / u U D B o = " &gt; A A A B + 3 i c b V C 7 T s M w F L 3 h W c o r l J H F o k U q S 5 V 0 g b E S S 9 m K R B 9 S W y r H d V q r j h P Z D q K K 8 i s s D C D E y o + w 8 T c 4 b Q Z o O Z K l o 3 P u 1 T 0 + X s S Z 0 o 7 z b W 1 s b m 3 v 7 B b 2 i v s H h 0 f H 9 k m p o 8 J Y E t o m I Q 9 l z 8 O K c i Z o W z P N a S + S F A c e p 1 1 v d p P 5 3 U c q F Q v F v Z 5 H d B j g i W A + I 1 g b a W S X K o M A 6 6 n n J 8 3 0 I a k 6 l 2 l l Z J e d m r M A W i d u T s q Q o z W y v w b j k M Q B F Z p w r F T f d S I 9 T L D U j H C a F g e x o h E m M z y h f U M F D q g a J o v s K b o w y h j 5 o T R P a L R Q f 2 8 k O F B q H n h m M g u q V r 1 M / M / r x 9 q / H i Z M R L G m g i w P + T F H O k R Z E W j M J C W a z w 3 B R D K T F Z E p l p h o U 1 f R l O C u f n m d d O o 1 1 6 m 5 d / V y 4 z a v o w B n c A 5 V c O E K G t C E F r S B w B M 8 w y u 8 W a n 1 Y r 1 b H 8 v R D S v f O Y U / s D 5 / A L J l k 5 E = &lt; / l a t e x i t &gt; &lt; l a t e x i t s h a 1 _ b a s e 6 4 = " v D 5 a a F O u a D m q Z 1 m w s T 2 D S / u U D B o = " &gt; A A A B + 3 i c b V C 7 T s M w F L 3 h W c o r l J H F o k U q S 5 V 0 g b E S S 9 m K R B 9 S W y r H d V q r j h P Z D q K K 8 i s s D C D E y o + w 8 T c 4 b Q Z o O Z K l o 3 P u 1 T 0 + X s S Z 0 o 7 z b W 1 s b m 3 v 7 B b 2 i v s H h 0 f H 9 k m p o 8 J Y E t o m I Q 9 l z 8 O K c i Z o W z P N a S + S F A c e p 1 1 v d p P 5 3 U c q F Q v F v Z 5 H d B j g i W A + I 1 g b a W S X K o M A 6 6 n n J 8 3 0 I a k 6 l 2 l l Z J e d m r M A W i d u T s q Q o z W y v w b j k M Q B F Z p w r F T f d S I 9 T L D U j H C a F g e x o h E m M z y h f U M F D q g a J o v s K b o w y h j 5 o T R P a L R Q f 2 8 k O F B q H n h m M g u q V r 1 M / M / r x 9 q / H i Z M R L G m g i w P + T F H O k R Z E W j M J C W a z w 3 B R D K T F Z E p l p h o U 1 f R l O C u f n m d d O o 1 1 6 m 5 d / V y 4 z a v o w B n c A 5 V c O E K G t C E F r S B w B M 8 w y u 8 W a n 1 Y r 1 b H 8 v R D S v f O Y U / s D 5 / A L J l k 5 E = &lt; / l a t e x i t &gt; &lt; l a t e x i t s h a 1 _ b a s e 6 4 = " v D 5 a a F O u a D m q Z 1 m w s T 2 D S / u U D B o = " &gt; A A A B + 3 i c b V C 7 T s M w F L 3 h W c o r l J H F o k U q S 5 V 0 g b E S S 9 m K R B 9 S W y r H d V q r j h P Z D q K K 8 i s s D C D E y o + w 8 T c 4 b Q Z o O Z K l o 3 P u 1 T 0 + X s S Z 0 o 7 z b W 1 s b m 3 v 7 B b 2 i v s H h 0 f H 9 k m p o 8 J Y E t o m I Q 9 l z 8 O K c i Z o W z P N a S + S F A c e p 1 1 v d p P 5 3 U c q F Q v F v Z 5 H d B j g i W A + I 1 g b a W S X K o M A 6 6 n n J 8 3 0 I a k 6 l 2 l l Z J e d m r M A W i d u T s q Q o z W y v w b j k M Q B F Z p w r F T f d S I 9 T L D U j H C a F g e x o h E m M z y h f U M F D q g a J o v s K b o w y h j 5 o T R P a L R Q f 2 8 k O F B q H n h m M g u q V r 1 M / M / r x 9 q / H i Z M R L G m g i w P + T F H O k R Z E W j M J C W a z w 3 B R D K T F Z E p l p h o U 1 f R l O C u f n m d d O o 1 1 6 m 5 d / V y 4 z a v o w B n c A 5 V c O E K G t C E F r S B w B M 8 w y u 8 W a n 1 Y r 1 b H 8 v R D S v f O Y U / s D 5 / A L J l k 5 E = &lt; / l a t e x i t &gt; Part 5 z i &lt; l a t e x i t s h a 1 _ b a s e 6 4 = " 2 r L D q 3 3 E N a s T E g f b 1 4 u B H S C B J d A = " &gt; A A A B 9 X i c b V C 7 T s M w F L 0 p r 1 J e B U Y W i x a J q U q 6 w F j B w l g k + p D a U D m u 0 1 q 1 n c h 2 Q C X q f 7 A w g B A r / 8 L G 3 + C 0 G a D l S J a O z r l X 9 / g E M W f a u O 6 3 U 1 h b 3 9 j c K m 6 X d n b 3 9 g / K h 0 d t H S W K 0 B a J e K S 6 A d a U M 0 l b h h l O u 7 G i W A S c d o L J d e Z 3 H q j S L J J 3 Z h p T X + C R Z C E j 2 F j p v t o X 2 I y D M H 2 a D V h 1 U K 6 4 N X c O t E q 8 n F Q g R 3 N Q / u o P I 5 I I K g 3 h W O u e 5 8 b G T 7 E y j H A 6 K / U T T W N M J n h E e 5 Z K L K j 2 0 3 n q G T q z y h C F k b J P G j R X f 2 + k W G g 9 F Y G d z E L q Z S 8 T / / N 6 i Q k v / Z T J O D F U k s W h M O H I R C i r A A 2 Z o s T w q S W Y K G a z I j L G C h N j i y r Z E r z l L 6 + S d r 3 m u T X v t l 5 p X O V 1 F O E E T u E c P L i A B t x A E 1 p A Q M E z v M K b 8 + i 8 O O / O x 2 K 0 4 O Q 7 x / A H z u c P P 6 + S V A = = &lt; / l a t e x i t &gt; &lt; l a t e x i t s h a 1 _ b a s e 6 4 = " 2 r L D q 3 3 E N a s T E g f b 1 4 u B H S C B J d A = " &gt; A A A B 9 X i c b V C 7 T s M w F L 0 p r 1 J e B U Y W i x a J q U q 6 w F j B w l g k + p D a U D m u 0 1 q 1 n c h 2 Q C X q f 7 A w g B A r / 8 L G 3 + C 0 G a D l S J a O z r l X 9 / g E M W f a u O 6 3 U 1 h b 3 9 j c K m 6 X d n b 3 9 g / K h 0 d t H S W K 0 B a J e K S 6 A d a U M 0 l b h h l O u 7 G i W A S c d o L J d e Z 3 H q j S L J J 3 Z h p T X + C R Z C E j 2 F j p v t o X 2 I y D M H 2 a D V h 1 U K 6 4 N X c O t E q 8 n F Q g R 3 N Q / u o P I 5 I I K g 3 h W O u e 5 8 b G T 7 E y j H A 6 K / U T T W N M J n h E e 5 Z K L K j 2 0 3 n q G T q z y h C F k b J P G j R X f 2 + k W G g 9 F Y G d z E L q Z S 8 T / / N 6 i Q k v / Z T J O D F U k s W h M O H I R C i r A A 2 Z o s T w q S W Y K G a z I j L G C h N j i y r Z E r z l L 6 + S d r 3 m u T X v t l 5 p X O V 1 F O E E T u E c P L i A B t x A E 1 p A Q M E z v M K b 8 + i 8 O O / O x 2 K 0 4 O Q 7 x / A</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Notations</head><p>In the sequel of this paper, we will use the lower case letters (e.g., x) to represent scalars, lower case bold letters (e.g., x) to denote column vectors, bold-face upper case letters (e.g., X) to denote matrices, and upper case calligraphic letters (e.g., X ) to denote sets or high-order tensors. Given a matrix X, we denote X(i, ∶) and X(∶, j) as its i th row and j th column, respectively. The (i th , j th ) entry of matrix X can be denoted as either X(i, j). We use X ⊺ and x ⊺ to represent the transpose of matrix X and vector x. For vector x, we represent its L p -norm as x p = (∑ i x(i) p ) 1 p . The Frobenius-norm of matrix X is represented as X F = (∑ i,j X(i, j) 2 ) 1 2 . The element-wise product of vectors x and y of the same dimension is represented as x ⊗ y, whose concatenation is represented as x ⊔ y.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Linkless Subgraph Batching</head><p>Prior to talking about the subgraph batching method, we would like to present the problem settings first. Formally, we can represent the input graph data as G = (V, E, w, x, y), where V and E denote the sets of nodes and links in graph G, respectively. Mapping w ∶ E → R projects links to their weight; whereas mappings x ∶ V → X and y ∶ V → Y can project the nodes to their raw features and labels. The graph size can be represented by the number of involved nodes, i.e., V . The above term defines a general graph concept. If the studied G is unweighted, we will have w(</p><formula xml:id="formula_2">v i , v j ) = 1, ∀(v i , v j ) ∈ E; whereas ∀(v i , v j ) ∈ V × V ∖ E, we have w(v i , v j ) = 0.</formula><p>Notations X and Y denote feature space and label space, respectively. In this paper, we can simply represent X = R dx and Y = R dy . For node v i , we can also simplify its raw feature and label vector representations as</p><formula xml:id="formula_3">x i = x(v i ) ∈ R dx and y i = y(v i ) ∈ R dy .</formula><p>The GRAPH-BERT model pre-training doesn't require any label supervision information actually, but partial of the labels will be used for the fine-tuning application task on node classification to be introduced later.</p><p>Instead of working on the complete graph G, GRAPH-BERT will be trained with linkless subgraph batches sampled from the input graph instead. It will effectively enable the learning of GRAPH-BERT to parallelize (even though we will not study parallel computing of GRAPH-BERT in this paper) on extremely large-sized graphs that the existing graph neural networks cannot handle. Different approaches can be adopted here to sample the subgraphs from the input graph as studied in . However, to control the randomness involved in the sampling process, in this paper, we introduce the top-k intimacy sampling approach instead. Such a sampling algorithm works based on the graph intimacy matrix S ∈ R V × V , where entry S(i, j) measures the intimacy score between nodes v i and v j .</p><p>There exist different metrics to measure the intimacy scores among the nodes within the graph, e.g., Jaccard's coefficienty <ref type="bibr" target="#b5">[Jaccard, 1901]</ref>, Adamic/Adar <ref type="bibr" target="#b0">[Adamic and Adar, 2003</ref>], Katz <ref type="bibr" target="#b7">[Katz, 1953]</ref>. In this paper, we define matrix S based on the pagerank algorithm, which can be denoted as</p><formula xml:id="formula_4">S = α ⋅ I − (1 − α) ⋅Ā −1 ,<label>(1)</label></formula><p>where factor α ∈ [0, 1] (which is usually set as 0.15). Term A = AD −1 denotes the colum-normalized adjacency matrix. In its representation, A is the adjacency matrix of the input graph, and D is its corresponding diagonal matrix with D(i, i) = ∑ j A(i, j) on its diagonal. Formally, for any target node v i ∈ V in the input graph, based on the intimacy matrix S, we can define its learning context as follows: DEFINITION 1. (Node Context): Given an input graph G and its intimacy matrix S, for node v i in the graph, we define its learning context as set Γ(</p><formula xml:id="formula_5">v i ) = {v j v j ∈ V ∖ {v i } ∧ S(i, j) ≥ θ i }.</formula><p>Here, the term θ i defines the minimum intimacy score threshold for nodes to involve in v i 's context.</p><p>We may need to add a remark: for all the nodes in v i ' learning context Γ(v i ), they can cover both local neighbors of v i as well as the nodes which are far away. In this paper, we define the threshold θ i as the k th entry of sorted(S(i, ∶)) (with v i being excluded), i.e., Γ(v i ) covers the top-k intimate nodes of v i in graph G. Based on the node context concept, we can also represent the set of sampled graph batches for all the nodes as set G = {g 1 , g 2 , ⋯, g V }, and g i denotes the subgraph sampled for v i (as the target node). Formally, g i can be represented as g i = (V i , ∅), where the node set V i = {v i } ∪ Γ(v i ) covers both v i and its context nodes and the link set is null. For large-sized input graphs, set G can further be decomposed into several mini-batches, i.e., B ⊆ G, which will be fed to train the GRAPH-BERT model.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Node Input Vector Embeddings</head><p>Different from image and text data, where the pixels and words/chars have their inherent orders, nodes in graphs are orderless. The GRAPH-BERT model to be learned in this paper doesn't require any node orders of the input sampled subgraph actually. Meanwhile, to simplify the presentations, we still propose to serialize the input subgraph nodes into certain ordered list instead. Formally, for all the nodes V i in the sampled linkless subgraph g i ∈ B, we can denote them as a node list</p><formula xml:id="formula_6">[v i , v i,1 , ⋯, v i,k ], where v i,j will be placed ahead of v i,m if S(i, j) &gt; S(i, m), ∀v i,j , v i,m ∈ V i .</formula><p>For the remaining of this subsection, we will follow the identical node orders as indicated above by default to define their input vector embeddings.</p><p>The input vector embeddings to be fed to the graphtransformer model actually cover four parts: (1) raw feature vector embedding, (2) Weisfeiler-Lehman absolute role embedding, (3) intimacy based relative positional embedding, and (4) hop based relative distance embedding, respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Raw Feature Vector Embedding</head><p>Formally, for each node v j ∈ V i in the subgraph g i , we can embed its raw feature vector into a shared feature space (of the same dimension d h ) with its raw feature vector x j , which can be denoted as</p><formula xml:id="formula_7">e (x) j = Embed (x j ) ∈ R d h ×1 .</formula><p>(2) Depending on the input raw features properties, different models can be used to define the Embed(⋅) function. For instance, CNN can be used if x j denotes images; LSTM/BERT can be applied if x j denotes texts; and simple fully connected layers can also be used for simple attribute inputs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Weisfeiler-Lehman Absolute Role Embedding</head><p>The Weisfeiler-Lehman (WL) algorithm <ref type="bibr" target="#b12">[Niepert et al., 2016]</ref> can label the nodes according to their structural roles in the graph data, where the nodes with the identical roles will be labeled with the same code (e.g., integer strings or node colors). Formally, for node v j ∈ V i in the sampled subgraph, we can denote its WL code as WL(v j ) ∈ N, which can be pre-computed based on the complete graph and is invariant for different sampled subgraphs. In this paper, we adopt the embedding approach proposed in <ref type="bibr">[Vaswani et al., 2017]</ref> and define the nodes WL absolute role embedding vector as e (r)</p><formula xml:id="formula_8">j = Position-Embed (WL(v j )) = sin WL(v j ) 10000 2l d h , cos WL(v j ) 10000 2l+1 d h ⌊ d h 2 ⌋ l=0 ,<label>(3)</label></formula><p>where e (r) j ∈ R d h ×1 . The index l iterates throughout all the entries in the above vector to compute the entry values with sin(⋅) and cos(⋅) functions for the node based on its WL code.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Intimacy based Relative Positional Embedding</head><p>The WL based role embeddings can capture the global node role information in the representations. Here, we will introduce a relative positional embedding to extract the local information in the subgraph based on the placement orders of the serialized node list introduced at the beginning of this subsection. Formally, based on that serialized node list, we can denote the position of v j ∈ V i as P (v j ). We know that P (v i ) = 0 by default and nodes closer to v i will have a small positional index. Furthermore, P (⋅) is a variant position index metric. For the identical node v j , its positional index P (v j ) will be different for different sampled subgraphs. Formally, for node v j , we can also extract its intimacy based relative positional embedding with the Position-Embed(⋅) function defined above as follows:</p><formula xml:id="formula_9">e (p) j = Position-Embed (P(v j )) ∈ R d h ×1 ,<label>(4)</label></formula><p>which is quite close to the positional embedding in <ref type="bibr">[Vaswani et al., 2017]</ref> for the relative positions in the word sequence.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Hop based Relative Distance Embedding</head><p>The hop based relative distance embedding can be treated as a balance between the absolute role embedding (for global information) and intimacy based relative positional embedding (for local information). Formally, for node v j ∈ V i in the subgraph g i , we can denote its relative distance in hops to v i in the original input graph as H(v j ; v i ), which can be used to define its embedding vector as</p><formula xml:id="formula_10">e (d) j = Position-Embed (H(v j ; v i )) ∈ R d h ×1 . (5)</formula><p>It it easy to observe that vector e (d) j will also be variant for the identical node v j in different subgraphs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Graph Transformer based Encoder</head><p>Based on the computed embedding vectors defined above, we will be able to aggregate them together to define the initial input vectors for nodes, e.g., v j , in the subgraph g i as follows:</p><formula xml:id="formula_11">h (0) j = Aggregate(e (x) j , e (r) j , e (p) j , e (d) j ).<label>(6)</label></formula><p>In this paper, we simply define the aggregation function as the vector summation. Furthermore, the initial input vectors for all the nodes in g i can organized into a matrix</p><formula xml:id="formula_12">H (0) = [h (0) i , h (0) i,1 , ⋯, h<label>(0)</label></formula><p>i,k ] ⊺ ∈ R (k+1)×d h . The graph-transformer based encoder to be introduced below will update the nodes' representations iteratively with multiple layers (D layers), and the output by the l th layer can be denoted as</p><formula xml:id="formula_13">H (l) = G-Transformer H (l−1) = softmax QK ⊺ √ d h V + G-Res H (l−1) , X i ,<label>(7)</label></formula><p>where</p><formula xml:id="formula_14">⎧ ⎪ ⎪ ⎪ ⎪ ⎨ ⎪ ⎪ ⎪ ⎪ ⎩ Q = H (l−1) W (l) Q , K = H (l−1) W (l) K , V = H (l−1) W (l) V .<label>(8)</label></formula><p>In the above equations, W</p><formula xml:id="formula_15">(l) Q , W (l) K , W (l) K ∈ R d h ×d h denote</formula><p>the involved variables. To simplify the presentations in the paper, we assume nodes' hidden vectors in different layers have the same length. Notation G-Res H (l−1) , X i represents the graph residual term introduced in [Zhang and <ref type="bibr" target="#b12">Meng, 2019]</ref>, and X i ∈ R (k+1)×dx is the raw features of all nodes in the subgraph g i . Also different from conventional residual learning, we will add the residual terms computed for the target node v i to the hidden state vectors of all the nodes in the subgraph at each layer. Based on the graph-transformer function defined above, we can represent the representation learning process of GRAPH-BERT as follows:</p><formula xml:id="formula_16">⎧ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎨ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎩ H (0) = [h (0) i , h (0) i,1 , ⋯, h (0) i,k ] ⊺ , H (l) = G-Transformer H (l−1) , ∀l ∈ {1, 2, ⋯, D}, z i = Fusion H (D) .<label>(9)</label></formula><p>Different from the application of conventional transformer model on NLP problems, which aims at learning the representations of all the input tokens. In this paper, we aim to apply the graph-transformer to get the representations of the target node only. In the above equation, function Fusion (⋅) will average the representations of all the nodes in input list, which defines the final state of the target v i , i.e., z i ∈ R d h ×1 .</p><p>Both vector z i and matrix H (D) will be outputted to the following functional component attached to GRAPH-BERT. Depending on the application tasks, the functional component and learning objective (i.e., the loss function) will be different. We will show more detailed information in the following section on GRAPH-BERT pre-training and fine-tuning.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">GRAPH-BERT Learning</head><p>We propose to pre-train GRAPH-BERT with two tasks: (1) node attribute reconstruction, and (2) graph structure recovery. Meanwhile, depending on the objective application tasks, e.g., (1) node classification and (2) graph clustering as studied in this paper, GRAPH-BERT can be further fine-tuned to adapt both the model and the learned node representations accordingly to the new tasks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Pre-training</head><p>The node raw attribute reconstruction task focuses on capturing the node attribute information in the learned representations, whereas the graph structure recovery task focuses more on the graph connection information instead.</p><p>Task #1: Node Raw Attribute Reconstruction Formally, for the target node v i in the sampled subgraph g i , we have its learned representation by GRAPH-BERT to be z i . Via the fully connected layer (together with the activation function layer if necessary), we can denote the reconstructed raw attributes for node v i based on z i asx i = FC(z i ). To ensure the learned representations can capture the node raw attribute information, compared against the node raw features, e.g., x i for v i , we can define the node raw attribute reconstruction based loss term as follows:</p><formula xml:id="formula_17">1 = 1 V vi∈V x i −x i 2 .<label>(10)</label></formula><p>Task #2: Graph Structure Recovery Furthermore, to ensure such representation vectors can also capture the graph structure information, the graph structure recovery task is also used as a pre-training task. Formally, for any two nodes v i and v j , based on their learned representations, we can denote the inferred connection score between them by computing their cosine similarity, i.e.,ŝ i,j = z ⊺ i zj zi zj . Compared against the ground truth graph intimacy matrix defined in Section 3.2, i.e., S, we can denote the introduced loss term as follows:</p><formula xml:id="formula_18">2 = 1 V 2 S −Ŝ 2 F ,<label>(11)</label></formula><p>whereŜ</p><formula xml:id="formula_19">∈ R V × V with entryŜ(i, j) =ŝ i,j .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Model Transfer and Fine-tuning</head><p>In applying the learned GRAPH-BERT into new learning tasks, the learned graph representations can be either fed into the new tasks directly or with necessary adjustment, i.e., finetuning. In this part, we can take the node classification and graph clustering tasks as the examples, where graph clustering can use the learned representations directly but finetuning will be necessary for the node classification task.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Task # 1: Node Classification</head><p>Based on the nodes learned representations, e.g., z i for v i , we can denote the inferred label for the node via the functional component asŷ i = softmax(FC(z i )). Compared with the nodes' true labels, we will be able to define the introduced node classification loss term on training batch T as</p><formula xml:id="formula_20">nc = vi∈T dy m=1 −y i (m) logŷ i (m).<label>(12)</label></formula><p>By re-training these stacked fully connected layers together with GRAPH-BERT (loaded from pre-training), we will be able to infer node class labels.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Task # 2: Graph Clustering</head><p>Meanwhile, for the graph clustering task, the main objective is to partition nodes in the graph into several different clusters, e.g., C = {C 1 , C 2 , ⋯, C l } (l is a hyper-parameter prespecified in advance). For each objective cluster, e.g., C j ∈ C, we can denote its center as a variable vector µ j = ∑ vi∈Cj z i ∈ R d h . For the graph clustering tasks, the main objective is to group similar nodes into the same cluster, whereas the different nodes will be partitioned into different clusters instead. Therefore, the objective function of graph clustering can be defined as follows:</p><formula xml:id="formula_21">min µ 1 ,⋯,µ l min C l j=1 vi∈Cj z i − µ j 2 .<label>(13)</label></formula><p>The above objective function involves multiple variables to be learned concurrently, which can be trained with the EM algorithm much more effectively instead of error backpropagation. Therefore, instead of re-training the above graph clustering model together with GRAPH-BERT, we will only take the learned node representations as the node feature input for learning the graph clustering model instead.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Experiments</head><p>To test the effectiveness of GRAPH-BERT in learning the graph representations, in this section, we will provide extensive experimental results of GRAPH-BERT on three realworld benchmark graph datasets, i.e., Cora, Citeseer and Pubmed , respectively.</p><p>Reproducibility. Both the datasets and source code used can be accessed via link 3 . Detailed information about the server used to run the model can be found at the footnote 4 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Dataset and Learning Settings</head><p>The graph benchmark datasets used in the experiments include Cora, Citeseer and Pubmed , which are used in most of the recent state-of-the-art graph neural network research works <ref type="bibr" target="#b9">[Kipf and Welling, 2016;</ref><ref type="bibr" target="#b12">Veličković et al., 2018;</ref>. Based on the input graph data, we will first pre-compute the node intimacy scores, based on which subgraph batches will be sampled subject to the subgraph size k ∈ {1, 2, ⋯, 10, 15, 20, ⋯, 50}. In addition, we will also pre-compute the node pairwise hop distance and WL node codes. By minimizing the node raw feature reconstruction loss and graph structure recovery loss, GRAPH-BERT can be effectively pre-trained, whose learned  variables will be transferred to the follow-up node classification and graph clustering tasks with/without fine-tuning. In the experiments, we first pre-train GRAPH-BERT based on the node attribute reconstruction task with 200 epochs, then load and pre-train the same GRAPH-BERT model again based on the graph structure recovery task with another 200 epochs.</p><p>In <ref type="figure" target="#fig_3">Figure 2</ref>, we show the learning performance of GRAPH-BERT on node attribute reconstruction and graph recovery, which converges very fast on both of these tasks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Default Parameter Settings</head><p>If not clearly specified, the results reported in this paper are based on the following parameter settings of GRAPH-BERT: subgraph size: k = 7 (Cora), k = 5 (Citeseer) and k = 30   GRAPH-BERT is a powerful mode and it can be applied to address various graph learning tasks in the standalone mode.</p><p>To show the effectiveness of GRAPH-BERT, we will first provide the experimental results of GRAPH-BERT on the node classification task without pre-training here, whereas the pretrained GRAPH-BERT based node classification results will be provided in Section 5.4 in more detail. Here, we will follow the identical train/validation/test set partitions used in the existing graph neural network papers  for fair comparisons.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Learning Convergence of Deep GRAPH-BERT</head><p>In <ref type="figure" target="#fig_4">Figure 3</ref>, we illustrate the training records of GRAPH-BERT for node classification on the Cora dataset. To show that GRAPH-BERT is different from other GNN models and GRAPH-BERT works with deep architectures, we also change the model depth with values from {1, 2, ⋯, 5, 10, 20, ⋅, 50}.</p><p>According to the plots, GRAPH-BERT can converge very fast (with less than 10 epochs) on the training set. What's more, as the model depth increases, GRAPH-BERT will not suffer from the suspended animation problem. Even the very deep GRAPH-BERT (50 layers) can still respond effectively to the training data and achieve good learning performance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Main Results</head><p>The learning results of GRAPH-BERT (with different graph residual terms) on node classification are provided in Table 1. The comparison methods used here cover both classic and state-of-the-art GNN models. For the variant models which extend GCN and GAT (with new learning settings, include more training data, re-configure the graph structure  or use new optimization methods), we didn't compare them here. However, similar techniques proposed by these extension works can be used to further help improve GRAPH-BERT as well. According to the achieved scores, we observe that GRAPH-BERT can out-perform most of these baseline methods with a big improvement on both Cora and Pubmed. On Citeseer, its perofrmance is also among the top 3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Subgraph Size k Analysis</head><p>As illustrated in <ref type="table" target="#tab_2">Table 2</ref>, we provide the learning performance analysis of GRAPH-BERT with different subgraph sizes, i.e., parameter k, on the Cora dataset. According to the results, parameter k affects the learning performance of GRAPH-BERT a lot, since it defines how many nearby nodes will be used to define the nodes' learning context. For the Cora dataset, we observe that the learning performance of GRAPH-BERT improves steadily as k increases from 1 to 7. After that, as k further increases, the performance will degrade dramatically. For the good scores with k = 1, partial contributions come from the graph residual terms in GRAPH-BERT. The time cost of GRAPH-BERT increases as k goes larger, which is very minor actually compared with other existing GNN models, like GCN and GAT. Similar results can be observed for the other two datasets, but the optimal k are different.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Graph Residual Analysis</head><p>What's more, in <ref type="table" target="#tab_3">Table 3</ref>, we also provide the learning results of GRAPH-BERT with different graph residual terms. According to the scores, GRAPH-BERT with graph-raw residual term can outperform the other two, which is also consistent with the experimental observations on these different residual terms as reported in .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Initial Embedding Analysis</head><p>As shown in <ref type="table" target="#tab_4">Table 4</ref>, we provide the learning performance of GRAPH-BERT on these three datasets, which takes different initial embeddings as the input. To better show the performance differences, the GRAPH-BERT used here doesn't <ref type="table">Table 6</ref>: Performance comparison of GRAPH-BERT on fine-tuning tasks with/without pre-training. For all the models shown here, we will only use 1 5 of the normal training max epochs as used by GRAPH-BERT in involve any residual learning. According to the results, using the Weisfeiler-Lehman role embedding, hop based distance embedding and intimacy based positional embedding vectors along, GRAPH-BERT cannot work very well actually, whereas the raw feature embeddings do contribute a lot. Meanwhile, by incorporating such complementary embeddings into the raw feature embedding, the model can achieve better performance than using raw feature embedding only.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Graph Clustering without Pre-Training</head><p>In <ref type="table" target="#tab_5">Table 5</ref>, we show the learning results of GRAPH-BERT on graph clustering without any pre-training on the three datasets. Formally, the clustering component used in GRAPH-BERT is KMeans, which takes the nodes' raw feature vectors as the input. The results are evaluated with several different metrics shown above.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Pre-training vs. No Pre-training</head><p>The results reported in the previous subsections are all based on the GRAPH-BERT without pre-training actually.</p><p>Here, we will provide the experimental results on GRAPH-BERT with pre-training to show their differences. According to the experiments, given enough training epochs, models with/without pre-training can both converge to very good learning results. Therefore, to highlight the differences, we will only use 1 5 of the normal training epochs here for finetuning GRAPH-BERT, and the results are provided in <ref type="table">Table 6</ref>. We also show the performance of GRAPH-BERT without pretraining here for comparison.</p><p>According to the scores, for most of the datasets, pretraining do give GRAPH-BERT a good initial state, which helps the model achieve better performance with only a very small number of fine-tuning epochs. On Cora and Citeseer, pre-training helps both the node classification and graph clustering tasks. Meanwhile, for Pubmed, pre-training helps node classification but degrades the results on graph clustering. Also pre-training with both node classification and graph recovery help the model to capture more information from the graph data, which also lead to higher scores than the models with single pre-training tasks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusion</head><p>In this paper, we have introduced the new GRAPH-BERT model for graph representation learning. Different from existing GNNs, GRAPH-BERT works well in deep architectures and will not suffer from the common problems with other GNNs. Based on a batch of linkless subgraphs sampled from the original graph data, GRAPH-BERT can effectively learn the representations of the target node with the extended graph-transformer layers introduced in this paper. GRAPH-BERT can serve as the graph representation learning component in graph learning pipeline. The pre-trained GRAPH-BERT can be transferred and applied to address new tasks either directly or with necessary fine-tuning.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>t e x i t s h a 1 _ b a s e 6 4 = " v D 5 a a F O u a D m q Z 1 m w s T 2 D S / u U D B o = " &gt; A A A B + 3 i c b V C 7 T s M w F L 3 h W c o r l J H F o k U q S 5 V 0 g b E S S 9 m K R B 9 S W y r H d V q r j h P Z D q K K 8 i s s D C D E y o + w 8 T c 4 b Q Z o O Z K l o 3 P u 1 T 0 + X s S Z 0 o 7 z b W 1 s b m 3 v 7 B b 2 i v s H h 0 f H 9 k m p o 8 J Y E t o m I Q 9 l z 8 O K c i Z o W z P N a S + S F A c e p 1 1 v d p P 5 3 U c q F Q v F v Z 5 H d B j g i W A + I 1 g b a W S X K o M A 6 6 n n J 8 3 0 I a k 6 l 2 l l Z J e d m r M A W i d u T s q Q o z W y v w b j k M Q B F Z p w r F T f d S I 9 T L D U j H C a F g e x o h E m M z y h f U M F D q g a J o v s K b o w y h j 5 o T R P a L R Q f 2 8 k O F B q H n h m M g u q V r 1 M / M / r x 9 q / H i Z M R L G m g i w P + T F H O k R Z E W j M J C W a z w 3 B R D K T F Z E p l p h o U 1 f R l O C u f n m d d O o 1 1 6 m 5 d / V y 4 z a v o w B n c A 5 V c O E K G t C E F r S B w B M 8 w y u 8 W a n 1 Y r 1 b H 8 v R D S v f O Y U / s D 5 / A L J l k 5 E = &lt; / l a t e x i t &gt; &lt; l a t e x i t s h a 1 _ b a s e 6 4 = " v D 5 a a F O u a D m q Z 1 m w s T 2 D S / u U D B o = " &gt; A A A B + 3 i c b V C 7 T s M w F L 3 h W c o r l J H F o k U q S 5 V 0 g b E S S 9 m K R B 9 S W y r H d V q r j h P Z D q K K 8 i s s D C D E y o + w 8 T c 4 b Q Z o O Z K l o 3 P u 1 T 0 + X s S Z 0 o 7 z b W 1 s b m 3 v 7 B b 2 i v s H h 0 f H 9 k m p o 8 J Y E t o m I Q 9 l z 8 O K c i Z o W z P N a S + S F A c e p 1 1 v d p P 5 3 U c q F Q v F v Z 5 H d B j g i W A + I 1 g b a W S X K o M A 6 6 n n J 8 3 0 I a k 6 l 2 l l Z J e d m r M AW i d u T s q Q o z W y v w b j k M Q B F Z p w r F T f d S I 9 T L D U j H C a F g e x o h E m M z y h f U M F D q g a J o v s K b o w y h j 5 o T R P a L R Q f 2 8 k O F B q H n h m M g u q V r 1 M / M / r x 9 q / H i Z M R L G m g i w P + T F H O k R Z E W j M J C W a z w 3 B R D K T F Z E p l p h o U 1 f R l O C u f n m d d O o 1 1 6 m 5 d / V y 4 z a v o w B n c A 5 V c O E K G t C E F r S B w B M 8 w y u 8 W a n 1 Y r 1 b H 8 v R D S v f O Y U / s D 5 / A L J l k 5 E = &lt; / l a t e x i t &gt; &lt; l at e x i t s h a 1 _ b a s e 6 4 = " v D 5 a a F O u a D m q Z 1 m w s T 2 D S / u U D B o = " &gt; A A A B + 3 i c b V C 7 T s M w F L 3 h W c o r l J H F o k U q S 5 V 0 g b E S S 9 m K R B 9 S W y r H d V q r j h P Z D q K K 8 i s s D C D E y o + w 8 T c 4 b Q Z o O Z K l o 3 P u 1 T 0 + X s S Z 0 o 7 z b W 1 s b m 3 v 7 B b 2 i v s H h 0 f H 9 k m p o 8 J Y E t o m I Q 9 l z 8 O K c i Z o W z P N a S + S F A c e p 1 1 v d p P 5 3 U c q F Q v F v Z 5 H d B j g i W A + I 1 g b a W S X K o M A 6 6 n n J 8 3 0 I a k 6 l 2 l l Z J e d m r M A W i d u T s q Q o z W y v w b j k M Q B F Z p w r F T f d S I 9 T L D U j H C a F g e x o h E m M z y h f U M F D q g a J o v s K b o w y h j 5 o T R P a L R Q f 2 8 k O F B q H n h m M g u q V r 1 M / M / r x 9 q / H i Z M R L G m g i w P + T F H O k R Z E W j M J C W a z w 3 B R D K T F Z E p l p h o U 1 f R l O C u f n m d d O o 1 1 6 m 5 d / V y 4 z a v o w B n c A 5 V c O E K G t C E F r S B w B M 8 w y u 8 W a n 1 Y r 1 b H 8 v R D S v f O Y U / s D 5 / A L J l k 5 E = &lt; / l a t e x i t &gt; &lt; l a t e x i t s h a 1 _ b a s e 6 4 = " h P + 6 L r U f 2 d 3 t Z a l d q a Q Q v E K M X y w = " &gt; A A A B 2 X i c b Z D N S g M x F I X v 1 L 8 6 V q 1 r N 8 E i u C o z b n Q p u H F Z w b Z C O 5 R M 5 k 4 b m s k M y R 2 h D H 0 B F 2 5 E f C 9 3 v o 3 p z 0 J b D w Q + z k n I v S c u l L Q U B N 9 e b W d 3 b / + g f u g f N f z j k 9 N m o 2 f z 0 g j s i l z l 5 j n m F p X U 2 C V J C p 8 L g z y L F f b j 6 f 0 i 7 7 + g s T L X T z Q r M M r 4 W M t U C k 7 O 6 o y a r a A d L M W 2 I V x D C 9 Y a N b + G S S 7 K D D U J x a 0 d h E F B U c U N S a F w 7 g 9 L i w U X U z 7 G g U P N M 7 R R t R x z z i 6 d k 7 A 0 N + 5 o Y k v 3 9 4 u K Z 9 b O s t j d z D h N 7 G a 2 M P / L B i W l t 1 E l d V E S a r H 6 K C 0 V o 5 w t d m a J N C h I z R x w Y a S b l Y k J N 1 y Q a 8 Z 3 H Y S b G 2 9 D 7 7 o d B u 3 w M Y A 6 n M M F X E E I N 3 A H D 9 C B L g h I 4 B X e v Y n 3 5 n 2 s u q p 5 6 9 L O 4 I + 8 z x 8 4 x I o 4 &lt; / l a t e x i t &gt; &lt; l a t e x i t s h a 1 _ b a s e 6 4 = " m p k T r c G V i G 1 T / f Z O 9 E g c x E T M k S 8 = " &gt; A A A B 8 H i c b V A 9 T 8 M w F H z h s 5 Q C o S u L R Y t U l s p h g R G J p W O R 6 I f U h s p x n d a q 4 0 S 2 g 6 i i / B U W B h D i 1 7 D x b 3 D a D t B y k q X T 3 X t 6 5 w s S w b X B + N v Z 2 t 7 Z 3 d s v H Z Q P K 0 f H J + 5 p p a v j V F H W o b G I V T 8 g m g k u W c d w I 1 g / U Y x E g W C 9 Y H Z X + L 0 n p j S P 5 Y O Z J 8 y P y E T y k F N i r D R y q / V h R M w 0 C L N W / p g 1 8 G V e H 7 k 1 3 M Q L o E 3 i r U g N V m i P 3 K / h O K Z p x K S h g m g 9 8 H B i / I w o w 6 l g e X m Y a p Y Q O i M T N r B U k o h p P 1 t k z 9 G F V c Y o j J V 9 0 q C F + n s j I 5 H W 8 y i w k 0 V Q v e 4 V 4 n / e I D X h j Z 9 x m a S G S b o 8 F K Y C m R g V R a A x V 4 w a M b e E U M V t V k S n R B F q b F 1 l W 4 K 3 / u V N 0 r 1 q e r j p 3 W M o w R m c Q w M 8 u I Z b a E E b O k D h G V 7 g D d 6 d 3 H l 1 P p Z 1 b T m r 3 q r w B 8 7 n D 1 d + k i Y = &lt; / l a t e x i t &gt; &lt; l a t e x i t s h a 1 _ b a s e 6 4 = " m p k T r c G V i G 1 T / f Z O 9 E g c x E T M k S 8 = " &gt; A A A B 8 H i c b V A 9 T 8 M w F H z h s 5 Q C o S u L R Y t U l s p h g R G J p W O R 6 I f U h s p x n d a q 4 0 S 2 g 6 i i / B U W B h D i 1 7 D x b 3 D a D t B y k q X T 3 X t 6 5 w s S w b X B + N v Z 2 t 7 Z 3 d s v H Z Q P K 0 f H J + 5 p p a v j V F H W o b G I V T 8 g m g k u W c d w I 1 g / U Y x E g W C 9 Y H Z X + L 0 n p j S P 5 Y O Z J 8 y P y E T y k F N i r D R y q / V h R M w 0 C L N W / p g 1 8 G V e H 7 k 1 3</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>t e x i t s h a 1 _ b a s e 6 4 = " v N q k 7 B o T W l 9 r u b J + a v e S 1 G 3 i h 5 8 = " &gt; A A A B + 3 i c b V C 7 T s M w F L 0 p r 1 J e o Y w s E S 1 S W S q H B c Z K L G U r E n 1 I b a k c 1 2 m t O k 5 k O 4 g q y q + w M I A Q K z / C x t / g t B m g 5 U i W j s 6 5 V / f 4 e B F n S i P 0 b R U 2 N r e 2 d 4 q 7 p b 3 9 g 8 M j + 7 j c U W E s C W 2 T k I e y 5 2 F F O R O 0 r Z n m t B d J i g O P 0 6 4 3 u 8 n 8 7 i O</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 1 :</head><label>1</label><figDesc>H z u c P P 6 + S V A = = &lt; / l a t e x i t &gt; &lt; l a t e x i t s h a 1 _ b a s e 6 4 = " 2 r L D q 3 3 E N a s T E g f b 1 4 u B H S C B J d A = " &gt; A A A B 9 X i c b V C 7 T s M w F L 0 p r 1 J e B U Y W i x a J q U q 6 w F j B w l g k + p D a U D m u 0 1 q 1 n c h 2 Q C X q f 7 A w g B A r / 8 L G 3 + C 0 G a D l S J a O z r l X 9 / g E M W f a u O 6 3 U 1 h b 3 9 j c K m 6 X d n b 3 9 g / K h 0 d t H S W K 0 B a J e K S 6 A d a U M 0 l b h h l O u 7 G i W A S c d o L J d e Z 3 H q j S L J J 3 Z h p T X + C R Z C E j 2 F j p v t o X 2 I y D M H 2 a D V h 1 U K 6 4 N X c O t E q 8 n F Q g R 3 N Q / u o P I 5 I I K g 3 h W O u e 5 8 b G T 7 E y j H A 6 K / U T T W N M J n h E e 5 Z K L K j 2 0 3 n q G T q z yh C F k b J P G j R X f 2 + k W G g 9 F Y G d z E L q Z S 8 T / / N 6 i Q k v / Z T J O D F U k s W h M O H I R C i r A A 2 Z o s T w q S W Y K G a z I j L G C h N j i y r Z E r z l L 6 + S d r 3 m u T X v t l 5 p X O V 1 F O E E T u E c P L i A B t x A E 1 p A Q M E z v M K b 8 + i 8 O O / O x 2 K 0 4 O Q 7 x / AH z u c P P 6 + S V A = = &lt; / l a t e x i t &gt; &lt; l a t e x i t s h a 1 _ b a s e 6 4 = " 2 r L D q 3 3 E N a s T E g f b 1 4 u B H S C B J d A = " &gt; A A A B 9 X i c b V C 7 T s M w F L 0 p r 1 J e B U Y W i x a J q U q 6 w F j B w l g k + p D a U D m u 0 1 q 1 n c h 2 Q C X q f 7 A w g B A r / 8 L G 3 + C 0 G a D l S J a O z r l X 9 / g E M W f a u O 6 3 U 1 h b 3 9 j c K m 6 X d n b 3 9 g / K h 0 d t H S W K 0 B a J e K S 6 A d a U M 0 l b h h l O u 7 G i W A S c d o L J d e Z 3 H q j S L J J 3 Z h p T X + C R Z C E j 2 F j p v t o X 2 I y D M H 2 a D V h 1 U K 6 4 N X c O t E q 8 n F Q g R 3 N Q / u o P I 5 I I K g 3 h W O u e 5 8 b G T 7 E y j H A 6 K / U T T W N M J n h E e 5 Z K L K j 2 0 3n q G T q z y h C F k b J P G j R X f 2 + k W G g 9 F Y G d z E L q Z S 8 T / / N 6 i Q k v / Z T J O D F U k s W h M O H I R C i r A A 2 Z o s T w q S W Y K G a z I j L G C h N j i y r Z E r z l L 6 + S d r 3 m u T X v t l 5 p X O V 1 F O E E T u E c P L i A B t x A E 1 p A Q M E z v M K b 8 + i 8 O O / O x 2 K 0 4 O Q 7 x / AH z u c P P 6 + S V A = = &lt; / l a t e x i t &gt; Hop based Relative Positional Embedding Part 4 H (D) &lt; l a t e x i t s h a 1 _ b a s e 6 4 = " 2 a Z i T n g 6 2 C f d E L H g Y k / L L P B m F N s = " &gt; A A A B + 3 i c b V D L T s J A F L 3 F F + K r 4 t L N R D D B D W n Z 6 J K o C 5 a Y y C O B S q b D F C Z M H 5 m Z G k n T X 3 H j Q m P c + i P u / B u n 0 I W C J 5 n k 5 J x 7 c 8 8 c N + J M K s v 6 N g o b m 1 v b O 8 X d 0 t 7 + w e G R e V z u y j A W h H Z I y E P R d 7 G k n A W 0 o 5 j i t B 8 J i n 2 X 0 5 4 7 u 8 n 8 3 i M V k o X B v Z p H 1 P H x J G A e I 1 h p a W S W q 0 M f q 6 n r J a 3 0 I a n d X q T V k V m x 6 t Y C a J 3 Y O a l A j v b I / B q O Q x L 7 N F C E Y y k H t h U p J 8 F C M c J p W h r G k k a Y z P C E D j Q N s E + l k y y y p + h c K 2 P k h U K / Q K G F + n s j w b 6 U c 9 / V k 1 l Q u e p l 4 n / e I F b e l Z O w I I o V D c j y k B d z p E K U F Y H G T F C i + F w T T A T T W R G Z Y o G J 0 n W V d A n 2 6 p f X S b d R t 6 2 6 f d e o N K / z O o p w C m d Q A x s u o Q k t a E M H C D z B M 7 z C m 5 E a L 8 a 7 8 b E c L R j 5 z g n 8 g f H 5 A 8 7 W k 5 4 = &lt; / l a t e x i t &gt; &lt; l a t e x i t s h a 1 _ b a s e 6 4 = " 2 a Z i T n g 6 2 C f d E L H g Y k / L L P B m F N s = " &gt; A A A B + 3 i c b V D L T s J A F L 3 F F + K r 4 t L N R D D B D W n Z 6 J K o C 5 a Y y C O B S q b D F C Z M H 5 m Z G k n T X 3 H j Q m P c + i P u / B u n 0 I W C J 5 n k 5 J x 7 c 8 8 c N + J M K s v 6 N g o b m 1 v b O 8 X d 0 t 7 + w e G R e V z u y j A W h H Z I y E P R d 7 G k n A W 0 o 5 j i t B 8 J i n 2 X 0 5 4 7 u 8 n 8 3 i M V k o X B v Z p H 1 P H x J G A e I 1 h p a W S W q 0 M f q 6 n r J a 3 0 I a n d X q T V k V m x 6 t Y C a J 3 Y O a l A j v b I / B q O Q x L 7 N F C E Y y k H t h U p J 8 F C M c J p W h r G k k a Y z P C E D j Q N s E + l k y y y p + h c K 2 P k h U K / Q K G F + n s j w b 6 U c 9 / V k 1 l Q u e p l 4 n / e I F b e l Z O w I I o V D c j y k B d z p E K U F Y H G T F C i + F w T T A T T W R G Z Y o G J 0 n W V d A n 2 6 p f X S b d R t 6 2 6 f d e o N K / z O o p w C m d Q A x s u o Q k t a E M H C D z B M 7 z C m 5 E a L 8 a 7 8 b E c L R j 5 z g n 8 g f H 5 A 8 7 W k 5 4 = &lt; / l a t e x i t &gt; &lt; l a t e x i t s h a 1 _ b a s e 6 4 = " 2 a Z i T n g 6 2 C f d E L H g Y k / L L P B m F N s = " &gt; A A A B + 3 i c b V D L T s J A F L 3 F F + K r 4 t L N R D D B D W n Z 6 J K o C 5 a Y y C O B S q b D F C Z M H 5 m Z G k n T X 3 H j Q m P c + i P u / B u n 0 I W C J 5 n k 5 J x 7 c 8 8 c N + J M K s v 6 N g o b m 1 v b O 8 X d 0 t 7 + w e G R e V z u y j A W h H Z I y E P R d 7 G k n A W 0 o 5 j i t B 8 J i n 2 X 0 5 4 7 u 8 n 8 3 i M V k o X B v Z p H 1 P H x J G A e I 1 h p a W S W q 0 M f q 6 n r J a 3 0 I a n d X q T V k V m x 6 t Y C a J 3 Y O a l A j v b I / B q O Q x L 7 N F C E Y y k H t h U p J 8 F C M c J p W h r G k k a Y z P C E D j Q N s E + l k y y y p + h c K 2 P k h U K / Q K G F + n s j w b 6 U c 9 / V k 1 l Q u e p l 4 n / e I F b e l Z O w I I o V D c j y k B d z p E K U F Y H G T F C i + F w T T A T T W R G Z Y o G J 0 n W V d A n 2 6 p f X S b d R t 6 2 6 f d e o N K / z O o p w C m d Q A x s u o Q k t a E M H C D z B M 7 z C m 5 E a L 8 a 7 8 b E c L R j 5 z g n 8 g f H 5 A 8 7 W k 5 4 = &lt; / l a t e x i t &gt; &lt; l a t e x i t s h a 1 _ b a s e 6 4 = " 2 a Z i T n g 6 2 C f d E L H g Y k / L L P B m F N s = " &gt; A A A B + 3 i c b V D L T s J A F L 3 F F + K r 4 t L N R D D B D W n Z 6 J K o C 5 a Y y C O B S q b D F C Z M H 5 m Z G k n T X 3 H j Q m P c + i P u / B u n 0 I W C J 5 n k 5 J x 7 c 8 8 c N + J M K s v 6 N g o b m 1 v b O 8 X d 0 t 7 + w e G R e V z u y j A W h H Z I y E P R d 7 G k n A W 0 o 5 j i t B 8 J i n 2 X 0 5 4 7 u 8 n 8 3 i M V k o X B v Z p H 1 P H x J G A e I 1 h p a W S W q 0 M f q 6 n r J a 3 0 I a n d X q T V k V m x 6 t Y C a J 3 Y O a l A j v b I / B q O Q x L 7 N F C E Y y k H t h U p J 8 F C M c J p W h r G k k a Y z P C E D j Q N s E + l k y y y p + h c K 2 P k h U K / Q K G F + n s j w b 6 U c 9 / V k 1 l Q u e p l 4 n / e I F b e l Z O w I I o V D c j y k B d z p E K U F Y H G T F C i + F w T T A T T W R G Z Y o G J 0 n W V d A n 2 6 p f X S b d R t 6 2 6 f d e o N K / z O o p w C m d Q A x s u o Q k t a E M H C D z B M 7 z C m 5 E a L 8 a 7 8 b E c L R j 5 z g n 8 g f H 5 A 8 7 W k 5 4 = &lt; / l a t e x i t &gt; Architecture of the GRAPH-BERT Model. (Part 1: linkless subgraph batching; Part 2: node input vector embeddings; Part 3: graph transformer based encoder; Part 4: representation fusion; Part 5: functional component. Depending on the target application task, the function component will generate different output. In the sampled subgraphs, it covers both the target node and the surrounding context nodes.)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 2 :</head><label>2</label><figDesc>Pre-training of GRAPH-BERT on node reconstruction and graph recovery tasks (x axis: iteration; y axis: training loss).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 3 :</head><label>3</label><figDesc>The learning performance of GRAPH-BERT on node classification with 1-layer, . . . , 5-layer, and 10-layer, ⋯, 50-layer on the Cora dataset. The x axis denotes the iterations over the whole training set. The y axes denote the training and testing accuracy, respectively.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1</head><label>1</label><figDesc></figDesc><table><row><cell cols="4">: Learning Performance of GRAPH-BERT (based on different</cell></row><row><cell cols="4">graph residual terms) compared against existing baseline methods</cell></row><row><cell cols="4">on node classification. The results of GRAPH-BERT reported here</cell></row><row><cell cols="4">denotes the best observed scores obtained with subgraph size k ∈ {1, 2, ⋯, 10, 15, 20, ⋯, 50}.</cell></row><row><cell>Methods</cell><cell cols="3">Datasets (Accuracy) Cora Citeseer Pubmed</cell></row><row><cell>LP ([Zhu et al., 2003])</cell><cell cols="2">0.680 0.453</cell><cell>0.630</cell></row><row><cell>ICA ([Lu and Getoor, 2003])</cell><cell cols="2">0.751 0.691</cell><cell>0.739</cell></row><row><cell>ManiReg ([Belkin et al., 2006])</cell><cell cols="2">0.595 0.601</cell><cell>0.707</cell></row><row><cell cols="3">SemiEmb ([Weston et al., 2008]) 0.590 0.596</cell><cell>0.711</cell></row><row><cell cols="3">DeepWalk ([Perozzi et al., 2014b]) 0.672 0.432</cell><cell>0.653</cell></row><row><cell>Planetoid ([Yang et al., 2016])</cell><cell cols="2">0.757 0.647</cell><cell>0.772</cell></row><row><cell>MoNet ([Monti et al., 2016])</cell><cell>0.817</cell><cell>-</cell><cell>0.788</cell></row><row><cell cols="3">GCN ([Kipf and Welling, 2016]) 0.815 0.703</cell><cell>0.790</cell></row><row><cell>GAT ([Veličković et al., 2018])</cell><cell cols="2">0.830 0.725</cell><cell>0.790</cell></row><row><cell>LOOPYNET ([Zhang, 2018])</cell><cell cols="2">0.826 0.716</cell><cell>0.792</cell></row><row><cell>GRAPH-BERT</cell><cell cols="2">0.843 0.712</cell><cell>0.793</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 2 :</head><label>2</label><figDesc>Analysis of subgraph size k on Cora for model performance (testing accuracy and testing loss) and total time cost.</figDesc><table><row><cell></cell><cell></cell><cell>Cora Dataset</cell><cell></cell></row><row><cell>k</cell><cell cols="3">Test Accuracy Test Loss Total Time Cost (s)</cell></row><row><cell>1</cell><cell>0.804</cell><cell>0.791</cell><cell>3.64</cell></row><row><cell>2</cell><cell>0.806</cell><cell>0.708</cell><cell>4.02</cell></row><row><cell>3</cell><cell>0.819</cell><cell>0.663</cell><cell>4.65</cell></row><row><cell>4</cell><cell>0.818</cell><cell>0.690</cell><cell>4.75</cell></row><row><cell>5</cell><cell>0.824</cell><cell>0.636</cell><cell>5.20</cell></row><row><cell>6</cell><cell>0.834</cell><cell>0.625</cell><cell>5.62</cell></row><row><cell>7</cell><cell>0.843</cell><cell>0.620</cell><cell>5.96</cell></row><row><cell>8</cell><cell>0.828</cell><cell>0.653</cell><cell>6.54</cell></row><row><cell>9</cell><cell>0.814</cell><cell>0.679</cell><cell>6.87</cell></row><row><cell>10</cell><cell>0.819</cell><cell>0.653</cell><cell>7.26</cell></row><row><cell>20</cell><cell>0.819</cell><cell>0.666</cell><cell>12.31</cell></row><row><cell>30</cell><cell>0.801</cell><cell>0.710</cell><cell>17.56</cell></row><row><cell>40</cell><cell>0.768</cell><cell>0.805</cell><cell>23.77</cell></row><row><cell>50</cell><cell>0.759</cell><cell>0.833</cell><cell>31.59</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 3</head><label>3</label><figDesc></figDesc><table><row><cell cols="5">: Learning performance of GRAPH-BERT with different</cell></row><row><cell cols="2">graph residual terms.</cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="2">Methods</cell><cell></cell><cell cols="2">Datasets (Accuracy)</cell></row><row><cell>Models</cell><cell cols="2">Residual Cora</cell><cell cols="2">Citeseer Pubmed</cell></row><row><cell></cell><cell>none</cell><cell>0.804</cell><cell>0.616</cell><cell>0.786</cell></row><row><cell>GRAPH-BERT</cell><cell>raw</cell><cell>0.817</cell><cell>0.653</cell><cell>0.786</cell></row><row><cell></cell><cell cols="2">graph-raw 0.843</cell><cell>0.712</cell><cell>0.793</cell></row><row><cell cols="5">5.2 Node Classification without Pre-training</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 4 :</head><label>4</label><figDesc>Learning performance of GRAPH-BERT with different initial embedding inputs.</figDesc><table><row><cell cols="2">Methods</cell><cell></cell><cell cols="2">Datasets (Accuracy)</cell></row><row><cell>Models</cell><cell cols="2">Embedding Cora</cell><cell cols="2">Citeseer Pubmed</cell></row><row><cell></cell><cell cols="2">hop distance 0.307</cell><cell>0.348</cell><cell>0.445</cell></row><row><cell></cell><cell>position</cell><cell>0.323</cell><cell>0.331</cell><cell>0.395</cell></row><row><cell>GRAPH-BERT</cell><cell>wl role</cell><cell>0.457</cell><cell>0.345</cell><cell>0.443</cell></row><row><cell></cell><cell cols="2">raw feature 0.795</cell><cell>0.611</cell><cell>0.780</cell></row><row><cell></cell><cell>all</cell><cell>0.804</cell><cell>0.616</cell><cell>0.786</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 5 :</head><label>5</label><figDesc>Clustering results of GRAPH-BERT without pre-training solely based on node raw features (MI: mutual information).</figDesc><table><row><cell>Metrics</cell><cell cols="2">Datasets Cora Citeseer Pubmed</cell></row><row><cell>Rand</cell><cell>0.080 0.249</cell><cell>0.281</cell></row><row><cell>Adjusted MI</cell><cell>0.130 0.287</cell><cell>0.313</cell></row><row><cell cols="2">Normalized MI 0.133 0.289</cell><cell>0.313</cell></row><row><cell cols="2">Homogeneity 0.133 0.287</cell><cell>0.280</cell></row><row><cell cols="2">Completeness 0.132 0.291</cell><cell>0.355</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>Table 1 .</head><label>1</label><figDesc>For KMeans, the epoch denotes its max-iter parameter.</figDesc><table><row><cell cols="2">Methods</cell><cell cols="3">Datasets (Accuracy/Rand &amp; Epoch)</cell></row><row><cell>Pre-Train Task</cell><cell>Fine-Tune Task</cell><cell>Cora</cell><cell>Citeseer</cell><cell>Pubmed</cell></row><row><cell>Node Reconstruction</cell><cell cols="2">Node Classification 0.827 30 Graph Clustering 0.400 30</cell><cell>0.649 400 0.312 400</cell><cell>0.780 100 0.027 100</cell></row><row><cell>Structural Recovery</cell><cell cols="2">Node Classification 0.823 30 Graph Clustering 0.123 30</cell><cell>0.662 400 0.090 400</cell><cell>0.788 100 0.132 100</cell></row><row><cell>Both</cell><cell cols="2">Node Classification 0.836 30 Graph Clustering 0.177 30</cell><cell>0.672 400 0.203 400</cell><cell>0.791 100 0.159 100</cell></row><row><cell>None</cell><cell cols="2">Node Classification 0.805 30 Graph Clustering 0.080 30</cell><cell>0.654 400 0.249 400</cell><cell>0.786 100 0.281 100</cell></row></table><note></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3">https://github.com/jwzhanggy/Graph-Bert 4 GPU Server: ASUS X99-E WS motherboard, Intel Core i7 CPU 6850K@3.6GHz (6 cores), 3 Nvidia GeForce GTX 1080 Ti GPU (11 GB buffer each), 128 GB DDR4 memory and 128 GB SSD swap.</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Manifold regularization: A geometric framework for learning from labeled and unlabeled examples</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Adar ; Eytan</forename><surname>Adamic</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lada</forename><forename type="middle">A</forename><surname>Adar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Belkin</surname></persName>
		</author>
		<idno>abs/1607.00653</idno>
	</analytic>
	<monogr>
		<title level="m">node2vec: Scalable feature learning for networks</title>
		<editor>Jacob Devlin, Ming-Wei Chang, Kenton Lee, and Kristina Toutanova</editor>
		<imprint>
			<publisher>Grover and Leskovec</publisher>
			<date type="published" when="1901" />
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="2399" to="2434" />
		</imprint>
	</monogr>
	<note>BERT: pre-training of deep bidirectional transformers for language understanding. An anatomy of graph neural networks going deep via the lens of mutual information: Exponential decay vs. full preservation. ArXiv, abs/1910.04499</note>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Inductive representation learning on large graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">[</forename><surname>Hamilton</surname></persName>
		</author>
		<idno>abs/1706.02216</idno>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Wavelets on graphs via spectral graph theory. Applied and Computational Harmonic</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">[</forename><surname>Hammond</surname></persName>
		</author>
		<idno>129?150</idno>
	</analytic>
	<monogr>
		<title level="j">Analysis</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="2011-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Kaiming He, Ross B. Girshick, and Piotr Dollár. Rethinking imagenet pre-training</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">[</forename><surname>He</surname></persName>
		</author>
		<idno>abs/1811.08883</idno>
		<imprint>
			<date type="published" when="2018" />
			<publisher>CoRR</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Long short-term memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sepp</forename><surname>Hochreiter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jürgen</forename><surname>Schmidhuber</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Neural Comput</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">8</biblScope>
			<date type="published" when="1997-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Inductive graph representation learning with recurrent graph neural networks. CoRR, abs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Carley ; Binxuan</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kathleen</forename><forename type="middle">M</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Carley ; Paul Jaccard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bulletin del la Société Vaudoise des Sciences Naturelles</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="page" from="547" to="579" />
			<date type="published" when="1901" />
		</imprint>
	</monogr>
	<note>Étude comparative de la distribution florale dans une portion des alpes et des jura</note>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Junction tree variational autoencoder for molecular graph generation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">[</forename><surname>Jin</surname></persName>
		</author>
		<idno>abs/1802.04364</idno>
		<imprint>
			<date type="published" when="2018" />
			<publisher>CoRR</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">A new status index derived from sociometric analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Leo</forename><surname>Katz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Katz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Psychometrika</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="39" to="43" />
			<date type="published" when="1953-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Convolutional neural networks for sentence classification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kim ; Yoon</forename><surname>Kim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2014 Conference on Empirical Methods in Natural Language Processing (EMNLP)</title>
		<meeting>the 2014 Conference on Empirical Methods in Natural Language Processing (EMNLP)<address><addrLine>Doha, Qatar</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computational Linguistics</publisher>
			<date type="published" when="2014" />
			<biblScope unit="page" from="1746" to="1751" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Semi-supervised classification with graph convolutional networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Kipf</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Welling ; Thomas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Max</forename><surname>Kipf</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Welling</surname></persName>
		</author>
		<idno>abs/1609.02907</idno>
		<imprint>
			<date type="published" when="2016" />
			<publisher>CoRR</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Personalized embedding propagation: Combining neural networks on graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">[</forename><surname>Klicpera</surname></persName>
		</author>
		<idno>abs/1810.05997</idno>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Piyush Sharma, and Radu Soricut. Albert: A lite bert for self-supervised learning of language representations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">[</forename><surname>Lan</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Isonn: Isomorphic neural network for graph representation learning and classification. CoRR, abs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">[</forename><surname>Li</surname></persName>
		</author>
		<idno>abs/1111.4503</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twentieth International Conference on International Conference on Machine Learning, ICML&apos;03</title>
		<editor>Vaswani et al., 2017] Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N. Gomez, Lukasz Kaiser, and Illia Polosukhin</editor>
		<meeting>the Twentieth International Conference on International Conference on Machine Learning, ICML&apos;03<address><addrLine>New York, NY, USA; Jason Weston, Frédéric Ratle, and Ronan Collobert; New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>CoRR</publisher>
			<date type="published" when="1906" />
			<biblScope unit="volume">6652</biblScope>
			<biblScope unit="page" from="1168" to="1175" />
		</imprint>
	</monogr>
	<note>Proceedings of the 25th International Conference on Machine Learning, ICML&apos;08. Association for Computing Machinery</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Jiawei Zhang. Deep loopy neural network model for graph structured data representation learning</title>
		<idno>abs/1805.07504</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twentieth International Conference on International Conference on Machine Learning, ICML&apos;03</title>
		<meeting>the Twentieth International Conference on International Conference on Machine Learning, ICML&apos;03</meeting>
		<imprint>
			<publisher>AAAI Press</publisher>
			<date type="published" when="1909" />
			<biblScope unit="page" from="912" to="919" />
		</imprint>
		<respStmt>
			<orgName>Zhang and Meng</orgName>
		</respStmt>
	</monogr>
	<note>Semi-supervised learning using gaussian fields and harmonic functions</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
