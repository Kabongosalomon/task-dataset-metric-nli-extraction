<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /nfs/home/kabenamualus/Research/task-dataset-metric-extraction/../grobid-0.6.0/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A Parallel-Hierarchical Model for Machine Comprehension on Sparse Data</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Adam</forename><surname>Trischler</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Maluuba Research Montreal</orgName>
								<address>
									<region>Québec</region>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Adam</forename><surname>Trischler</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Maluuba Research Montreal</orgName>
								<address>
									<region>Québec</region>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zheng</forename><surname>Ye</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Maluuba Research Montreal</orgName>
								<address>
									<region>Québec</region>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xingdi</forename><surname>Yuan</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Maluuba Research Montreal</orgName>
								<address>
									<region>Québec</region>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eric</forename><surname>Yuan</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Maluuba Research Montreal</orgName>
								<address>
									<region>Québec</region>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jing</forename><surname>He</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Maluuba Research Montreal</orgName>
								<address>
									<region>Québec</region>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Phillip</forename><surname>Bachman</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Maluuba Research Montreal</orgName>
								<address>
									<region>Québec</region>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
						</author>
						<author role="corresp">
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kaheer</forename><surname>Suleman</surname></persName>
							<email>k.suleman@maluuba.com</email>
							<affiliation key="aff0">
								<orgName type="institution">Maluuba Research Montreal</orgName>
								<address>
									<region>Québec</region>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">A Parallel-Hierarchical Model for Machine Comprehension on Sparse Data</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>

		<encodingDesc>
			<appInfo>
				<application version="0.6.0" ident="GROBID-SDO" when="2021-06-26T09:39+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid-sdo"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Understanding unstructured text is a major goal within natural language processing. Comprehension tests pose questions based on short text passages to evaluate such understanding. In this work, we investigate machine comprehension on the challenging MCTest benchmark. Partly because of its limited size, prior work on MCTest has focused mainly on engineering better features. We tackle the dataset with a neural approach, harnessing simple neural networks arranged in a parallel hierarchy. The parallel hierarchy enables our model to compare the passage, question, and answer from a variety of trainable perspectives, as opposed to using a manually designed, rigid feature set. Perspectives range from the word level to sentence fragments to sequences of sentences; the networks operate only on word-embedding representations of text. When trained with a methodology designed to help cope with limited training data, our Parallel-Hierarchical model sets a new state of the art for MCTest, outperforming previous feature-engineered approaches slightly and previous neural approaches by a significant margin (over 15% absolute).</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Humans learn in a variety of ways-by communication with each other, and by study, the reading of text. Comprehension of unstructured text by machines, at a near-human level, is a major goal for natural language processing. It has garnered significant attention from the machine learning research community in recent years.</p><p>Machine comprehension (MC) is evaluated by posing a set of questions based on a text passage (akin to the reading tests we all took in school). Such tests are objectively gradable and can be used to assess a range of abilities, from basic understanding to causal reasoning to inference <ref type="bibr" target="#b12">(Richardson et al., 2013)</ref>. Given a text passage and a question about its content, a system is tested on its ability to determine the correct answer <ref type="bibr" target="#b13">(Sachan et al., 2015)</ref>. In this work, we focus on MCTest, a complex but data-limited comprehension benchmark, whose multiple-choice questions require not only extraction but also inference and limited reasoning <ref type="bibr" target="#b12">(Richardson et al., 2013)</ref>. Inference and reasoning are important human skills that apply broadly, beyond language.</p><p>We present a parallel-hierarchical approach to machine comprehension designed to work well in a data-limited setting. There are many use-cases in which comprehension over limited data would be handy: for example, user manuals, internal documentation, legal contracts, and so on. Moreover, work towards more efficient learning from any quantity of data is important in its own right, for bringing machines more in line with the way humans learn. Typically, artificial neural networks require numerous parameters to capture complex patterns, and the more parameters, the more training data is required to tune them. Likewise, deep models learn to extract their own features, but this is a data-intensive process. Our model learns to comprehend at a high level even when data is sparse.</p><p>The key to our model is that it compares the question and answer candidates to the text using several distinct perspectives. We refer to a question combined with one of its answer candidates as a hypothesis (to be detailed below). The semantic perspective compares the hypothesis to sentences in the text viewed as single, self-contained thoughts; these are represented using a sum and transformation of word embedding vectors, similarly to in . The word-by-word perspective focuses on similarity matches between individual words from hypothesis and text, at various scales. As in the semantic perspective, we consider matches over complete sentences. We also use a sliding window acting on a subsentential scale (inspired by the work of <ref type="bibr" target="#b6">Hill et al. (2015)</ref>), which implicitly considers the linear distance between matched words. Finally, this word-level sliding window operates on two different views of text sentences: the sequential view, where words appear in their natural order, and the dependency view, where words are reordered based on a linearization of the sentence's dependency graph. Words are represented throughout by embedding vectors <ref type="bibr" target="#b10">(Mikolov et al., 2013)</ref>. These distinct perspectives naturally form a hierarchy that we depict in <ref type="figure" target="#fig_0">Figure 1</ref>. Language is hierarchical, so it makes sense that comprehension relies on hierarchical levels of understanding.</p><p>The perspectives of our model can be considered a type of feature. However, they are implemented by parametric differentiable functions. This is in contrast to most previous efforts on MCTest, whose numerous hand-engineered features cannot be trained. Our model, significantly, can be trained end-to-end with backpropagation. To facilitate learning with limited data, we also develop a unique training scheme. We initialize the model's neural networks to perform specific heuristic functions that yield decent (thought not impressive) performance on the dataset. Thus, the training scheme gives the model a safe, reasonable baseline from which to start learning. We call this technique training wheels.</p><p>Computational models that comprehend (insofar as they perform well on MC datasets) have developed contemporaneously in several research groups <ref type="bibr" target="#b16">Sukhbaatar et al., 2015;</ref><ref type="bibr" target="#b6">Hill et al., 2015;</ref><ref type="bibr" target="#b5">Hermann et al., 2015;</ref><ref type="bibr" target="#b7">Kumar et al., 2015)</ref>. Models designed specifically for MCTest include those of <ref type="bibr" target="#b12">Richardson et al. (2013)</ref>, and more recently <ref type="bibr" target="#b13">Sachan et al. (2015)</ref>, <ref type="bibr" target="#b17">Wang and</ref><ref type="bibr">McAllester (2015), and</ref><ref type="bibr" target="#b20">Yin et al. (2016)</ref>. In experiments, our Parallel-Hierarchical model achieves state-of-the-art accuracy on MCTest, outperforming these existing methods.</p><p>Below we describe related work, the mathematical details of our model, and our experiments, then analyze our results.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">The Problem</head><p>In this section we borrow from <ref type="bibr" target="#b13">Sachan et al. (2015)</ref>, who laid out the MC problem nicely. Machine comprehension requires machines to answer questions based on unstructured text. This can be viewed as selecting the best answer from a set of candidates. In the multiple-choice case, candidate answers are predefined, but candidate answers may also be undefined yet restricted (e.g., to yes, no, or any noun phrase in the text) <ref type="bibr" target="#b13">(Sachan et al., 2015)</ref>.</p><p>For each question q, let T be the unstructured text and A = {a i } the set of candidate answers to q. The machine comprehension task reduces to selecting the answer that has the highest evidence given T . As in <ref type="bibr" target="#b13">Sachan et al. (2015)</ref>, we combine an answer and a question into a hypothesis, h i = f (q, a i ). To facilitate comparisons of the text with the hypotheses, we also break down the passage into sentences t j , T = {t j }. In our setting, q, a i , and t j each represent a sequence of embedding vectors, one for each word and punctuation mark in the respective item.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Related Work</head><p>Machine comprehension is currently a hot topic within the machine learning community. In this section we will focus on the best-performing models applied specifically to MCTest, since it is somewhat unique among MC datasets (see Section 5). Generally, models can be divided into two categories: those that use fixed, engineered features, and neural models. The bulk of the work on MCTest falls into the former category.</p><p>Manually engineered features often require significant effort on the part of a designer, and/or various auxiliary tools to extract them, and they cannot be modified by training. On the other hand, neural models can be trained end-to-end and typically harness only a single feature: vectorrepresentations of words. Word embeddings are fed into a complex and possibly deep neural network which processes and compares text to question and answer. Among deep models, mechanisms of attention and working memory are common, as in  and <ref type="bibr" target="#b5">Hermann et al. (2015)</ref>.</p><p>3.1 Feature-engineering models <ref type="bibr" target="#b13">Sachan et al. (2015)</ref> treated MCTest as a structured prediction problem, searching for a latent answerentailing structure connecting question, answer, and text. This structure corresponds to the best latent alignment of a hypothesis with appropriate snippets of the text. The process of (latently) selecting text snippets is related to the attention mechanisms typically used in deep networks designed for MC and machine translation <ref type="bibr" target="#b0">(Bahdanau et al., 2014;</ref><ref type="bibr" target="#b6">Hill et al., 2015;</ref><ref type="bibr" target="#b5">Hermann et al., 2015)</ref>. The model uses event and entity coreference links across sentences along with a host of other features. These include specifically trained word vectors for synonymy; antonymy and class-inclusion relations from external database sources; dependencies and semantic role labels. The model is trained using a latent structural SVM extended to a multitask setting, so that questions are first classified using a pretrained top-level classifier. This enables the system to use different processing strategies for different question categories. The model also combines question and answer into a well-formed statement using the rules of Cucerzan and Agichtein <ref type="formula" target="#formula_5">(2005)</ref>.</p><p>Our model is simpler than that of <ref type="bibr" target="#b13">Sachan et al. (2015)</ref> in terms of the features it takes in, the training procedure (stochastic gradient descent vs. alternating minimization), question classification (we use none), and question-answer combination (simple concatenation or mean vs. a set of rules). <ref type="bibr">Wang and McAllester (2015)</ref> augmented the baseline feature set from <ref type="bibr" target="#b12">Richardson et al. (2013)</ref> with features for syntax, frame semantics, coreference chains, and word embeddings. They combined features using a linear latent-variable classifier trained to minimize a max-margin loss function. As in <ref type="bibr" target="#b13">Sachan et al. (2015)</ref>, questions and answers are combined using a set of manually written rules. The method of <ref type="bibr">Wang and McAllester (2015)</ref> achieved the previous state of the art, but has significant complexity in terms of the feature set.</p><p>Space does not permit a full description of all models in this category, but see also <ref type="bibr" target="#b14">Smith et al. (2015)</ref> and <ref type="bibr">Narasimhan and Barzilay (2015)</ref>.</p><p>Despite its relative lack of features, the Parallel-Hierarchical model improves upon the featureengineered state of the art for MCTest by a small amount (about 1% absolute) as detailed in Section 5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Neural models</head><p>Neural models have, to date, performed relatively poorly on MCTest. This is because the dataset is sparse and complex.</p><p>Yin et al. <ref type="formula" target="#formula_1">(2016)</ref> investigated deep-learning approaches concurrently with the present work. They measured the performance of the Attentive Reader <ref type="bibr" target="#b5">(Hermann et al., 2015)</ref> and the Neural Reasoner <ref type="bibr" target="#b11">(Peng et al., 2015)</ref>, both deep, end-to-end recurrent models with attention mechanisms, and also developed an attention-based convolutional network, the HABCNN. Their network operates on a hierarchy similar to our own, providing further evidence of the promise of hierarchical perspectives. Specifically, the HABCNN processes text at the sentence level and the snippet level, where the latter combines adjacent sentences (as we do through an n-gram input). Embedding vectors for the question and the answer candidates are combined and encoded by a convolutional network. This encoding modulates attention over sentence and snippet encodings, followed by maxpooling to determine the best matches between question, answer, and text. As in the present work, matching scores are given by cosine similarity. The HABCNN also makes use of a question classifier.</p><p>Despite the shared concepts between the HABCNN and our approach, the Parallel-Hierarchical model performs significantly better on MCTest (more than 15% absolute) as detailed in Section 5. Other neural models tested in <ref type="bibr" target="#b20">Yin et al. (2016)</ref> fare even worse.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">The Parallel-Hierarchical Model</head><p>Let us now define our machine comprehension model in full. We first describe each of the perspectives separately, then describe how they are combined. Below, we use subscripts to index elements of sequences, like word vectors, and superscripts to indicate whether elements come from the text, question, or answer. In particular, we use the subscripts k, m, n, p to index sequences from the text, question, answer, and hypothesis, respectively, and superscripts t, q, a, h. We depict the model schematically in <ref type="figure" target="#fig_0">Figure 1</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Semantic Perspective</head><p>The semantic perspective is similar to the Memory Networks approach for embedding inputs into memory space . Each sen- tence of the text is a sequence of d-dimensional word vectors:</p><formula xml:id="formula_0">t j = {t k }, t k ∈ R d .</formula><p>The semantic vector s t is computed by embedding the word vectors into a D-dimensional space using a two-layer network that implements weighted sum followed by an affine tranformation and a nonlinearity; i.e.,</p><formula xml:id="formula_1">s t = f A t k ω k t k + b t A .<label>(1)</label></formula><p>The matrix A t ∈ R D×d , the bias vector b t A ∈ R D , and for f we use the leaky ReLU function. The scalar ω k is a trainable weight associated to each word in the vocabulary. These scalar weights implement a kind of exogenous or bottomup attention that depends only on the input stimulus <ref type="bibr" target="#b9">(Mayer et al., 2004)</ref>. They can, for example, learn to perform the function of stopword lists in a soft, trainable way, to nullify the contribution of unimportant filler words.</p><p>The semantic representation of a hypothesis is formed analogously, except that we combine the question word vectors q m and answer word vectors a n as a single sequence {h p } = {q m , a n }. For semantic vector s h of the hypothesis, we use a unique transformation matrix A h ∈ R D×d and bias vector b h A ∈ R D . These transformations map a text sentence and a hypothesis into a common space where they can be compared. We compute the semantic match be-tween text sentence and hypothesis using the cosine similarity, M sem = cos(s t , s h ).</p><p>(2)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Word-by-Word Perspective</head><p>The first step in building the word-by-word perspective is to transform word vectors from a text sentence, question, and answer through respective neural functions. For the text,</p><formula xml:id="formula_2">t k = f B t t k + b t B , where B t ∈ R D×d , b t B</formula><p>∈ R D and f is again the leaky ReLU. We transform the question and the answer toq m andã n analogously using distinct matrices and bias vectors. In contrast with the semantic perspective, we keep the question and answer candidates separate in the wordby-word perspective. This is because matches to answer words are inherently more important than matches to question words, and we want our model to learn to use this property.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.1">Sentential</head><p>Inspired by the work of <ref type="bibr" target="#b17">Wang and Jiang (2015)</ref> in paraphrase detection, we compute matches between hypotheses and text sentences at the word level. This computation uses the cosine similarity as before:</p><formula xml:id="formula_3">c q km = cos(t k ,q m ),<label>(3)</label></formula><p>c a kn = cos(t k ,ã n ).</p><p>The word-by-word match between a text sentence and question is determined by taking the maximum over k (finding the text word that best matches each question word) and then taking a weighted mean over m (finding the average match over the full question):</p><formula xml:id="formula_5">M q = 1 Z m ω m max k c q km .<label>(5)</label></formula><p>Here, ω m is the word weight for the question word and Z normalizes these weights to sum to one over the question. We define the match between a sentence and answer candidate, M a , analogously. Finally, we combine the matches to question and answer according to</p><formula xml:id="formula_6">M word = α 1 M q + α 2 M a + α 3 M q M a .<label>(6)</label></formula><p>Here the α are trainable parameters that control the relative importance of the terms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.2">Sequential Sliding Window</head><p>The sequential sliding window is related to the original MCTest baseline by <ref type="bibr" target="#b12">Richardson et al. (2013)</ref>. Our sliding window decays from its focus word according to a Gaussian distribution, which we extend by assigning a trainable weight to each location in the window. This modification enables the window to use information about the distance between word matches; the original baseline used distance information through a predefined function. The sliding window scans over the words of the text as one continuous sequence, without sentence breaks. Each window is treated like a sentence in the previous subsection, but we include a location-based weight λ(k). This weight is based on a word's position in the window, which, given a window, depends on its global position k. The cosine similarity is adapted as</p><formula xml:id="formula_7">s q km = λ(k) cos(t k ,q m ),<label>(7)</label></formula><p>for the question and analogously for the answer. We initialize the location weights with a Gaussian and fine-tune them during training. The final matching score, denoted as M sws , is computed as in <ref type="formula" target="#formula_5">(5)</ref> and <ref type="formula" target="#formula_6">(6)</ref> with s q km replacing c q km .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.3">Dependency Sliding Window</head><p>The dependency sliding window operates identically to the linear sliding window, but on a different view of the text passage. The output of this component is M swd and is formed analogously to M sws . The dependency perspective uses the Stanford Dependency Parser (Chen and Manning, 2014) as an auxiliary tool. Thus, the dependency graph can be considered a fixed feature. Moreover, linearization of the dependency graph, because it relies on an eigendecomposition, is not differentiable. However, we handle the linearization in data preprocessing so that the model sees only reordered word-vector inputs.</p><p>Specifically, we run the Stanford Dependency Parser on each text sentence to build a dependency graph. This graph has n w vertices, one for each word in the sentence. From the dependency graph we form the Laplacian matrix L ∈ R nw×nw and determine its eigenvectors. The second eigenvector u 2 of the Laplacian is known as the Fiedler vector. It is the solution to the minimization</p><formula xml:id="formula_8">minimize g N i,j=1 η ij (g(v i ) − g(v j )) 2 ,<label>(8)</label></formula><p>where v i are the vertices of the graph, and η ij is the weight of the edge from vertex i to vertex j <ref type="bibr" target="#b3">(Golub and Van Loan, 2012)</ref>. The Fiedler vector maps a weighted graph onto a line such that connected nodes stay close, modulated by the connection weights. 1 This enables us to reorder the words of a sentence based on their proximity in the dependency graph. The reordering of the words is given by the ordered index set I = arg sort(u 2 ).</p><p>To give an example of how this works, consider the following sentence from MCTest and its dependency-based reordering:</p><p>Jenny, Mrs. Mustard 's helper, called the police. the police, called Jenny helper, Mrs. 's Mustard.</p><p>Sliding-window-based matching on the original sentence will answer the question Who called the police? with Mrs. Mustard. The dependency reordering enables the window to determine the correct answer, Jenny.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Combining Distributed Evidence</head><p>It is important in comprehension to synthesize information found throughout a document. MCTest was explicitly designed to ensure that it could not be solved by lexical techniques alone, but would instead require some form of inference or limited reasoning <ref type="bibr" target="#b12">(Richardson et al., 2013)</ref>. It therefore includes questions where the evidence for an answer spans several sentences.</p><p>To perform synthesis, our model also takes in ngrams of sentences, i.e., sentence pairs and triples strung together. The model treats these exactly as it does single sentences, applying all functions detailed above. A later pooling operation combines scores across all n-grams (including the singlesentence input). This is described in the next subsection.</p><p>With n-grams, the model can combine information distributed across contiguous sentences. In some cases, however, the required evidence is spread across distant sentences. To give our model some capacity to deal with this scenario, we take the top N sentences as scored by all the preceding functions, and then repeat the scoring computations viewing these top N as a single sentence.</p><p>The reasoning behind these approaches can be explained well in a probabilistic setting. If we consider our similarity scores to model the likelihood of a text sentence given a hypothesis, p(t j |h i ), then the n-gram and top N approaches model a joint probability p(t j 1 , t j 2 , . . . , t j k |h i ). We cannot model the joint probability as a product of individual terms (score values) because distributed pieces of evidence are likely not independent.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Combining Perspectives</head><p>We use a multilayer perceptron to combine M sem , M word , M swd , and M sws as a final matching score M i for each answer candidate. This network also pools and combines the separate n-gram scores, and uses a linear activation function.</p><p>Our overall training objective is to minimize the ranking loss</p><formula xml:id="formula_10">L(T, q, A) = max(0, µ + max i M i =i * − M i * ),<label>(10)</label></formula><p>where µ is a constant margin, i * indexes the correct answer, and we take the maximum over i so that we are ranking the correct answer over the best-ranked incorrect answer (of which there are three). This approach worked better than comparing the correct answer to the incorrect answers individually as in <ref type="bibr">Wang and McAllester (2015)</ref>.</p><p>Our implementation of the Parallel-Hierarchical model, using the Keras framework, is available on Github. 2</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Training Wheels</head><p>Before training, we initialized the neural-network components of our model to perform sensible heuristic functions. Training did not converge on the small MCTest without this vital approach.</p><p>Empirically, we found that we could achieve above 50% accuracy on MCTest using a simple sum of word vectors followed by a dot product between the question sum and the hypothesis sum. Therefore, we initialized the network for the semantic perspective to perform this sum, by initializing A x as the identity matrix and b x A as the zero vector, x ∈ {t, h}. Recall that the activation function is a ReLU so that positive outputs are unchanged.</p><p>We also found basic word-matching scores to be helpful, so we initialized the word-by-word networks likewise. The network for perspectivecombination was initialized to perform a sum of individual scores, using a zero bias-vector and a weight matrix of ones, since we found that each perspective contributed positively to the overall result.</p><p>This training wheels approach is related to other techniques from the literature. For instance, <ref type="bibr" target="#b8">Le et al. (2015)</ref> proposed the identity-matrix initialization in the context of recurrent neural networks in order to preserve the error signal through backpropagation. In residual networks <ref type="bibr" target="#b4">(He et al., 2015)</ref>, shortcut connections bypass certain layers in the network so that a simpler function can be trained in conjunction with the full model.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Experiments</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">The Dataset</head><p>MCTest is a collection of 660 elementary-level children's stories and associated questions, written by human subjects. The stories are fictional, ensuring that the answer must be found in the text itself, and carefully limited to what a young child can understand <ref type="bibr" target="#b12">(Richardson et al., 2013)</ref>.</p><p>The more challenging variant consists of 500 stories with four multiple-choice questions each. Despite the elementary level, stories and questions are more natural and more complex than those found in synthetic MC datasets like bAbI  and CNN <ref type="bibr" target="#b5">(Hermann et al., 2015)</ref>.</p><p>MCTest is challenging because it is both complicated and small. As per <ref type="bibr" target="#b6">Hill et al. (2015)</ref>, "it is very difficult to train statistical models only on MCTest." Its size limits the number of parameters that can be trained, and prevents learning any complex language modeling simultaneously with the capacity to answer questions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Training and Model Details</head><p>In this section we describe important details of the training procedure and model setup. For a complete list of hyperparameter settings, our stopword list, and other minutiae, we refer interested readers to our Github repository.</p><p>For word vectors we use Google's publicly available embeddings, trained with word2vec on the 100-billion-word News corpus <ref type="bibr" target="#b10">(Mikolov et al., 2013)</ref>. These vectors are kept fixed throughout training, since we found that training them was not helpful (likely because of MCTest's size). The vectors are 300-dimensional (d = 300).</p><p>We do not use a stopword list for the text passage, instead relying on the trainable word weights to ascribe global importance ratings to words. These weights are initialized with the inverse document frequency (IDF) statistic computed over the MCTest corpus. 3 However, we do use a short stopword list for questions. This list nullifies query words such as {Who, what, when, where, how}, along with conjugations of the verbs to do and to be.</p><p>Following earlier methods, we use a heuristic to improve performance on negation questions <ref type="bibr" target="#b13">(Sachan et al., 2015;</ref><ref type="bibr">Wang and McAllester, 2015)</ref>. When a question contains the words which and not, we negate the hypothesis ranking scores so that the minimum becomes the maximum.</p><p>The most important technique for training the model was the training wheels approach. Without this, training was not effective at all. The identity initialization requires that the network weight matrices are square (d = D).</p><p>We found dropout <ref type="bibr" target="#b15">(Srivastava et al., 2014)</ref> to be particularly effective at improving generalization from the training to the test set, and used 0.5 as the dropout probability. Dropout occurs after all neural-network transformations, if those transformations are allowed to change with training. Our best performing model held networks at the wordby-word level fixed.</p><p>For combining distributed evidence, we used up to trigrams over sentences and our bestperforming model reiterated over the top two sentences (N = 2).</p><p>We used the Adam optimizer with the standard settings (Kingma and Ba, 2014) and a learning rate of 0.003. To determine the best hyperparameters we performed a grid search over 150 settings based on validation-set accuracy. MCTest's original validation set is too small for reliable hyperparameter tuning, so, following <ref type="bibr">Wang and McAllester (2015)</ref>, we merged the training and validation sets of MCTest-160 and MCTest-500, then split them randomly into a 250-story training set and a 200-story validation set. <ref type="table" target="#tab_0">Table 1</ref> presents the performance of featureengineered and neural methods on the MCTest test set. Accuracy scores are divided among questions whose evidence lies in a single sentence (single) and across multiple sentences (multi), and among the two variants. Clearly, MCTest-160 is easier.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Results</head><p>The first three rows represent featureengineered methods. <ref type="bibr" target="#b12">Richardson et al. (2013)</ref> + RTE is the best-performing variant of the original baseline published along with MCTest. It uses a lexical sliding window and distance-based measure, augmented with rules for recognizing textual entailment. We described the methods of <ref type="bibr" target="#b13">Sachan et al. (2015)</ref> and <ref type="bibr">Wang and McAllester (2015)</ref> in Section 3. On MCTest-500, the Parallel Hierarchical model significantly outperforms these methods on single questions (&gt; 2%) and slightly outperforms the latter two on multi questions (≈ 0.3%) and overall (≈ 1%). The method of <ref type="bibr">Wang and McAllester (2015)</ref> achieves the best overall result on MCTest-160. We suspect this is because our neural method suffered from the relative lack of training data.</p><p>The last four rows in <ref type="table" target="#tab_0">Table 1</ref> are neural methods that we discussed in Section 3. Performance measures are taken from <ref type="bibr" target="#b20">Yin et al. (2016)</ref>. Here we see our model outperforming the alternatives by a large margin across the board (&gt; 15%). The Neural Reasoner and the Attentive Reader are large, deep models with hundreds of thousands of parameters, so it is unsurprising that they performed poorly on MCTest. The specificallydesigned HABCNN fared better, its convolutional architecture cutting down on the parameter count. Because there are similarities between our model and the HABCNN, we hypothesize that much of the performance difference is attributable to our training wheels methodology.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Analysis and Discussion</head><p>We measure the contribution of each component of the model by ablating it. Results are given in <ref type="table" target="#tab_1">Table 2</ref>. Not surprisingly, the n-gram functionality is important, contributing almost 5% accuracy improvement. Without this, the model has almost no  means for synthesizing distributed evidence. The top N function contributes very little to the overall performance, suggesting that most multi questions have their evidence distributed across contiguous sentences. Ablating the sentential component made the most significant difference, reducing performance by more than 5%. Simple word-by-word matching is obviously useful on MCTest. The sequential sliding window makes a 3% contribution, highlighting the importance of word-distance measures. On the other hand, the dependency-based sliding window makes only a minor contribution. We found this surprising. It may be that linearization of the dependency graph removes too much of its information. Finally, the exogenous word weights make a significant contribution of almost 5%. Analysis reveals that most of our system's test failures occur on questions about quantity (e.g., How many...? ) and temporal order (e.g., Who was invited last? ). Quantity questions make up 9.5% of our errors on the validation set, while order questions make up 10.3%. This weakness is not unexpected, since our architecture lacks any capacity for counting or tracking temporal order. Incorporating mechanisms for these forms of reasoning is a priority for future work (in contrast, the Memory Network model is quite good at temporal reasoning ).</p><p>The Parallel-Hierarchical model is simple. It does no complex language or sequence modeling. Its simplicity is a response to the limited data of MCTest. Nevertheless, the model achieves stateof-the-art results on the multi questions, which (putatively) require some limited reasoning. Our model is able to handle them reasonably well just by stringing important sentences together. Thus, the model imitates reasoning with a heuristic. This suggests that, to learn true reasoning abilities, MCTest is too simple a dataset-and it is almost certainly too small for this goal.</p><p>However, it may be that human language processing can be factored into separate processes of comprehension and reasoning. If so, the Parallel-Hierarchical model is a good start on the former. Indeed, if we train the method exclusively on single questions then its results become even more impressive: we can achieve a test accuracy of 79.1% on MCTest-500.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusion</head><p>We have presented the novel Parallel-Hierarchical model for machine comprehension, and evaluated it on the small but complex MCTest. Our model achieves state-of-the-art results, outperforming several feature-engineered and neural approaches.</p><p>Working with our model has emphasized to us the following (not necessarily novel) concepts, which we record here to promote further empirical validation.</p><p>• Good comprehension of language is supported by hierarchical levels of understanding (Cf. <ref type="bibr" target="#b6">Hill et al. (2015)</ref>).</p><p>• Exogenous attention (the trainable word weights) may be broadly helpful for NLP.</p><p>• The training wheels approach, that is, initializing neural networks to perform sensible heuristics, appears helpful for small datasets.</p><p>• Reasoning over language is challenging, but easily simulated in some cases.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Schematic of the Parallel-Hierarchical model. SW stands for "sliding window." MLP represents a general neural network.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 :</head><label>1</label><figDesc>Experimental results on MCTest.</figDesc><table><row><cell>Method</cell><cell cols="2">MCTest-160 accuracy (%) Single (112) Multiple (128)</cell><cell>All</cell><cell cols="2">MCTest-500 accuracy (%) Single (272) Multiple (328)</cell><cell>All</cell></row><row><cell>Richardson et al. (2013) + RTE</cell><cell>76.78</cell><cell>62.50</cell><cell>69.16</cell><cell>68.01</cell><cell>59.45</cell><cell>63.33</cell></row><row><cell>Sachan et al. (2015)</cell><cell>-</cell><cell>-</cell><cell>-</cell><cell>67.65</cell><cell>67.99</cell><cell>67.83</cell></row><row><cell>Wang et al. (2015)</cell><cell>84.22</cell><cell>67.85</cell><cell>75.27</cell><cell>72.05</cell><cell>67.94</cell><cell>69.94</cell></row><row><cell>Attentive Reader</cell><cell>48.1</cell><cell>44.7</cell><cell>46.3</cell><cell>44.4</cell><cell>39.5</cell><cell>41.9</cell></row><row><cell>Neural Reasoner</cell><cell>48.4</cell><cell>46.8</cell><cell>47.6</cell><cell>45.7</cell><cell>45.6</cell><cell>45.6</cell></row><row><cell>HABCNN-TE</cell><cell>63.3</cell><cell>62.9</cell><cell>63.1</cell><cell>54.2</cell><cell>51.7</cell><cell>52.9</cell></row><row><cell>Parallel-Hierarchical</cell><cell>79.46</cell><cell>70.31</cell><cell>74.58</cell><cell>74.26</cell><cell>68.29</cell><cell>71.00</cell></row><row><cell cols="2">Ablated component Test accuracy (%)</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>-</cell><cell>71.00</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>n-gram</cell><cell>66.51</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>Top N</cell><cell>70.34</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>Sentential</cell><cell>64.33</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>SW-sequential</cell><cell>68.00</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>SW-dependency</cell><cell>70.00</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>Word weights</cell><cell>66.51</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 2 :</head><label>2</label><figDesc>Ablation study on MCTest-500 (all).</figDesc><table /><note></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1">We experimented with assigning unique edge weights to unique relation types in the dependency graph. However, this had negligible effect. We hypothesize that this is because dependency graphs are trees, without cycles.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2">http://www.hiddenwebsite.com</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3">We override the IDF initialization for words like not, which are frequent but highly informative.</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">[</forename><surname>References</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Bahdanau</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1409.0473</idno>
		<title level="m">Neural machine translation by jointly learning to align and translate</title>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">A fast and accurate dependency parser using neural networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Danqi</forename><surname>Manning2014</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christopher D</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Manning</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EMNLP</title>
		<imprint>
			<date type="published" when="2014" />
			<biblScope unit="page" from="740" to="750" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Factoid question answering over unstructured and structured web content</title>
	</analytic>
	<monogr>
		<title level="m">TREC</title>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="volume">72</biblScope>
			<biblScope unit="page">90</biblScope>
		</imprint>
	</monogr>
	<note>Silviu Cucerzan and Eugene Agichtein</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">[</forename><surname>Golub</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Van Loan2012] Gene</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Charles</forename><forename type="middle">F</forename><surname>Golub</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Van Loan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Matrix computations</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<date type="published" when="2012" />
			<publisher>JHU Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">[</forename><surname>He</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1512.03385</idno>
		<title level="m">Deep residual learning for image recognition</title>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Teaching machines to read and comprehend</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">[</forename><surname>Hermann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems</title>
		<imprint>
			<date type="published" when="2015" />
			<biblScope unit="page" from="1684" to="1692" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">The goldilocks principle: Reading children&apos;s books with explicit memory representations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">[</forename><surname>Hill</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1511.02301</idno>
		<idno>arXiv:1412.6980</idno>
	</analytic>
	<monogr>
		<title level="m">Adam: A method for stochastic optimization</title>
		<editor>Diederik Kingma and Jimmy Ba</editor>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
	<note>Kingma and Ba2014</note>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">[</forename><surname>Kumar</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1506.07285</idno>
		<title level="m">Ask me anything: Dynamic memory networks for natural language processing</title>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">[</forename><surname>Le</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1504.00941</idno>
		<title level="m">A simple way to initialize recurrent networks of rectified linear units</title>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Neural networks underlying endogenous and exogenous visual-spatial orienting</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">[</forename><surname>Mayer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Neuroimage</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="534" to="541" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Narasimhan and Barzilay2015] Karthik Narasimhan and Regina Barzilay</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">[</forename><surname>Mikolov</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1301.3781</idno>
	</analytic>
	<monogr>
		<title level="m">53rd Annual Meeting of the Association for Computational Linguistics</title>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
	<note>Machine comprehension with discourse relations</note>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Peng</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1508.05508</idno>
		<title level="m">Towards neural network-based reasoning</title>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Mctest: A challenge dataset for the open-domain machine comprehension of text</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Richardson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EMNLP</title>
		<imprint>
			<date type="published" when="2013" />
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page">2</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Learning answerentailing structures for machine comprehension</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Sachan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACL</title>
		<meeting>ACL</meeting>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">A strong lexical matching method for the machine comprehension test</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">[</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2015 Conference on Empirical Methods in Natural Language Processing</title>
		<meeting>the 2015 Conference on Empirical Methods in Natural Language Processing<address><addrLine>Lisbon, Portugal</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computational Linguistics</publisher>
			<date type="published" when="2015-09" />
			<biblScope unit="page" from="1693" to="1698" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Dropout: A simple way to prevent neural networks from overfitting</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">[</forename><surname>Srivastava</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The Journal of Machine Learning Research</title>
		<imprint>
			<date type="published" when="2014" />
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page" from="1929" to="1958" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">End-to-end memory networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">[</forename><surname>Sukhbaatar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems</title>
		<imprint>
			<date type="published" when="2015" />
			<biblScope unit="page" from="2431" to="2439" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">[</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jiang2015] Shuohang</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jing</forename><surname>Jiang</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1512.08849</idno>
		<title level="m">Learning natural language inference with lstm</title>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Machine comprehension with syntax, frames, and semantics</title>
		<editor>Wang and McAllester2015] Hai Wang and Mohit Bansal Kevin Gimpel David McAllester</editor>
		<imprint>
			<date type="published" when="2015" />
			<publisher>Short Papers</publisher>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page">700</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">[</forename><surname>Weston</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1410.3916</idno>
	</analytic>
	<monogr>
		<title level="m">Sumit Chopra, and Antoine Bordes. 2014. Memory networks</title>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Attention-based convolutional neural network for machine comprehension</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yin</forename></persName>
		</author>
		<idno type="arXiv">arXiv:1602.04341</idno>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
