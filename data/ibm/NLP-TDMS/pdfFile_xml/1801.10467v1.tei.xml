<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /nfs/home/kabenamualus/Research/task-dataset-metric-extraction/../grobid-0.6.0/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Deep Reinforcement Learning for Programming Language Correction</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rahul</forename><surname>Gupta</surname></persName>
							<email>rahulg@iisc.ac.in</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science and Automation</orgName>
								<orgName type="institution">Indian Institute of Science Bangalore</orgName>
								<address>
									<postCode>560012</postCode>
									<region>KA</region>
									<country key="IN">India</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Aditya</forename><surname>Kanade</surname></persName>
							<email>kanade@iisc.ac.in</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science and Automation</orgName>
								<orgName type="institution">Indian Institute of Science Bangalore</orgName>
								<address>
									<postCode>560012</postCode>
									<region>KA</region>
									<country key="IN">India</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shirish</forename><surname>Shevade</surname></persName>
							<email>shirish@iisc.ac.in</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science and Automation</orgName>
								<orgName type="institution">Indian Institute of Science Bangalore</orgName>
								<address>
									<postCode>560012</postCode>
									<region>KA</region>
									<country key="IN">India</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Deep Reinforcement Learning for Programming Language Correction</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>

		<encodingDesc>
			<appInfo>
				<application version="0.6.0" ident="GROBID-SDO" when="2021-06-26T06:51+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid-sdo"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Novice programmers often struggle with the formal syntax of programming languages. To assist them, we design a novel programming language correction framework amenable to reinforcement learning. The framework allows an agent to mimic human actions for text navigation and editing. We demonstrate that the agent can be trained through self-exploration directly from the raw input, that is, program text itself, without any knowledge of the formal syntax of the programming language. We leverage expert demonstrations for one tenth of the training data to accelerate training. The proposed technique is evaluated on 6975 erroneous C programs with typographic errors, written by students during an introductory programming course. Our technique fixes 14% more programs and 29% more compiler error messages relative to those fixed by a state-of-the-art tool, DeepFix, which uses a fully supervised neural machine translation approach.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Programming languages prescribe formal rules of syntactic validity of program text. A program text that does not adhere to those rules cannot be compiled and executed. The inability to write syntactically correct programs therefore becomes a stumbling block for novice programmers. In large-scale online programming courses, getting personalized feedback from instructors or TAs is infeasible. On the other hand, compiler error messages are often difficult to understand and do not localize the errors accurately <ref type="bibr" target="#b2">[Traver, 2010]</ref>. Therefore, our aim in this work is to develop a technique to assist novice programmers by automatically correcting common syntactic errors in programs.</p><p>We approach this problem through reinforcement learning (RL). When faced with an error, a programmer navigates through the program text to arrive at the location of error and then performs an edit to fix the error. We propose a novel programming language correction framework, in which an agent can mimic these actions. While the agent can access and modify the program text, the compiler which checks syntactic validity of the program text is a black-box for the agent.</p><p>As noted above, compilers usually do not pinpoint error locations precisely. Hence, we do not rely on a compiler to aid in error localization or correction. We instead design a reward function using only the number of error messages generated by the compiler. The goal of the agent is to perform edits necessary for successful compilation of the program.</p><p>The challenge in this framework is to learn a control policy for the agent from program text without the agent having any knowledge of the formal syntax of the programming language. Through deep reinforcement learning, agents have been trained to play visual and text-based games at expert levels <ref type="bibr" target="#b2">[Mnih et al., 2015;</ref><ref type="bibr" target="#b2">Narasimhan et al., 2015;</ref><ref type="bibr">Wu and Tian, 2017]</ref>. Interestingly, these techniques learn directly from raw inputs such as pixels and text. In this work, for the first time, we show that this is possible even in the space of computer programs.</p><p>To see our framework in action, consider an example C program shown in <ref type="figure" target="#fig_0">Figure 1</ref> which implements a tax calculation algorithm. It has two syntactic errors: (1) incorrect use of semicolon within the scanf in line 4 and (2) a missing closing brace at the end of line 12. This program is given to a trained agent which has not seen it during training. The program is presented in a tokenized form to the agent and the cursor position of the agent is initialized to the first token in the program. The navigation actions of the agent over the program text are shown by arrows. As shown by the sequence of actions taken by the agent in <ref type="figure" target="#fig_0">Figure 1</ref>, the agent correctly localizes and fixes both the errors. First, the agent navigates to the error location at line 4 and replaces the incorrect semicolon with a comma (marked by e 1 ). Next, it navigates to the error location at line 12 and inserts the missing closing brace (marked by e 2 ). After these edits, the program compiles successfully and the agent stops. In comparison, a brute-force search will have to enumerate all possible edited versions of the program with up to two simultaneous edits and compile each of them to identify the right edits. This will be far more expensive than using the agent.</p><p>A video demonstration of this example is available at:</p><p>https://youtu.be/S4D6MR728zY</p><p>We encode the program text, augmented with the position of the cursor, using a long short-term memory (LSTM) network <ref type="bibr" target="#b2">[Hochreiter and Schmidhuber, 1997</ref>]. The agent is allowed a set of navigation and edit actions to fix the program. It receives a small reward for every edit which fixes some error and the maximum reward is given for reaching the goal state, which is an error-free version of the program. The control policy of the agent is learned using the asynchronous advantage actor-critic (A3C) algorithm <ref type="bibr" target="#b2">[Mnih et al., 2016]</ref>.</p><p>Training an agent in this setting is non-trivial for two reasons. First, as illustrated by the example above, the agent needs to both localize the errors and make precise edits at the error locations to be able to fix a program. A wrong edit only makes the program worse by introducing more errors and consequently, makes the task even more difficult. To overcome this, we configure the environment to reject such edits. This significantly prunes the state space that an agent is allowed to explore without sacrificing its ability to fix programs. Second, reinforcement learning tends to be slow for the tasks with large state spaces as the time required for gathering information by state exploration increases. One way to mitigate this problem is to guide the agent with expert demonstrations <ref type="bibr" target="#b0">[Argall et al., 2009]</ref>. Motivated by this, we design a scheme to enable the agent to take advantage of expert demonstrations illustrating the required actions for fixing the programs. As explained later, for our task, these demonstrations are generated automatically without any human intervention. We call our technique RLAssist.</p><p>DeepFix <ref type="bibr" target="#b1">[Gupta et al., 2017]</ref> is a state-of-the-art tool for fixing common programming errors. We compare RLAssist with DeepFix on the task of fixing typographic errors in 6975 C programs. These programs were written by students during an introductory programming course and span 93 different programming problems <ref type="bibr" target="#b1">[Gupta et al., 2017;</ref><ref type="bibr">Das et al., 2017]</ref> 1 . These programs use non-trivial constructs of the C language such as multiple procedures, conditionals, switch statements, nested loops, multi-dimensional arrays and recursion. DeepFix uses a fully supervised neural machine translation approach.</p><p>In contrast, RLAssist is a deep reinforcement learning based technique. We demonstrate that RLAssist can be trained through self-exploration using erroneous programs only, while still matching the performance of DeepFix. We further show that we can leverage expert demonstrations to accelerate the training. In particular, we generate expert demonstrations for one tenth of the training dataset. The rest 90% of the dataset is used without demonstrations. RLAssist fixes 26.6% programs from the test set completely and resolves 39.7% error messages. Relative to DeepFix, this is an improvement of 14% and 29% respectively. Thus, RLAssist outperforms DeepFix using expert demonstrations for a fraction of training data.</p><p>The main contributions of this work are as follows:</p><p>1. We design a novel framework of programming language correction amenable to reinforcement learning.</p><p>2. We use A3C for programming language correction and accelerate training through expert demonstrations.</p><p>3. Our experiments show that our technique outperforms a state-of-the-art tool, DeepFix, using expert demonstrations for only one tenth of the training data. Moreover, our technique also works without any demonstrations while still matching the performance of DeepFix.</p><p>4. The implementation of RLAssist will be open sourced.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Related Work</head><p>Natural language correction is a well researched problem. Some of the earlier works in this area have focused on identifying and correcting specific types of grammatical errors such as misuse of verb forms, articles, and prepositions <ref type="bibr">[Chodorow et al., 2007;</ref><ref type="bibr" target="#b2">Han et al., 2006;</ref><ref type="bibr">Rozovskaya and Roth, 2010]</ref>. The more recent works consider a broader range of error classes, often relying on language models, and machine translation <ref type="bibr" target="#b2">[Ng et al., 2014;</ref><ref type="bibr">Rozovskaya et al., 2014]</ref>. Although natural languages and programming languages are similar to some extent, the latter have procedural interpretation and richer structure. Due to the huge popularity of programming oriented massive open online courses (MOOCs), recent years have seen increasing interest in programming language correction <ref type="bibr" target="#b1">[Gupta et al., 2017;</ref><ref type="bibr">Parihar et al., 2017]</ref>. These works either rely on supervised learning techniques or use hand written rules to fix common programming errors. This paper proposes a reinforcement learning framework in which an agent can learn programming language correction directly from raw program text through self-exploration.</p><p>Learning from demonstration (LfD) approaches train an agent using expert demonstrations. Behavioral cloning <ref type="bibr">[Ross et al., 2011]</ref> is one particular class of LfD techniques to make the agent mimic expert demonstrations using supervised learning. We complement the self-exploration with expert demonstrations to accelerate the training. Inverse reinforcement learning is another class of LfD techniques. These use demonstrations to first infer a reward function which is then used to learn the policy <ref type="bibr" target="#b0">[Abbeel and Ng, 2004</ref>]. These methods have been used for the tasks where there is no obvious reward function, e.g., autonomous driving <ref type="bibr" target="#b0">[Abbeel and Ng, 2004]</ref> and acrobatic helicopter maneuvers <ref type="bibr" target="#b0">[Abbeel et al., 2007]</ref>. For our task, the rewards are well defined and can be calculated easily.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Background</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Reinforcement Learning</head><p>In reinforcement learning, an agent interacts with its environment over a number of discrete time steps. At each time step t, the environment presents a state s t ∈ S to the agent. In response, the agent selects an action a t from the set of allowed actions A. This selection is controlled by the agent's policy π(a|s) = P r{a t = a|s t = s}. The action is passed on to the environment and its execution may modify the internal state of the environment. The agent then receives the updated state s t+1 and a scalar reward r t . This interaction, which is also called an episode, stops when the agent reaches a goal state. The objective of the agent is to maximize the expected sum of discounted future rewards G t from each state s t . For an episode terminating at time step T , G t =</p><formula xml:id="formula_0">T −t−1 k=0 γ k r t+k ,</formula><p>where the discount rate γ ∈ (0, 1] [Sutton and <ref type="bibr" target="#b2">Barto, 1998</ref>].</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Asynchronous Advantage Actor-Critic (A3C)</head><p>One of the many ways to solve an RL problem is to use policy gradient methods. These methods learn a parameterized policy π(a|s; θ), where θ represents the parameters of a function approximator, such as a neural network. One example of policy gradient methods is the actor-critic methods, which learn both π(a|s; θ), the 'actor', and the value function V (s; w), the 'critic'. Here, V (s; w) defines the expected reward from state s, with w being the parameters of a function approximator. The critic evaluates how advantageous is it to be in the new state reached by taking an action a t sampled from the distribution given by π(s t ). Based on this evaluation, the parameterized policy is updated using an appropriate optimization technique such as gradient ascent <ref type="bibr" target="#b2">[Sutton and Barto, 1998</ref>].</p><p>The A3C algorithm uses multiple asynchronous parallel actor-learner threads to update a shared model, stabilizing the learning process by reducing the correlation of an agent's experience. It has also been observed to reduce training time by a factor that is roughly linear in the number of parallel actor-learners <ref type="bibr" target="#b2">[Mnih et al., 2016]</ref>. We use A3C in this work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Technical Details</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">A Framework for Programming Language Correction Tasks</head><p>When faced with an error, a programmer navigates the program text to arrive at the location of error and then performs an edit operation to fix the error. In the presence of multiple errors, the programmer can repeat these steps. We present a programming language (PL) correction framework in which an agent can mimic these actions. We now describe the components of this framework and their instantiation for our task of correcting syntactic errors in C programs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>States</head><p>A state is a pair string, cursor , where string is the program text, and cursor ∈ {1, . . . , len(string)}, where len(string) denotes the number of tokens in the string.</p><p>The environment also keeps track of the number of errors in string. These errors can either be determined from the ground truth whenever available or estimated using the error messages generated by a compiler upon compiling the string. For compilation, we use the GNU C compiler. We encode the state into a sequence of tokens as follows. First, we convert the program string into a sequence of lexemes. The lexemes are of different types, such as keywords, operators, types, functions, literals, and variables. In addition, we also retain line-breaks as lexemes to allow twodimensional navigation actions over the program text. The cursor part of the state is represented by a special token, which is inserted in the sequence of lexemes right after the token whose index is held by cursor.</p><p>Next, we build a shared vocabulary across all programs. Except some common library functions such as printf and scanf, all other function and variable identifiers are mapped to a special token ID. Similarly, all the literals are mapped to special tokens according to their type, e.g., numbers to NUM and strings to STR. All remaining tokens are included in the vocabulary without any modifications. This mapping reduces the size of the vocabulary seen by the agent.</p><p>Note that this encoding is only required for feeding the state to the agent. The actions predicted by the agent based on this encoding are executed on the original program string by the environment.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Actions and Transitions</head><p>The agent actions are divided into two categories, the first which update the cursor and the second which modify the string. We refer to the first category of actions as navigation actions and the latter as edit actions. The navigation actions allow an agent to navigate through the string. These actions only change the cursor of a state and not the string. The edit actions on the other hand, are used for error correction. They only modify the string and not the cursor. Wrong edit actions introduce more errors in the string rather than fixing them. We configure the environment to reject all such edits to prune the state space from which fixing the program becomes even more difficult. In addition, rejecting wrong edits prevents arbitrary changes to the program.</p><p>For our task, we allow only two navigation actions, move right and move down. These set the cursor to the next token on the right or to the first token of the next line respectively. The move right (respectively, move down) action has no effect if the cursor is already set to the last token of a line (respectively, any token of the last line). Note that the move down action is possible because we retain the linebreaks in the state encoding.</p><p>Based on a study of common typographic errors that novice programmers make, we design three types of edit actions.</p><p>The first is a parameterized insert token action which inserts the parameter token immediately before the cursor position. The parameter can be any token from a fixed set of tokens which we call mutable tokens. The second is the delete action, which deletes the token at the cursor position. However, the token is deleted only if it is from the set of mutable tokens. We restrict the set of mutable tokens to the following five types of tokens: semicolon, parentheses, braces, period, and comma. The third edit action is a parameterized replace token1 with token2 action which replaces token1 at the cursor position with token2. We have the following four actions in this class: (1) replace ';' with ',', (2) replace ',' with ';', (3) replace '.' with ';', and (4) replace ';)' with ');'. Although atomic replacement actions can be substituted with a sequence of delete and insert actions, having them prevents the cases where the constituent delete and/or insert actions can be rejected by the environment.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Episode, Termination, and Rewards</head><p>An episode starts with an erroneous program text as string and the curosr set to its first token. The goal state is reached when the edited program compiles successfully. An agent is allowed max episode len number of discrete time steps to reach the goal state in an episode after which the episode is terminated. Also, the agent is allowed only one pass over the program in an episode, i.e., once the agent navigates past the last token of a program, the episode is terminated.</p><p>In each step, the agent is penalized with a small step penalty in order to encourage it to learn to fix a program in the minimum number of steps. Additionally, the agent is penalized with a relatively higher edit penalty for taking edit actions. The reason is that the edit actions are somewhat costly as they need to be verified by invoking a compiler. Therefore, we discourage the agent to make edits unnecessarily. The agent is given maximum reward for reaching the goal state. Also, a small intermediate reward is given for taking an edit action that fixes at least one error.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Model</head><p>We use the A3C algorithm in the PL correction task. Our model first uses a long short-term memory (LSTM) [Hochreiter and Schmidhuber, 1997] network for embedding the tokenized state into a real vector. The LSTM network maps each token x i of an input sequence (x 1 , . . . , x n ) to a real vector y i . The final state embedding is calculated by taking an element-wise mean over all the output vectors (y 1 , . . . , y n ) following <ref type="bibr" target="#b2">[Narasimhan et al., 2015]</ref>.</p><p>Given this state embedding, we use two separate fully connected linear layers to produce the policy function π(a|s; θ), and the value function V (s; w) outputs. Finally, before updating the network parameters, the gradients are accumulated using the following rules:</p><formula xml:id="formula_1">dθ ← dθ + ∇ θ log π(a t |s t ; θ )(R − V (s t ; w )) + β∇ θ H(π(s t ; θ )) dw ← dw + ∇ w (R − V (s t ; w )) 2 where R = k−1 i=0 γ i r t+i + γ k V (s t+k ; w )</formula><p>, H is the entropy, and β is a hyperparameter to control the weight of the entropy regularization term; θ and w are the thread specific parameters corresponding to θ and w respectively <ref type="bibr" target="#b2">[Mnih et al., 2016]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Expert Demonstrations</head><p>As we show later in the experiments section, RLAssist can be trained without using any demonstrations, but requires longer training time. The reason is that in the A3C algorithm, in each episode, an agent starts with a random state s and then uses its policy function to interact with the environment. As the policy network is initialized randomly, this interaction is governed with random exploration at the beginning of the training. With only random exploration, the agent finds it difficult to reach the goal state and wins rewards infrequently. Consequently, the training slows down.</p><p>We use expert demonstrations to accelerate training. An expert demonstration is a sequence of actions leading to the goal state of an episode. Given a pair (p, p ) where p is an incorrect program and p is its correct version, a demonstration is generated automatically as follows. Starting from the first token in p , each unmodified line (w.r.t. p) is skipped through a move down action. At the first erroneous line, the cursor is moved rightwards through a move right action until reaching an error location and the appropriate edit action is generated. This process is repeated until the last error in the program is resolved.</p><p>We configure an agent to use expert demonstrations as follows. For the episodes for which a demonstration is available, the agent follows the predetermined sequence of actions provided, instead of sampling driven by the policy. The updates to the policy network parameters are made as if the predetermined action was sampled. For the rest of the episodes, the agent takes the actions sampled using the policy, following the standard A3C algorithm. Note that the demonstrations are provided at the episode level and not at a finer granularity of transition level. The reasoning is that the agent needs to take the right actions throughout the episode to reach the goal state and earn reward. If it takes intermittent guidance in an episode then it can still fail to reach the goal state.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Experiments</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Dataset</head><p>We use the training and test datasets used in <ref type="bibr" target="#b1">[Gupta et al., 2017]</ref> for the task of correcting typographic errors. The programs in the datasets span 93 programming problems in an introductory programming course and make use of non-trivial C language constructs. The program lengths range from 75 to 450 tokens. In addition to the test set of actual studentwritten erroneous programs, DeepFix has also been evaluated on some programs with seeded errors. In this work, we only use the test set of student-written erroneous programs. This test set contains 6975 erroneous programs with 16766 compilation error messages together, as shown in <ref type="table" target="#tab_0">Table 1</ref>. The dataset is divided into five folds for cross validation. Each fold holds aside about 1/5th of the 93 programming problems. The student-written erroneous programs belonging to the held out problems form the test set in that fold. The training data associated with the remaining 4/5th programming problems is used for training. Thus, a learning algorithm must learn the  syntactic validity as per the language syntax so that it can generalize to unseen programming problems. Each fold roughly contains about 160K labeled training examples. For more details of the dataset, we refer the reader to <ref type="bibr" target="#b1">[Gupta et al., 2017]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Experiment Configuration and Training</head><p>We implement our technique in Tensorflow <ref type="bibr" target="#b0">[Abadi et al., 2016]</ref>, following an open source implementation 2 of A3C. We find a suitable configuration of the PL correction framework and the learning model for our task through experimentation. In particular, the LSTM encoder in our model has two recurrent layers with 128 cells each. Our vocabulary has 91 tokens, which are embedded into 24-dimensional vectors. We set the discounting factor γ = 0.99, the maximum number of exploration steps before a neural network parameter update is made t max = 24, and entropy regularization factor β = 0.01. We use 32 parallel agents, and a learning rate of 0.0001 for optimizing our model using the ADAM optimizer <ref type="bibr" target="#b2">[Kingma and Ba, 2015]</ref>. We also use gradient clipping to prevent the gradients from exploding <ref type="bibr">[Pascanu et al., 2013]</ref>. We configure the PL correction framework for our task by setting max episode len = 100, step penalty = −0.005, edit penalty = −0.025, maximum reward = 1, and intermediate reward = 0.045. In order to accelerate training, we use expert demonstrations for one tenth of examples in the training dataset. In our experiments, we observed that using more demonstrations did not result in significant speedup in training while reducing the demonstrations slowed it down. With demonstrations, the training took about four days for 10 epochs of training on an Intel(R) Xeon(R) E5-2630 v4 machine, clocked at 2.20GHz with 32GB of RAM.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Evaluation</head><p>In this section, we first discuss the training performance of RLAssist with expert demonstrations on one tenth of the training data. Next, we compare it with DeepFix on the test dataset described earlier. Later we compare RLAssist with two baselines which are trained without using any expert demonstrations. While the first baseline fails to learn at all, the second one is able to learn enough to match the performance of DeepFix, demonstrating that RLAssist can be trained using only erroneous programs and self-exploration.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Training Performance of RLAssist</head><p>In order to evaluate the training performance of RLAssist, we use the following metrics: (1) the percentage of error messages resolved, (2) the average episode length, (3) the average number of edit actions, and (4) the average reward obtained by the agent as the training progresses. We report the training performance on one of the folds. For ease of plotting, the average reward shown in the figures is scaled by a factor of 100. <ref type="figure" target="#fig_1">Figure 2a</ref> illustrates the training performance of RLAssist.</p><p>RLAssist learns to solve the task very well and is able to resolve about 90% of the error messages after training for about a million episodes. In the last epoch of training, RLAssist reaches the goal state for 85% of the episodes. Furthermore, it manages to resolve 56% of the error messages for the programs corresponding to the remaining 15% episodes. At the same time, the average scaled reward also reaches the maximum of about 52 from −65, the reward obtained at the beginning of the training. The maximum scaled reward is almost always less than 100 because of the penalty that the agent incurs for navigating to the error location. The average length of an episode reaches about 38 consisting about 31 navigation and 7 edit actions. For the 85% of the programs that RLAssist fixes in the last epoch, the number of rejected edit actions  per episode is less than 4. This shows that RLAssist not only learns to fix a program but it also learns to do so by taking almost precise navigation and edit actions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Comparison with DeepFix</head><p>In <ref type="table" target="#tab_0">Table 1</ref>, we show the comparison of RLAssist with Deep-Fix on the test dataset. For this comparison, we use the number of error messages resolved, and completely and partially fixed programs; the same metrics as reported in <ref type="bibr" target="#b1">[Gupta et al., 2017]</ref>. Further in <ref type="table" target="#tab_2">Table 2</ref>, we also report the number of programs which are fixed exclusively by DeepFix or RLAssist. For comparison, we take the most recent results available from the DeepFix webpage: https://bitbucket.org/ iiscseal/deepfix. <ref type="table" target="#tab_0">Table 1</ref>, the test dataset has 16766 error messages from 6975 erroneous programs out of which DeepFix resolves 5156 error messages, fixing 1625 programs completely and 1129 partially. RLAssist resolves 6652 error messages, fixing 1854 programs completely and 1426 partially. Thus RLAssist outperforms DeepFix by a relative margin of 29% and 14% in terms of error messages resolved and completely fixed programs, respectively. Relative to DeepFix, the percentage of programs fixed partially by RLAssist is 26% higher. At test time, both RLAssist and DeepFix take less than a second to fix a program.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>As shown in</head><p>One reason for better performance of RLAssist is that it works at a finer token-level granularity compared to the coarser line-level granularity of DeepFix. RLAssist can edit an incorrect line in place, whereas DeepFix has to produce a complete replacement of the erroneous line. This requires it to copy the correct token subsequences from the input while simultaneously rectifying the erroneous tokens. Another reason is that DeepFix halts when it cannot fix a line, i.e., if it fails to fix an erroneous line, it cannot fix the subsequent erroneous lines. This limitation arises because of the iterative nature of DeepFix. If a fix suggested by DeepFix is accepted by the compiler, the fix is applied and the updated program is shown to DeepFix to identify the next fix. However, if it is rejected, the iterative procedure stops. RLAssist, on the other hand, does not have such a limitation. If the action taken by the agent is rejected by the environment, it takes the next highest value action and continues to attempt other fixes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Comparison with Baselines</head><p>We now discuss two baselines which do not use expert demonstrations for training. Baseline1 is identical to RLAssist except that it does not use demonstrations. <ref type="figure" target="#fig_1">Figure 2b</ref> shows the training performance of Baseline1. It shows that the training fails to make any progress even after 1.5 million episodes. As the edit actions are penalized more than the navigation actions, the agent tries only about 5 edits per episode <ref type="figure">Figure 3</ref>: PCA projection of embeddings of 350 programs in three different states. The first, the second, and the third states are shown by diamonds, squares, and circles, respectively. during exploration, causing the training to fail.</p><p>Considering this, in Baseline2, we set the edit penalty to zero. As seen in <ref type="figure" target="#fig_1">Figure 2c</ref>, this baseline starts showing signs of learning after a million episodes. After about 1.5 million episodes (about 10 epochs), it learns to resolve nearly 70% of the error messages. With additional 10 epochs (not shown in <ref type="figure" target="#fig_1">Figure 2c</ref>), it resolves 76% of the error messages. Further, it matches the performance of DeepFix on the test dataset. In fact, it slightly outperforms DeepFix. This shows that RLAssist can also be trained entirely through self-exploration without using any expert demonstrations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Embedding Visualization</head><p>We select 350 test programs containing only one error per program. Next, we get embeddings corresponding to the following three states of each of these programs: (1) when the cursor is set to the first token of the line preceding the erroneous line, (2) when the cursor is set to the first token of the erroneous line, and (3) when the cursor is set to the error location and the program has been fixed. <ref type="figure">Figure 3</ref> shows the first three principal components of these embeddings. It can be seen that the three states form three distinct clusters with almost no overlap. This shows that RLAssist's encoder learns to capture not only the syntactic validity of the programs but also the location of the errors in them. This in turn helps the agent select appropriate actions, e.g., move down in the first state and move right in the second state.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusions and Future Work</head><p>We address the problem of programming language correction and present a novel deep reinforcement learning based solution, called RLAssist, for it. We compare RLAssist with a state-of-the-art tool, DeepFix, on the task of correcting typographic errors in 6975 student-written erroneous C programs. Our experiments show that RLAssist outperforms DeepFix. Moreover, we show that RLAssist can be trained without any expert demonstrations while still matching performance of DeepFix.</p><p>RLAssist is programming language agnostic and has been evaluated on C programs. In future, we will experiment with other programming languages as well. We plan to extend RLAssist to target more classes of errors, and devise RL algorithms that can learn and exploit deeper syntactic and semantic properties of programs.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>An erroneous program and the sequence of actions taken by a trained agent to fix it: The error locations are highlighted in the red color. The arrows show how the agent navigates over the program text. The edit actions are marked by e1 and e2.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Training performance comparison of RLAssist with two baselines on one fold of the training dataset. None of the baselines uses expert demonstrations. Additionally, Baseline2 has edit penalty set to zero. The X-axis shows the number of training episodes in millions. epLen and fix% stand for episode length and the percentage of error messages resolved, respectively.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 :</head><label>1</label><figDesc>(23.3%) 1129 (16.2%) 5156 (30.8%) 1854 (26.6%) 1426 (20.4%) 6652 (39.7%) Summary of the test dataset and performance comparison of DeepFix and RLAssist on it.</figDesc><table><row><cell cols="2">Dataset statistics</cell><cell></cell><cell>DeepFix results</cell><cell></cell><cell></cell><cell>RLAssist results</cell><cell></cell></row><row><cell>Erroneous</cell><cell>Error</cell><cell>Completely</cell><cell>Partially</cell><cell>Error</cell><cell>Completely</cell><cell>Partially</cell><cell>Error</cell></row><row><cell>programs</cell><cell>msgs.</cell><cell>fixed</cell><cell>fixed</cell><cell>messages</cell><cell>fixed</cell><cell>fixed</cell><cell>messages</cell></row><row><cell></cell><cell></cell><cell>programs</cell><cell>programs</cell><cell>resolved</cell><cell>programs</cell><cell>programs</cell><cell>resolved</cell></row><row><cell cols="3">6975 16766 1625</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 2 :</head><label>2</label><figDesc>Comparison of DeepFix and RLAssist on the number of programs fixed exclusively by each technique.</figDesc><table /><note></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1">https://www.cse.iitk.ac.in/users/karkare/ prutor/prutor-deepfix-09-12-2017.db.gz</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2">https://github.com/awjuliani/ DeepRL-Agents/</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>We thank Sonata Software Ltd. for partially funding this work.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Brenna Argall, Sonia Chernova, Manuela Veloso, and Brett Browning. A survey of robot learning from demonstration</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">[</forename><surname>References</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Abadi</surname></persName>
		</author>
		<ptr target="https://www.cse.iitk.ac.in/users/karkare/prutor/" />
	</analytic>
	<monogr>
		<title level="m">Rajdeep Das, Umair Z. Ahmed, Amey Karkare, and Sumit Gulwani. Prutor: A system for tutoring cs1 and collecting student programs for analysis</title>
		<editor>Chodorow et al., 2007] Martin Chodorow, Joel R Tetreault, and Na-Rae Han</editor>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="page" from="25" to="30" />
		</imprint>
	</monogr>
	<note>Proceedings of the 12th USENIX Symposium on Operating Systems Design and Implementation</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">DeepFix: Fixing common c language errors by deep learning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">[</forename><surname>Gupta</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 31st AAAI Conference on Artificial Intelligence</title>
		<meeting>the 31st AAAI Conference on Artificial Intelligence</meeting>
		<imprint>
			<date type="published" when="2017" />
			<biblScope unit="page" from="1345" to="1351" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Automatic grading and feedback using program repair for introductory programming courses</title>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM Conference on Innovation and Technology in Computer Science Education</title>
		<editor>Alla Rozovskaya, Kai-Wei Chang, Mark Sammons, Dan Roth, and Nizar Habash</editor>
		<meeting>the ACM Conference on Innovation and Technology in Computer Science Education</meeting>
		<imprint>
			<publisher>MIT press Cambridge</publisher>
			<date type="published" when="1997" />
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="34" to="42" />
		</imprint>
	</monogr>
	<note>The 5th International Conference on Learning Representations</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
