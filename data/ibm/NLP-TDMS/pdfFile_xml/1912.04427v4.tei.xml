<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /nfs/home/kabenamualus/Research/task-dataset-metric-extraction/../grobid-0.6.0/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Winning the Lottery with Continuous Sparsification</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pedro</forename><surname>Savarese</surname></persName>
							<email>savarese@ttic.edu</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hugo</forename><surname>Silva</surname></persName>
							<email>hugoluis@ualberta.ca</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Maire</surname></persName>
							<email>mmaire@uchicago.edu</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">TTI-Chicago</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">University of Alberta</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="institution">University of Chicago</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Winning the Lottery with Continuous Sparsification</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>

		<encodingDesc>
			<appInfo>
				<application version="0.6.0" ident="GROBID-SDO" when="2021-06-26T08:36+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid-sdo"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The search for efficient, sparse deep neural network models is most prominently performed by pruning: training a dense, overparameterized network and removing parameters, usually via following a manually-crafted heuristic. Additionally, the recent Lottery Ticket Hypothesis conjectures that, for a typically-sized neural network, it is possible to find small sub-networks which, when trained from scratch on a comparable budget, match the performance of the original dense counterpart. We revisit fundamental aspects of pruning algorithms, pointing out missing ingredients in previous approaches, and develop a method, Continuous Sparsification, which searches for sparse networks based on a novel approximation of an intractable 0 regularization. We compare against dominant heuristic-based methods on pruning as well as ticket search -finding sparse subnetworks that can be successfully re-trained from an early iterate. Empirical results show that we surpass the state-ofthe-art for both objectives, across models and datasets, including VGG trained on CIFAR-10 and ResNet-50 trained on ImageNet. In addition to setting a new standard for pruning, Continuous Sparsification also offers fast parallel ticket search, opening doors to new applications of the Lottery Ticket Hypothesis.</p><p>Prior work has shown that pruned networks are hard to train from scratch <ref type="bibr" target="#b2">[3]</ref>, suggesting that while overparameterization is not necessary for a model's capacity, it might be required for successful training. Frankle and Carbin <ref type="bibr" target="#b12">[13]</ref> put this idea into question by training heavily pruned networks</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Although deep neural networks have become ubiquitous in fields such as computer vision and natural language processing, extreme overparameterization is typically required to achieve stateof-the-art results, incurring higher training costs and hindering applications limited by memory or inference time. Recent theoretical work suggest that overparameterization plays a key role in network training dynamics <ref type="bibr" target="#b0">[1]</ref> and generalization <ref type="bibr" target="#b1">[2]</ref>. However, it remains unclear whether, in practice, overparameterization is truly necessary to train networks to state-of-the-art performance.</p><p>Concurrently, empirical approaches have been successful in finding compact neural networks, either by shrinking trained models <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b4">5]</ref> or through efficient architectures, yielding less overparameterized models that can be trained from scratch <ref type="bibr" target="#b5">[6]</ref>. Recently, combining these two strategies has lead to new methods which discover efficient architectures through optimization instead of design <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b7">8]</ref>. Nonetheless, parameter efficiency is typically maximized by pruning an already trained network.</p><p>Despite the fact that the search for sparse solutions to optimization problems can be naturally described by 0 regularization, the vast majority of pruning methods rely on manually-designed strategies that are not based on the 0 penalty <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b9">10]</ref>. The approaches that aim to approximate an 0 -regularized problem in order to find sparse, less overparameterized networks are limited in number <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b11">12]</ref> and fail to perform competitively against heuristic-based pruning methods. from scratch, while achieving performance matching that of their original counterparts. A key finding is that the same initialization should be used when re-training the pruned network, or, equivalently, that better strategies -depending on future weights -can result in trainable pruned networks.</p><p>More recently, Frankle et al. <ref type="bibr" target="#b13">[14]</ref> show that although this approach can fail in large-scale settings, pruned networks can be successfully re-trained when parameters from very early training are used as initialization. Coupling a pruned network with a set of parameter values from initialization yields a ticket -a winning ticket if it is able to match the dense model's performance when trained in isolation for a comparable number of iterations. These have already found applications in, for example, transfer learning <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b16">17]</ref>, making ticket search a problem of independent interest.</p><p>Iterative Magnitude Pruning (IMP) <ref type="bibr" target="#b12">[13]</ref>, the first and currently only algorithm able to find winning tickets, consists of a repeating a two-stage procedure that alternates between training and pruning. IMP relies on a sensible choice for pruning strategy <ref type="bibr" target="#b17">[18]</ref> and can be costly: maximizing the performance of the found subnetworks typically requires multiple rounds of training followed by pruning <ref type="bibr" target="#b18">[19]</ref>.</p><p>In this paper, we focus on two questions related to pruning and the Lottery Ticket Hypothesis. First, can we find sparse networks with competitive performance by approximating 0 regularization instead of relying on a heuristic pruning strategy and, if yes, what are the missing ingredients in previous approaches <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b11">12]</ref>? Second, would a method that relies on 0 -regularization, rather than an ad-hoc heuristic, be able to find winning tickets, as IMP does?</p><p>We provide positive answers to both questions by proposing Continuous Sparsification 1 , a new pruning method that relies on approximating the intractable 0 penalty and finds networks that perform competitively when either fine-tuned or re-trained. Unlike prior 0 -based approaches, our approximation is deterministic, providing insights and raising questions on how pruning and sparse regularization should be performed. The core of our method lies in constructing a smooth continuation path <ref type="bibr" target="#b19">[20]</ref> connecting training of soft-gated parameters and the intractable 0 -regularized objective.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Contributions:</head><p>• We propose a novel approximation to 0 regularization, resulting in Continuous Sparsification, a new pruning method with theoretical and empirical advantages over previous 0 -based approaches.</p><p>We show through experiments that the deterministic nature of our re-parameterization is key to achieving competitive results with 0 approximations. • We show that Continuous Sparsification outperforms state-of-the-art heuristic-based pruning methods. Our experiments include pruning of VGG-16 <ref type="bibr" target="#b20">[21]</ref> and ResNet-20 <ref type="bibr" target="#b21">[22]</ref> trained on CIFAR-10 <ref type="bibr" target="#b22">[23]</ref>, and ResNet-50 trained on ImageNet <ref type="bibr" target="#b23">[24]</ref>. • Our method raises questions on how to do better ticket search -producing subnetworks that can be re-trained from early iterates. We show empirically that Continuous Sparsification is capable of finding subnetworks of VGG-16, ResNet-20, and ResNet-50 that, when re-trained, outperform ones found by IMP. Moreover, the search cost of our method does not depend on the produced subnetwork's sparsity, making ticket search considerably more efficient when run in parallel.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Preliminaries</head><p>Here we define terms used throughout the paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Subnetwork:</head><p>For a network f that maps samples x ∈ X and parameters w ∈ R d to f (x; w), a subnetwork f of f is given by a binary mask m ∈ {0, 1} d , where a parameter component w i is kept in f if m i = 1 and removed otherwise i.e., f : x, w → f (x; w m), with denoting element-wise multiplication. For any configuration m, the effective parameter space of the induced network f is {w m|w ∈ R d } -a m 0 -dimensional space, hence we say that the subnetwork f has m 0 many parameters instead of d.</p><p>Matching subnetwork: For a network f and randomly-initialized parameters w (0) , a matching subnetwork f of f is given by a configuration m ∈ {0, 1} d , such that f can be trained in isolation from w (0) = w (k) m, where w (k) is the collection of parameter values obtained by training f from w (0) for k iterations, where k is small. Moreover, to be a matching subnetwork, f needs to match the performance of a trained f given the same budget, when measured in terms of training iterations.</p><p>Winning ticket: For a network f and randomly-initialized parameters w (0) , a winning ticket is a matching subnetwork f of f that can be trained in isolation from initialization, i.e., w (0) = w (0) m. In other words, a winning ticket is a matching subnetwork such that k = 0 in the definition above.</p><p>Ticket search is the task of finding matching subnetworks given a network f and randomly-initialized parameters w (0) . We say that an algorithm A performs ticket search if A(f, w (0) ) = m ∈ {0, 1} d , such that m induces a (possibly matching) subnetwork f .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Related Work</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Sparse Networks</head><p>Classical pruning methods <ref type="bibr" target="#b24">[25]</ref> follow a pre-defined strategy to remove weights, and generally operate by ranking parameters according to an easy-to-compute statistic like weight magnitude <ref type="bibr" target="#b2">[3]</ref>. Such methods rely on the assumption that the considered statistic is a sensible surrogate for how much each parameter affects a network's output, and typically select weights for removal once the dense model has been fully trained. Magnitude-based pruning, the most prominent heuristic pruning method, improves when given multiple rounds of training followed by pruning <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b25">26]</ref>.</p><p>Another approach consists of approximating an intractable 0 -regularized objective which accounts for the number of non-zero weights in the model, yielding one-stage procedures that can be fully described in the optimization framework. More common in the literature are stochastic approximations, where a binary mask m over the weights is sampled from a distribution M(s) at each training iteration, introducing new variables s which are optimized jointly with the weight parameters <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b11">12]</ref>.</p><p>Training the mask parameters s is done by estimating the gradients of the expected loss w.r.t. s, e.g., via the straight-through estimator <ref type="bibr" target="#b26">[27]</ref>, thus relying on estimated gradients which can be biased and have high variance. 0 -based methods have the advantage of not relying on a heuristic to prune weights, and continuously sparsify the network during training instead of at pre-defined steps.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Lottery Ticket Hypothesis</head><p>Frankle and Carbin <ref type="bibr" target="#b12">[13]</ref> show that, in some settings, sparse subnetworks can be successfully retrained and yield better performance than their original dense networks, often also on a smaller compute budget for re-training. This observation leads to the Lottery Ticket Hypothesis <ref type="bibr" target="#b12">[13]</ref>, which conjectures that for a reasonably-sized network f and randomly-initialized parameters w (0) ∈ R d , there exists a sparse subnetwork f , given by a configuration m ∈ {0, 1} d , m 0 d, that can be trained from w (0) = m w (0) to perform comparably to a trained version of the original model f .</p><p>The proposal of Iterative Magnitude Pruning (IMP; Algorithm 1) <ref type="bibr" target="#b18">[19]</ref> supports this hypothesis. IMP is capable of finding such subnetworks, named winning tickets, in convolutional networks trained for image classification. IMP operates in multiple rounds, sparsifying the network at discrete time intervals and producing subnetworks with increasing sparsity levels during execution. More specifically, each round in IMP consists of: (1) training the weights w of a network, (2) pruning a fixed fraction of the weights with the smallest magnitude, and (3) rewinding: setting the remaining weights back to their original initialization w (0) . Following Frankle et al. <ref type="bibr" target="#b18">[19]</ref>, we consider a general form of IMP where step (3) is relaxed to rewind the weights to an early iterate w (k) (for relatively small k) instead of the original initialization values w (0) . We refer to the process of searching for a sparse subnetwork and a set of early iterates w (k) as ticket search, even though the produced subnetworks are truly only winning tickets when they perform comparably to the dense model when trained in isolation from w (0) , i.e., k = 0.</p><p>The search for winning tickets has attracted attention due to their valuable properties. In smallscale settings, tickets can be trained faster than their dense counterparts while yielding better final performance <ref type="bibr" target="#b12">[13]</ref>. Moreover, they can be transferred between datasets <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b16">17]</ref> and training methods <ref type="bibr" target="#b14">[15]</ref>. Zhou et al. <ref type="bibr" target="#b17">[18]</ref> attempt to better understand the Lottery Ticket Hypothesis through extensive experiments, showing that a stochastic approximation to 0 regularization can be used to perform ticket search with SGD, without ever training the weights (non-retroactive search).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 1 Iterative Magnitude Pruning [19]</head><p>Input: Pruning ratio τ , number of rounds R, iterations per round T , rewind point k</p><formula xml:id="formula_0">1: Initialize w ∼ D, m ← 1 d , r ← 1 2: Minimize L(f ( · ; m w)) for T iterations,</formula><p>producing w (T ) 3: Remove τ percent of the weights with smallest magnitude 4: If r = R, output f ( · ; m w (k) ) 5: Otherwise, set w ← w (k) , r ← r + 1 and go back to step 2, thereby starting a new round</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 2 Continuous Sparsification</head><p>Input: Mask init s (0) , penalty λ, number of rounds R, iterations per round T , rewind point k</p><formula xml:id="formula_1">1: Initialize w ∼ D, s ← s (0) , β ← 1, r ← 1 2: Minimize L(f ( · ; σ(βs) w))+λ σ(βs) 1 for T iterations while increasing β, producing w (T ) , s (T ) , and β (T ) 3: If r = R, output f ( · ; H(s (T ) ) w (k) ) 4: Otherwise, set s ← min(β (T ) s (T ) , s (0) ),</formula><p>β ← 1, r ← r + 1 and go back to step 2, thereby starting a new round</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Method</head><p>Our goal is to design a method that can efficiently sparsify networks without causing performance degradation. Ideally, and in contrast to magnitude pruning, the time to produce a subnetwork should be independent of its sparsity. Unlike dominant pruning approaches <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b8">9]</ref>, we rely on approximating 0 regularization, as it induces a clear trade-off between sparsity and performance, providing a way to maximize sparsity while maintaining performance. By continuously sparsifying the network during training, we do not require a heuristic to select which parameters to remove or when to remove them.</p><p>To avoid gradient estimators and to avoid having to commit to a configuration for m to be used at inference -obstacles that are inherent to stochastic approximations to the 0 objective -we design a deterministic approximation instead, as we describe below.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Continuous Sparsification by Learning Deterministic Masks</head><p>Given a network f that maps samples x to f (x; w) using parameters w ∈ R d , we first frame the search for sparse subnetworks as a loss minimization problem with 0 regularization:</p><formula xml:id="formula_2">min w∈R d L(f ( · ; w)) + λ · w 0 ,<label>(1)</label></formula><p>where L(f ( · ; w)) denotes the loss incurred by the network f ( · ; w) and λ ≥ 0 controls the trade-off between the loss and number of parameters w 0 . We restate the above minimization problem as</p><formula xml:id="formula_3">min w∈R d , m∈{0,1} d L(f ( · ; m w)) + λ · m 1 ,<label>(2)</label></formula><p>which uses the fact that m 0 = m 1 for binary m. While the 1 penalty is amenable to subgradient descent, the combinatorial constraint m ∈ {0, 1} d makes local search unsuited for the problem above.</p><p>As in most methods that approximate 0 regularization, we will circumvent the discrete space of m by re-parameterizing it as a function of a newly-introduced variable s ∈ R d . In contrast to previous work <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b10">11]</ref>, we propose a re-parameterization that is fully deterministic, hence avoiding biased and/or noisy training caused by gradient estimators <ref type="bibr" target="#b26">[27]</ref>. </p><formula xml:id="formula_4">min w∈R d , s∈R d =0 L(f ( · ; H(s) w)) + λ · H(s) 1 .<label>(3)</label></formula><p>Being equivalent to (1), the above is still intractable: the step function H is discontinuous and its derivative is zero everywhere. We approximate H by constructing a set of functions indexed by β ∈ [1, ∞) given by s → σ(βs) where σ is the sigmoid function σ(s) = 1 1+e −s applied element-wise. This set can be seen as a path parameterized by β, and given any fixed s ∈ R =0 , we have at one of its endpoints lim β→∞ σ(βs) = H(s). Conversely, for β = 1 we have σ(βs) = σ(s), the standard sigmoid activation function that is smooth and widely used in neural network models.</p><p>Using this family of functions to approximate H yields the re-parameterization m := σ(βs). Controlling the inverse temperature β allows interpolation between the sigmoid activation σ(s), which assigns continuous values for m, and the step function H(s) ∈ {0, 1}. Each β induces the objective</p><formula xml:id="formula_5">L β (w, s) := L(f ( · ; σ(βs) w)) + λ · σ(βs) 1 .<label>(4)</label></formula><p>Note that if L is continuous in w, then:</p><formula xml:id="formula_6">min w∈R d s∈R d =0 lim β→∞ L β (w, s) = min w∈R d s∈R d =0 L(f ( · ; H(s) w)) + λ · H(s) 1 ,<label>(5)</label></formula><p>where the right-hand-side is equivalent to the 0 -regularized objective. Therefore, β controls the computational hardness of the objective: as β increases from 1 to ∞, the objective changes from L 1 (w, s), where a soft-gating w σ(s) is applied to the weights, to L ∞ (w, s), where weights are either removed or fully preserved. Increasing the hardness of the underlying objective during training stems from continuation methods <ref type="bibr" target="#b19">[20]</ref> and can be successful in approximating intractable problems.</p><p>In terms of sparsification, every negative component of s will drive the corresponding component of w σ(βs) to 0 as β → ∞, effectively pruning a weight. While analytically it is never the case that σ(βs) = 0 regardless of how large β is, limited numerical precision has a fortunate side-effect of causing actual sparsification to the network during training as β becomes sufficiently large.</p><p>In a nutshell, our method consists of learning sparse networks by minimizing L β (w, s) for T parameter updates with gradient descent while jointly annealing β: producing w (T ) , s (T ) and β (T ) . Note that, in order to recover a binary mask m from our re-parameterization, β must be large enough such that, numerically 2 , σ(β (T ) s (T ) ) = H(s (T ) ). Alternatively, we can directly output m = H(s (T ) ) at the end of training, guaranteeing that the learned mask is indeed binary. We adopt an exponential schedule β (t) = β (T ) t T for β during training, increasing it from 1 up to β (T ) . Such a schedule has the advantage of only requiring us to tune β (T ) , and has been successfully utilized in prior work <ref type="bibr" target="#b27">[28]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Ticket Search through Continuous Sparsification</head><p>The method described above is essentially a pruning method, which we use to replace magnitudebased pruning as the backbone for ticket search. Note that searching for matching subnetworks requires produced masks to be binary: otherwise, the magnitude of the weights will also be learned. We guarantee that the final mask is binary regardless of numerical precision by outputting H(s (T ) ).</p><p>Similarly to IMP, our ticket search procedure operates in rounds, where each round consists of training and sparsifying the network. At the beginning of a round, we set β back to 1 so that additional weights can be removed (otherwise β would be large throughout the round, causing a vanishing Jacobian of σ(βs) w.r.t. s). Moreover, we reset the parameter s of each weight w that has not been suppressed by the optimizer during the round (i.e., weights whose gating value has increased during training). This is achieved by setting s ← min(β (T ) s (T ) , s (0) ), effectively resetting the soft mask parameters s for "kept" weights without interfering with weights that have been suppressed. Algorithm 2 presents our method for ticket search, which does not rewind weights between rounds, in contrast to IMP <ref type="bibr" target="#b18">[19]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Comparison to Stochastic Approaches</head><p>Prior works <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b11">12]</ref> approximating the 0 objective adopt a stochastic re-parameterization m ∼ M(s) for some distribution M with parameters s. During training, a new binary mask m is sampled from M(s) at every forward pass of the network. Hence, outputs can change drastically from one pass to another due to variance in sampling. Such approaches have found limited success in pruning.</p><p>Gale et al. <ref type="bibr" target="#b25">[26]</ref> report that the stochastic approach from Louizos et al. <ref type="bibr" target="#b11">[12]</ref> fails to sparsify a residual network without degrading its accuracy to random chance. Stochastic approximations introduce another problem: different behavior between training and inference. While a new mask is sampled at each training iteration, at inference it is common to use a deterministic mask, such as that with highest mass <ref type="bibr" target="#b10">[11]</ref> or an approximation for it <ref type="bibr" target="#b11">[12]</ref>. This assures that the outputs at inference are consistent, but can introduce a gap in sparsity and performance between training and inference modes.</p><p>Conversely, Continuous Sparsification offers consistency in training mode -outputs for a input are the same across forward passes -and no gap between training and inference. In Section 5.2, experimental comparisons with stochastic approximations show that these differences play a key role in attaining faster training, higher sparsity, and superior performance when pruning deep networks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Experiments</head><p>We compare methods on the tasks of pruning and finding matching subnetworks. We quantify the performance of ticket search by focusing on two specific subnetworks produced by each method: • Sparsest matching subnetwork: the sparsest subnetwork that, when trained in isolation from an early iterate, yields performance no worse than that achieved by the trained dense counterpart. • Best performing subnetwork: the subnetwork that achieves the best performance when trained in isolation from an early iterate, regardless of its sparsity.</p><p>We also measure the efficiency of each method in terms of total number of epochs to produce subnetworks, given enough parallel computing resources. As we will see, Continuous Sparsification is particularly suited for parallel execution since it requires relatively few rounds to produce subnetworks regardless of sparsity. On the other hand, CS offers no explicit mechanism to control the sparsity of the found subnetworks, hence producing a subnetwork with a pre-defined sparsity level can require multiple runs with different hyperparameter settings. For this use case, IMP is more efficient by design, since a single run suffices to produce subnetworks with varying, pre-defined sparsity levels.</p><p>For Continuous Sparsification, we set hyperparameters λ = 10 −8 and β (T ) = 200, based on analysis in Appendix A, which studies how λ, s (0) , and β (T ) affect the sparsity of produced subnetworks. We observe that s (0) has a major impact on sparsity levels, while λ and β (T ) require little to no tuning.</p><p>We reiterate that Continuous Sparsification does not perform weight rewinding in the following experiments; rather, it maintains weights between rounds. Our experimental comparisons include a variant of IMP that also does not rewind weights between rounds, which we denote as "continued" IMP (IMP-C). Algorithms 1 and 2 provide more implementation details. Comparisons against a baseline inspired by Zhou et al. <ref type="bibr" target="#b17">[18]</ref>, and described in Appendix B, on the tasks of learning a supermask and ticket search on a 6-layer CNN can be found in Appendices C and D.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Ticket Search on Residual Networks and VGG</head><p>First, we evaluate how IMP and CS perform on the task of ticket search for VGG-16 <ref type="bibr" target="#b20">[21]</ref> and ResNet-20 <ref type="bibr" target="#b2">3</ref>  <ref type="bibr" target="#b21">[22]</ref> trained on the CIFAR-10 dataset, a setting where IMP can take over 10 rounds (850 epochs given 85 epochs per round <ref type="bibr" target="#b18">[19]</ref>) to find sparse subnetworks. We follow Frankle and Carbin's setup <ref type="bibr" target="#b12">[13]</ref>: in each round, we train with SGD, a learning rate of 0.1, and a momentum of 0.9, for a total of 85 epochs, using a batch size of 64 for VGG and 128 for ResNet. We decay the learning rate by a factor of 10 at epochs 56 and 71, and utilize a weight decay of 0.0001.</p><p>For CS, we do not apply weight decay to the mask parameters s, since they are already suffer 1 regularization. Sparsification is performed on all convolutional layers, excluding the two skipconnections of ResNet-20 that have 1 × 1 kernels: for IMP, their parameters are not pruned, while for CS their weights do not have an associated learnable mask.</p><p>We evaluate produced subnetworks by initializing their weights with the iterates from the end of epoch 2, similarly to Frankle et al. <ref type="bibr" target="#b18">[19]</ref>, followed by re-training. IMP performs global pruning at a per-round rate of removing 20% of the remaining parameters with smallest magnitude. We run IMP for 30 iterations, yielding 30 tickets with varying sparsity levels (80%, 64%, . . . ). To produce tickets of differing sparsity with CS, we vary s (0) across 11 values from −0.3 to 0.3, performing a run of 5 rounds for each setting. We repeat experiments 3 times, with different random seeds.    <ref type="figure" target="#fig_1">Figure 1</ref> shows the performance and sparsity of tickets produced by CS and IMP, including IMP without rewinding (continued). Purple curves show individual runs of CS for different values of s (0) , each consisting of 5 rounds, and the green curve shows the performance of subnetworks produced with different hyperparameters. Plots of individual runs are available in Appendix E, but have been omitted here for the sake of clarity. Given a search budget of 5 rounds (i.e., 5 × 85 = 425 epochs), CS successfully finds subnetworks with diverse sparsity levels. Notably, IMP produces tickets with superior performance when weight rewinding is not employed between rounds. <ref type="table" target="#tab_1">Table 1</ref> summarizes the performance of each method when evaluated in terms of the sparsest matching and best performing subnetworks. IMP-C denotes IMP without rewinding, i.e., IMP (continued) from <ref type="figure" target="#fig_1">Figure 1</ref>. Sparsest matching subnetworks produced by CS are sparser than the ones found by IMP and IMP-C, while also delivering higher accuracy. CS also outperforms IMP and IMP-C when evaluating the best performing produced subnetworks. In particular, CS yields highly sparse subnetworks that outperform the original model by approximately 1% on both VGG-16 and ResNet-20.</p><p>If all runs are executed in parallel, producing all tickets presented in <ref type="figure" target="#fig_1">Figure 1</ref> takes CS a total of 5 × 85 = 425 training epochs, while IMP requires 30 × 85 = 2550 epochs instead. Note that our re-parameterization results in approximately 10% longer training times on a GPU due to the mask parameters s, therefore wall-clock time for CS is 10% higher per epoch. Sequential search takes 5 × 11 × 85 = 4675 epochs for CS to produce all tickets in <ref type="figure" target="#fig_1">Figure 1</ref>, while IMP requires 30 × 85 = 2550 epochs, hence CS is faster given sufficient parallelism, but slower if run sequentially. Appendix F shows preliminary results of a variant of CS designed for sequential search.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Pruning</head><p>Since CS is a general-purpose method to find sparse networks, we also evaluate it on the more standard task of network pruning, where produced subnetworks are fine-tuned instead of re-trained. We compare it against the prominent pruning methods AMC <ref type="bibr" target="#b28">[29]</ref>, magnitude pruning (MP) <ref type="bibr" target="#b2">[3]</ref>,   GMP <ref type="bibr" target="#b3">[4]</ref>, and Network Slimming (Slim) <ref type="bibr" target="#b29">[30]</ref>, along with the 0 -based method of Louizos et al. <ref type="bibr" target="#b11">[12]</ref> (referred to as " 0 "), which, in contrast to ours, adopts a stochastic approximation for 0 regularization.</p><p>We Adopting the inference behavior suggested in Louizos et al. <ref type="bibr" target="#b11">[12]</ref> for 0 , i.e., using the expected value of the uniform distribution to generate hard concrete samples, leads to poor results, including accuracy akin to random guessing at sparsity above 90%; this is also reported in Gale et al. <ref type="bibr" target="#b25">[26]</ref>. Instead, at epoch 160, we sample different masks and commit to the one that performs the best -this strategy results in drastic improvements at high sparsity levels. This suggests that the gap between training and inference behavior introduced by stochastic approaches can be an obstacle. Although our modification improves results for 0 , the method still performs poorly compared to alternatives.</p><p>Moreover, some methods required modifications as they were originally designed to perform structured pruning. For AMC, Slim, and 0 we replace a filter-wise mask by one that acts over weights.</p><p>Since Network Slimming relies on the filter-wise scaling factors of batch norm, we introduce weightwise scaling factors which are trained jointly with the weights. We observe that applying both 1 and 2 regularization to the scaling parameters, as done by Liu et al. <ref type="bibr" target="#b29">[30]</ref>, yields inferior performance, which we attribute to over-regularization. A grid search over the penalty of each norm regularizer shows that only applying 1 regularization with a strength of λ 1 = 10 −5 for ResNet-20 and λ 1 = 10 −6 for VGG-16 improves results.  <ref type="table" target="#tab_3">Table 2</ref> shows the percentage of weights that each method can remove while maintaining a performance within 2% of the original, dense model. CS is capable of removing significantly more parameters than all competing methods on both networks: on ResNet-20, the pruned network found by CS contains 60% less parameters than the one found by GMP, when counting prunable parameters only. CS not only offers significantly superior performance compared to the prior 0 -based method of Louizos et al. <ref type="bibr" target="#b11">[12]</ref>, but also comfortably outperforms all other methods, providing a new state-of-the-art for network pruning.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Residual Networks on ImageNet</head><p>We perform pruning and ticket search for ResNet-50 trained on ImageNet <ref type="bibr" target="#b23">[24]</ref>. Following Frankle et al. <ref type="bibr" target="#b18">[19]</ref>, we train the network with SGD for 90 epochs, with an initial learning rate of 0.1 that is decayed by a factor of 10 at epochs 30 and 60. We use a batch size of 256 distributed across 4 GPUs and a weight decay of 0.0001. We run CS for a single round due to the high computational cost of training ResNet-50 on ImageNet. Once the round is complete, we evaluate the performance of the produced subnetwork when fine-tuned (pruning) or re-trained from an early iterate (ticket search). We run CS with s (0) ∈ {0.0, −0.01, −0.02, −0.03, −0.05} yielding 5 subnetworks with varying sparsity levels. <ref type="table" target="#tab_4">Table 3</ref> summarizes the results achieved by CS, IMP, and current state-of-the-art pruning methods GMP <ref type="bibr" target="#b3">[4]</ref>, STR <ref type="bibr" target="#b9">[10]</ref>, and DNW <ref type="bibr" target="#b8">[9]</ref>. A † superscript denotes results of a re-trained, rather than fine-tuned, subnetwork. Differences in each technique's methodology -for example, the adopted learning rate schedule and number of epochs -complicate the comparison.</p><p>CS produces subnetworks that, when re-trained, outperform the ones found by IMP by a comfortable margin (compare CS † and IMP † ). Moreover, when evaluated as a pruning method, CS outperforms all competing approaches, especially in the high-sparsity regime. Therefore, our method provides state-of-the-art results whether the network is fine-tuned (pruning) or re-trained (ticket search).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Discussion</head><p>With Frankle and Carbin <ref type="bibr" target="#b12">[13]</ref>, we now realize that sparse subnetworks can indeed be successfully trained from scratch or an early iterate, putting in question whether overparameterization is required for proper optimization of neural networks. Such subnetworks can potentially decrease the required resources for training deep networks, as they are shown to transfer between different, but similar, tasks <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b16">17]</ref>.</p><p>The search for winning tickets is a poorly explored problem, with, prior to our work, Iterative Magnitude Pruning <ref type="bibr" target="#b12">[13]</ref> standing as the only algorithm suited for this task. It is unclear whether IMP's key ingredients -post-training magnitude pruning and parameter rewinding -are the correct choices. Here, we approach the problem of finding sparse subnetworks as an 0 -regularized optimization problem, which we approximate through a smooth relaxation of the step function.</p><p>Our proposed algorithm, Continuous Sparsification, relies on a deterministic approximation of 0 regularization, removes parameters automatically and continuously during training, and can be fully described by the optimization framework. We show empirically that, indeed, post-training pruning might not be the most sensible choice for ticket search, raising questions on how the search for tickets differs from standard network compression. In tasks such as pruning VGG and finding winning tickets in ResNets, our method offers improvements in terms of ticket search and resulting sparsity -we can sparsify VGG to extreme levels, and speed up ticket search using an efficiently parallelizable framework. We hope to further motivate the problem of quickly finding tickets in complex networks, as the task might be highly relevant to transfer learning and mobile applications.</p><p>At the same time, Continuous Sparsification serves as a practical network pruning method, outperforming modern competitors as measured by accuracy and sparsity of produced subnetworks. Continuous Sparsification's principled formulation has the potential to open new avenues for research into neural network optimization and architecture search.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix A Hyperparameter Analysis</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.1 Continuous Sparsification</head><p>In this section, we study how the hyperparameters of Continuous Sparsification affect its behavior in terms of sparsity and performance of the produced tickets. More specifically, we consider the following hyperparameters:</p><p>• Final temperature β (T ) : the final value for β, which controls how close to the original 0 -regularized problem the proxy objective L β (w, s) is. • 1 penalty λ: the strength of the 1 regularization applied to the soft mask σ(βs), which promotes sparsity.</p><p>• Mask initial value s (0) : the value used to initialize all components of the soft mask m = σ(βs), where smaller values promote sparsity.</p><p>Our setup is as follows. To analyze how each of the 3 hyperparameters impact the performance of Continuous Sparsification, we train ResNet-20 on CIFAR-10 (following the same protocol from Section 5.1), varying one hyperparameter while keeping the other two fixed. To capture how hyperparameters interact with each other, we repeat the described experiment with different settings for the fixed hyperparameters.</p><p>Since different hyperparameter settings naturally yield vastly distinct sparsity and performance for the found tickets, we report relative changes in accuracy and in sparsity.</p><p>In <ref type="figure" target="#fig_7">Figure 3</ref>     . Results are given in <ref type="figure" target="#fig_9">Figure 5</ref>: unlike the exploration on λ and β (T ) , we can see that s (0) has a strong and consistent effect on the sparsity of the found tickets. For this reason, we suggest proper tuning of s (0) when the goal is to achieve a specific sparsity value. Since the percentage of remaining weights is monotonically increasing with s (0) , we can employ search strategies over values for s (0) to achieve pre-defined desired sparsity levels (e.g., binary search). In terms of performance, lower values for s (0) naturally lead to performance degradation, since sparsity quickly increases as s (0) becomes more negative. Test Accuracy (%) IMP, prune rate = 0.1 IMP, prune rate = 0.2 IMP, prune rate = 0.4 IMP, prune rate = 0.6 <ref type="figure">Figure 6</ref>: Performance of tickets found by Iterative Magnitude Pruning in a ResNet-20 trained on CIFAR-10, for different pruning rates.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.2 Iterative Magnitude Pruning</head><p>Here, we assess whether the running time of Iterative Magnitude Pruning can be improved by increasing the amount of parameters pruned at each iteration. The goal of this experiment is to evaluate if better tickets (both in terms of performance and sparsity) can be produced by more aggressive pruning strategies.</p><p>Following the same setup as the previous section, we train ResNet-20 on CIFAR-10. We run IMP for 30 iterations, performing global pruning with different pruning rates at the end of each iteration. <ref type="figure">Figure 6</ref> shows that the performance of tickets found by IMP decays when the pruning rate is increased to 40%. In particular, the final performance of found tickets is mostly monotonically decreasing with the number of remaining parameters, suggesting that, in order to find tickets which outperform the original network, IMP is not compatible with more aggressive pruning rates. Besides comparing our proposed method to Iterative Magnitude Pruning (Algorithm 1), we also design a baseline method, Iterative Stochastic Sparsification (ISS, Algorithm 3), motivated by the procedure in Zhou et al. <ref type="bibr" target="#b17">[18]</ref> to find a binary mask m with gradient descent in an end-to-end fashion. More specifically, ISS uses a stochastic re-parameterization m ∼ Bernoulli(σ(s)) with s ∈ R d , and  <ref type="figure">Figure 7</ref>: Learning a binary mask with weights frozen at initialization with Stochastic Sparsification (SS, Algorithm 3 with one iteration) and Continuous Sparsification (CS), on a 6-layer CNN on CIFAR-10. Left: Training curves with hyperparameters for which masks learned by SS and CS were both approximately 50% sparse. CS learns the mask significantly faster while attaining similar early-stop performance. Right: Sparsity and test accuracy of masks learned with different settings for SS and CS: our method learns sparser masks while maintaining test performance, while SS is unable to successfully learn masks with over 50% sparsity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B Iterative Stochastic Sparsification</head><p>trains w and s jointly with gradient descent and the straight-through estimator <ref type="bibr" target="#b26">[27]</ref>. Note that the method is also similar to the one proposed by Srinivas et al. <ref type="bibr" target="#b10">[11]</ref> to prune networks. The goal of this baseline and comparisons is to evaluate whether the deterministic nature of CS's re-parameterization is advantageous when performing sparsification through optimization methods.</p><p>When run for multiple iterations, all components of the mask parameters s which have decreased in value from initialization are set to −∞, such that the corresponding weight is permanently removed from the network. While this might look arbitrary, we observe empirically that ISS was unable to remove weights quickly without this step unless λ was chosen to be large -in which case the model's performance decreases in exchange for sparsity.</p><p>We also observe that the mask parameters s require different settings in terms of optimization to be successfully trained. In particular, Zhou et al. <ref type="bibr" target="#b17">[18]</ref> use SGD with a learning rate of 100 when training s, which is orders of magnitude larger than the one used when training CNNs. Our observations are similar, in that typical learning rates on the order of 0.1 cause s to be barely updated during training, which is likely a side-effect of using gradient estimators to obtain update directions for s. The following sections present experiments that compare IMP, CS and ISS on ticket search tasks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C Supermask Search on a 6-layer CNN</head><p>We train a neural network with 6 convolutional layers on the CIFAR-10 dataset <ref type="bibr" target="#b22">[23]</ref>, following Frankle and Carbin <ref type="bibr" target="#b12">[13]</ref>. The network consists of three blocks of two resolution-preserving convolutional layers followed by 2 × 2 max-pooling, where convolutions in each block have 64, 128, and 256 channels, a 3 × 3 kernel, and are immediately followed by ReLU activations. The blocks are followed by fully-connected layers with 256, 256, and 10 neurons, with ReLUs in between. The network is trained with Adam <ref type="bibr" target="#b30">[31]</ref> with a learning rate of 0.0003 and a batch size of 60.</p><p>As a first baseline, we consider the task of learning a "supermask" <ref type="bibr" target="#b17">[18]</ref>: a binary mask m that aims to maximize the performance of a network with randomly initialized weights once the mask is applied. This task is equivalent to pruning a randomly-initialized network since weights are neither updated during the search for the supermask, nor for the comparison between different methods.</p><p>We only compare ISS and CS for this specific experiment: the reason not to consider IMP is that, since the network weights are kept at their initialization values, IMP amounts to removing the weights whose initialization were the smallest. Hence, we compare ISS and CS, where each method is run for a single round composed of 100 epochs. In this case, where it is run for a single round, ISS is equivalent to the algorithm proposed in Zhou et al. <ref type="bibr" target="#b17">[18]</ref> to learn a supermask, referred here as simply Stochastic Sparsification (SS). We control the sparsity of the learned masks by varying s (0) and λ. All parameters are trained using Adam and a learning rate of 3 × 10 −4 , excluding the mask parameters s for SS, for which we adopted SGD with a learning rate of 100 -following Zhou et al. <ref type="bibr" target="#b17">[18]</ref> and the discussion in the previous section. <ref type="figure">Figure 7</ref> presents results: CS is capable of finding high performing sparse supermasks (i.e., 25% or less remaining weights while yielding 75% test accuracy), while SS fails at finding competitive supermasks for sparsity levels above 50%. Moreover, CS makes faster progress in training, suggesting that not relying on gradient estimators indeed results in better optimization and faster progress when measured in epochs or parameter updates.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D Ticket Search on a 6-layer CNN</head><p>In what follows we compare IMP, ISS and CS in the task of finding winning tickets on the Conv-6 architecture used in the supermask experiments in Appendix C. The goal of these experiments is to assess how our deterministic re-parameterization compares to the common stochastic approximations to 0 -regularization <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b17">18]</ref>. Therefore, we run CS with weight rewinding between rounds, so that we remove any advantages that might be caused by not performing weight rewinding -in this case, we better isolate the effects caused by our re-parameterization. Following Frankle and Carbin <ref type="bibr" target="#b12">[13]</ref>, we re-train the produced tickets from their values at initialization (i.e., k = 0 on each algorithm).</p><p>We run IMP and ISS for a total of 30 rounds, each consisting of 40 epochs. Parameters are trained with Adam <ref type="bibr" target="#b30">[31]</ref> with a learning rate of 3 × 10 −4 , following Frankle and Carbin <ref type="bibr" target="#b12">[13]</ref>. For IMP, we use pruning rates of 15%/20% for convolutional/dense layers. We initialize the Bernoulli parameters of ISS with s (0) = 1, and train them with SGD and a learning rate of 20, along with a 1 regularization of λ = 10 −8 . For CS, we train both the weights and the mask with Adam and a learning rate of 3 × 10 −4 . Each run of CS is limited to 4 rounds, and we perform a total of 16 runs, each with a different value for the mask initialization s (0) , from −0.2 up to 0.1. Runs are repeated with 3 different random seeds so that error bars can be computed. <ref type="figure" target="#fig_12">Figure 8</ref> presents tickets produced by each method, measured by their sparsity and test accuracy when trained from scratch. Even when performing weight rewinding, CS produces tickets that are significantly superior than the ones found by ISS, both in terms of sparsity and test accuracy, showing that our deterministic re-parameterization is fundamental to finding winning tickets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E Additional Plots for Ticket Search Experiments</head><p>In Section 5.1, we compare IMP and CS in the task of performing ticket search for ResNet-20 trained on CIFAR-10, where CS was run with 11 different values for s (0) in order to produce tickets with diverse sparsity levels, each run consisting of 5 rounds. . For each setting, we also execute IMP with a pruning rate per round matching CS, which is presented a blue curve -note that these runs of IMP are different than the ones in Section 5.1, where IMP had a fixed and pre-defined pruning ratio of 20% per round.</p><p>The plots show that CS not only adjusts the per-round pruning ratio automatically, but it is also superior in terms of what parameters are removed from the network. The bottom right plot of <ref type="figure" target="#fig_1">Figure 10</ref> shows curves connecting tickets that are presented in all other plots of <ref type="figure" target="#fig_14">Figure 9</ref> and 10 (left), where we can see that CS produces superior tickets even when IMP adopts a dynamic pruning ratio that matches the one of CS at each round.    </p><formula xml:id="formula_7">s (0) = 0.0</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>F Sequential Search with Continuous Sparsification</head><p>There might be cases where the goal is either to find a ticket with a specific sparsity value or to produce a set of tickets with varying sparsity levels in a single run -tasks that can be naturally performed with a single run of Iterative Magnitude Pruning. However, Continuous Sparsification has no explicit mechanism to control the sparsity of the produced tickets, and, as shown in Section 5.1 and Appendix E, CS quickly sparsifies the network in the first few rounds and then roughly maintains the number of parameters during the following rounds until the end of the run. In this scenario, IMP  has a clear advantage, as a single run suffices to produce tickets with varying, pre-defined sparsity levels.</p><p>Here, we present a sequential variant of CS, named Sequential Continuous Sparsification, that removes a fixed fraction of the weights at each round, hence being better suited for the task described above. Unlike IMP, this sequential form of CS removes the weights with lowest mask values snote the difference from CS, which, given a large enough temperature β, removes all weights whose corresponding mask parameters are negative.</p><p>Following the same experimental protocol from Section 5.1, we again perform ticket search on ResNet-20 trained on CIFAR-10. We run Sequential Continuous Sparsification and Iterative Magnitude Pruning for a total of 30 rounds each, and with a pruning rate of 20% per round. Note that unlike the experiments with Continuous Sparsification (the non-sequential form), we perform a single run with s (0) = 0, i.e., no hyperparameters are used to control the sparsity of the produced tickets. <ref type="figure" target="#fig_1">Figure 11</ref> shows the performance of tickets produced by Sequential CS and IMP, indicating that CS might be a competitive method in the sequential search setting. Note that the performance of the tickets produced by Sequential CS is considerably inferior to those found by CS (refer to Section 5.1, <ref type="figure" target="#fig_1">Figure 1</ref>). Although these results are promising, additional experiments would be required to more thoroughly evaluate the potential of Sequential Continuous Sparsification and its comparison to Iterative Magnitude Pruning.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>G Learned Sparsity Structure</head><p>To see how CS differs from magnitude pruning in terms of which layers are more heavily pruned by each method, we force the two to prune VGG to the same sparsity level in a single round. We first run CS with s (0) = 0, yielding 94.19% sparsity, and then run IMP with global pruning rate of 94.19%, producing a sub-network with the same number of parameters. <ref type="figure" target="#fig_1">Figure 12</ref> shows the final sparsity of blocks consisting of two consecutive convolutional layers (8 blocks total since VGG has 16 convolutional layers). CS applies a pruning rate that is roughly twice as aggressive as IMP to the first blocks. Both methods heavily sparsify the widest layers of VGG (blocks 5 to 8), while still achieving over 91% test accuracy. More heavily pruning earlier layers in CNNs can offer inference speed benefits: due to the increased spatial size of earlier layers' inputs, each weight is used more times and has a larger contribution in terms of FLOPs.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>Consider an intermediate and still intractable problem, given by defining m := H(s), with s ∈ R d =0 and H : R =0 → {0, 1} being the Heaviside step function applied element-wise, i.e., H(s) = 1 if s &gt; 0 and 0 otherwise. This yields the following equivalent form for the problem in (2):</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1 :</head><label>1</label><figDesc>Test accuracy and sparsity of subnetworks produced by IMP and CS after re-training from weights of epoch 2. Purple curves show individual runs of CS, while the green curve connects tickets produced after 5 rounds of CS with varying s (0) . Iterative Magnitude Pruning (continued) refers to IMP without rewinding between rounds. Error bars depict variance across 3 runs.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2 :</head><label>2</label><figDesc>Performance of different methods when performing one-shot pruning on VGG-16 and ResNet-20, measured in terms of test accuracy and sparsity of produced subnetworks after fine-tuning.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>train VGG-16 and ResNet-20 on CIFAR-10 for 200 epochs, with a initial learning rate of 0.1 which is decayed by a factor of 10 at epochs 80 and 120. The subnetwork is produced at epoch 160 and is then fine-tuned for 40 extra epochs with a learning rate of 0.001. More specifically, at epoch 160 the subnetwork structured is fixed: AMC, MP, GMP and Slim zero-out elements in the binary matrix m for the last time, while CS fixes m = H(s) and stops training of the mask parameters s.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 2</head><label>2</label><figDesc>displays one-shot pruning results. On VGG, only CS and Slim successfully prune over 98% of the weights without severely degrading the performance of the model, while on ResNet the best results are achieved by CS and GMP.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>, we vary λ between 0 and 10 −8 for three different (s (0) , β (T ) ) settings: (s (0) = −0.2, β (T ) = 100), (s (0) = 0.05, β (T ) = 200), and (s (0) = −0.3, β (T ) = 100). As we can see, there is little impact on either the performance or the sparsity of the found ticket, except for the case where s (0) = 0.05 and β (T ) = 200, for which λ = 10 −8 yields slightly increased sparsity.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>s0 = 0.2; T = 100 s0 = 0.3; T = 100 s0 = 0.05; T = 200</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 3 :</head><label>3</label><figDesc>Impact on relative test accuracy and sparsity of tickets found in a ResNet-20 trained on CIFAR-10, for different values of λ and fixed settings for β (T ) and s (0) . Next, we consider the fixed settings (s (0) = −0.2, λ = 10 −10 ), (s (0) = 0.05, λ = 10 −12 ), (s (0) = −0.3, λ = 10 −8 ), and proceed to vary the final inverse temperature β (T ) between 50 and 200.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 4 Figure 4 :</head><label>44</label><figDesc>shows the results: in all cases, a larger β of 200 yields better accuracy. However, it decreases sparsity compared to smaller temperature values for the settings (s (0) = −0.2, λ = 10 −10 ) and (s (0) = −0.3, λ = 10 −8 ), while at the same time increasing sparsity for (s (0) = 0.05, λ = 10 −12 ). While larger β appear beneficial and might suggest that even higher values should be used, note that, the larger β (T ) is, the earlier in training the gradients of s will vanish, at which point training of the mask will stop. Since the performance for temperatures between 100 and 200 does not change Impact on relative test accuracy and sparsity of tickets found in a ResNet-20 trained on CIFAR-10, for different values of β (T ) and fixed settings for λ and s (0) . T = 100; = 1e 08 T = 100; = 1e 10 T = 200; = 1e 12</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 5 :</head><label>5</label><figDesc>Impact on relative test accuracy and sparsity of tickets found in a ResNet-20 trained on CIFAR-10, for different values of s (0) and fixed settings for β (T ) and λ. significantly, we recommend values around 150 or 200 when either pruning or performing ticket search. Lastly, we vary the initial mask value s (0) between −0.3 and +0.3, with hyperpameter settings (β (T ) = 100, λ = 10 −10 ), (β (T ) = 200, λ = 10 −12 ), and (β (T ) = 100, λ = 10 −8 )</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Algorithm 3</head><label>3</label><figDesc>Iterative Stochastic Sparsification (inspired by [18]) Input: Mask init s (0) , penalty λ, number of rounds R, iterations per round T , rewind point k 1: Initialize w ∼ D, s ← s (0) , r ← 1 2: Minimize E m∼Ber(σ(s)) [L(f ( · ; m w))] + λ σ(s) 1 for T iterations, producing w (T ) and s (T ) 3: If r = R, sample m ∼ Ber(σ(s (T ) )) and output f ( · ; m w (k) ) 4: Otherwise, set w ← w (k) , s ← −∞ for components of s where s (T ) &lt; s (0) , r ← r + 1 and go back to step 2, starting a new round</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 8 :</head><label>8</label><figDesc>Accuracy and sparsity of tickets produced by IMP, ISS and CS after re-training, starting from initialization. Tickets are extracted from a Conv-6 network trained on CIFAR-10. Purple curves show individual runs of CS, while green curve connects tickets produced after 4 rounds of CS with varying s (0) . Blue and red curves show performance and sparsity of tickets produced by IMP and ISS, respectively. Error bars depict variance across 3 runs.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Figures 9 and 10</head><label>10</label><figDesc>contain the training curves for each of the 11 settings of s (0) that produce tickets presented inFigure 1(left). Purple curves show the performance and sparsity of tickets produced after each of the 5 rounds. The accuracy for each ticket is computed by re-training from early-training weights (epoch 2)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Figure 9 :</head><label>9</label><figDesc>Accuracy and sparsity of tickets produced by IMP and CS after re-training, starting from weights of epoch 2. Tickets were extracted from a ResNet-20 trained on CIFAR-10. Each plot corresponds to different value for the mask initialization s (0) of CS, ranging from 0.3 to 0.0, with IMP adopting the same pruning rate per round. Ticket performance is given by purple curves when produced by CS, while blue shows performance of IMP and continued IMP (IMP without weight rewinding between rounds).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Figure 10 :</head><label>10</label><figDesc>Accuracy and sparsity of tickets produced by IMP and CS after re-training, starting from weights of epoch 2. Tickets were extracted from a ResNet-20 trained on CIFAR-10. Each plot corresponds to different value for the mask initialization s (0) of CS, ranging from −0.03 to −0.3, with IMP adopting the same pruning rate per round. Ticket performance is given by purple curves when produced by CS, while blue shows performance of IMP and continued IMP (IMP without weight rewinding between rounds). The bottom right plot shows performance of tickets produced during runs corresponding to all other plots in Figures 9 and 10.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>Figure 11 :</head><label>11</label><figDesc>Accuracy and sparsity of tickets produced by IMP and Sequential CS after re-training, starting from weights of epoch 2. Tickets are extracted from a ResNet-20 trained on CIFAR-10.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head>Figure 12 :</head><label>12</label><figDesc>Sparsity patterns learned by CS and IMP for VGG-16 trained on CIFAR-10 -each block consists of 2 non-overlapping consecutive layers of VGG.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 :</head><label>1</label><figDesc></figDesc><table><row><cell>Test accu-racy and sparsity of the sparsest matching and best performing subnetworks pro-</cell><cell cols="2">Method Dense Network</cell><cell cols="4">VGG-16 Test Accuracy Remaining Weights Round 1 92.35% Round 100.0% 1 90.55% ResNet-20 Test Accuracy Remaining Weights 100.0%</cell></row><row><cell>duced by CS, IMP,</cell><cell>Sparsest</cell><cell>IMP</cell><cell>18 92.36%</cell><cell>1.8%</cell><cell>7 90.57%</cell><cell>20.9%</cell></row><row><cell>and IMP-C (IMP without rewinding)</cell><cell cols="2">Matching IMP-C Subnetwork CS</cell><cell>18 92.56% 5 93.35%</cell><cell>1.8% 1.7%</cell><cell>8 91.00% 5 91.43%</cell><cell>16.7% 12.3%</cell></row><row><cell>for VGG-16 and</cell><cell>Best</cell><cell>IMP</cell><cell>13 92.97%</cell><cell>5.5%</cell><cell>6 90.67%</cell><cell>26.2%</cell></row><row><cell>ResNet-20 trained</cell><cell cols="2">Performing IMP-C</cell><cell>12 92.77%</cell><cell>6.9%</cell><cell>4 91.08%</cell><cell>40.9%</cell></row><row><cell>on CIFAR-10.</cell><cell cols="2">Subnetwork CS</cell><cell>4 93.45%</cell><cell>2.4%</cell><cell>5 91.54%</cell><cell>16.9%</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 2 :</head><label>2</label><figDesc></figDesc><table><row><cell>Sparsity (%) of the sparsest subnetwork within 2% test accuracy of the original dense model, for different pruning methods on CIFAR.</cell><cell>[12] AMC 18.2% 86.0% 97.5% 98.0% MP GMP NetSlim 99.0% 99.6% CS ResNet-20 13.6% 50.0% 80.0% 86.0% VGG-16 85.0% 94.4%</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 3</head><label>3</label><figDesc></figDesc><table><row><cell></cell><cell cols="2">: Performance of</cell></row><row><cell cols="3">found ResNet-50 subnet-</cell></row><row><cell cols="3">works on ImageNet.</cell></row><row><cell>Method</cell><cell>Top-1 Acc.</cell><cell>Sparsity</cell></row><row><cell>GMP</cell><cell>73.9%</cell><cell>90.0%</cell></row><row><cell>DNW</cell><cell>74.0%</cell><cell>90.0%</cell></row><row><cell>STR</cell><cell>74.3%</cell><cell>90.2%</cell></row><row><cell>IMP  †</cell><cell>73.6%</cell><cell>90.0%</cell></row><row><cell>CS  †</cell><cell>75.5%</cell><cell>91.8%</cell></row><row><cell>GMP</cell><cell>70.6%</cell><cell>95.0%</cell></row><row><cell>DNW</cell><cell>68.3%</cell><cell>95.0%</cell></row><row><cell>STR</cell><cell>70.4%</cell><cell>95.0%</cell></row><row><cell>CS</cell><cell>72.4%</cell><cell>95.3%</cell></row><row><cell>IMP  †</cell><cell>69.2%</cell><cell>95.0%</cell></row><row><cell>CS  †</cell><cell>71.1%</cell><cell>95.3%</cell></row><row><cell>STR</cell><cell>67.2%</cell><cell>96.5%</cell></row><row><cell>CS</cell><cell>71.4%</cell><cell>97.1%</cell></row><row><cell>CS  †</cell><cell>69.6%</cell><cell>97.1%</cell></row><row><cell>GMP</cell><cell>57.9%</cell><cell>98.0%</cell></row><row><cell>DNW</cell><cell>58.2%</cell><cell>98.0%</cell></row><row><cell>STR</cell><cell>61.5%</cell><cell>98.5%</cell></row><row><cell>CS</cell><cell>70.0%</cell><cell>98.0%</cell></row><row><cell>CS  †</cell><cell>67.9%</cell><cell>98.0%</cell></row><row><cell>GMP</cell><cell>44.8%</cell><cell>99.0%</cell></row><row><cell>STR</cell><cell>54.8%</cell><cell>98.8%</cell></row><row><cell>CS</cell><cell>66.8%</cell><cell>98.9%</cell></row><row><cell>CS  †</cell><cell>64.9%</cell><cell>98.9%</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head></head><label></label><figDesc>Ticket Search with Sequential Continuous Sparsification: ResNet-20 on CIFAR-10</figDesc><table><row><cell></cell><cell>94</cell><cell></cell><cell></cell></row><row><cell></cell><cell>92</cell><cell></cell><cell></cell></row><row><cell>Test Accuracy (%)</cell><cell>86 88 90</cell><cell></cell><cell></cell></row><row><cell></cell><cell>100.0 82 84</cell><cell>51.4 Iterative Mag.Pr 26.5 Percentage of weights remaining (%) 13.7 7.1 CS (Sequential)</cell><cell>3.7</cell><cell>1.9</cell></row></table><note></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1">Code available at https://github.com/lolemacs/continuous-sparsification</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2">In experiments, we observed that a final temperature of 500 is sufficient for iterates of s when training with SGD using 32-bit precision. The required temperature is likely to depend on how s is represented numerically, as our implementation relies on numerical imprecision rather than (alternatively) clamping after some threshold.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3">We used the same network as Frankle and Carbin<ref type="bibr" target="#b12">[13]</ref> and Frankle et al.<ref type="bibr" target="#b18">[19]</ref>, who refer to it as ResNet-18.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments and Disclosure of Funding</head><p>We thank the anonymous reviewers for providing extensive and extremely valuable feedback on earlier drafts of this work.</p><p>The University of Chicago CERES Center contributed to the financial support of Pedro Savarese. The authors have no competing interests.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">A convergence theory for deep learning via over-parameterization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Allen-Zhu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Song</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICML</title>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">The role of over-parametrization in generalization of neural networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Neyshabur</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Bhojanapalli</surname></persName>
		</author>
		<idno>ICLR. 2019</idno>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Learning both weights and connections for efficient neural networks. In NeurIPS</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Pool</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Tran</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">To prune, or not to prune: exploring the efficacy of pruning for model compression</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Gupta</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1710.01878</idno>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Deep compression: Compressing deep neural networks with pruning, trained quantization and Huffman coding</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Mao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">J</forename><surname>Dally</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICLR</title>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><forename type="middle">N</forename><surname>Iandola</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">W</forename><surname>Moskewicz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Ashraf</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1602.07360</idno>
		<title level="m">AlexNet-level accuracy with 50x fewer parameters and &lt;1MB model size</title>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">DARTS: Differentiable architecture search</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Simonyan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Yang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICLR</title>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Learning implicitly recurrent CNNs through parameter sharing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Savarese</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Maire</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICLR</title>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Discovering neural wirings. In NeurIPS</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Wortsman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Farhadi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Rastegari</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Soft threshold weight reparameterization for learnable sparsity</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Kusupati</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>V. Ramanujan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Somani</surname></persName>
		</author>
		<idno>ICML. 2020</idno>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Srinivas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Subramanya</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Venkatesh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Babu</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1611.06694</idno>
		<title level="m">Training sparse neural networks</title>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Learning sparse neural networks through l 0 regularization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Louizos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Welling</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">P</forename><surname>Kingma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICLR</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">The lottery ticket hypothesis: Finding sparse, trainable neural networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Frankle</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Carbin</surname></persName>
		</author>
		<idno>ICLR. 2019</idno>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Linear mode connectivity and the lottery ticket hypothesis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Frankle</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">Karolina</forename><surname>Dziugaite</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">M</forename><surname>Roy</surname></persName>
		</author>
		<idno>ICML. 2020</idno>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">One ticket to win them all: generalizing lottery ticket initializations across datasets and optimizers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">S</forename><surname>Morcos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Paganini</surname></persName>
		</author>
		<editor>NeurIPS</editor>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Mehta</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1905.07785</idno>
		<title level="m">Sparse transfer learning via winning lottery tickets</title>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Using winning lottery tickets in transfer learning for convolutional neural networks. In IJCNN</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">V</forename><surname>Soelen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">W</forename><surname>Sheppard</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Deconstructing lottery tickets: Zeros, signs, and the supermask</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Lan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NeurIPS</title>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Frankle</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">Karolina</forename><surname>Dziugaite</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">M</forename><surname>Roy</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1903.01611</idno>
		<title level="m">Stabilizing the lottery ticket hypothesis</title>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Introduction to Numerical Continuation Methods</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">L</forename><surname>Allgower</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Georg</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Very deep convolutional networks for large-scale image recognition</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Simonyan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Zisserman</surname></persName>
		</author>
		<idno>ICLR. 2015</idno>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Deep residual learning for image recognition</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Ren</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CVPR</title>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Learning multiple layers of features from tiny images</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Krizhevsky</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
	<note type="report_type">Tech. rep.</note>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">ImageNet large scale visual recognition challenge</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Russakovsky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Deng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Su</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2015" />
			<publisher>IJCV</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Optimal brain damage</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Lecun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">S</forename><surname>Denker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">A</forename><surname>Solla</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NIPS</title>
		<imprint>
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">The state of sparsity in deep neural networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Trevor</forename><surname>Gale</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">H</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Erich</forename><surname>Elsen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICML</title>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">Estimating or propagating gradients through stochastic neurons for conditional computation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Bengio</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Léonard</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Courville</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1308.3432</idno>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Categorical reparameterization with gumbel-softmax</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Jang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Gu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Poole</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICLR</title>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">AutoML for model compression and acceleration on mobile devices</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ECCV</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title level="m" type="main">Learning efficient convolutional networks through network slimming</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Shen</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Adam: A method for stochastic optimization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">P</forename><surname>Kingma</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Ba</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICLR</title>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
