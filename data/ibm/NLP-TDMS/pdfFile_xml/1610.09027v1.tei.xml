<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /nfs/home/kabenamualus/Research/task-dataset-metric-extraction/../grobid-0.6.0/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Scaling Memory-Augmented Neural Networks with Sparse Reads and Writes</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jack</forename><forename type="middle">W</forename><surname>Rae</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jonathan</forename><forename type="middle">J</forename><surname>Hunt</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tim</forename><surname>Harley</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrew</forename><surname>Senior</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Greg</forename><surname>Wayne</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alex</forename><surname>Graves</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Timothy</forename><forename type="middle">P</forename><surname>Lillicrap</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Google</forename><surname>Deepmind</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<address>
									<settlement>jwrae</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<address>
									<settlement>jjhunt</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<address>
									<settlement>Ivo Danihelka danihelka</settlement>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Scaling Memory-Augmented Neural Networks with Sparse Reads and Writes</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>

		<encodingDesc>
			<appInfo>
				<application version="0.6.0" ident="GROBID-SDO" when="2021-06-26T08:51+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid-sdo"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Neural networks augmented with external memory have the ability to learn algorithmic solutions to complex tasks. These models appear promising for applications such as language modeling and machine translation. However, they scale poorly in both space and time as the amount of memory grows -limiting their applicability to real-world domains. Here, we present an end-to-end differentiable memory access scheme, which we call Sparse Access Memory (SAM), that retains the representational power of the original approaches whilst training efficiently with very large memories. We show that SAM achieves asymptotic lower bounds in space and time complexity, and find that an implementation runs 1,000× faster and with 3,000× less physical memory than non-sparse models. SAM learns with comparable data efficiency to existing models on a range of synthetic tasks and one-shot Omniglot character recognition, and can scale to tasks requiring 100,000s of time steps and memories. As well, we show how our approach can be adapted for models that maintain temporal associations between memories, as with the recently introduced Differentiable Neural Computer.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Recurrent neural networks, such as the Long Short-Term Memory (LSTM) <ref type="bibr" target="#b10">[11]</ref>, have proven to be powerful sequence learning models <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b17">18]</ref>. However, one limitation of the LSTM architecture is that the number of parameters grows proportionally to the square of the size of the memory, making them unsuitable for problems requiring large amounts of long-term memory. Recent approaches, such as Neural Turing Machines (NTMs) <ref type="bibr" target="#b6">[7]</ref> and Memory Networks <ref type="bibr" target="#b20">[21]</ref>, have addressed this issue by decoupling the memory capacity from the number of model parameters. We refer to this class of models as memory augmented neural networks (MANNs). External memory allows MANNs to learn algorithmic solutions to problems that have eluded the capabilities of traditional LSTMs, and to generalize to longer sequence lengths. Nonetheless, MANNs have had limited success in real world application.</p><p>A significant difficulty in training these models results from their smooth read and write operations, which incur linear computational overhead on the number of memories stored per time step of training. Even worse, they require duplication of the entire memory at each time step to perform backpropagation through time (BPTT). To deal with sufficiently complex problems, such as processing a book, or Wikipedia, this overhead becomes prohibitive. For example, to store 64 memories, a straightforward implementation of the NTM trained over a sequence of length 100 consumes ≈ 30 MiB physical memory; to store 64,000 memories the overhead exceeds 29 GiB (see <ref type="figure" target="#fig_1">Figure 1</ref>).</p><p>In this paper, we present a MANN named SAM (sparse access memory). By thresholding memory modifications to a sparse subset, and using efficient data structures for content-based read operations, our model is optimal in space and time with respect to memory size, while retaining end-to-end gradient based optimization. To test whether the model is able to learn with this sparse approximation, we examined its performance on a selection of synthetic and natural tasks: algorithmic tasks from the NTM work <ref type="bibr" target="#b6">[7]</ref>, Babi reasoning tasks used with Memory Networks <ref type="bibr" target="#b16">[17]</ref> and Omniglot one-shot classification <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b11">12]</ref>. We also tested several of these tasks scaled to longer sequences via curriculum learning. For large external memories we observed improvements in empirical run-time and memory overhead by up to three orders magnitude over vanilla NTMs, while maintaining near-identical data efficiency and performance.</p><p>Further, in Supplementary D we demonstrate the generality of our approach by describing how to construct a sparse version of the recently published Differentiable Neural Computer <ref type="bibr" target="#b7">[8]</ref>. This Sparse Differentiable Neural Computer (SDNC) is over 400× faster than the canonical dense variant for a memory size of 2,000 slots, and achieves the best reported result in the Babi tasks without supervising the memory access.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Background</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Attention and content-based addressing</head><p>An external memory M ∈ R N ×M is a collection of N real-valued vectors, or words, of fixed size M . A soft read operation is defined to be a weighted average over memory words,</p><formula xml:id="formula_0">r = N i=1 w(i)M(i) ,<label>(1)</label></formula><p>where w ∈ R N is a vector of weights with non-negative entries that sum to one. Attending to memory is formalized as the problem of computing w. A content addressable memory, proposed in <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b20">21,</ref><ref type="bibr" target="#b1">2,</ref><ref type="bibr" target="#b16">17]</ref>, is an external memory with an addressing scheme which selects w based upon the similarity of memory words to a given query q. Specifically, for the ith read weight w(i) we define,</p><formula xml:id="formula_1">w(i) = f (d(q, M(i))) N j=1 f (d(q, M(j)) ,<label>(2)</label></formula><p>where d is a similarity measure, typically Euclidean distance or cosine similarity, and f is a differentiable monotonic transformation, typically a softmax. We can think of this as an instance of kernel smoothing where the network learns to query relevant points q. Because the read operation (1) and content-based addressing scheme (2) are smooth, we can place them within a neural network, and train the full model using backpropagation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Memory Networks</head><p>One recent architecture, Memory Networks, make use of a content addressable memory that is accessed via a series of read operations <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b16">17]</ref> and has been successfully applied to a number of question answering tasks <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b9">10]</ref>. In these tasks, the memory is pre-loaded using a learned embedding of the provided context, such as a paragraph of text, and then the controller, given an embedding of the question, repeatedly queries the memory by content-based reads to determine an answer.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Neural Turing Machine</head><p>The Neural Turing Machine is a recurrent neural network equipped with a content-addressable memory, similar to Memory Networks, but with the additional capability to write to memory over time. The memory is accessed by a controller network, typically an LSTM, and the full model is differentiable -allowing it to be trained via BPTT.</p><p>A write to memory,</p><formula xml:id="formula_2">M t ← (1 − R t ) M t−1 + A t ,<label>(3)</label></formula><p>consists of a copy of the memory from the previous time step M t−1 decayed by the erase matrix R t indicating obsolete or inaccurate content, and an addition of new or updated information A t . The erase matrix R t = w W t e T t is constructed as the outer product between a set of write weights w W t ∈ [0, 1] N and erase vector e t ∈ [0, 1] M . The add matrix A T = w W t a T t is the outer product between the write weights and a new write word a t ∈ R M , which the controller outputs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Architecture</head><p>This paper introduces Sparse Access Memory (SAM), a new neural memory architecture with two innovations. Most importantly, all writes to and reads from external memory are constrained to a sparse subset of the memory words, providing similar functionality as the NTM, while allowing computational and memory efficient operation. Secondly, we introduce a sparse memory management scheme that tracks memory usage and finds unused blocks of memory for recording new information.</p><p>For a memory containing N words, SAM executes a forward, backward step in Θ(log N ) time, initializes in Θ(N ) space, and consumes Θ(1) space per time step. Under some reasonable assumptions, SAM is asymptotically optimal in time and space complexity (Supplementary A).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Read</head><p>The sparse read operation is defined to be a weighted average over a selection of words in memory:</p><formula xml:id="formula_3">r t = K i=1w R t (s i )M t (s i ),<label>(4)</label></formula><p>wherew R t ∈ R N contains K number of non-zero entries with indices s 1 , s 2 , . . . , s K ; K is a small constant, independent of N , typically K = 4 or K = 8. We will refer to sparse analogues of weight vectors w asw, and when discussing operations that are used in both the sparse and dense versions of our model use w.</p><p>We wish to constructw R t such thatr t ≈ r t . For content-based reads where w R t is defined by <ref type="bibr" target="#b1">(2)</ref>, an effective approach is to keep the K largest non-zero entries and set the remaining entries to zero. We can computew R t naively in O(N ) time by calculating w R t and keeping the K largest values. However, linear-time operation can be avoided. Since the K largest values in w R t correspond to the K closest points to our query q t , we can use an approximate nearest neighbor data-structure, described in Section 3.5, to calculatew R t in O(log N ) time. Sparse read can be considered a special case of the matrix-vector product defined in (1), with two key distinctions. The first is that we pass gradients for only a constant K number of rows of memory per time step, versus N , which results in a negligible fraction of non-zero error gradient per timestep when the memory is large. The second distinction is in implementation: by using an efficient sparse matrix format such as Compressed Sparse Rows (CSR), we can compute (4) and its gradients in constant time and space (see Supplementary A).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Write</head><p>The write operation is SAM is an instance of (3) where the write weightsw W t are constrained to contain a constant number of non-zero entries. This is done by a simple scheme where the controller writes either to previously read locations, in order to update contextually relevant memories, or the least recently accessed location, in order to overwrite stale or unused memory slots with fresh content.</p><p>The introduction of sparsity could be achieved via other write schemes. For example, we could use a sparse content-based write scheme, where the controller chooses a query vector q W t and applies writes to similar words in memory. This would allow for direct memory updates, but would create problems when the memory is empty (and shift further complexity to the controller). We decided upon the previously read / least recently accessed addressing scheme for simplicity and flexibility.</p><p>The write weights are defined as</p><formula xml:id="formula_4">w W t = α t γ t w R t−1 + (1 − γ t ) I U t ,<label>(5)</label></formula><p>where the controller outputs the interpolation gate parameter γ t and the write gate parameter α t . The write to the previously read locations w R t−1 is purely additive, while the least recently accessed word I U t is set to zero before being written to. When the read operation is sparse (w R t−1 has K non-zero entries), it follows the write operation is also sparse.</p><p>We define I U t to be an indicator over words in memory, with a value of 1 when the word minimizes a usage measure U t</p><formula xml:id="formula_5">I U t (i) = 1 if U t (i) = min j=1,...,N U t (j) 0 otherwise.<label>(6)</label></formula><p>If there are several words that minimize U t then we choose arbitrarily between them. We tried two definitions of U t . The first definition is a time-discounted sum of write weights U (1)</p><formula xml:id="formula_6">T (i) = T t=0 λ T −t (w W t (i) + w R t (i))</formula><p>where λ is the discount factor. This usage definition is incorporated within Dense Access Memory (DAM), a dense-approximation to SAM that is used for experimental comparison in Section 4.</p><p>The second usage definition, used by SAM, is simply the number of time-steps since a non-negligible memory access: U </p><formula xml:id="formula_7">T (i) = T − max { t : w W t (i) + w R t (i) &gt; δ} .</formula><p>Here, δ is a tuning parameter that we typically choose to be 0.005. We maintain this usage statistic in constant time using a custom data-structure (described in <ref type="figure">Supplementary A</ref>). Finally we also use the least recently accessed word to calculate the erase matrix. R t = I U t 1 T is defined to be the expansion of this usage indicator where 1 is a vector of ones. The total cost of the write is constant in time and space for both the forwards and backwards pass, which improves on the linear space and time dense write (see Supplementary A).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Controller</head><p>We use a one layer LSTM for the controller throughout. At each time step, the LSTM receives a concatenation of the external input, x t , the word, r t−1 read in the previous time step. The LSTM then produces a vector, p t = (q t , a t , α t , γ t ), of read and write parameters for memory access via a linear layer. The word read from memory for the current time step, r t , is then concatenated with the output of the LSTM, and this vector is fed through a linear layer to form the final output, y t . The full control flow is illustrated in <ref type="figure">Supplementary Figure 6</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Efficient backpropagation through time</head><p>We have already demonstrated how the forward operations in SAM can be efficiently computed in O(T log N ) time. However, when considering space complexity of MANNs, there remains a dependence on M t for the computation of the derivatives at the corresponding time step. A naive implementation requires the state of the memory to be cached at each time step, incurring a space overhead of O(N T ), which severely limits memory size and sequence length.</p><p>Fortunately, this can be remedied. Since there are only O(1) words that are written at each time step, we instead track the sparse modifications made to the memory at each timestep, apply them in-place to compute M t in O(1) time and O(T ) space. During the backward pass, we can restore the state of M t from M t+1 in O(1) time by reverting the sparse modifications applied at time step t. As such the memory is actually rolled back to previous states during backpropagation (Supplementary <ref type="figure">Figure 5</ref>).</p><p>At the end of the backward pass, the memory ends rolled back to the start state. If required, such as when using truncating BPTT, the final memory state can be restored by making a copy of M T prior to calling backwards in O(N ) time, or by re-applying the T sparse updates in O(T ) time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Approximate nearest neighbors</head><p>When querying the memory, we can use an approximate nearest neighbor index (ANN) to search over the external memory for the K nearest words. Where a linear KNN search inspects every element in memory (taking O(N ) time), an ANN index maintains a structure over the dataset to allow for fast inspection of nearby points in O(log N ) time.</p><p>In our case, the memory is still a dense tensor that the network directly operates on; however the ANN is a structured view of its contents. Both the memory and the ANN index are passed through the network and kept in sync during writes. However there are no gradients with respect to the ANN as its function is fixed.</p><p>We considered two types of ANN indexes: FLANN's randomized k-d tree implementation <ref type="bibr" target="#b14">[15]</ref> that arranges the datapoints in an ensemble of structured (randomized k-d) trees to search for nearby points via comparison-based search, and one that uses locality sensitive hash (LSH) functions that map points into buckets with distance-preserving guarantees. We used randomized k-d trees for small word sizes and LSHs for large word sizes. For both ANN implementations, there is an O(log N ) cost for insertion, deletion and query. We also rebuild the ANN from scratch every N insertions to ensure it does not become imbalanced. We measured the forward and backward times of the SAM architecture versus the dense DAM variant and the original NTM (details of setup in Supplementary E). SAM is over 100 times faster than the NTM when the memory contains one million words and an exact linear-index is used, and 1600 times faster with the k-d tree <ref type="figure" target="#fig_1">(Figure 1a</ref>). With an ANN the model runs in sublinear time with respect to the memory size. SAM's memory usage per time step is independent of the number of memory words <ref type="figure" target="#fig_1">(Figure 1b)</ref>, which empirically verifies the O(1) space claim from Supplementary A. For 64 K memory words SAM uses 53 MiB of physical memory to initialize the network and 7.8 MiB to run a 100 step forward and backward pass, compared with the NTM which consumes 29 GiB.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Results</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Speed and memory benchmarks</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Learning with sparse memory access</head><p>We have established that SAM reaps a huge computational and memory advantage of previous models, but can we really learn with SAM's sparse approximations? We investigated the learning cost of inducing sparsity, and the effect of placing an approximate nearest neighbor index within the network, by comparing SAM with its dense variant DAM and some established models, the NTM and the LSTM.</p><p>We trained each model on three of the original NTM tasks <ref type="bibr" target="#b6">[7]</ref>. 1. Copy: copy a random input sequence of length 1-20, 2. Associative Recall: given 3-6 random (key, value) pairs, and subsequently a cue key, return the associated value. 3. Priority Sort: Given 20 random keys and priority values, return the top 16 keys in descending order of priority. We chose these tasks because the NTM is known to perform well on them. <ref type="figure" target="#fig_2">Figure 2</ref> shows that sparse models are able to learn with comparable efficiency to the dense models and, surprisingly, learn more effectively for some tasks -notably priority sort and associative recall. This shows that sparse reads and writes can actually benefit early-stage learning in some cases.</p><p>Full hyperparameter details are in Supplementary C.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Scaling with a curriculum</head><p>The computational efficiency of SAM opens up the possibility of training on tasks that require storing a large amount of information over long sequences. Here we show this is possible in practice, by scaling tasks to a large scale via an exponentially increasing curriculum.</p><p>We parametrized three of the tasks described in Section 4.2: associative recall, copy, and priority sort, with a progressively increasing difficulty level which characterises the length of the sequence and number of entries to store in memory. For example, level specifies the input sequence length for the copy task. We exponentially increased the maximum level h when the network begins to learn the fundamental algorithm. Since the time taken for a forward and backward pass scales O(T ) with the sequence length T , following a standard linearly increasing curriculum could potentially take O(T 2 ), if the same amount of training was required at each step of the curriculum. Specifically, h was doubled whenever the average training loss dropped below a threshold for a number of episodes. The level was sampled for each minibatch from the uniform distribution over integers U(0, h).</p><p>We compared the dense models, NTM and DAM, with both SAM with an exact nearest neighbor index (SAM linear) and with locality sensitive hashing (SAM ANN). The dense models contained 64 memory words, while the sparse models had 2 × 10 6 words. These sizes were chosen to ensure all models use approximately the same amount of physical memory when trained over 100 steps.</p><p>For all tasks, SAM was able to advance further than the other models, and in the associative recall task, SAM was able to advance through the curriculum to sequences greater than 4000 <ref type="figure" target="#fig_4">(Figure 3</ref>). Note that we did not use truncated backpropagation, so this involved BPTT for over 4000 steps with a memory size in the millions of words.</p><p>To investigate whether SAM was able to learn algorithmic solutions to tasks, we investigated its ability to generalize to sequences that far exceeded those observed during training. Namely we trained SAM on the associative recall task up to sequences of length 10, 000, and found it was then able to generalize to sequences of length 200,000 ( <ref type="figure">Supplementary Figure 8</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Question answering on the Babi tasks</head><p>[20] introduced toy tasks they considered a prerequisite to agents which can reason and understand natural language. They are synthetically generated language tasks with a vocab of about 150 words that test various aspects of simple reasoning such as deduction, induction and coreferencing.  We tested the models (including the Sparse Differentiable Neural Computer described in Supplementary D) on this task. The full results and training details are described in Supplementary G.</p><p>The MANNs, except the NTM, are able to learn solutions comparable to the previous best results, failing at only 2 of the tasks. The SDNC manages to solve all but 1 of the tasks, the best reported result on Babi that we are aware of.</p><p>Notably the best prior results have been obtained by using supervising the memory retrieval (during training the model is provided annotations which indicate which memories should be used to answer a query). More directly comparable previous work with end-to-end memory networks, which did not use supervision <ref type="bibr" target="#b16">[17]</ref>, fails at 6 of the tasks.</p><p>Both the sparse and dense perform comparably at this task, again indicating the sparse approximations do not impair learning. We believe the NTM may perform poorly since it lacks a mechanism which allows it to allocate memory effectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Learning on real world data</head><p>Finally, we demonstrate that the model is capable of learning in a non-synthetic dataset. Omniglot <ref type="bibr" target="#b11">[12]</ref> is a dataset of 1623 characters taken from 50 different alphabets, with 20 examples of each character. This dataset is used to test rapid, or one-shot learning, since there are few examples of each character but many different character classes. Following <ref type="bibr" target="#b15">[16]</ref>, we generate episodes where a subset of characters are randomly selected from the dataset, rotated and stretched, and assigned a randomly chosen label. At each time step an example of one of the characters is presented, along with the correct label of the proceeding character. Each character is presented 10 times in an episode (but each presentation may be any one of the 20 examples of the character). In order to succeed at the task the model must learn to rapidly associate a novel character with the correct label, such that it can correctly classify subsequent examples of the same character class.</p><p>Again, we used an exponential curriculum, doubling the number of additional characters provided to the model whenever the cost was reduced under a threshold. After training all MANNs for the same length of time, a validation task with 500 characters was used to select the best run, and this was then tested on a test set, containing all novel characters for different sequence lengths <ref type="figure">(Figure 4</ref>). All of the MANNs were able to perform much better than chance, even on sequences ≈ 4× longer than seen during training. SAM outperformed other models, presumably due to its much larger memory capacity. Previous results on the Omniglot curriculum <ref type="bibr" target="#b15">[16]</ref> task are not identical, since we used 1-hot labels throughout and the training curriculum scaled to longer sequences, but our results with the dense models are comparable (≈ 0.4 errors with 100 characters), while the SAM is significantly better (0.2 &lt; errors with 100 characters).  <ref type="figure">Figure 4</ref>: Test errors for the Omniglot task (described in the text) for the best runs (as chosen by the validation set). The characters used in the test set were not used in validation or training. All of the MANNs were able to perform much better than chance with ≈ 500 characters (sequence lengths of ≈ 5000), even though they were trained, at most, on sequences of ≈ 130 (chance is 0.002 for 500 characters). This indicates they are learning generalizable solutions to the task. SAM is able to outperform other approaches, presumably because it can utilize a much larger memory.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Discussion</head><p>Scaling memory systems is a pressing research direction due to potential for compelling applications with large amounts of memory. We have demonstrated that you can train neural networks with large memories via a sparse read and write scheme that makes use of efficient data structures within the network, and obtain significant speedups during training. Although we have focused on a specific MANN (SAM), which is closely related to the NTM, the approach taken here is general and can be applied to many differentiable memory architectures, such as Memory Networks <ref type="bibr" target="#b20">[21]</ref>.</p><p>It should be noted that there are multiple possible routes toward scalable memory architectures. For example, prior work aimed at scaling Neural Turing Machines <ref type="bibr" target="#b21">[22]</ref> used reinforcement learning to train a discrete addressing policy. This approach also touches only a sparse set of memories at each time step, but relies on higher variance estimates of the gradient during optimization. Though we can only guess at what class of memory models will become staple in machine learning systems of the future, we argue in Supplementary A that they will be no more efficient than SAM in space and time complexity if they address memories based on content.</p><p>We have experimented with randomized k-d trees and LSH within the network to reduce the forward pass of training to sublinear time, but there may be room for improvement here. K-d trees were not designed specifically for fully online scenarios, and can become imbalanced during training. Recent work in tree ensemble models, such as Mondrian forests <ref type="bibr" target="#b12">[13]</ref>, show promising results in maintaining balanced hierarchical set coverage in the online setting. An alternative approach which may be well-suited is LSH forests <ref type="bibr" target="#b2">[3]</ref>, which adaptively modifies the number of hashes used. It would be an interesting empirical investigation to more fully assess different ANN approaches in the challenging context of training a neural network.</p><p>Humans are able to retain a large, task-dependent set of memories obtained in one pass with a surprising amount of fidelity <ref type="bibr" target="#b3">[4]</ref>. Here we have demonstrated architectures that may one day compete with humans at these kinds of tasks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Supplementary Information</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A Time and space complexity</head><p>Under a reasonable class of content addressable memory architectures A, SAM is optimal in time and space complexity.</p><p>Definition 1. Let M be a collection of real vectors m1, m2, . . . , mN of fixed dimension d. Let A be the set of all content addressable memory data structures that store M and can return at least one word mj such that D(q, mj) ≤ c (1 + ) for a given L p norm D, query vector q, and &gt; 0; provided such a memory mc exists with D(q, mc) = c.</p><p>Existing lower bounds <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b0">1]</ref> assert that for any data structure a ∈ A, a requires Ω(log N ) time and Ω(N ) space to perform a read operation. The SAM memory architecture proposed in this paper is contained within A as it computes the approximate nearest neighbors problem in fixed dimensions <ref type="bibr" target="#b14">[15]</ref>. As we will show, SAM requires O(log N ) time to query and maintain the ANN, O(1) to perform all subsequent sparse read, write, and error gradient calculations. It requires O(N ) space to initialize the memory and O(1) to store intermediate sparse tensors. We thus conclude it is optimal in asymptotic time and space complexity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.1 Initialization</head><p>Upon initialization, SAM consumes O(N ) space and time to instantiate the memory and the memory Jacobian. Furthermore, it requires O(N ) time and space to initialize auxiliary data structures which index the memory, such as the approximate nearest neighbor which provides a content-structured view of the memory, and the least accessed ring, which maintains the temporal ordering in which memory words are accessed. These initializations represent an unavoidable one-off cost that does not recur per step of training, and ultimately has little effect on training speed. For the remainder of the analysis we will concentrate on the space and time cost per training step.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.2 Read</head><p>Recall the sparse read operation,r</p><formula xml:id="formula_8">t = K i=1w R t (si)Mt(si) .<label>(7)</label></formula><p>As K is chosen to be a fixed constant, it is clear we can compute <ref type="bibr" target="#b6">(7)</ref> in O(1) time. During the backward pass, we see the gradients are sparse with only K non-zero terms,</p><formula xml:id="formula_9">∂L ∂w R t (i) = Mt(i) · ∂L ∂r t if i ∈ {s1, s2, . . . , sK } 0 otherwise. and ∂L ∂Mt (i) = w R t (i) ∂L ∂r t if i ∈ {s1, s2, . . . , sK } 0 otherwise.</formula><p>where 0 is a vector of M zeros. Thus they can both be computed in constant time by skipping the computation of zeros. Furthermore by using an efficient sparse matrix format to store these matrices and vectors, such as the CSR, we can represent them using at most 3K values. Since the read wordrt and its respective error gradient is the size of a single word in memory (M elements), the overall space complexity is O(1) per time step for the read.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.3 Write</head><p>Recall the write operation,</p><formula xml:id="formula_10">Mt ← Mt−1 − Et + At, ,<label>(8)</label></formula><p>where At = w W t a T t is the add matrix, Et = Mt−1 Rt is the erase matrix, and Rt = I U t 1 T is defined to be the erase weight matrix. We chose the write weights to be an interpolation between the least recently accessed location and the previously read locations,</p><formula xml:id="formula_11">w W t = αt γtw R t−1 + (1 − γt) I U t .<label>(9)</label></formula><p>For sparse reads where w R t =w R t is a sparse vector with K non-zeros, the write weights w W t is also sparse with K + 1 non-zeros: 1 for the least recently accessed location and K for the previously read locations. Thus the sparse-dense outer product At = w W t a T t can be performed in O(1) time as K is a fixed constant. Since Rt = I U t 1 T can be represented as a sparse matrix with one single non-zero, the erase matrix Et can also. As At and Et are sparse matrices we can then add them component-wise to the dense Mt−1 in O(1) time. By analogous arguments the backward pass can be computed in O(1) time and each sparse matrix can be represented in O(1) space.</p><p>We avoid caching the modified memory, and thus duplicating it, by applying the write directly to the memory. To restore its prior state during the backward pass, which is crucial to gradient calculations at earlier time steps, we roll the memory it back by reverting the sparse modifications with an additional O(1) time overhead (Supplementary <ref type="figure">Figure 5)</ref>.</p><p>The location of the least recently accessed memory can be maintained in O(1) time by constructing a circular linked list that tracks the indices of words in memory, and preserves a strict ordering of relative temporal access. The first element in the ring is the least recently accessed word in memory, and the last element in the ring is the most recently modified. We keep a "head" pointer to the first element in the ring. When a memory word is randomly accessed, we can push its respective index to the back of the ring in O(1) time by redirecting a small number of pointers. When we wish to pop the least recently accessed memory (and write to it) we move the head to the next element in the ring in O(1) time.  <ref type="figure">Figure 5</ref>: A schematic of the memory efficient backpropagation through time. Each circle represents an instance of the SAM core at a given time step. The grey box marks the dense memory. Each core holds a reference to the single instance of the memory, and this is represented by the solid connecting line above each core. We see during the forward pass, the memory's contents are modified sparsely, represented by the solid horizontal lines. Instead of caching the changing memory state, we store only the sparse modifications -represented by the dashed white boxes. During the backward pass, we "revert" the cached modifications to restore the memory to its prior state, which is crucial for correct gradient calculations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.4 Content-based addressing</head><p>As discussed in Section 3.5 we can calculate the content-based attention, or read weights w R t , in O(log N ) time using an approximate nearest neighbor index that views the memory. We keep the ANN index synchronized with the memory by passing it through the network as a non-differentiable member of the network's state (so we do not pass gradients for it), and we update the index upon each write or erase to memory in O(log N ) time. Maintaining and querying the ANN index represents the most expensive part of the network, which is reasonable as content-based addressing is inherently expensive <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b0">1]</ref>.</p><p>For the backward pass computation, specifically calculating ∂L ∂q t and ∂L ∂M t with respect to w R t , we can once again compute these using sparse matrix operations in O(1) time. This is because the K non-zero locations have been determined during the forward pass.  <ref type="figure">Figure 6</ref>: Schematic showing how the controller interfaces with the external memory in our experiments. The controller (LSTM) output h t is used (through a linear projection, p t ) to read and write to the memory. The result of the read operation r t is combined with h t to produce output y t , as well as being feed into the controller at the next timestep (r t−1 ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C Training details</head><p>Here we provide additional details on the training regime used for our experiments used in <ref type="figure" target="#fig_2">Figure 2</ref>.</p><p>To avoid bias in our results, we chose the learning rate that worked best for DAM (and not SAM). We tried learning rates {10 −6 , 5 × 10 −5 , 10 −5 , 5 × 10 −4 , 10 −4 } and found that DAM trained best with 10 −5 . We also tried values of K {4, 8, 16} and found no significant difference in performance across the values. We used 100 hidden units for the LSTM (including the controller LSTMs), a minibatch of 8, 8 asynchronous workers to speed up training, and RMSProp <ref type="bibr" target="#b18">[19]</ref> to optimize the controller. We used 4 memory access heads and configured SAM to read from only K = 4 locations per head.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D Sparse Differentiable Neural Computer</head><p>Recently <ref type="bibr" target="#b7">[8]</ref> proposed a novel MANN the Differentiable Neural Computer (DNC). The two innovations proposed by this model are a new approach to tracking memory freeness (dynamic memory allocation) and a mechanism for associating memories together (temporal memory linkage). We demonstrate here that the approaches enumerated in the paper can be adapted to new models by outlining a sparse version of this model, the Sparse Differentiable Neural Computer (SDNC), which learns with similar data efficiency while retaining the computational advantages of sparsity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D.1 Architecture</head><p>For brevity, we will only explain the sparse implementations of these two items, for the full model details refer to the original paper. The mechanism for sparse memory reads and writes was implemented identically to SAM.</p><p>It is possible to implement a scalable version of the dynamic memory allocation system of the DNC avoiding any O(N ) operations by using a heap. However, because it is practical to run the SDNC with many more memory words, reusing memory is less crucial so we did not implement this and used the same usage tracking as in SAM.</p><p>The temporal memory linkage in the DNC is a system for associating and recalling memory locations which were written in a temporal order, for exampling storing and retrieving a list. In the DNC this is done by maintaining a temporal linkage matrix Lt ∈ [0, 1] N ×N . Lt[i, j] represents the degree to which location i was written to after location j. This matrix is updated by tracking the precedence weighting pt, where pt(i) represents the degree to which location i was written to.</p><formula xml:id="formula_12">p0 = 0 (10) pt = (1 − i w W t (i)) pt−1 + w W t<label>(11)</label></formula><p>The memory linkage is updated according to the following recurrence L0 = 0 (12)</p><formula xml:id="formula_13">Lt(i, j) = 0 i = j (1 − w W t (i) − w W t (j))Lt−1(i, j) + w W t (i)pt−1(j) i = j<label>(13)</label></formula><p>The temporal linkage Lt can be used to compute read weights following the temporal links either forward</p><formula xml:id="formula_15">f r t = Ltw r t−1<label>(15)</label></formula><p>or backward b r t = L T t w r t−1 (16) The read head then uses a 3-way softmax to select between a content-based read or following the forward or backward weighting. Naively, the link matrix requires O(N 2 ) memory and computation although <ref type="bibr" target="#b7">[8]</ref> proposes a method to reduce the computational cost to O(N log N ) and O(N ) memory cost.</p><p>In order to maintain the scaling properties of the SAM, we wish to avoid any computational dependence on N . We do this by maintaining two sparse matrices Nt, Pt ∈ [0, 1] N ×{K L } that approximate Lt and L T t respectively. We store these matrices in Compressed Sparse Row format. They are defined by the following updates:</p><formula xml:id="formula_16">N0 = 0 (17) P0 = 0 (18) Nt(i, j) = (1 − w W t (i)) Nt−1(i, j) + w W t (i) pt−1(j)<label>(19)</label></formula><formula xml:id="formula_17">Pt(i, j) = (1 − w W t (j)) Pt−1(i, j) + w W t (j) pt−1(i)<label>(20)</label></formula><p>Additionally, pt is, as with the other weight vectors maintained as a sparse vector with at most KL non-zero entries. This means that the outer product of wtp T t−1 has at most K 2 L non-zero entries. In addition to the updates specified above, we also constrain each row of the matrices Nt and Pt to have at most KL non-zero entriesthis constraint can be applied in O(K 2 L ) because at most KL rows change in the matrix. Once these matrices are applied the read weights following the temporal links can be computed similar to before:</p><formula xml:id="formula_18">f r t = Ntw r t−1 (21) b r t = Ptw r t−1<label>(22)</label></formula><p>Note, the number of locations we read from, K, does not have to equal the number of outward and inward links we preserve, KL. We typically choose KL = 8 as this is still very fast to compute (100µs in total to calculate Nt, Pt, pt, f r t , b r t on a single CPU thread) and we see no learning benefit with larger KL. In order to compute the gradients, Nt and Pt need to be stored. This could be done by maintaining a sparse record of the updates applied and reversing them, similar to that performed with the memory as described in Section 3.4. However, for implementation simplicity we did not pass gradients through the temporal linkage matrices.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D.2 Results</head><p>We benchmarked the speed and memory performance of the SDNC versus a naive DNC implementation (details of setup in Supplementary E). The results are displayed in <ref type="figure" target="#fig_8">Figure 7</ref>. Here, the computational benefits of sparsity are more pronounced due to the expensive (quadratic time and space) temporal transition table operations in the DNC. We were only able to run comparative benchmarks up to N = 2048, as the DNC quickly exceeded the machine's physical memory for larger values; however even at this modest memory size we see a speed increase of ≈ 440× and physical memory reduction of ≈ 240×. Note, unlike the SAM memory benchmark in Section 4 we plot the total memory consumption, i.e. the memory overhead of the initial start state plus the memory overhead of unrolling the core over a sequence. This is because the SDNC and DNC do not have identical start states. The sparse temporal transition matrices N0, P0 ∈ [0, 1] N ×N{K} consume much less memory than the corresponding L0 ∈ [0, 1] N ×N in the DNC. In order to compare the models on an interesting task we ran the DNC and SDNC on the Babi task (this task is described more fully in the main text). The results are described in Supplementary G and demonstrate the SDNC is capable of learning competitively. In particular, it achieves the best report result on the Babi task.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E Benchmarking details</head><p>Each model contained an LSTM controller with 100 hidden units, an external memory containing N slots of memory, with word size 32 and 4 access heads. For speed benchmarks, a minibatch size of 8 was used to ensure fair comparison -as many dense operations (e.g. matrix multiplication) can be batched efficiently. For memory benchmarks, the minibatch size was set to 1.</p><p>We used Torch7 <ref type="bibr" target="#b4">[5]</ref> to implement SAM, DAM, NTM, DNC and SDNC. Eigen v3 <ref type="bibr" target="#b8">[9]</ref> was used for the fast sparse tensor operations, using the provided CSC and CSR formats. All benchmarks were run on a Linux desktop running Ubuntu 14.04.1 with 32GiB of RAM and an Intel Xeon E5-1650 3.20GHz processor with power scaling disabled.</p><p>F Generalization on associative recall L <ref type="figure">Figure 8</ref>: We tested the generalization of SAM on the associative recall task. We train each model up to a difficulty level, which corresponds to the task's sequence length, of 10, 000, and evaluate on longer sequences. The SAM models (with and without ANN) are able to perform much better than chance (48 bits) on sequences of length 200, 000.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>G Babi results</head><p>See the main text for a description of the Babi task and its relevance. Here we report the best and mean results for all of the models on this task.</p><p>The task was encoded using straightforward 1-hot word encodings for both the input and output. We trained a single model on all of the tasks, and used the 10,000 examples per task version of the training set (a small subset of which we used as a validation set for selecting the best run and hyperparameters). Previous work has reported best results <ref type="figure" target="#fig_1">(Supplementary table 1)</ref>, which with only 15 runs is a noisy comparison, so we additionally report the mean and variance for all runs with the best selected hyperparameters ( <ref type="table">Supplementary table 2</ref>  <ref type="table">Table 1</ref>: Test results for the best run (chosen by validation set) on the Babi task. The model was trained and tested jointly on all tasks. All tasks received approximately equal training resources. Both SAM and DAM pass all but 2 of the tasks, without any supervision of their memory accesses. SDNC achieves the best reported result on this task with unsupervised memory access, solving all but 1 task. We've included comparison with memory networks, both with supervision of memories (MemNet S) and, more directly comparable with our approach, learning end-to-end (MemNets U). </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>LSTM</head></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1 :</head><label>1</label><figDesc>(a) Wall-clock time of a single forward and backward pass. The k-d tree is a FLANN randomized ensemble with 4 trees and 32 checks. For 1M memories a single forward and backward pass takes 12 s for the NTM and 7 ms for SAM, a speedup of 1600×. (b) Memory used to train over sequence of 100 time steps, excluding initialization of external memory. The space overhead of SAM is independent of memory size, which we see by the flat line. When the memory contains 64,000 words the NTM consumes 29 GiB whereas SAM consumes only 7.8 MiB, a compression ratio of 3700.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2 :</head><label>2</label><figDesc>Training curves for sparse (SAM) and dense (DAM, NTM) models. SAM trains comparably for the Copy task, and reaches asymptotic error significantly faster for Associative Recall and Priority Sort.Light colors indicate one standard deviation over 30 random seeds.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 3 :</head><label>3</label><figDesc>Curriculum training curves for sparse and dense models on (a) Associative recall, (b) Copy, and (c) Priority sort. Difficulty level indicates the task difficulty (e.g. the length of sequence for copy). We see SAM train (and backpropagate over) episodes with thousands of steps, and tasks which require thousands of words to be stored to memory. Each model is averaged across 5 replicas of identical hyper-parameters (light lines indicate individual runs).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>Thus to conclude, SAM consumes in total O(1) space for both the forward and backward step during training, O(log N ) time per forward step, and O(1) per backward step.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 7 :</head><label>7</label><figDesc>Performance benchmarks between the DNC and SDNC for small to medium memory sizes. Here the SDNC uses a linear KNN. (a) Wall-clock time of a single forward and backward pass. (b) Total memory usage (including initialization) when trained over sequence of 10 time steps.</figDesc></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>We thank Vyacheslav Egorov, Edward Grefenstette, Malcolm Reynolds, Fumin Wang and Yori Zwols for their assistance, and the Google DeepMind family for helpful discussions and encouragement.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">An optimal algorithm for approximate nearest neighbor searching fixed dimensions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sunil</forename><surname>Arya</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><forename type="middle">M</forename><surname>Mount</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nathan</forename><forename type="middle">S</forename><surname>Netanyahu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ruth</forename><surname>Silverman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Angela</forename><forename type="middle">Y</forename><surname>Wu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="891" to="923" />
			<date type="published" when="1998-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Neural machine translation by jointly learning to align and translate</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dzmitry</forename><surname>Bahdanau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kyunghyun</forename><surname>Cho</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yoshua</forename><surname>Bengio</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1409.0473</idno>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Lsh forest: self-tuning indexes for similarity search</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mayank</forename><surname>Bawa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tyson</forename><surname>Condie</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Prasanna</forename><surname>Ganesan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 14th international conference on World Wide Web</title>
		<meeting>the 14th international conference on World Wide Web</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2005" />
			<biblScope unit="page" from="651" to="660" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Visual long-term memory has a massive storage capacity for object details</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Timothy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Talia</forename><surname>Brady</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Konkle</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>George</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Aude</forename><surname>Alvarez</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Oliva</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proceedings of the National Academy of Sciences</title>
		<imprint>
			<biblScope unit="volume">105</biblScope>
			<biblScope unit="issue">38</biblScope>
			<biblScope unit="page" from="14325" to="14329" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Torch7: A matlab-like environment for machine learning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ronan</forename><surname>Collobert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Koray</forename><surname>Kavukcuoglu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Clément</forename><surname>Farabet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">BigLearn, NIPS Workshop, number EPFL-CONF-192376</title>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Speech recognition with deep recurrent neural networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alex</forename><surname>Graves</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mohamed</forename><surname>Abdel-Rahman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Geoffrey</forename><surname>Hinton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2013 IEEE International Conference on</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2013" />
			<biblScope unit="page" from="6645" to="6649" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alex</forename><surname>Graves</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Greg</forename><surname>Wayne</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ivo</forename><surname>Danihelka</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1410.5401</idno>
		<title level="m">Neural turing machines</title>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Hybrid computing using a neural network with dynamic external memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alex</forename><surname>Graves</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Greg</forename><surname>Wayne</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Malcolm</forename><surname>Reynolds</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tim</forename><surname>Harley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ivo</forename><surname>Danihelka</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Agnieszka</forename><surname>Grabska-Barwińska</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sergio</forename><forename type="middle">Gómez</forename><surname>Colmenarejo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Edward</forename><surname>Grefenstette</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tiago</forename><surname>Ramalho</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><surname>Agapiou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nature</title>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gaël</forename><surname>Guennebaud</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Benoıt</forename><surname>Jacob</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Philip</forename><surname>Avery</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Abraham</forename><surname>Bachrach</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sebastien</forename><surname>Barthelemy</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
	<note>et al. Eigen v3</note>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">The goldilocks principle: Reading children&apos;s books with explicit memory representations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Felix</forename><surname>Hill</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Antoine</forename><surname>Bordes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sumit</forename><surname>Chopra</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jason</forename><surname>Weston</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1511.02301</idno>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Long short-term memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sepp</forename><surname>Hochreiter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jürgen</forename><surname>Schmidhuber</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Neural computation</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="1735" to="1780" />
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Human-level concept learning through probabilistic program induction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ruslan</forename><surname>Brenden M Lake</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joshua</forename><forename type="middle">B</forename><surname>Salakhutdinov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Tenenbaum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science</title>
		<imprint>
			<biblScope unit="volume">350</biblScope>
			<biblScope unit="issue">6266</biblScope>
			<biblScope unit="page" from="1332" to="1338" />
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Mondrian forests: Efficient online random forests</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Balaji</forename><surname>Lakshminarayanan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Daniel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yee Whye</forename><surname>Roy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Teh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems</title>
		<imprint>
			<date type="published" when="2014" />
			<biblScope unit="page" from="3140" to="3148" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Lower bounds on locality sensitive hashing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rajeev</forename><surname>Motwani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Assaf</forename><surname>Naor</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rina</forename><surname>Panigrahy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal on Discrete Mathematics</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="930" to="935" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Scalable nearest neighbor algorithms for high dimensional data. Pattern Analysis and Machine Intelligence</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marius</forename><surname>Muja</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><forename type="middle">G</forename><surname>Lowe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Meta-learning with memory-augmented neural networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Adam</forename><surname>Santoro</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sergey</forename><surname>Bartunov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Matthew</forename><surname>Botvinick</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daan</forename><surname>Wierstra</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Lillicrap</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International conference on machine learning</title>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">End-to-end memory networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sainbayar</forename><surname>Sukhbaatar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jason</forename><surname>Weston</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rob</forename><surname>Fergus</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems</title>
		<imprint>
			<date type="published" when="2015" />
			<biblScope unit="page" from="2431" to="2439" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Sequence to sequence learning with neural networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ilya</forename><surname>Sutskever</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Oriol</forename><surname>Vinyals</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Quoc V</forename><surname>Le</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems</title>
		<imprint>
			<publisher>Curran Associates, Inc</publisher>
			<date type="published" when="2014" />
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="3104" to="3112" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Lecture 6.5-rmsprop: Divide the gradient by a running average of its recent magnitude</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tijmen</forename><surname>Tieleman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Geoffrey</forename><surname>Hinton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">COURSERA: Neural Networks for Machine Learning</title>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="volume">4</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Towards ai-complete question answering: A set of prerequisite toy tasks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jason</forename><surname>Weston</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Antoine</forename><surname>Bordes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sumit</forename><surname>Chopra</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alexander</forename><forename type="middle">M</forename><surname>Rush</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bart</forename><surname>Van Merriënboer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Armand</forename><surname>Joulin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tomas</forename><surname>Mikolov</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1502.05698</idno>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jason</forename><surname>Weston</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sumit</forename><surname>Chopra</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Antoine</forename><surname>Bordes</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1410.3916</idno>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
	<note type="report_type">Memory networks. arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wojciech</forename><surname>Zaremba</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ilya</forename><surname>Sutskever</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1505.00521</idno>
		<title level="m">Reinforcement learning neural turing machines</title>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
