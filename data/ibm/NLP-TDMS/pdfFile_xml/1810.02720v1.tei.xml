<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /nfs/home/kabenamualus/Research/task-dataset-metric-extraction/../grobid-0.6.0/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">TRANX: A Transition-based Neural Abstract Syntax Parser for Semantic Parsing and Code Generation</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pengcheng</forename><surname>Yin</surname></persName>
							<email>pcyin@cs.cmu.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">Language Technologies Institute Carnegie Mellon University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Graham</forename><surname>Neubig</surname></persName>
							<email>gneubig@cs.cmu.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">Language Technologies Institute Carnegie Mellon University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">TRANX: A Transition-based Neural Abstract Syntax Parser for Semantic Parsing and Code Generation</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>

		<encodingDesc>
			<appInfo>
				<application version="0.6.0" ident="GROBID-SDO" when="2021-06-26T11:44+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid-sdo"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We present TRANX, a transition-based neural semantic parser that maps natural language (NL) utterances into formal meaning representations (MRs). TRANX uses a transition system based on the abstract syntax description language for the target MR, which gives it two major advantages: (1) it is highly accurate, using information from the syntax of the target MR to constrain the output space and model the information flow, and (2) it is highly generalizable, and can easily be applied to new types of MR by just writing a new abstract syntax description corresponding to the allowable structures in the MR. Experiments on four different semantic parsing and code generation tasks show that our system is generalizable, extensible, and effective, registering strong results compared to existing neural semantic parsers. 1</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Semantic parsing is the task of transducing natural language (NL) utterances into formal meaning representations (MRs). The target MRs can be defined according to a wide variety of formalisms. This include linguistically-motivated semantic representations that are designed to capture the meaning of any sentence such as λcalculus <ref type="bibr" target="#b21">(Zettlemoyer and Collins, 2005)</ref> or the abstract meaning representations <ref type="bibr" target="#b1">(Banarescu et al., 2013)</ref>. Alternatively, for more task-driven approaches to semantic parsing, it is common for meaning representations to represent executable programs such as SQL queries <ref type="bibr" target="#b24">(Zhong et al., 2017)</ref>, robotic commands <ref type="bibr" target="#b0">(Artzi and Zettlemoyer, 2013)</ref>, smart phone instructions <ref type="bibr" target="#b9">(Quirk et al., 2015)</ref>, and even general-purpose programming languages like Python <ref type="bibr" target="#b18">(Yin and Neubig, 2017;</ref><ref type="bibr" target="#b10">Rabinovich et al., 2017)</ref> and Java <ref type="bibr" target="#b5">(Ling et al., 2016)</ref>.</p><p>Because of these varying formalisms for MRs, the design of semantic parsers, particularly neural network-based ones has generally focused on a small subset of tasks -in order to ensure the syntactic well-formedness of generated MRs, a parser is usually specifically designed to reflect the domain-dependent grammar of MRs in the structure of the model <ref type="bibr" target="#b24">(Zhong et al., 2017;</ref><ref type="bibr" target="#b17">Xu et al., 2017)</ref>. To alleviate this issue, there have been recent efforts in neural semantic parsing with general-purpose grammar models <ref type="bibr" target="#b16">(Xiao et al., 2016;</ref><ref type="bibr" target="#b3">Dong and Lapata, 2018)</ref>. <ref type="bibr" target="#b18">Yin and Neubig (2017)</ref> put forward a neural sequence-to-sequence model that generates tree-structured MRs using a series of tree-construction actions, guided by the task-specific context free grammar provided to the model a priori. <ref type="bibr" target="#b10">Rabinovich et al. (2017)</ref> propose the abstract syntax networks (ASNs), where domain-specific MRs are represented by abstract syntax trees (ASTs, <ref type="figure" target="#fig_0">Fig. 2</ref> Left) specified under the abstract syntax description language (ASDL) framework <ref type="bibr" target="#b15">(Wang et al., 1997)</ref>. An ASN employs a modular architecture, generating an AST using specifically designed neural networks for each construct in the ASDL grammar.</p><p>Inspired by this existing research, we have developed TRANX, a TRANsition-based abstract syntaX parser for semantic parsing and code generation. TRANX is designed with the following principles in mind:</p><p>• Generalization ability TRANX employs ASTs as a general-purpose intermediate meaning representation, and the task-dependent grammar is provided to the system as external knowledge to guide the parsing process, therefore decoupling the semantic parsing procedure with specificities of grammars.</p><p>• Extensibility TRANX uses a simple transition system to parse NL utterances into tree-  <ref type="figure">Figure 1</ref>: Workflow of TRANX structured ASTs. The transition system is designed to be easy to extend, requiring minimal engineering to adapt to tasks that need to handle extra domain-specific information.</p><p>• Effectiveness We test TRANX on four semantic parsing (ATIS, GEO) and code generation (DJANGO, WIKISQL) tasks, and demonstrate that TRANX is capable of generalizing to different domains while registering strong performance, out-performing existing neural networkbased approaches on three of the four datasets (GEO, ATIS, DJANGO).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Methodology</head><p>Given an NL utterance, TRANX parses the utterance into a formal meaning representation, typically represented as λ-calculus logical forms, domain-specific, or general-purpose programming languages (e.g., Python). In the following description we use Python code generation as a running example, where a programmer's natural language intents are mapped to Python source code. <ref type="figure">Fig. 1</ref> depicts the workflow of TRANX. We will present more use cases of TRANX in § 3. The core of TRANX is a transition system. Given an input NL utterance x, TRANX employs the transition system to map the utterance x into an AST z using a series of treeconstruction actions ( § 2.2). TRANX employs ASTs as the intermediate meaning representation to abstract over domain-specific structure of MRs. This parsing process is guided by the userdefined, domain-specific grammar specified under the ASDL formalism ( § 2.1). Given the generated AST z, the parser calls the user-defined function, AST to MR(·), to convert the intermediate AST into a domain-specific meaning representation y, completing the parsing process. TRANX uses a probabilistic model p(z|x), parameterized by a neural network, to score each hypothesis AST ( § 2.3).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Modeling ASTs using ASDL Grammar</head><p>TRANX uses ASTs as the general-purpose, intermediate semantic representation for MRs. ASTs are commonly used to represent programming languages, and can also be used to represent other tree-structured MRs (e.g., λ-calculus). The ASDL framework is a grammatical formalism to define ASTs. See <ref type="figure">Fig. 1</ref> for an excerpt of the Python ASDL grammar. TRANX provides APIs to read such a grammar from human-readable text files.</p><p>An ASDL grammar has two basic constructs: types and constructors. A composite type is defined by the set of constructors under that type. For example, the stmt and expr composite types in <ref type="figure">Fig. 1</ref> refer to Python statements and expressions, repectively, each defined by a series of constructors. A constructor specifies a language construct of a particular type using its fields. For instance, the Call constructor under the composite type expr denotes function call expressions, and has three fields: func, args and keywords. Each field in a constructor is also strongly typed, which specifies the type of value the field can hold. A field with a composite type can be instantiated by constructors of the same type. For example, the func field above can hold a constructor of type expr. There are also fields with primitive types, which store values. For example, the id field of Name constructor has a primitive type identifier, and is used to store identifier names. And the field s in the Str (string) constructor hold string literals. Finally, each field has a cardinality (single, optional ? and sequential * ), denoting the number of values the field holds.</p><p>An AST is then composed of multiple constructors, where each node on the tree corresponds to a typed field in a constructor (except for the root node, which denotes the root constructor). Depending on the cardinality of the field, a node can hold one or multiple constructors as its values. For instance, the func field with single car- Purple squares denote fields with sequential cardinality. Grey nodes denote primitive identifier fields. Fields are labeled with time steps at which they are generated. Right The action sequence used to construct the AST. Each action is labeled with its frontier field n f t . APPLYCONSTR actions are represented by their constructors.</p><p>dinality in the ASDL grammar in <ref type="figure">Fig. 1</ref> is instantiated with one Name constructor, while the args field with sequential cardinality have multiple child constructors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Transition System</head><p>Inspired by <ref type="bibr" target="#b18">Yin and Neubig (2017)</ref> (hereafter YN17), we develop a transition system that decomposes the generation procedure of an AST into a sequence of tree-constructing actions. We now explain the transition system using our running example. <ref type="figure" target="#fig_0">Fig. 2</ref> Right lists the sequence of actions used to construct the example AST. In high level, the generation process starts from an initial derivation AST with a single root node, and proceeds according to a top-down, left-to-right order traversal of the AST. At each time step, one of the following three types of actions is evoked to expand the opening frontier field n ft of the derivation: APPLYCONSTR[c] actions apply a constructor c to the opening composite frontier field which has the same type as c, populating the opening node using the fields in c. If the frontier field has sequential cardinality, the action appends the constructor to the list of constructors held by the field.</p><p>REDUCE actions mark the completion of the generation of child values for a field with optional (?) or multiple ( * ) cardinalities.</p><p>GENTOKEN <ref type="bibr">[v]</ref> actions populate a (empty) primitive frontier field with a token v. For example, the field f 7 on <ref type="figure" target="#fig_0">Fig. 2</ref> has type identifier, and is instantiated using a single GENTOKEN action. For fields of string type, like f 8 , whose value could consists of multiple tokens (only one shown here), it can be filled using a sequence of GENTOKEN actions, with a special GENTOKEN[&lt;/f&gt;] action to terminate the generation of token values.</p><p>The generation completes once there is no frontier field on the derivation. TRANX then calls the user specified function AST to MR(·) to convert the generated intermediate AST z into the target domain-specific MR y. TRANX provides various helper functions to ease the process of writing conversion functions. For example, our example conversion function to transform ASTs into Python source code contains only 32 lines of code. TRANX also ships with several built-in conversion functions to handle MRs commonly used in semantic parsing and code generation, like λcalculus logical forms and SQL queries.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Computing Action Probabilities p(z|x)</head><p>Given the transition system, the probability of an z is decomposed into the probabilities of the sequence of actions used to generate z p(z|x) = t p(a t |a &lt;t , x), Following YN17, we parameterize the transitionbased parser p(z|x) using a neural encoderdecoder network with augmented recurrent connections to reflect the topology of ASTs.</p><p>Encoder The encoder is a standard bidirectional Long Short-term Memory (LSTM) network, which encodes the input utterance x of n tokens,</p><formula xml:id="formula_0">{x i } n i=1 into vectorial representations {h} n i=1 . Decoder</formula><p>The decoder is also an LSTM network, with its hidden state s t at each time temp given by</p><formula xml:id="formula_1">s t = f LSTM ([a t−1 :s t−1 : p t ], s t−1 ),</formula><p>where f LSTM is the LSTM transition function, and [:] denotes vector concatenation. a t−1 is the em-   <ref type="bibr" target="#b10">Rabinovich et al. (2017)</ref> bedding of the previous action. We maintain an embedding vector for each action.s t is the attentional vector defined as in <ref type="bibr" target="#b6">Luong et al. (2015)</ref> </p><formula xml:id="formula_2">s t = tanh(W c [c t : s t ]).</formula><p>where c t is the context vector retrieved from input encodings {h i } n i=1 using attention. Parent Feeding p t is a vector that encodes the information of the parent frontier field n ft on the derivation, which is a concatenation of two vectors: the embedding of the frontier field n ft , and s pt , the decoder's state at which the constructor of n ft is generated by the APPLYCONSTR action. Parent feeding reflects the topology of treestructured ASTs, and gives better performance on generating complex MRs like Python code ( § 3).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Action Probabilities</head><p>The probability of an AP- <ref type="bibr">PLYCONSTR[c]</ref> action with embedding a c is 2</p><formula xml:id="formula_3">p(a t = APPLYCONSTR[c]|a &lt;t , x) = softmax(a c Ws t ) (1)</formula><p>For GENTOKEN actions, we employ a hybrid approach of generation and copying, allowing for out-of-vocabulary variable names and literals (e.g., "file.csv" in <ref type="figure">Fig. 1</ref>) in x to be directly copied to the derivation. Specifically, the action probability is defined to be the marginal probability</p><formula xml:id="formula_4">p(a t = GENTOKEN[v]|a &lt;t , x)</formula><p>= p(gen|a t , x)p(v|gen, a t , x)+ p(copy|a t , x)p(v|copy, a t , x) 2 REDUCE is treated as a special APPLYCONSTR action.  The binary probability p(gen|·) and p(copy|·) is given by softmax(Ws t ). The probability of generating v from a closed-set vocabulary, p(v|gen, ·) is defined similarly as Eq. (1). The copy probability of copying the i-th word in x is defined using a pointer network <ref type="bibr" target="#b12">(Vinyals et al., 2015)</ref> p(x i |copy, a &lt;t , x) = softmax(h i Ws t ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Experiments</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Datasets</head><p>To demonstrate the generalization and extensibility of TRANX, we deploy our parser on four semantic parsing and code generation tasks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.1">Semantic Parsing</head><p>We evaluate on GEO and ATIS datasets. GEO is a collection of 880 U.S. geographical questions (e.g., "Which states border Texas?"), and ATIS is a set of 5,410 inquiries of flight information (e.g., "Show me flights from Dallas to Baltimore").</p><p>The MRs in the two datasets are defined in λ-calculus logical forms (e.g., "lambda x (and (state x) (next to x texas))" and "lambda x (and (flight x dallas) (to x baltimore))"). We use the pre-processed datasets released by <ref type="bibr" target="#b2">Dong and Lapata (2016)</ref>. We use the ASDL grammar defined in <ref type="bibr" target="#b10">Rabinovich et al. (2017)</ref>, as listed in <ref type="figure" target="#fig_1">Fig. 3</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.2">Code Generation</head><p>We evaluate TRANX on both general-purpose (Python, DJANGO) and domain-specific (SQL, WIKISQL) code generation tasks. The DJANGO dataset <ref type="bibr" target="#b8">(Oda et al., 2015)</ref> consists of 18,805 lines of Python source code extracted from the Django Web framework, with each line paired with an NL description. Code in this dataset covers various real-world use cases of Python, like string manipulation, I/O operation, exception handling, etc.</p><p>WIKISQL <ref type="bibr" target="#b24">(Zhong et al., 2017</ref>) is a code generation task for domain-specific languages (i.e., SQL). It consists of 80,654 examples of NL questions (e.g., "What position did Calvin Mccarty play?") and annotated SQL queries (e.g., "SELECT Position FROM <ref type="table">Table WHERE</ref> Methods GEO ATIS ZH15 <ref type="bibr" target="#b23">(Zhao and Huang, 2015)</ref> 88.9 84.2 ZC07 <ref type="bibr" target="#b22">(Zettlemoyer and Collins, 2007)</ref> 89.0 84.6 WKZ14 <ref type="bibr" target="#b13">(Wang et al., 2014)</ref> 90.4 91.3 Neural Network-based Models SEQ2TREE <ref type="bibr" target="#b2">(Dong and Lapata, 2016)</ref> 87.1 84.6 ASN <ref type="bibr" target="#b10">(Rabinovich et al., 2017)</ref> 85  <ref type="bibr" target="#b5">(Ling et al., 2016)</ref> 31.5 SEQ2TREE <ref type="bibr" target="#b2">(Dong and Lapata, 2016)</ref> 39.4 NMT <ref type="bibr" target="#b7">(Neubig, 2015)</ref> 45.1 LPN <ref type="bibr" target="#b5">(Ling et al., 2016)</ref> 62.3 YN17 <ref type="bibr" target="#b18">(Yin and Neubig, 2017)</ref> 71.6 TRANX (w/o parent feeding) 72.7 TRANX (w parent feeding) 73.7 Extending TRANX for WIKISQL In order to achieve strong results, existing parsers, like most models in Tab. 3, use specifically designed architectures to reflect the syntactic structure of SQL queries. We show that the transition system used by TRANX can be easily extended for WIKISQL with minimal engineering, while registering strong performance. First, we use define a simple ASDL grammar following the syntax of SQL <ref type="figure" target="#fig_2">(Fig. 4)</ref>. We then augment the tran </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Results</head><p>In this section we discuss our experimental results. All results are averaged over three runs with different random seeds.</p><p>Semantic Parsing Tab. 1 lists the results for semantic parsing tasks. We test TRANX with Methods ACCEM ACCEX Seq2Seq <ref type="bibr" target="#b24">(Zhong et al., 2017)</ref> 23.4 35.9 SEQ2TREE <ref type="bibr" target="#b2">(Dong and Lapata, 2016)</ref> 23.4 35.9 Seq2SQL <ref type="bibr" target="#b24">(Zhong et al., 2017)</ref> 48.3 59.4 SQLNet <ref type="bibr" target="#b17">(Xu et al., 2017)</ref> -68.0 PT-MAML <ref type="bibr" target="#b4">(Huang et al., 2018)</ref> 62.8 68.0 TypeSQL <ref type="bibr" target="#b20">(Yu et al., 2018)</ref> -73.5 TRANX w/ parent feeding 62.6 71.6 w/o parent feeding 62.9 71.7 PointSQL <ref type="bibr" target="#b14">(Wang et al., 2017</ref>  two configurations, with or without parent feeding ( § 2.3). Our system outperforms existing neural network-based approaches. This demonstrates the effectiveness of TRANX in closed-domain semantic parsing. Interestingly, we found the model without parent feeding achieves slightly better accuracy on GEO, probably because that its relative simple grammar does not require extra handling of parent information.</p><p>Code Generation Tab. 2 lists the results on DJANGO. TRANX achieves state-of-the-art results on DJANGO. We also find parent feeding yields +1 point gain in accuracy, suggesting the importance of modeling parental connections in ASTs with complex domain grammars (e.g., Python). Tab. 3 shows the results on WIKISQL. We first discuss our standard model which only uses information of column names and do not use the contents of input tables during inference, as listed in the top two blocks in Tab. 3. We find TRANX, although just with simple extensions to adapt to this dataset, achieves impressive results and outperforms many task-specific methods. This demonstrates that TRANX is easy to extend to incorporate task-specific information, while maintaining its effectiveness. We also extend TRANX with a very simple answer pruning strategy, where we execute the candidate SQL queries in the beam against the input table, and prune those that yield empty execution results. Results are listed in the bottom two-blocks in Tab. 3, where we compare with systems that also use the contents of tables. Surprisingly, this (frustratingly) simple extension yields significant improvements, outperforming many task-specific models that use specifically de-signed, heavily-engineered neural networks to incorporate information of table contents.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Conclusion</head><p>We present TRANX, a transition-based abstract syntax parser. TRANX is generalizable, extensible and effective, achieving strong results on semantic parsing and code generation tasks.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 2 :</head><label>2</label><figDesc>Left The ASDL AST for the target Python code inFig. 1. Field names are labeled on upper arcs, and indexed as fi.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 :</head><label>3</label><figDesc>The λ-calculus ASDL grammar for GEO and ATIS, defined in</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 :</head><label>4</label><figDesc>The ASDL grammar for WIKISQL</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>Apply(pred predicate, expr * arguments) | Argmax(var variable, expr domain, expr body) | Argmin(var variable, expr domain, expr body) | Count(var variable, expr body)</figDesc><table><row><cell>expr</cell></row><row><cell>= Variable(var variable)</cell></row><row><cell>| Entity(ent entity)</cell></row><row><cell>| Number(num number)</cell></row><row><cell>| | Exists(var variable, expr body)</cell></row><row><cell>| Lambda(var variable, var type type, expr body)</cell></row><row><cell>| Max(var variable, expr body)</cell></row><row><cell>| Min(var variable, expr body)</cell></row><row><cell>| Sum(var variable, expr domain, expr body)</cell></row><row><cell>| The(var variable, expr body)</cell></row><row><cell>| Not(expr argument)</cell></row><row><cell>| And(expr *  arguments)</cell></row><row><cell>| Or(expr *  arguments)</cell></row><row><cell>| Compare(cmp op op, expr left, expr right)</cell></row><row><cell>cmp op = Equal | LessThan | GreaterThan</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>stmt = Select(agg op? agg, idx column idx, cond expr * conditions) cond expr = Condition(cmp op op, idx column idx, string value) agg op = Max | Min | Count | Sum | Avg cmp op = Equal | GreaterThan | LessThan | Other</figDesc><table /><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 2 :</head><label>2</label><figDesc>Code generation accuracies on DJANGO</figDesc><table><row><cell>Player = Calvin Mccarty"). Different from</cell></row><row><cell>other datasets, each example also has a table ex-</cell></row><row><cell>tracted from Wikipedia, and the SQL query is ex-</cell></row><row><cell>ecuted against the table to get an answer.</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head>Table 3 :</head><label>3</label><figDesc>Exact match (EM) and execution (EX) accuracies on WIKISQL. † Methods that use the contents of input tables.</figDesc><table /><note></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1">Available at https://github.com/pcyin/tranX. An earilier version is used in<ref type="bibr" target="#b19">Yin et al. (2018)</ref>.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4">args f 9 value f 1 0 n f 1 1 t 1 t 2 t 3 t 4 t 5 t 6 t 7 t 8 t 1 0 t 9 t 1 1 t 1 2t n ft Action t 1 root Expr(expr value) t 2 f 1 Call(expr func, expr* args, keyword* keywords) t 3 f 2 Attribute(expr value, identifier attr) t 4 f 5 Name(identifier id) t 5 f 7 GENTOKEN[pandas] t 6 f 6 GENTOKEN[read csv] t 7 f 3 Str(string s) t 8 f 8 GENTOKEN[file.csv] t 9 f 8 GENTOKEN[&lt;/f&gt;] t 10 f 3 REDUCE (close the frontier field f 3 ) t 11 f 4 keyword(identifier arg, expr value) t 12 f 9 GENTOKEN[nrows] t 13 f 10 Num(object n) t 14 f 11 GENTOKEN[1000] t 15 f 4 REDUCE (close the frontier field f 4 )</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>This material is based upon work supported by the National Science Foundation under Grant No. 1815287. PY would like to thank Junxian He and Li Dong for helpful discussions.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Weakly supervised learning of semantic parsers for mapping instructions to actions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yoav</forename><surname>Artzi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Luke</forename><surname>Zettlemoyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Transaction of ACL</title>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Abstract meaning representation for sembanking</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Laura</forename><surname>Banarescu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Claire</forename><surname>Bonial</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shu</forename><surname>Cai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Madalina</forename><surname>Georgescu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kira</forename><surname>Griffitt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ulf</forename><surname>Hermjakob</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of LAW-ID@ACL</title>
		<meeting>LAW-ID@ACL<address><addrLine>Kevin Knight, Philipp Koehn, Martha Palmer, and Nathan Schneider</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Language to logical form with neural attention</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Li</forename><surname>Dong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mirella</forename><surname>Lapata</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACL</title>
		<meeting>ACL</meeting>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Coarse-to-fine decoding for neural semantic parsing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Li</forename><surname>Dong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mirella</forename><surname>Lapata</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACL</title>
		<meeting>ACL</meeting>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Natural language to structured query generation via meta-learning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Po-Sen</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chenglong</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rishabh</forename><surname>Singh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wen</forename><surname>Tau Yih</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xiaodong</forename><surname>He</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of NAACL-HLT</title>
		<meeting>NAACL-HLT</meeting>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Latent predictor networks for code generation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wang</forename><surname>Ling</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Phil</forename><surname>Blunsom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Edward</forename><surname>Grefenstette</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Karl</forename><forename type="middle">Moritz</forename><surname>Hermann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tomás</forename><surname>Kociský</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fumin</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrew</forename><surname>Senior</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACL</title>
		<meeting>ACL</meeting>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Effective approaches to attentionbased neural machine translation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thang</forename><surname>Luong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hieu</forename><surname>Pham</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christopher</forename><forename type="middle">D</forename><surname>Manning</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of EMNLP</title>
		<meeting>EMNLP</meeting>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">lamtram: A toolkit for language and translation modeling using neural networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Graham</forename><surname>Neubig</surname></persName>
		</author>
		<ptr target="http://www.github.com/neubig/lamtram" />
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Learning to generate pseudo-code from source code using statistical machine translation (T)</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yusuke</forename><surname>Oda</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hiroyuki</forename><surname>Fudaba</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Graham</forename><surname>Neubig</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hideaki</forename><surname>Hata</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sakriani</forename><surname>Sakti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tomoki</forename><surname>Toda</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Satoshi</forename><surname>Nakamura</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ASE</title>
		<meeting>ASE</meeting>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Language to code: Learning semantic parsers for if-this-then-that recipes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chris</forename><surname>Quirk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Raymond</forename><forename type="middle">J</forename><surname>Mooney</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michel</forename><surname>Galley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACL</title>
		<meeting>ACL</meeting>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Abstract syntax networks for code generation and semantic parsing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Maxim</forename><surname>Rabinovich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mitchell</forename><surname>Stern</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dan</forename><surname>Klein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACL</title>
		<meeting>ACL</meeting>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Semantic parsing with syntax-and table-aware SQL generation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yibo</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Duyu</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nan</forename><surname>Duan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jianshu</forename><surname>Ji</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Guihong</forename><surname>Cao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xiaocheng</forename><surname>Feng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bing</forename><surname>Qin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ting</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ming</forename><surname>Zhou</surname></persName>
		</author>
		<idno>abs/1804.08338</idno>
		<imprint>
			<date type="published" when="2018" />
			<publisher>CoRR</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Pointer networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Oriol</forename><surname>Vinyals</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Meire</forename><surname>Fortunato</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Navdeep</forename><surname>Jaitly</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of NIPS</title>
		<meeting>NIPS</meeting>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Morpho-syntactic lexical generalization for CCG semantic parsing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Adrienne</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tom</forename><surname>Kwiatkowski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Luke</forename><surname>Zettlemoyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of EMNLP</title>
		<meeting>EMNLP</meeting>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Pointing out SQL queries from text</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chenglong</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marc</forename><surname>Brockschmidt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rishabh</forename><surname>Singh</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">The Zephyr abstract syntax description language</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Daniel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrew</forename><forename type="middle">W</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jeffrey</forename><forename type="middle">L</forename><surname>Appel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christopher</forename><forename type="middle">S</forename><surname>Korn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Serra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of DSL</title>
		<meeting>DSL</meeting>
		<imprint>
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Sequence-based structured prediction for semantic parsing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chunyang</forename><surname>Xiao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marc</forename><surname>Dymetman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Claire</forename><surname>Gardent</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACL</title>
		<meeting>ACL</meeting>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xiaojun</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chang</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dawn</forename><surname>Song</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1711.04436</idno>
		<title level="m">SQL-Net: Generating structured queries from natural language without reinforcement learning</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">A syntactic neural model for general-purpose code generation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pengcheng</forename><surname>Yin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Graham</forename><surname>Neubig</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACL</title>
		<meeting>ACL</meeting>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">StructVAE: Tree-structured latent variable models for semi-supervised semantic parsing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pengcheng</forename><surname>Yin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chunting</forename><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACL</title>
		<meeting>ACL</meeting>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
	<note>Junxian He, and Graham Neubig</note>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">TypeSQL: Knowledgebased type-aware neural text-to-sql generation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tao</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zifan</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zilin</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rui</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dragomir</forename><forename type="middle">R</forename><surname>Radev</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Learning to map sentences to logical form structured classification with probabilistic categorial grammars</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Luke</forename><surname>Zettlemoyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Collins</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of UAI</title>
		<meeting>UAI</meeting>
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Online learning of relaxed CCG grammars for parsing to logical form</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Luke</forename><forename type="middle">S</forename><surname>Zettlemoyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Collins</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of EMNLP-CoNLL</title>
		<meeting>EMNLP-CoNLL</meeting>
		<imprint>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Type-driven incremental semantic parsing with polymorphism</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kai</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Liang</forename><surname>Huang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of NAACL-HLT</title>
		<meeting>NAACL-HLT</meeting>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Victor</forename><surname>Zhong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Caiming</forename><surname>Xiong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Richard</forename><surname>Socher</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1709.00103</idno>
		<title level="m">Seq2SQL: Generating structured queries from natural language using reinforcement learning</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
