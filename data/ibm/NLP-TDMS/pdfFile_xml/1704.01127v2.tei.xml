<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /nfs/home/kabenamualus/Research/task-dataset-metric-extraction/../grobid-0.6.0/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">0.5 Petabyte Simulation of a 45-Qubit Quantum Circuit</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Häner</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Institute for Theoretical Physics</orgName>
								<orgName type="institution">ETH Zurich</orgName>
								<address>
									<postCode>8093</postCode>
									<settlement>Zurich</settlement>
									<country key="CH">Switzerland</country>
								</address>
							</affiliation>
						</author>
						<author role="corresp">
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Damian</forename><forename type="middle">S</forename><surname>Steiger</surname></persName>
							<email>dsteiger@phys.ethz.ch</email>
							<affiliation key="aff1">
								<orgName type="department">Institute for Theoretical Physics ETH</orgName>
								<address>
									<postCode>8093</postCode>
									<settlement>Zurich, Zurich</settlement>
									<country key="CH">Switzerland</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">0.5 Petabyte Simulation of a 45-Qubit Quantum Circuit</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>

		<encodingDesc>
			<appInfo>
				<application version="0.6.0" ident="GROBID-SDO" when="2021-06-26T08:55+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid-sdo"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>CCS CONCEPTS • Applied computing → Physics;</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Near-term quantum computers will soon reach sizes that are challenging to directly simulate, even when employing the most powerful supercomputers. Yet, the ability to simulate these early devices using classical computers is crucial for calibration, validation, and benchmarking. In order to make use of the full potential of systems featuring multi-and many-core processors, we use automatic code generation and optimization of compute kernels, which also enables performance portability. We apply a scheduling algorithm to quantum supremacy circuits in order to reduce the required communication and simulate a 45-qubit circuit on the Cori II supercomputer using 8, 192 nodes and 0.5 petabytes of memory. To our knowledge, this constitutes the largest quantum circuit simulation to this date. Our highly-tuned kernels in combination with the reduced communication requirements allow an improvement in time-to-solution over state-of-the-art simulations by more than an order of magnitude at every scale.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>CCS CONCEPTS</head><p>• Applied computing → Physics; arXiv:1704.01127v2 [quant-ph]  </p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Quantum computers promise to solve problems which would be impossible to tackle with classical machines. While such devices will not speed up every application, there are certain areas which could be revolutionized by quantum computers. This includes quantum chemistry <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b2">3,</ref><ref type="bibr" target="#b12">14]</ref>, material science <ref type="bibr" target="#b3">[4]</ref>, machine learning <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b11">13,</ref><ref type="bibr" target="#b19">21]</ref>, and cryptography <ref type="bibr" target="#b14">[16]</ref>.</p><p>Experimental devices featuring close to 50 quantum bits (qubits) will soon be available and may be able to perform well-defined computational tasks which would classically require the world's most powerful supercomputers. Going even beyond these capabilities means entering the domain of Quantum Supremacy <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b4">5]</ref>. While one of the computational tasks proposed to demonstrate this supremacy -the execution of low-depth random quantum circuits, see <ref type="figure">Fig. 1</ref> -is not scientifically useful on its own, running such circuits is still of great use to calibrate, validate, and benchmark near-term quantum devices <ref type="bibr" target="#b4">[5]</ref>.</p><p>Therefore, in addition to verifying quantum algorithms and carrying out studies of their behavior under noise, quantum circuit simulators may provide the means to carry out these calibrations and benchmarks and thereby enable more efficient quantum hardware/software co-design. Quantum circuit simulators are thus comparable to tools such as the structural simulation toolkit (SST) <ref type="bibr" target="#b13">[15]</ref>, which allows to simulate upcoming classical hardware.</p><p>Related work. There are many implementations of quantum circuit simulators <ref type="bibr">[12]</ref> available, most of them are meant to simulate small systems on a single node. The most widely-used single-node simulator is Microsoft's LIQU i |⟩ <ref type="bibr" target="#b18">[20]</ref>, which is implemented in F# and is thus not as fast as simulators written in, e.g., C++ such as ProjectQ <ref type="bibr" target="#b16">[18]</ref>. The massively parallel simulator from <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b17">19]</ref> was used to simulate 42 qubits on the Jülich supercomputer in 2010, which set the new world record in number of simulated quantum bits. Recently, Intel's qHiPSTER <ref type="bibr" target="#b15">[17]</ref> was specialized for the simulation of quantum supremacy circuits and then used to simulate these circuits up to 42 qubits <ref type="bibr" target="#b4">[5]</ref>. A topic similar to quantum circuit simulation is emulation which, instead of simulating individual gates, uses classical shortcuts in order to reduce the time-to-solution for quantum operations whose action is known in advance. An example for such a shortcut is the quantum Fourier transform, which can be emulated by applying a fast Fourier transform to the state vector <ref type="bibr" target="#b6">[7]</ref>. However, such emulation techniques are not applicable to quantum supremacy circuits.</p><p>Our contribution. We improve the strong scaling behavior of the compute kernels underlying quantum circuit simulation in order to reduce time-to-solution when employing multi-and many-core processors. In the multi-node domain, we employ a communication scheme similar to <ref type="bibr" target="#b5">[6]</ref> and introduce an additional layer of optimization to reduce the amount of communication required: We apply a clustering algorithm to the quantum circuit in order to improve the scheduling of quantum gate operations. While this pre-computation terminates in 1 − 3 seconds on a laptop, it greatly reduces the number of communication steps. We then simulate quantum supremacy circuits of various sizes and report speedups of over one order of magnitude on all scales. Finally, we simulate a 45-qubit quantum supremacy circuit on the Cori II supercomputing system using 0.5 petabytes of memory and 8, 192 nodes. To our knowledge, this constitutes a new record in the maximal number of simulated qubits. The classical simulation of such circuits is believed to be impossible already for 49 qubits which, according to <ref type="bibr" target="#b10">[11]</ref>, is the threshold for quantum computers outperforming the largest supercomputers available today at the task of sampling from the output distribution of random low-depth quantum circuits. While we do not carry out a classical simulation of 49 qubits, we provide numerical evidence that this may be possible. Our optimizations allow reducing the number of communication steps required to simulate the entire circuit to just two all-to-alls, making it possible to use, e.g., solid-state drives if the available memory is less than the 8 petabytes required.</p><p>(1) <ref type="bibr" target="#b1">(2)</ref> (3) (4) (5) (6) (7) (8) <ref type="figure">Figure 1</ref>: Low-depth random quantum circuit proposed by Google to show quantum supremacy <ref type="bibr" target="#b4">[5]</ref>. We generated identical circuits using the following rules: At clock cycle 0, a Hadamard gate is applied to each qubit. Afterwards, eight different patterns of controlled Z (CZ) gates are applied repeatedly until the desired circuit depth is achieved. See the 8 different CZ patterns above in clock cycles 1-8 for a 6 × 6 qubit circuit, where the CZ gates are represented by a line between two qubits. This pattern ensures that all possible two qubit interactions on this 2D nearest neighbor architecture are executed every 8 cycles.</p><p>In addition to the CZ gates, single qubit gates are applied to all qubits which in the previous cycle (but not in the current cycle) performed a CZ gate. The single qubit gates are randomly chosen to be either a T (red), X 1/2 (blue), or Y 1/2 (yellow) gate, except that the second single-qubit gate on each qubit (the first is the Hadamard gate in cycle 0) is always a T gate and when randomly choosing a single-qubit gate, it must be different from the previous single-qubit gate on that qubit.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">BASICS OF QUANTUM COMPUTER SIMULATION</head><p>A quantum computer consists of quantum bits (qubits). A qubit is a two-level quantum systems whose state |ψ ⟩ can be described by 2 complex numbers α 0 and α 1 as</p><formula xml:id="formula_0">|ψ ⟩ = α 0 |0⟩ + α 1 |1⟩ , where |α 0 | 2 + |α 1 | 2 = 1.</formula><p>The two computational basis states |0⟩ and |1⟩ are orthonormal and the qubit, when measured, collapses onto either |0⟩ or |1⟩ with probability p = |α 0 | 2 and |α 1 | 2 = 1 − p, respectively. The measured qubit is then just a classical bit. To store |ψ ⟩ on a classical computer, it is more practical to choose two orthonormal vectors to represent |0⟩ and |1⟩,</p><formula xml:id="formula_1">|ψ ⟩ = α 0 1 0 + α 1 0 1 = α 0 α 1 .</formula><p>Any operation on this qubit can then be represented as a complex unitary 2 × 2 matrix. Applying, for example, a bit-flip operation, denoted by X = 0 1 1 0 , to the state |ψ ⟩, amounts to a matrix-vector multiplication:</p><formula xml:id="formula_2">X |ψ ⟩ = 0 1 1 0 α 0 α 1 = α 1 α 0 = α 1 |0⟩ + α 0 |1⟩ .</formula><p>Other single-qubit gates used in quantum supremacy circuits are the</p><formula xml:id="formula_3">Hadamard gate H = 1 √ 2 1 1 1 −1 , the T gate T = 1 0 0 e i π /4 , X 1/2 = 1 2 1+i 1−i 1−i 1+i , and Y 1/2 = 1 2 1+i −1−i 1+i 1+i .</formula><p>The state of a two-qubit system |ϕ⟩ can be represented using 4 complex coefficients giving the contribution of all possible classical states featuring two bits, i.e.,</p><formula xml:id="formula_4">|ϕ⟩ = α 00 |00⟩ + α 01 |01⟩ + α 10 |10⟩ + α 11 |11⟩ = α 0 α 1 α 2 α 3</formula><p>. and operations acting on the entire state can be represented by complex unitary matrices of dimension 4 × 4. An example for a two-qubit gate which occurs in quantum supremacy circuits is the controlled-Z or CZ gate,</p><formula xml:id="formula_5">CZ = 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 −1 ,</formula><p>which adds a (−1)-phase to the |11⟩ basis state. Also, note that this gate is symmetric in terms of qubits -it does not matter which qubit is the control / target qubit. This symmetry of the CZ gate can also be seen in <ref type="figure">Fig. 1</ref>.</p><p>To build the 4 × 4 matrix acting on the entire system when applying a single-qubit operation to just one qubit, one performs a Kronecker product with a 2 × 2 identity matrix. Applying an X -gate to the first qubit (with bit-index 0) can be achieved as follows:</p><formula xml:id="formula_6">X 0 |ϕ⟩ = 1 2 ⊗ X |ϕ⟩ = α 01 |00⟩ + α 00 |01⟩ + α 11 |10⟩ + α 10 |11⟩ = α 00 |01⟩ + α 01 |00⟩ + α 10 |11⟩ + α 11 |10⟩ .</formula><p>More generally, the state of an n-qubit quantum computer can be represented by a complex vector of size 2 n |Ψ⟩ = α 0 |0 · · · 00⟩ + α 1 |0 · · · 01⟩ + · · · + α 2 n −1 |1 · · · 11⟩ and operations on this state are 2 n ×2 n unitary matrices. Finally, applying a single-qubit gate U to the i-th qubit of an n-qubit quantum computer amounts to multiplying the state vector of coefficients α i by the matrix</p><formula xml:id="formula_7">1 2 ⊗ · · · ⊗ 1 2 n−i−1 ⊗ U ⊗ 1 2 ⊗ · · · ⊗ 1 2 i ,</formula><p>which is just a complex sparse matrix-vector multiplication of dimension 2 n . Thus, for double-precision values, just storing the state vector for 50 qubits would already require 16 petabytes of memory.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">OPTIMIZATIONS</head><p>Our simulator was implemented and optimized using a layered approach. The first layer aims to improve the single-core performance of our quantum gate kernels by employing explicit vectorization using compiler intrinsics, instruction reordering, and blocking to reduce register-spilling. The second layer uses OpenMP to enable a good strong scaling behavior on an entire node. The third and final layer implements the inter-node communication scheme using MPI. This allows to simulate up to 45 qubits on current supercomputers, in addition to reducing the time-to-solution when executing quantum circuits featuring fewer qubits.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Standard optimizations</head><p>In order to be able to simulate large systems, it is important not to actually store the 2 n × 2 n matrix acting on the state vector. Instead, one can exploit its regular structure and implement methods which, given the state vector, mimic a multiplication by this matrix. A standard implementation features two state vectors (one input, one output). To determine one entry of the output vector, two complex multiplications and one complex addition have to be carried out on two entries of the input vector when applying a general single-qubit gate. In total, there are thus 2 · (4[mul] + 2[add]) + 2[add] = 14 FLOP per complex entry of the output state vector. One complex doubleprecision entry requires 16 bytes of memory and the input vector has to be loaded from memory and the output vector has to be written back to memory. The operational intensity is therefore less than 1/2, which shows that this application is memory-bandwidth bound on most systems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Single-core</head><p>In order to reduce the memory requirements by a factor of 2x, this complex sparse matrix-vector multiplication can be performed inplace, at the cost of a cache-unfriendly access pattern. Moreover, k-qubit gates require more operations for larger k, allowing to better utilize hardware with strong compute capabilities. In fact, the number of operations grows exponentially with k, since applying a k-qubit gate amounts to performing one scalar product of dimension 2 k per (output) entry.</p><p>To apply a k-qubit gate (of dimension 2 k × 2 k ) to a state vector of size 2 n , where n denotes the number of qubits, the entries corresponding to all 2 k indices of the gate matrix have to be loaded into a 2 k -sized temporary vector, which then gets multiplied by the matrix before it is written back to the state vector. The indices of these state vector entries, when represented in binary, are bit-strings of the form</p><formula xml:id="formula_8">c n−k −1 x i k −1 ...c j ...x i 1 ...c 0 , where i 0 , i 1 , .</formula><p>.., i k −1 denote the k qubits indices to which the gate is being applied. Extracting and combining the bits x i j from the index of an entry, i.e.,</p><formula xml:id="formula_9">x = x i k −1 ...x i 1 x i 0 ,</formula><p>yields the index of this entry with respect to the temporary vector. All 2 k entries which have an identical c = c n−k −1 c n−k −2 ...c 0 index substring are part of this matrix-vector multiplication. Once all entries have been gathered, multiplied by the matrix, and stored back into the state vector, the next c ′ = c + 1 index substring can be dealt with. In total, this amounts to performing 2 n−k complex matrix-vector multiplications of dimension 2 k .</p><p>A first observation is that the same matrix is used 2 n−k times. One can thus permute the matrix entries before-hand in order to always have sorted qubit indices, which results in memory accesses to occur in a more local fashion.</p><p>When applying the matrix-vector product, doing so in the usual manner, i.e.,ṽ</p><formula xml:id="formula_10">l = 2 k −1 i=0 m l,i v i ,</formula><p>would require all entries of the temporary vector v to be in register (and already loaded from memory). In order to address this issue, we employ blocking of the computation and determine the block size using an automatic code-generation / benchmarking feedback loop. For each block index b = 0, 1, ..., 2 k B − 1, all indices l of the temporary output vectorṽ are updated according tõ</p><formula xml:id="formula_11">v l += j &lt;B m l,i(b, j) v i(b, j) ,</formula><p>where i(b, j) = b · B + j, before moving on to the next block.</p><p>We employ explicit vectorization to parallelize updates for consecutive values of l. Since we are dealing with complex doubleprecision values, this theoretically allows to speed up the execution by a factor of 2x or even 4x when using AVX or AVX512, respectively. Denoting by a R and a I the real and imaginary parts of a, respectively, we now inspect the update above more closely. Multiplying one complex entry v l = (v R , v I ) of the temporary vector v with one complex entry of the gate matrix m = (m R , m I ) and summing the result into the temporary output vectorṽ can be written 3.</p><p>(a) Roofline plot for one Edison socket.  Step 1 introduces lazy evaluation, making the application more compute-bound.</p><p>Step 2 adds explicit vectorization and instruction re-ordering, followed by step 3 which applies blocking for registers in addition to a pre-computation on the gate matrix, re-ordering and permuting the complex-valued matrix entries to improve the FLOP/instruction ratio. An additional optimization specific to KNL is the blocking for MCDRAM, which is introduced in step 1.</p><p>as follows:</p><formula xml:id="formula_12">(ṽ R ,ṽ I ) += (v R · m R − v I · m I , v I · m R + v R · m I )<label>(1)</label></formula><p>Yet, implementing this update results in wasted compute resources due to artificial dependencies and additional permutes. However, these instructions can be re-ordered as follows</p><formula xml:id="formula_13">(ṽ R ,ṽ I ) += (v R · m R , v I · m R ) (2) (ṽ R ,ṽ I ) += (v I · −1 · m I , v R · m I )<label>(3)</label></formula><p>in order to increase the maximal achievable performance. Namely, having both (m R , m R ) and (−1 · m I , m I ) available, this update requires only two fused multiply-accumulate instructions instead of several individual multiplications, additions, and permutations. This is an improvement in both FLOP/instruction and FLOP/FMA ratios.</p><p>Note that v l can be permuted once upon loading (and then kept in register), as it is re-used for 2 k such complex multiplications. Also, since the matrix m is used in 2 n−k matrix-vector multiplications, the pre-computation to build up these two matrices consisting of (m R , m R ) and (−1 · m I , m I ) is essentially free.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Single-node</head><p>The optimizations discussed above do not change the fact that the operational intensity for applying a 1-qubit gate is very low, making it harder to fully utilize the power of multi-and manycore processors (see, e.g., <ref type="figure">Fig. 10</ref>). Yet, as mentioned previously, applying a k-qubit gate requires more operations for larger values of k and as long as the application remains memory bound, larger gates can be applied in (almost) the same amount of time. The benefitbesides increased operational intensity -is that larger gates can be used to execute an entire sequence of single-and two-qubit gates at once. In particular, multiple gates acting on k different qubits can be combined into one large k-qubit gate.</p><p>Which value of k to choose depends on the peak performance, the memory-bandwidth, the cache-size &amp; associativity of the system, and the circuit to simulate. The cache specifications are important especially when gates are applied to qubits with larger indices, which cause memory access strides of large powers of two. For lowassociativity caches, this causes conflicts to arise already for small kernel sizes. Since 2 k values need to be loaded from the state vector (which are at least 2 m apart, where m is the lowest qubit index) for each of the 2 n−k matrix-vector multiplications, a 2 k -way cache should map the corresponding cache-lines to different locations, no matter how large m is. This allows to directly access these values from cache for the next matrix-vector multiplication. See <ref type="figure">Fig. 6</ref> and <ref type="figure">Fig. 9</ref> for experimental results.</p><p>Finally, these k-qubit gate kernels are parallelized using OpenMP with NUMA-aware initialization of the state vector to ensure scaling beyond 1 NUMA node. Depending on the qubits to which the gate is applied, the outer-most loop may perform very few iterations, prohibiting a good strong scaling behavior. The OpenMP collapse directive remedies this problem. Please see <ref type="figure" target="#fig_2">Fig. 2a</ref> and <ref type="figure" target="#fig_2">Fig. 2b</ref>, which show the improvements in performance when applying all mentioned optimizations and running the kernels on one socket of Edison or Cori II, which feature one 12-core Intel® Xeon® Processor E5-2695 v2 and one 68-core Intel® Xeon Phi™ Processor 7250 (KNL), respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Multi-node</head><p>The simulation of quantum computers featuring many more than 30 qubits requires multiple nodes in order for the state vector to fit into memory. We use MPI to communicate between 2 д nodes, each node having its own state vector of size 2 l , where д and l denote the number of global and local qubits, respectively. Gate operations on local qubits, i.e., qubits with index i &lt; l, require no communication. Qubits with index i ≥ l, on the other hand, do require communication.</p><p>There are two basic schemes which can be used to perform multinode quantum circuit simulations. The first <ref type="bibr" target="#b17">[19]</ref> keeps global qubits global and applies global gates by employing 2 pair-wise exchanges of half the state vector. The second scheme <ref type="bibr" target="#b5">[6]</ref> swaps global qubits with local ones, applies gates to local qubits in the usual fashion and, if need be, swaps them again with global qubits. Note that swapping in a global qubit and then immediately swapping it back out requires the same amount of communication as the first scheme. We thus expect the global-to-local scheme to perform better and focus on this scheme.</p><p>1-Qubit Example (see <ref type="figure" target="#fig_4">Fig. 3a</ref>). For the case of two ranks, swapping the highest-order qubit (highest bit in the local index) with the global qubit (first bit of the rank number) can be achieved as follows:</p><p>The first block of rank 0 remains unchanged, since swapping 0 with 0 has no effect. Swapping 0 (global) and 1 (local) for the second block requires sending the entire block to rank 1, where these coefficients are associated with the local qubit being 0. Proceeding in this manner results in an exchange of the colored blocks, which is equivalent to an all-to-all. <ref type="figure" target="#fig_4">Fig. 3b</ref>). To swap two global qubits with the two highest-order local qubits for the case of four ranks, each rank sends its i-th quarter of the state vector to rank number i. Therefore, all identically-colored state vector parts are exchanged, which results again in one all-to-all.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2-Qubit Example (see</head><p>Additionally, as done in <ref type="bibr" target="#b5">[6]</ref>, we generalize this scheme to swap multiple or even all global qubits with local ones. Yet, in contrast to <ref type="bibr" target="#b5">[6]</ref>, we do not iteratively copy out parts of the state vector and carry out the pair-wise exchanges manually. Instead, we employ higherlevel abstractions to achieve the same task, with the benefit that optimized implementations for, e.g., specific network topologies are likely to be already available. A q-qubit global-to-local swap, which exchanges q global with q local qubits, can be achieved using 1 group-local all-to-all for each of the 2 д−q groups of processes. Therefore, turning all global qubits into local ones amounts to executing one all-to-all on the MPI_COMM_WORLD communicator. This allows swapping the k qubits with highest local index with k global ones. In order to allow for arbitrary local qubits to be exchanged, we first use our optimized kernels to achieve local swaps between highest-index qubits and those to be swapped. We then perform the group-local all-to-all and, if need be, another local swap (with lower-index qubits) in order to improve data locality in our k-qubit gate kernels.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Global gate specialization</head><p>While a general global gate always requires communication, there are a few common ones which do not. Examples include the controlled-NOT gate (or controlled-X) which, when applied to global qubits, causes merely a re-numbering of ranks. The (diagonal) controlled-Z gate either turns into a conditional global phase or a local Z-gate which, depending on the rank, is executed or not. Finally, the Tgate is also diagonal and results in a global phase, which can be absorbed into the next gate matrix to be applied. Making use of such insights allows to further reduce the number of global-to-local swaps without increasing the amount of computation performed locally.</p><p>For 36-qubit quantum supremacy circuits, this optimization enables a reduction of the required communication by another factor  of 2x: Only one global-to-local swap is required to run the entire depth-25 circuit. For 42-and 45-qubit circuits, 2 global-to-local swaps are necessary, whereas 3 are required without gate specialization.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.6">Circuit Optimizations: Gate scheduling and qubit mapping</head><p>In addition to performing implementation optimizations, also the circuit requires optimization in order to reduce the number of communication steps and to use our highly-tuned kernels in a more efficient manner. We will demonstrate the different optimizations for gate scheduling and qubit mapping using the quantum supremacy circuits from <ref type="bibr" target="#b4">[5]</ref>, for which we also present performance results in the next section. Our optimizations are general and can be applied to any quantum circuit. In fact, these quantum supremacy circuits happen to be designed in a way that is least suitable for these kinds of performance optimizations. We thus expect even larger improvements when employing these techniques for the simulation of other circuits. The construction of these random, low-depth quantum circuits is shown in <ref type="figure">Fig. 1</ref>. These circuits are designed to be run on a quantum computer architecture featuring a 2D nearest-neighbor connectivity graph. By design, all possible two qubit gates are applied within 8 cycles, which makes the system highly entangled. Note that a simulator can skip the initial Hadamard gates in cycle 0 and initialize the wave function directly to (2 − n 2 , ...) T , instead of starting in state |0...0⟩ = (1, 0, ..., 0) T . Furthermore, we do not simulate the final CZ gates as they only alter the phases of the probability amplitudes α i , but not the probabilities p i = |α i | 2 which we are interested in.</p><p>3.6.1 Gate scheduling. The most important optimization on the quantum circuit is gate scheduling, as it drastically reduces the amount of communication in the multi-node setting and also the number of k-qubit gate kernels on the single-node level. The optimizations can be broken into three steps:</p><p>1. Minimize number of communication steps. In a first optimization step, gate scheduling minimizes the number of global-to-local swaps which is the most important parameter in the multi-node setting. Executing every clock-cycle of the circuit on its own requires at least one communication step for every cycle which features a non-diagonal global gate.</p><p>However, as explained in the multi-node strategy, it is beneficial not to execute those global gates but rather swap global qubits with local qubits and then execute these gates locally. In order for this scheme to be most beneficial, the gate scheduling algorithm reorders (if possible) the gates into stages, where each stage consists of a sequence of quantum gates acting only on local qubits, see <ref type="figure">Fig. 4</ref>. Gates acting on the same qubit never commute for quantum supremacy circuits by design, making classical simulation harder. Nevertheless, we can reorder gates which act on different qubits as they commute trivially. After completing a stage, some local qubits are swapped with global qubits, and a new stage is started. This scheme reduces the number of communication steps significantly. A depth-25 42-qubit supremacy circuit requires only two global-tolocal swaps, see <ref type="figure" target="#fig_8">Fig. 5b</ref>. An important feature of our gate scheduling algorithm is that the number of global-to-local swaps is mostly independent of the number of local qubits (29, 30, 31, or 32). This allows for a good strong scaling behavior. <ref type="figure" target="#fig_8">Fig. 5a</ref> shows how the number of global-to-local swaps behaves as a function of circuit depth.</p><p>We decided to always swap global qubits with the lowest-order local qubits to arrive at an upper bound for the number of communication steps required. In addition, we apply a cheap search algorithm to find better local qubits to swap with. In case of a 36qubit supremacy circuit, this results in a 2x reduction in the number of global-to-local swaps, from two swaps to just one. Note that our stage-finding algorithm assumes the worst-case scenario, in which all randomly picked global single-qubit gates are dense, meaning that we cannot apply our gate specialization for T gates to reduce the amount of communication.</p><p>2. Minimize number of k-qubit gates. In a second step, we schedule all the gates within a stage such that we can merge sequences of consecutive 1-or 2-qubit gates into a k-qubit gate and execute this k-qubit gate instead of many single-and two-qubit gates. See <ref type="figure">Fig. 4</ref>, which shows how such a cluster with k = 3 can be built. We greedily try to increase the number of qubits k within a cluster while still maintaining the condition that k ≤ k max , where k max is the largest k for which the k-qubit gate kernel still shows good performance on the target system. To reduce the over-all number of clusters, we perform a small local search in order to build the largest cluster with gates not yet assigned, before assigning the remaining gates to new clusters. We summarize the required number of clusters to execute a quantum supremacy circuit in <ref type="table">Table 1</ref>. Clearly, even for these circuits, more than k gates can be merged into one k-qubit cluster on average.  <ref type="figure">Figure 4</ref>: Example of gate scheduling for a circuit with CZ gates and dense single-qubit rotations gates (R). Note that we use gate specialization for CZ gates, which means we can apply them without communication on global qubits. First, instead of applying the gates cycle by cycle, we identify the largest first stage of gates which can be applied without communication. These are all the gates on the left of the solid red line. Second, we schedule the gates within a stage into clusters. For example, we can combine all the gates on the left of the dashed green line into one 3-qubit gate instead of applying 7 individual gates.</p><p>3. Local adjustments of global-to-local swaps. The last cluster within each stage tends to contain a lower number of single-and two-qubit gates. In order to increase the average number of gates in each cluster and thereby decrease the total number of clusters in the circuit, we try to remove the last clusters of each stage by performing the global-to-local swap earlier if this is possible without increasing the total number of global-to-local swaps.</p><p>3.6.2 Qubit mapping. Last, the bit-location of each qubit is optimized in order to reduce the number of clusters experiencing the performance decrease resulting from the set-associativity of the last-level cache. Since this performance decrease only occurs if the gate is applied to high-order bit-locations, this can be achieved by remapping. The following heuristic allowed for a 2x decrease in time-to-solution:</p><p>Assign the qubit to bit-location 0 such that the number of clusters accessing bit-location 0 is maximal. From now on, ignore all clusters which act on this qubit and assign bit-locations 1, 2, and 3 in the same manner. Bit locations 4, 5, 6, and 7 are assigned the same to 50 for 42-qubit quantum supremacy circuits. The number of global-to-local swaps is mostly independent of the number of local qubits per node, which allows for a good strong scaling behavior.   <ref type="bibr" target="#b4">[5]</ref>. In contrast, the top two panels show the number of global-to-local swaps required to execute the full circuit when using our strategy of reordering gates and swapping global with local qubits. Note that one global-tolocal swap (of all global qubits) requires the same amount of communication as one global gate. Averaged over the different global qubits, executing a dense global gate takes approximately 1/2 of the time required to swap all global qubits with local qubits, because applying a dense gate to low-order global qubits is faster due to the increased locality of the communication, see <ref type="bibr" target="#b4">[5]</ref>. Note that the dashed lines are for worst case instances (only dense random gates on global qubits) and solid lines are for median hard instances, which we only consider in the two lower panels.</p><p>way, except that after each step, only clusters acting on two of these four bit-locations are ignored when assigning the next higher bit-location. For non-random circuits, it would pay off to perform a few local swaps between some bit-locations over the course of the algorithm, in order to maximize the number of clusters acting on low-order qubits.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">IMPLEMENTATION AND RESULTS</head><p>All optimizations mentioned in the previous sections were implemented in C++, except for the code generator for the k-qubit kernels and the circuit scheduler/qubit mapper, which were both implemented in Python.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Cori II</head><p>We performed simulations of quantum supremacy circuits featuring 30, 36, 42, and 45 qubits on the Cori II system at the Lawrence Berkeley National Laboratory (LBNL). Cori II consists of 9,304 singlesocket compute nodes, each containing one 68-core Intel® Xeon Phi™ Processor 7250 (KNL) at 1.40GHz. The nodes are interconnected by a Cray Aries high speed "dragonfly" <ref type="bibr" target="#b8">[9]</ref> topology interconnect and offer a combined theoretical peak performance of 29.1 PFLOPS and 1 PB of aggregate memory.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.1">Node-level performance.</head><p>These experiments were run on a single 68-core Intel® Xeon Phi™ Processor 7250 (KNL) node of the Cori II supercomputing system in the quad/cache setting. For k ∈ {1, 2, 3}-qubit gate kernels, four threads per core were used, as this resulted in the best performance. For k = 4 and k = 5, the best performance was achieved when using two and one thread per core, respectively. As mentioned in Sec. 3.3, the set-associativity of caches plays a crucial role in the performance of these k-qubit gate kernels. In particular, we find the theoretical predictions from Sec. 3.3 to agree perfectly with observations, see <ref type="figure">Fig. 6</ref>. The strong scaling behavior of executing one k-qubit gate kernel on a state vector of 28 qubits can be seen in <ref type="figure" target="#fig_11">Fig. 7</ref>  <ref type="table">Table 1</ref>: Re-scheduling of gates for depth-25 quantum supremacy circuits into clusters (using 30 local qubits). Clusters are built to contain k ≤ k max qubits using a heuristic which tries to maximize the number of gates merged into one cluster. Clearly more than k max individual gates can be combined into one single cluster on average. These optimizations take less than 3 seconds using Python and can be reused for all instance of the same size. High-order Low-order <ref type="figure">Figure 6</ref>: Decrease in performance when applying k-qubit gate kernels to qubits with large indices (high-order qubits) as opposed to low indices (low-order qubits). These experiments were run on all 68 cores of a Cori II KNL node. As mentioned in Sec. 3.3, this performance drop occurs when 2 k is larger than the set-associativity of the last-level cache. While the L2-cache is 16-way set-associative, it is shared between 2 cores. and {1024, 2048, 4096} KNL nodes of Cori II, respectively, is depicted in <ref type="figure">Fig. 8</ref>. Following these scaling experiments, we ran a 45-qubit quantum supremacy circuit using 8, 192 KNL nodes and a total of 0.5PB of memory. To our knowledge, this is the largest quantum circuit simulation ever carried out. Averaged over the entire simulation time (i.e., including communication time), this simulation achieved 0.428 PFLOPS. There are two reasons for this drop in performance. First, the time spent in communication and synchronization is 78%, and overlaying computation and communication would not improve this behavior due to the low k-qubit gate times (less than 1 second).      Second, the performance of our kernels suffers in the regime where only few k-qubit gates are applied before a global-to-local swap needs to be performed. This is due to the fact that blocking for MCDRAM requires a sequence of several gates acting on qubits below bit-location 29. While our mapping procedure aims to maximize this number, the total number of gates being applied is not large enough. Yet, this is mainly due to the artificial construction of random circuits and does not occur in actual quantum algorithms, where interactions remain local over longer periods of time. As our 4-qubit gate kernel achieves 1/2 of the MCDRAM bandwidth which corresponds to roughly 2x the bandwidth of DRAM (see <ref type="figure" target="#fig_2">Fig. 2b</ref>), we expect a 2x drop in performance if memory requirements exceed the MCDRAM size of 16GB. Averaging the performance of our k-qubit kernels in <ref type="figure">Fig. 6</ref> and including this 2x reduction yields approximately 250 GFLOPS per node. In total, we thus expect a performance of 22% × 8, 192 × 250 GFLOPS ≈ 0.45 PFLOPS, which agrees with the measurement results given that we also apply a few 3-and 2-qubit gate kernels for left-over gates.</p><p>For a summary of all runs carried out on Cori II, see <ref type="table" target="#tab_3">Table 2</ref>. Our implementation for, e.g., 42 qubits behaves as expected from <ref type="figure" target="#fig_8">Fig. 5a</ref>: For a depth-25 circuit, the communication scheme used in <ref type="bibr" target="#b4">[5]</ref> requires about 50 global gates, while our simulator performs 2 global-to-local swaps (of all global qubits). Including the fact that one such global-to-local swap requires the same amount of communication and that, averaged over all global qubits, a global gate is 2x faster than if it is applied to the highest-order global qubit due to the network bisection bandwidth (see <ref type="bibr" target="#b4">[5]</ref>), yields a reduction in communication of 50x 2 · 2 = 12.5x , and since we achieve a similar reduction in time-to-solution for the circuit simulation on each node, this is also the expected overall speedup.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Edison</head><p>In order to be able to compare our results directly to <ref type="bibr" target="#b4">[5]</ref>, we also ran 30-and 36-qubit quantum supremacy circuits on the Edison system, also at LBNL. We used up to 64 sockets, each featuring a 12-core Intel® Xeon® Processor E5-2695 v2 at 2.4GHz. The 5, 586 2-socket Edison nodes are interconnected by a Cray Aries "dragonfly" <ref type="bibr" target="#b8">[9]</ref> topology interconnect and the theoretical peak performance of the entire system is 2.57 PFLOPS.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>4.2.1</head><p>Node-level performance. The performance reduction from applying gates to high-order qubits due to the 8-way set-associativity of the L1-and L2-caches in Intel® Ivy Bridge™ processors can be seen in <ref type="figure">Fig. 9</ref>. These experiments were run on an entire two-socket node on all 24 cores with one OpenMP thread per core and using AVX vectorization.</p><p>The strong scaling of these k-qubit kernels with respect to the number of cores is depicted in <ref type="figure">Fig. 10</ref>. While the 5-qubit gate kernel scales best to the full node, the performance drop when applying it to high-order qubits is much greater than it is for 4-qubit gates. In addition, the 4-qubit gate kernel scales nearly perfectly to all 12 cores of a single socket, which suggests to use 2 MPI processes per node in the multi-node setting.</p><p>Running a single-socket simulation of a 30-qubit quantum supremacy circuit yields an improvement in time-to-solution by 3x. High-order Low-order <ref type="figure">Figure 9</ref>: Performance decrease when k-qubit gate kernels are applied to high-order qubits instead of low-order ones on a two-socket Edison node. The findings again correspond to the set-associativity of the caches, which is 2 3 = 8 in this case. For k ≤ 3, there is only a negligible drop in performance, since all 2 k entries are mapped to different locations in the cache and the next 2 k -sizes matrix-vector multiplication can access the next 2 k values directly from cache, see Sec. 3.3  <ref type="figure">Figure 10</ref>: Strong scaling of the k-qubit kernels using up to 24 cores of a two-socket Edison node, which features one 12-core Intel® Ivy Bridge™ processor per socket. Up to and including k = 4, the kernels are memory bandwidth limited. This in combination with <ref type="figure">Fig. 9</ref> suggests that k = 4 is the best kernel size to use on this system (with 1 MPI process per socket).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>4.2.2</head><p>Multi-node performance. In order to compare the present work directly to the state-of-the-art simulator in <ref type="bibr" target="#b4">[5]</ref>, we performed a simulation of a 36-qubit quantum supremacy circuit using identical hardware: 64 sockets of the Edison supercomputer. We calculated the entropy of a depth-25 quantum supremacy circuit in 99 seconds, of which 90.9 seconds were spent in actual simulation and the remaining 8.1 seconds were used to calculate the entropy, which requires a final reduction. This constitutes an improvement in timeto-solution of over 4x and indicates that the obtained speedups were not merely a consequence of a new generation of hardware.</p><p>The kernels perform at an average of 47% theoretical peak, or 218 GFLOPS on every node during the execution of a 36-qubit quantum supremacy circuit. When including communication time, the entire simulation achieved 30% of the theoretical peak performance of 64 Edison sockets, which is 4.4 TFLOPS.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">SUMMARY AND OUTLOOK</head><p>We demonstrated simulations of up to 45 qubits using up to <ref type="bibr" target="#b7">8,</ref><ref type="bibr">192</ref> nodes. With the same amount of compute resources, the simulation of 46 qubits is feasible when using single-precision floating point numbers to represent the complex amplitudes. The presented optimizations are general and our code generator improves performance portability across a wide range of processors. Extending the range of the code generator to the domain of GPUs is an ongoing project.</p><p>Additional optimizations on the quantum circuit description allows to reduce the required communication by an order of magnitude. As a result, the simulation of a 49-qubit quantum supremacy circuit would require only two global-to-local swap operations. While the memory requirements to simulate such a large circuit are beyond what is possible today, the low amount of communication may allow the use of, e.g., solid-state drives. The simulation results may then be used for verification and calibration of near-term quantum devices.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>Roofline plot for one KNL node of Cori II.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2 :</head><label>2</label><figDesc>Roofline plots illustrating the performance improvements from Sec. 3.2 and 3.3.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>. 01... 10... 11... 01 00... 01... 10... 11... 10 00... 01... 10... 11... 11 00... 01... 10... 11... (b) Two-qubit swap.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 3 :</head><label>3</label><figDesc>Illustration of a single-and multi-qubit globalto-local swap using one (group-) all-to-all. The blocks labeled, e.g., 01... represent the coefficients corresponding to the global basis state which starts with the bit-string r 01, where r is the bit-representation of the rank (see text).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>Scaling of the required communication for circuit depths 10</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>Scaling of the required communication for increasing numbers of qubits for quantum supremacy circuits with a fixed circuit depth of 25.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 5 :</head><label>5</label><figDesc>Scaling of the required number of communication steps for quantum supremacy circuits as a function of circuit depth (a) or number of qubits (b). The lower two panels show the number of global gates which require communication if executed individually as in</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 7 :</head><label>7</label><figDesc>Strong scaling for applying k-qubit kernels to a 28qubit system using 2 p , p ∈ {0, ..., 6} cores of the 68-core Intel® Xeon Phi™ Processor 7250 and 4, 2, and 1 OpenMP thread(s) per core for k ≤ 3, k = 4, and k = 5, respectively.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Figure 8 :</head><label>8</label><figDesc>Strong scaling of our simulator running a 36and 42-qubit quantum supremacy circuit on {16, 32, 64} and {1024, 2048, 4096} nodes of Cori II, respectively.</figDesc><table><row><cell cols="6">#Qubits #Gates #Nodes Time [s] Comm. Speedup</cell></row><row><cell>6 × 5</cell><cell>369</cell><cell>1</cell><cell>9.58</cell><cell>0%</cell><cell>14.8x</cell></row><row><cell>6 × 6</cell><cell>447</cell><cell>64</cell><cell>28.92</cell><cell>42.9%</cell><cell>12.8x</cell></row><row><cell>7 × 6</cell><cell>528</cell><cell>4096</cell><cell>79.53</cell><cell>71.8%</cell><cell>12.4x</cell></row><row><cell>9 × 5</cell><cell>569</cell><cell>8192</cell><cell>552.61</cell><cell>78.0%</cell><cell>N /A</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 2 :</head><label>2</label><figDesc>Results for all simulations carried out on Cori II. Circuit simulation time and speedup are given with respect to the depth-25 quantum supremacy circuit simulations performed in<ref type="bibr" target="#b4">[5]</ref>. The comm.-column gives the percentage of circuit simulation time spent in communication and synchronization.</figDesc><table /><note></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENTS</head><p>We thank Jarrod McClean for his outstanding help and support throughout the course of this project. Special thanks goes to our advisor, Matthias Troyer, for giving us the opportunity to work on this project and for enlightening discussions. Moreover, we would like to thank Ryan Babbush, Sergio Boixo, Brandon Cook, Jack Deslippe, Sergei Isakov, and Hartmut Neven for helpful comments and discussions.</p><p>This research used resources of the National Energy Research Scientific Computing Center, a DOE Office of Science User Facility supported by the Office of Science of the U.S. Department of Energy under Contract No. DE-AC02-05CH11231. This work was supported by the Swiss National Science Foundation through the National Competence Center for Research NCCR QSIT.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Scott</forename><surname>Aaronson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lijie</forename><surname>Chen</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1612.05903</idno>
		<title level="m">Complexity-Theoretic Foundations of Quantum Supremacy Experiments</title>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Simulated quantum computation of molecular energies</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alán</forename><surname>Aspuru-Guzik</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Anthony</forename><forename type="middle">D</forename><surname>Dutoi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Peter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Martin</forename><surname>Love</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Head-Gordon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science</title>
		<imprint>
			<biblScope unit="volume">309</biblScope>
			<biblScope unit="page" from="1704" to="1707" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Chemical basis of Trotter-Suzuki errors in quantum chemistry simulation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ryan</forename><surname>Babbush</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jarrod</forename><surname>Mcclean</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dave</forename><surname>Wecker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alán</forename><surname>Aspuru-Guzik</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nathan</forename><surname>Wiebe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Physical Review A</title>
		<imprint>
			<biblScope unit="volume">91</biblScope>
			<biblScope unit="page">22311</biblScope>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bela</forename><surname>Bauer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dave</forename><surname>Wecker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Andrew</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Millis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Matthew</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Matthias</forename><surname>Hastings</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Troyer</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1510.03859</idno>
		<title level="m">Hybrid quantum-classical approach to correlated materials</title>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sergio</forename><surname>Boixo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Sergei</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Isakov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Vadim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ryan</forename><surname>Smelyanskiy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nan</forename><surname>Babbush</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhang</forename><surname>Ding</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>John</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hartmut</forename><surname>Martinis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Neven</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1608.00263</idno>
		<title level="m">Characterizing quantum supremacy in near-term devices</title>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Massively parallel quantum computer simulator</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kristel</forename><surname>Koen De Raedt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Michielsen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Binh</forename><surname>Hans De Raedt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Guido</forename><surname>Trieu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marcus</forename><surname>Arnold</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Th</forename><surname>Richter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Lippert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Watanabe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Ito</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Physics Communications</title>
		<imprint>
			<biblScope unit="volume">176</biblScope>
			<biblScope unit="page" from="121" to="136" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">High performance emulation of quantum circuits</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Häner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Damian</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mikhail</forename><surname>Steiger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Matthias</forename><surname>Smelyanskiy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Troyer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2016" />
			<pubPlace>Supercomputing</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Quantum algorithm for linear systems of equations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Aram</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Avinatan</forename><surname>Harrow</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Seth</forename><surname>Hassidim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Lloyd</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Physical review letters</title>
		<imprint>
			<biblScope unit="volume">103</biblScope>
			<biblScope unit="page">150502</biblScope>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Wiliam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Steve</forename><surname>Dally</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dennis</forename><surname>Scott</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Abts</surname></persName>
		</author>
		<idno type="DOI">10.1145/1394608.1382129</idno>
		<ptr target="https://doi.org/10.1145/1394608.1382129" />
	</analytic>
	<monogr>
		<title level="j">Technology-Driven, Highly-Scalable Dragonfly Topology. SIGARCH Comput. Archit. News</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="77" to="88" />
			<date type="published" when="2008-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Quantum algorithms for supervised and unsupervised machine learning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Seth</forename><surname>Lloyd</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Masoud</forename><surname>Mohseni</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Patrick</forename><surname>Rebentrost</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1307.0411</idno>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Commercialize quantum technologies in five years</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Masoud</forename><surname>Mohseni</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Read</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hartmut</forename><surname>Neven</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sergio</forename><surname>Boixo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vasil</forename><surname>Denchev</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ryan</forename><surname>Babbush</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Austin</forename><surname>Fowler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vadim</forename><surname>Smelyanskiy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><surname>Martinis</surname></persName>
		</author>
		<idno type="DOI">10.1038/543171a</idno>
		<ptr target="https://doi.org/10.1038/543171a" />
	</analytic>
	<monogr>
		<title level="j">Nature</title>
		<imprint>
			<biblScope unit="volume">543</biblScope>
			<biblScope unit="page" from="171" to="174" />
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Quantum support vector machine for big data classification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Patrick</forename><surname>Rebentrost</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Masoud</forename><surname>Mohseni</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Seth</forename><surname>Lloyd</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Physical review letters</title>
		<imprint>
			<biblScope unit="volume">113</biblScope>
			<biblScope unit="page">130503</biblScope>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Elucidating reaction mechanisms on quantum computers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Markus</forename><surname>Reiher</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nathan</forename><surname>Wiebe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Krysta</forename><forename type="middle">M</forename><surname>Svore</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dave</forename><surname>Wecker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Matthias</forename><surname>Troyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the National Academy of Sciences</title>
		<meeting>the National Academy of Sciences</meeting>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">The structural simulation toolkit</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Arun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Scott</forename><surname>Rodrigues</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brian</forename><forename type="middle">W</forename><surname>Hemmert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Barrett</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGMETRICS Performance Evaluation Review</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="page" from="37" to="42" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Algorithms for quantum computation: Discrete logarithms and factoring</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Peter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Shor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Foundations of Computer Science, 1994 Proceedings., 35th Annual Symposium on</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1994" />
			<biblScope unit="page" from="124" to="134" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mikhail</forename><surname>Smelyanskiy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">D</forename><surname>Nicolas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alán</forename><surname>Sawaya</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Aspuru-Guzik</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1601.07195</idno>
		<title level="m">The Quantum High Performance Software Testing Environment</title>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Damian</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Steiger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Matthias</forename><surname>Häner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Troyer</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1612.08091</idno>
		<title level="m">ProjectQ: An Open Source Software Framework for Quantum Computing</title>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Large-scale simulations of error prone quantum computation devices</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Trieu</forename><surname>Doan Binh</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009" />
			<publisher>Forschungszentrum Jülich</publisher>
			<biblScope unit="volume">2</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">LIQU i |⟩: A software design architecture and domain-specific language for quantum computing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dave</forename><surname>Wecker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Krysta</forename><forename type="middle">M</forename><surname>Svore</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1402.4467</idno>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Quantum algorithm for data fitting</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nathan</forename><surname>Wiebe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Braun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Seth</forename><surname>Lloyd</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Physical review letters</title>
		<imprint>
			<biblScope unit="volume">109</biblScope>
			<biblScope unit="page">50505</biblScope>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
