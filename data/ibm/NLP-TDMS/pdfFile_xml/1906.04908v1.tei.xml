<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /nfs/home/kabenamualus/Research/task-dataset-metric-extraction/../grobid-0.6.0/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">SPoC: Search-based Pseudocode to Code</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sumith</forename><surname>Kulal</surname></persName>
							<email>sumith@cs.stanford.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Stanford University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Panupong</forename><surname>Pasupat</surname></persName>
							<email>ppasupat@cs.stanford.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Stanford University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kartik</forename><surname>Chandra</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Stanford University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mina</forename><surname>Lee</surname></persName>
							<email>minalee@cs.stanford.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Stanford University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Oded</forename><surname>Padon</surname></persName>
							<email>padon@cs.stanford.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Stanford University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alex</forename><surname>Aiken</surname></persName>
							<email>aaiken@cs.stanford.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Stanford University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Percy</forename><surname>Liang</surname></persName>
							<email>pliang@cs.stanford.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Stanford University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">SPoC: Search-based Pseudocode to Code</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>

		<encodingDesc>
			<appInfo>
				<application version="0.6.0" ident="GROBID-SDO" when="2021-06-25T21:59+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid-sdo"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We consider the task of mapping pseudocode to long programs that are functionally correct. Given test cases as a mechanism to validate programs, we search over the space of possible translations of the pseudocode to find a program that passes the validation. However, without proper credit assignment to localize the sources of program failures, it is difficult to guide search toward more promising programs. We propose to perform credit assignment based on signals from compilation errors, which constitute 88.7% of program failures. Concretely, we treat the translation of each pseudocode line as a discrete portion of the program, and whenever a synthesized program fails to compile, an error localization method tries to identify the portion of the program responsible for the failure. We then focus search over alternative translations of the pseudocode for those portions. For evaluation, we collected the SPoC dataset (Search-based Pseudocode to Code) containing 18,356 programs with human-authored pseudocode and test cases. Under a budget of 100 program compilations, performing search improves the synthesis success rate over using the top-one translation of the pseudocode from 25.6% to 44.7%. * Equal contributions.</p><p>Preprint. Under review.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>We consider the task of mapping natural language descriptions to functionally correct computer programs that are long enough to have significant intermediate state (e.g., 10-20 lines) and perform non-trivial computations. Previous work on executable semantic parsing mainly focuses on translating short text descriptions to a one-line program <ref type="bibr" target="#b41">[42,</ref><ref type="bibr" target="#b34">35,</ref><ref type="bibr" target="#b42">43,</ref><ref type="bibr" target="#b43">44,</ref><ref type="bibr" target="#b20">21,</ref><ref type="bibr" target="#b7">8]</ref>, and while recent work explored generating longer programs from text descriptions <ref type="bibr" target="#b21">[22,</ref><ref type="bibr" target="#b39">40,</ref><ref type="bibr" target="#b28">29,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b13">14]</ref>, these programs are mostly evaluated on syntactic metrics (e.g., exact match and BLEU score) rather than functional correctness. In contrast, program synthesis in the programming languages community emphasizes producing programs with the correct semantics, typically captured by a set of input-output test cases that the program must compute correctly <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b9">10]</ref>. However, input-output pairs usually give little information about the intermediate states of the program, making it difficult to synthesize long programs.</p><p>Synthesizing a general class of programs of significant length and internal complexity is extremely challenging without some description of the steps of computation. To that end, we propose a framework for synthesizing programs from natural language pseudocode and test cases. The test cases provide the semantic specification, while the pseudocode provides guidance for the intermediate computations the program should perform.</p><p>To synthesize a functionally correct program, instead of relying on the top-one translation of the pseudocode, we search over the space of possible translations to find one that passes the test cases. In this work, we treat the translation of each pseudocode line as a discrete portion of the program. As illustrated in <ref type="figure">Figure 1</ref>, each pseudocode line translates to a code line with approximately one or two  <ref type="figure">Figure 1</ref>: Given L pseudocode lines x 1:L (with indentation levels 1:L ) and public test cases, our task is to synthesize a program with code lines y 1:L . The program is evaluated against both public and hidden test cases.</p><p>atomic statements, and a program can be synthesized by choosing a candidate translation for each pseudocode line.</p><p>However, common search methods for machine translation, such as beam search over the possible sequences of code tokens <ref type="bibr" target="#b40">[41]</ref>, only use the sparse reward of whether the program succeeds. Without a proper credit assignment to pinpoint the causes of program failures, it is difficult to guide search toward more promising programs. Since empirically 88.7% of failures during search are due to compilation errors, we propose to perform credit assignment based on signals extracted from compilation results. At a high level, when a program fails to compile, we use an error localization method to identify which portion of the program is responsible for the failure, and then focus the search on alternative translations of the pseudocode for that portion.</p><p>We propose two error localization methods. The first method uses a multiclass classifier to pick one of the code lines as the offending line, which is then down-weighted in subsequent search iterations. In contrast to previous error correction models <ref type="bibr" target="#b11">[12]</ref>, our model also uses the error message and pseudocode for prediction. This is crucial when the compilation error can be fixed in multiple ways, but only some of which are consistent with the pseudocode. The second method, prefix-based pruning, uses additional compilations to find a code prefix that causes the error. Unlike the classification model, the identified code prefix is guaranteed to be erroneous and can be blacklisted entirely.</p><p>For evaluation, we collected and release a new dataset, SPoC (Search-based Pseudocode to Code) 2 , containing 18,356 C++ programs (14.7 lines on average). In contrast to other language-to-code datasets <ref type="bibr" target="#b21">[22,</ref><ref type="bibr" target="#b26">27,</ref><ref type="bibr" target="#b15">16]</ref>, all programs contain multiple test cases for validation. And in contrast to the closely related NAPS dataset <ref type="bibr" target="#b40">[41]</ref>, which also contains test cases but only 6% human-authored pseudocode, all programs in SPoC are associated with human-authored pseudocode of a consistent annotation granularity. Section 3 details the comparison between SPoC and related datasets.</p><p>Using the top-one translation of the pseudocode yields a success rate of 24.6% on the test set. Under a limited budget of 100 synthesis trials (i.e., 100 code compilations and executions), our best method achieves a success rate of 44.7%. The multiclass error localization model reduces the number of synthesis trials needed in 15.5% of the programs, with a median absolute reduction of 26 trails and a median relative reduction of 42%. On the other hand, prefix-based pruning slightly increases the number of compilations for easier problems, but is more effective on harder programs, making it outperform the multiclass classifier under larger budgets. <ref type="figure">Figure 1</ref> illustrates the setup of our synthesis task. The system is given (a) a sequence x of L pseudocode lines x 1 , x 2 , . . . , x L , where each x i is a string with indentation level i ; and (b) k public test cases in the form of input-output string pairs (T in 1 , T out 1 ), . . . , (T in k , T out k ). The task is to synthesize a program y consisting of L code lines y 1 , y 2 , . . . , y L . The program is accepted if it successfully compiles and passes all public test cases (i.e., the compiled binary prints the string T out i after reading the input T in i ) as well as k additional hidden test cases (T in 1 ,T out 1 ), . . . , (T in k ,T out k ). At training time, the system has access to a training dataset where each example contains pseudocode x, a gold program y, and both public and hidden test cases.</p><p>At test time, the system has access to pseudocode x, public test cases (not hidden ones), and a computation budget. For a fair comparison under different computing environments, we use the number of synthesis trials as the budget, where in each trial, the system can issue a single call to the compiler and execute the compiled program on public test cases. The system must output a single final program, which will be validated on both public and hidden test cases.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Dataset</head><p>Recall that our goal is to synthesize programs of significant length and complexity. To this end, we argue that it is important to have both description of the intermediate computation and a functional specification. <ref type="table" target="#tab_1">Table 1</ref> shows that most existing datasets <ref type="bibr" target="#b21">[22,</ref><ref type="bibr" target="#b26">27,</ref><ref type="bibr" target="#b15">16]</ref> have some varying levels of description, but lack mechanisms to validate the correctness of programs. This inevitably leads previous work to resort to proxy metrics, such as exact match accuracy, BLEU score, and tree node F1 score, which only measure syntactic similarity rather than functional correctness <ref type="bibr" target="#b21">[22,</ref><ref type="bibr" target="#b39">40,</ref><ref type="bibr" target="#b28">29,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b13">14]</ref>.</p><p>One notable exception and the inspiration for our work is the NAPS dataset <ref type="bibr" target="#b40">[41]</ref> which contains both description (pseudocode) and a functional specification (test cases) of competitive programming problems. However, most of their pseudocode is generated by heuristic rule-based templates, which in turn has a low information content compared to the human-authored pseudocode. Furthermore, the dataset suffers from the inconsistent granularity of text description, as the artificial pseudocode is fine-grained (e.g., "increase var0 by 1") whereas the human-written pseudocode tends to be abstract (e.g., "compute factorial") as the annotators were encouraged to provide high-level descriptions. This discrepancy is reflected on the ratio of the length of pseudocode to that of code, which is 1:1.82 in their synthetic dataset, and 1:3.26 in their human-authored dataset.</p><p>As no existing dataset contains both high-quality human-authored description with a consistent level of granularity and a mechanism to validate functional correctness, we created a new dataset called SPoC (Search-based Pseudocode to Code), which consists of programs, pseudocode, and test cases. The programs are non-trivial solutions to competitive programming problems, and each program is paired with public and hidden test cases. We collected natural language pseudocode for each code line from curated crowdworkers, which by design, ensures the consistent granularity of description.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Data collection</head><p>Programs and test cases. Similar to the NAPS dataset <ref type="bibr" target="#b40">[41]</ref>, we scraped competitive programming problems and their test cases from codeforces.com. Each problem has multiple programs submitted by participants as solutions to the problem. We collected accepted C++ programs from problems marked as the easiest level based on their metric. Based on our pilot study, we filtered out programs with constructs that are difficult to consistently annotate with pseudocode (i.e., programs with #define macros, classes, structs, templates, switch statements, and mallocs).</p><p>Decomposition. We decompose each program into code lines. To obtain slightly higher-level descriptions for common constructs, we group any block with only one statement with the preceding control statement (e.g., the one-line for loop "for (int i = 0; i &lt; n; i++) cin &gt;&gt; x[i];" allows a high-level description "read n values into x").</p><p>Pseudocode. We recruited 59 crowdworkers on Amazon Mechanical Turk to write pseudocode for each line of code. To our surprise, we were able to identify the workers (rather than curated specialists) who are capable of annotating C++ code by using a qualification round, in which we manually inspected their initial annotations.</p><p>Statistics. Our dataset contains 18,356 programs submitted for 677 programming problems. Each problem has roughly 27 programs, which are likely to have similar semantics yet different code syntax. Excluding closing braces and the common "int main()" line, each program contains an average of 14.7 lines (with the minimum of 1 and maximum of 457 lines of code). The average length of code lines is 9.08 tokens, while the average length of pseudocode lines is 7.86 tokens.</p><p>Training and test sets. To evaluate the generalization on unseen problems and annotation styles, we created two test sets. We generated the first test set TESTP by splitting based on problems: we held out 158 problems (23% out of 677 problems), which is equivalent to 1,820 programs (10.1% of all programs). The second test set TESTW is split by workers: we held out 7 workers (12% out of 59 workers), which is equivalent to 1,752 programs (9.7% of all programs, with 186 programs overlapping with TESTP). We used the remaining data for training and development (90:10 split).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Base approach</head><p>As illustrated in <ref type="figure" target="#fig_1">Figure 2</ref>, our base approach to synthesizing a program y 1:L from pseudocode x 1:L and public test cases involves two steps. First, a translation model encodes each pseudocode line x i and generates M candidate code lines c i1 , . . . , c iM to be used as the ith code line. Then, we search over the possible combinations of candidate translations until we find a programŷ 1:L that successfully compiles and passes all public test cases.</p><p>Translation. To generate candidate code lines, we use a standard seq2seq translation model with an LSTM encoder and decoder <ref type="bibr" target="#b18">[19]</ref>, attention-based copying mechanism <ref type="bibr" target="#b23">[24,</ref><ref type="bibr" target="#b36">37]</ref>, and coverage vector <ref type="bibr" target="#b33">[34]</ref>. After encoding the pseudocode line x i , we apply beam search with beam size M to produce a ranked list of candidates translations C i = (c i1 , . . . , c iM ), where each code line c ij is a sequence of string tokens. (We use M = 100 for our experiments.) The model also assigns a probability p ij = p(c ij | x i ) for each candidate c ij . The translation model is trained on pairs (x i , y i ) from the training data using the standard log-likelihood objective.</p><p>Best-first search. We now describe a basic approach for searching over the space of possible programs. Given the candidate lists C 1 , . . . , C L , we can synthesize a programŷ by picking a candidate c ij[i] from each C i (where j[i] ∈ {1, . . . , M }) and then concatenate them into a program.  In our search algorithm, we iterate through programsŷ in the descending order of probability p(ŷ) = p ij[i] . To do so, we maintain a heap of the combinationsŷ = (c 1j <ref type="bibr" target="#b0">[1]</ref> , . . . , c Lj[L] ) indexed by p(ŷ). The heap initially contains the program (c 11 , . . . , c L1 ), which is the top-one translation of the pseudocode. In each iteration, we pop a program (c 1j <ref type="bibr" target="#b0">[1]</ref> , . . . , c Lj[L] ) from the heap and test it. If the program fails (either from a compilation error, a runtime error, or a mismatch between the actual and expected test outputs), we push modified programs (c 1j <ref type="bibr" target="#b0">[1]</ref> , . . . , c i(j[i]+1) , . . . , c Lj[L] ) for all i ∈ {1, . . . , L} that have not been explored to the heap. We continue searching until we either find a program that passes all public test cases or fully utilize the computation budget.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Error localization</head><p>So far, we have been treating program compilation and execution as a black box that only tells whether a program passes its test cases. This sparse signal makes the search process less effective. For instance, best-first search will keep using an erroneous candidate c ij if its probability p ij is high.</p><p>To speed up search, we unpack the black box and extract more detailed search signals. In this work, we focus on compilation errors, which constitute 88.7% of the failure cases in best-first search. When a programŷ = (c 1j <ref type="bibr" target="#b0">[1]</ref> , . . . , c Lj[L] ) fails to compile, the compiler will report error messages along with the line numbers where the errors occur. Unfortunately, the reported line numbers do not always correspond to the actual location of the mistake (e.g., the error "'n' was not declared in this scope" can occur long after the line where n should be declared according to the pseudocode). Empirically, the reported line number does not match the actual incorrect line 21.7% of the time.</p><p>Therefore, we treat the compilation error message as a noisy signal, and propose to use an error localization method to infer the actual portion of the code that causes the error. As illustrated in <ref type="figure" target="#fig_1">Figure 2</ref>, the error localization method has access to the pseudocode x, the synthesized codeŷ, and the first error message (i err , m err ) from the compiler, where i err is a line number and m err is a message string. It can then either detect the offending code lines or abstain. Depending on the method, we either down-weight or blacklist the translation candidates in the offending code lines.</p><p>We now introduce two error localization methods: multiclass classification, which uses a neural model to predict a single offending line; and prefix-based pruning, which uses additional calls to the compiler for detecting an erroneous code prefix.</p><p>Multiclass classification. We train a neural multiclass classifier to predict the offending line i * among the L lines. Our model is similar to the error correction model in <ref type="bibr" target="#b11">[12]</ref>. For each line i, we embed the tokens of x i , y i , and m err , and then use three separate LSTMs to encode the sequences. We concatenate the final LSTM hidden states with the positional encoding <ref type="bibr" target="#b35">[36]</ref> of the line offset  <ref type="figure">Figure 3</ref>: (a) While the translation accuracy is high at the line level, we need to consider the result at the program level. For each program, we count the number of lines i where (b) the top candidate c i1 is incorrect, and (c) none of the candidates c ij ∈ C i is correct. ∆i = i err − i, and then apply a feedforward network to produce the line embedding of line i. The L line embeddings are then passed through another LSTM, and the hidden state of each cell i is passed through a feedforward network to compute the logit for line i. We return the line i * with the highest probability (softmax over logits) if that probability exceeds a threshold β mul and abstain otherwise. We use β mul = 0.95 for the experiments.</p><p>Given i * , we down-weight the current translation candidate of the line i * so that it is used less often in subsequent search iterations. Concretely, we multiply the probability p i * j[i * ] of the current candidate c i * j[i * ] in line i * with a constant factor α &lt; 1. As this affects the heap indices, we rebuild the heap from scratch (which takes negligible time) and continue the search, skipping any program that has already been explored before the heap rebuild.</p><p>To construct a dataset for training the model, we consider each program y = y 1:L in the synthesis training dataset, substitute a single line y i * with a candidate c i * j ∈ C i * generated from pseudocode line x i * , and then collect any modified program y that produces a compilation error with an error message (i err , m err ). The model is trained to maximize the log-likelihood of the offending lines i * .</p><p>Prefix-based pruning. The multiclass classification method does not guarantee that the predicted line i * is actually an offending line. Furthermore, a candidate code line might be offending in some contexts but not others (e.g., a variable re-declaration is no longer offending if the previous declaration no longer exists). To address these issues, we propose an alternative that uses additional compiler calls to find an offending prefix of the program. Concretely, when a compilation error occurs, we use the compiler to to find the minimum i * such that the prefix (c 1j <ref type="bibr" target="#b0">[1]</ref> , . . . , c i * j[i * ] ), plus closing braces to complete the program, fails to compile. Since programs containing that prefix will also always fail (with very rare exceptions), we can safely blacklist the prefix from future search iterations.</p><p>Each additional compiler call is counted as one trial toward the synthesis budget. To save the budget, we only test i * = i err − ∆i where ∆i ∈ {0, 1, 2} corresponds to the three most frequent offsets. If we fail to find an offending prefix, we simply abstain.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Experiments</head><p>Our main evaluation metric is success rate at B: the fraction of test examples where the system generates an accepted program under the budget of B trials. For error localization methods, we also consider the reduction in the number of trials used compared to normal best-first search.</p><p>Translation accuracy. When evaluating the translation model, surface-form metrics such as exact sequence match and BLEU scores fail to account for functional correctness of the code. For instance, a prediction "if (b)" is functionally equivalent to the gold code "if (b == true)" when b is a boolean. Hence, we instead evaluate the functional correctness of the translation. To check if a predicted code line c ij ∈ C i is functionally correct, we replace the code line y i in the gold program with c ij and then verify whether the program still passes both public and hidden test cases.</p><p>The results in <ref type="figure">Figure 3(a)</ref> shows that when the lines are considered independently, the translation model achieves a high accuracy of 84-87% under this notion of functional correctness. However, the picture is grimmer when we consider the statistics at the program level, which is what matters for synthesis. For each program, we count the number of lines i where the top candidate c i1 is    <ref type="figure">Figure 3</ref>(b) shows that only 18.2% of programs in TESTP and 32.0% of programs in TESTW have the top candidate correct in every line. As code lines that are functionally correct in isolation may be incompatible one another, the programs formed by combining the top candidate of each line have an even lower success rates of 17.8% on TESTP and 30.7% on TESTW.</p><p>Oracle success rate. To compute the maximum achievable success rate given the lists of candidates, for each program, we count the number of lines i where the candidate list C i does not have any correct candidate. <ref type="figure">Figure 3</ref>(c) shows that 44.8% of programs in TESTP and 28.6% of programs in TESTW have least one difficult line where the translation model does not produce a correct prediction among the top M = 100 candidates. This means a synthesizer with an infinite search budget would achieve a maximum success rate of 55.2% on TESTP and 71.4% on TESTW given our lists of candidates (assuming that incorrect candidates do not give a correct behavior when combined together).</p><p>Synthesis results. <ref type="figure">Figure 4</ref> compares the success rates of best-first search with and without error localization. As a baseline, we try down-weighting the reported error line (i * = i err ) whenever a compilation error occurs. Due to the mismatch between the actual offending line and the reported line, the synthesis result deteriorates. Up to the compilation budget of around B = 1500, the multiclass classifier improves the success rate the most. Prefix-based pruning achieves better success rates for higher budgets, but since it uses additional compilation calls, it performs worse under tighter budgets.  <ref type="bibr" target="#b0">(1)</ref> . . . <ref type="bibr" target="#b1">(2)</ref> . . . let s be a string create int l, p and q 7 string s ; 2 int a , p , q ; read s read l, p and q 8 cin &gt;&gt; s ;</p><p>3 cin &gt;&gt; l &gt;&gt; p &gt;&gt; q ; if s is half print l * p / (p + q) 9 if ( s / 2 == 0 ) 4 cout &lt;&lt; l * p / ( p + q ) &lt;&lt; endl ; . . . . . . <ref type="figure">Figure 5</ref>: Examples of programs synthesized during search. In Program 1, prefix-based pruning detects that the prefix up to line 9 is offending. In Program 2, the multiclass model incorrectly predicts line 3 as the offending line, which ultimately leads to a failure.</p><p>calls to verify its verdict, and thus slightly worsens the number of compilations needed in a large number of examples. However, for more difficult programs, the benefit outweighs the cost.</p><p>Error analysis. To understand the behavior of error localization methods, we analyzed several examples from the development data. Some prototypical examples are shown in <ref type="figure">Figure 5</ref>. Program 1 shows how error localization can improve search. The condition "s is half" in line 9 should be translated as "s == "half"", but was instead interpreted as "s / 2 == 0" and "s % 2 == 0" with high probability, and hence best-first search spends a significant amount of budget (1511 trails) using these incorrect candidates in the combination. In contrast, prefix-based pruning detects them as offending candidates and succeeds earlier (413 trials).</p><p>In contrast, Program 2 shows how an incorrect error localization can lead to a catastrophic failure.</p><p>Here, the multiclass model reads the error message m err = "'l' was not declared in this scope" with line number i err = 3, and incorrectly predicts that line 3 is an offending line. This causes the search to ultimately fail whereas best-first search finds a correct program in 80 search iterations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Related work and discussion</head><p>Program synthesis. Program synthesis using test cases has been extensively studied in the programming languages literature. The most focused and effective method is to formulate synthesis as a constraint satisfaction problem <ref type="bibr" target="#b31">[32,</ref><ref type="bibr" target="#b32">33]</ref>, which requires that the synthesis problem can be translated to a theory with effective constraint solvers. For other problems, brute force enumeration of programs (with some optimization) works surprisingly well <ref type="bibr" target="#b25">[26,</ref><ref type="bibr" target="#b2">3]</ref>, but when the search space is too large for enumeration, randomized search guided by a cost function can be effective <ref type="bibr" target="#b29">[30]</ref>. Some works combine aspects of multiple approaches (e.g., <ref type="bibr" target="#b17">[18]</ref>). For program specifications, the norm is to use input-output pairs. However, most synthesized programs are relatively short, and works that consistently synthesize longer programs are in the domains where the intermediate computation is easier to recover from input and output, such as string <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b27">28,</ref><ref type="bibr" target="#b5">6]</ref> and data structure transformations <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b37">38]</ref>. For other domains, while input-output examples are precise in evaluating functional correctness, they provide mostly global signals and inform very little about the intermediate computation, thereby requiring other forms of specification along with input-output examples (e.g., <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b30">31]</ref>).</p><p>Semantic parsing. Works on translating natural language specifications to executable programs, as discussed in Section 3, are closely related to semantic parsing whose goal is to map natural language utterances to formal representation. One of its traditional tasks is to parse a given question (usually a single sentence) into an executable database query <ref type="bibr" target="#b41">[42,</ref><ref type="bibr" target="#b42">43,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b43">44,</ref><ref type="bibr" target="#b38">39]</ref>. Instead of a single query, some work aims to parse a sequence of utterances into queries that can be sequentially executed <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b22">23]</ref>. However, the sequences are still relatively short (e.g., maximum 5 sentences).</p><p>Error localization. Error localization in the context of automated program repair has been an active topic of research. Many recent work that uses neural models to localize errors has focused on localizing and correcting syntax errors <ref type="bibr" target="#b11">[12]</ref> or a class of well-defined semantic errors such as variable misuse and variable replace <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b24">25]</ref>. Other work identifies error locations by interpreting compiler error messages <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b4">5]</ref>. Likewise, our multiclass error localization model uses compilation errors to locate offending code; however, since the code is tied to pseudocode, we also use the signal from pseudocode to distinguish ambiguous cases (e.g., in Program 2 of <ref type="figure">Figure 5</ref>, while changing either line 2 or line 3 can fix the error, a correct model should choose line 2 as the offending line with respect to the pseudocode.)</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>x 1 x 2 x 3 translate c 11 (</head><label>2311</label><figDesc>p 11 = 0.7) c 12 (p 12 = 0.2) c 13 (p 13 = 0.15) c 21 (p 21 = 0.4) c 22 (p 22 = 0.3) c 23 (p 23 = 0.05) c 31 (p 31 = 0.3) c 32 (p 32 = 0.2) c 33 (p 33 = 0.05) : 'n' was not declared best-first search with error localization</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Illustration of best-first search and error localization model. In this example, (c 11 , c 22 , c 32 ) satisfies the test cases. Best-first search iterates in the order of decreasing probabilities and succeeds in four compiler calls. The error localization method down-weights c 21 , leading to an earlier success.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>(a) Line-level accuracy (%) (b) Number of lines where (c) Number of lines where at ranks 1, 5, 10, and 100 the top candidate is incorrect no candidate is correct Rank</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>4 Figure 4 :</head><label>44</label><figDesc>top-one (B = 1): 17.8 oracle (B = ∞): 55.2 top-one (B = 1): 30.7 oracle (B = ∞): 71.Success rates at budgets B of best-first search with different error localization methods.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 :</head><label>1</label><figDesc>Datasets for natural language to code. In contrast to other datasets, our SPoC dataset contains human-authored pseudocode with a consistent granularity of description and test cases.</figDesc><table><row><cell></cell><cell>MTG</cell><cell>HS</cell><cell>DJANGO</cell><cell>CONCODE 1</cell><cell>NAPS 2</cell><cell>SPoC</cell></row><row><cell></cell><cell>[22]</cell><cell>[22]</cell><cell>[27, 22]</cell><cell>[16]</cell><cell>[41]</cell><cell></cell></row><row><cell>Programming language</cell><cell>Java</cell><cell>Python</cell><cell>Python</cell><cell>Java</cell><cell>UAST</cell><cell>C++</cell></row><row><cell>Number of programs (total)</cell><cell>13,297</cell><cell>665</cell><cell>18,805</cell><cell>2,184,310</cell><cell>17,477</cell><cell>18,356</cell></row><row><cell>Lines per program (average)</cell><cell>30.4</cell><cell>7.7</cell><cell>1</cell><cell>4.4</cell><cell>21.7</cell><cell>14.7</cell></row><row><cell>Type of natural language input</cell><cell cols="2">-card text -</cell><cell cols="4">comment documentation -pseudocode -</cell></row><row><cell>Additional input</cell><cell cols="2">-card metadata -</cell><cell>-</cell><cell>class context</cell><cell>-</cell><cell>-</cell></row><row><cell>Granularity of text description</cell><cell cols="2">program program</cell><cell>line</cell><cell>program</cell><cell>varies</cell><cell>line</cell></row><row><cell></cell><cell>(class)</cell><cell>(class)</cell><cell></cell><cell>(method)</cell><cell></cell><cell></cell></row><row><cell>Fraction of human-annotated text</cell><cell>100%</cell><cell>100%</cell><cell>100%</cell><cell>100%</cell><cell>6%</cell><cell>100%</cell></row><row><cell>Number of annotators (total)</cell><cell>n/a</cell><cell>n/a</cell><cell>1</cell><cell>n/a</cell><cell>n/a</cell><cell>59</cell></row><row><cell>Test cases</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>Number of test cases (average)</cell><cell>-</cell><cell>-</cell><cell>-</cell><cell>-</cell><cell>7.5</cell><cell>38.6</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 2 :</head><label>2</label><figDesc>Effects of using error localization methods on all test examples.</figDesc><table><row><cell></cell><cell cols="4">number of trials: absolute difference</cell><cell cols="2">relative difference</cell></row><row><cell>method</cell><cell>effect compared to best-first</cell><cell>count</cell><cell>mean</cell><cell cols="3">median geo.mean median</cell></row><row><cell>multiclass</cell><cell>improves number of trials</cell><cell cols="2">13.5 % -199.5</cell><cell>-26.0</cell><cell>×0.39</cell><cell>×0.58</cell></row><row><cell></cell><cell>failed to synthesize → succeeds</cell><cell>2.0 %</cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>worsens number of trials</cell><cell cols="2">0.4 % +407.5</cell><cell>+123.0</cell><cell>×6.70</cell><cell>×7.04</cell></row><row><cell></cell><cell>succeeded → fails to synthesize</cell><cell>1.6 %</cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="2">prefix-based improves number of trials</cell><cell cols="2">4.1 % -272.6</cell><cell>-91.0</cell><cell>×0.45</cell><cell>×0.57</cell></row><row><cell></cell><cell>failed to synthesize → succeeds</cell><cell>1.5 %</cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>worsens number of trials</cell><cell>15.7 %</cell><cell>+68.4</cell><cell>+12.0</cell><cell>×1.65</cell><cell>×1.63</cell></row><row><cell></cell><cell>succeeded → fails to synthesize</cell><cell>0.3 %</cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="2">not functionally correct.</cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 2 details</head><label>2</label><figDesc></figDesc><table /><note>how the error localization methods affect the synthesis outcome. The multiclass model decreases the number of trials in 15.5% of all examples, but since its predictions are not verified, the model is also more prone to catastrophic failures. Prefix-based pruning uses additional compilation</note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2">The dataset can be downloaded at https://cs.stanford.edu/~sumith/spoc/.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1">We counted the number of programs in the released dataset. Since the programs are provided as a sequence of tokens, the number of lines per program is approximated based on the number of ;, {, and }.<ref type="bibr" target="#b1">2</ref> We excluded partial programs (smaller pieces of full programs) in the dataset when counting.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>We thank Shivam Garg, Jason Koenig, Nadia Polikarpova, Alex Polozov and Rishabh Singh for valuable feedback at different stages of the project. This work was supported by NSF grant CCF-1409813, NSF CAREER Award IIS-1552635 and a grant from Amazon.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Learning to represent programs with graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Allamanis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Brockschmidt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Khademi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Learning Representations (ICLR)</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Alignment-based compositional semantics for instruction following</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Andreas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Klein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Empirical Methods in Natural Language Processing (EMNLP)</title>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Automatic generation of peephole superoptimizers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Bansal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Aiken</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Architectural Support for Programming Languages and Operating Systems (ASPLOS)</title>
		<imprint>
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Semantic parsing on Freebase from question-answer pairs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Berant</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Chou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Frostig</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Liang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Empirical Methods in Natural Language Processing (EMNLP)</title>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Neuro-symbolic program corrector for introductory programming assignments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Bhatia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Kohli</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Singh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Software Engineering (ICSE)</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Robustfill: Neural program learning under noisy i/o</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Devlin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Uesato</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Bhupatiraju</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Singh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Mohamed</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Kohli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Machine Learning (ICML)</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Semantic code repair using neuro-symbolic transformation networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Devlin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Uesato</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Singh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Kohli</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1710.11054</idno>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Coarse-to-fine decoding for neural semantic parsing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Dong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Lapata</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Association for Computational Linguistics (ACL)</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Component-based synthesis for complex apis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Feng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Martins</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Dillig</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">W</forename><surname>Reps</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Principles of Programming Languages</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Synthesizing data structure transformations from input-output examples</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">K</forename><surname>Feser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Chaudhuri</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Dillig</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Programming Language Design and Implementation (PLDI)</title>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Automating string processing in spreadsheets using input-output examples</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Gulwani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGPLAN Notices</title>
		<imprint>
			<biblScope unit="volume">46</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="317" to="330" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Deepfix: Fixing common C language errors by deep learning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Pal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Kanade</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">K</forename><surname>Shevade</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Association for the Advancement of Artificial Intelligence (AAAI)</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">What would other programmers do: suggesting solutions to error messages</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Hartmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Macdougall</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Brandt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">R</forename><surname>Klemmer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Conference on Human Factors in Computing Systems (CHI)</title>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">A retrieve-and-edit framework for predicting structured outputs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Hashimoto</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Guu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Oren</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Liang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems (NeurIPS)</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Retrieval-based neural code generation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">A</forename><surname>Hayati</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Olivier</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Avvaru</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Yin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Tomasic</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Neubig</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Empirical Methods in Natural Language Processing</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Mapping language to code in programmatic context</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Iyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Konstas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Cheung</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">S</forename><surname>Zettlemoyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Empirical Methods in Natural Language Processing</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Answering complicated question intents expressed in decomposed question sequences</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Iyyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Yih</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Chang</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2016" />
			<biblScope unit="page">0</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Oracle-guided component-based program synthesis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Jha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Gulwani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">A</forename><surname>Seshia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Tiwari</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Software Engineering (ICSE)</title>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Opennmt: Open-source toolkit for neural machine translation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Klein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Deng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Senellart</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">M</forename><surname>Rush</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1701.02810</idno>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Learning dependency-based compositional semantics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Liang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">I</forename><surname>Jordan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Klein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Association for Computational Linguistics (ACL)</title>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="page" from="590" to="599" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Nl2bash: A corpus and semantic parser for natural language interface to the linux operating system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><forename type="middle">V</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">S</forename><surname>Zettlemoyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">D</forename><surname>Ernst</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Language Resources and Evaluation Conference (LREC)</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Latent predictor networks for code generation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Ling</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Grefenstette</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">M</forename><surname>Hermann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Kočiský</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Senior</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Blunsom</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Association for Computational Linguistics (ACL)</title>
		<imprint>
			<date type="published" when="2016" />
			<biblScope unit="page" from="599" to="609" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Simpler context-dependent logical forms via model projections</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Long</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Pasupat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Liang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Association for Computational Linguistics (ACL)</title>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Effective approaches to attention-based neural machine translation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Luong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Pham</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">D</forename><surname>Manning</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Empirical Methods in Natural Language Processing (EMNLP)</title>
		<imprint>
			<date type="published" when="2015" />
			<biblScope unit="page" from="1412" to="1421" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Neural program repair by jointly learning to localize and repair</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Marko</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Aditya</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Petros</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>David</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Rishabh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Learning Representations (ICLR)</title>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Superoptimizer -a look at the smallest program</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Massalin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Architectural Support for Programming Languages and Operating Systems (ASPLOS)</title>
		<imprint>
			<date type="published" when="1987" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Learning to generate pseudo-code from source code using statistical machine translation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Oda</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Fudaba</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Neubig</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hata</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Sakti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Toda</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Nakamura</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE/ACM International Conference on Automated Software Engineering (ASE)</title>
		<imprint>
			<date type="published" when="2015" />
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="574" to="584" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Neuro-symbolic program synthesis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Parisotto</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Mohamed</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Singh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Kohli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Learning Representations (ICLR</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Abstract syntax networks for code generation and semantic parsing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Rabinovich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Stern</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Klein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Association for Computational Linguistics (ACL</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Stochastic superoptimization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Schkufza</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Sharma</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Aiken</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Architectural Support for Programming Languages and Operating Systems (ASPLOS)</title>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">FrAngel: Component-based synthesis with control structures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Steinhardt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Liang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Principles of Programming Languages (POPL)</title>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Combinatorial sketching for finite programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Solar-Lezama</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Tancau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Bodik</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Saraswat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Seshia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Architectural Support for Programming Languages and Operating Systems (ASPLOS)</title>
		<imprint>
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Equality saturation: a new approach to optimization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Tate</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Stepp</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Tatlock</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Lerner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Principles of Programming Languages</title>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Modeling coverage for neural machine translation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Tu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Association for Computational Linguistics (ACL)</title>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Programming with unrestricted natural language</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Vadas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">R</forename><surname>Curran</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Australasian Language Technology Workshop (ALTA)</title>
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Vaswani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Shazeer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Parmar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Uszkoreit</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Jones</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">N</forename><surname>Gomez</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Kaiser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Polosukhin</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1706.03762</idno>
		<title level="m">Attention is all you need</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Pointer networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Vinyals</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Fortunato</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Jaitly</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems (NeurIPS)</title>
		<imprint>
			<date type="published" when="2015" />
			<biblScope unit="page" from="2674" to="2682" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Synthesizing transformations on hierarchically structured data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Yaghmazadeh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Klinger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Dillig</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Chaudhuri</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Programming Language Design and Implementation (PLDI)</title>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Sqlizer: Query synthesis from natural language</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Yaghmazadeh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Dillig</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Dillig</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA)</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">A syntactic neural model for general-purpose code generation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Yin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Neubig</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Association for Computational Linguistics (ACL)</title>
		<imprint>
			<date type="published" when="2017" />
			<biblScope unit="page" from="440" to="450" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">NAPS: Natural program synthesis dataset</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Zavershynskyi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Skidanov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Polosukhin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Workshop on Neural Abstract Machines &amp; Program Induction (NAMPI)</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Learning to parse database queries using inductive logic programming</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Zelle</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">J</forename><surname>Mooney</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Association for the Advancement of Artificial Intelligence (AAAI)</title>
		<imprint>
			<date type="published" when="1996" />
			<biblScope unit="page" from="1050" to="1055" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Online learning of relaxed CCG grammars for parsing to logical form</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">S</forename><surname>Zettlemoyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Collins</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Empirical Methods in Natural Language Processing and Computational Natural Language Learning (EMNLP/CoNLL)</title>
		<imprint>
			<date type="published" when="2007" />
			<biblScope unit="page" from="678" to="687" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Zhong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Xiong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Socher</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1709.00103</idno>
		<title level="m">Seq2SQL: Generating structured queries from natural language using reinforcement learning</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
