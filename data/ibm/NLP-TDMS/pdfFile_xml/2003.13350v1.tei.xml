<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /nfs/home/kabenamualus/Research/task-dataset-metric-extraction/../grobid-0.6.0/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Agent57: Outperforming the Atari Human Benchmark</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Adrià</forename><surname>Puigdomènech Badia</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bilal</forename><surname>Piot</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Steven</forename><surname>Kapturowski</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pablo</forename><surname>Sprechmann</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alex</forename><surname>Vitvitskyi</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Guo</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Charles</forename><surname>Blundell</surname></persName>
						</author>
						<title level="a" type="main">Agent57: Outperforming the Atari Human Benchmark</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>

		<encodingDesc>
			<appInfo>
				<application version="0.6.0" ident="GROBID-SDO" when="2021-06-25T16:34+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid-sdo"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Atari games have been a long-standing benchmark in the reinforcement learning (RL) community for the past decade. This benchmark was proposed to test general competency of RL algorithms. Previous work has achieved good average performance by doing outstandingly well on many games of the set, but very poorly in several of the most challenging games. We propose Agent57, the first deep RL agent that outperforms the standard human benchmark on all 57 Atari games. To achieve this result, we train a neural network which parameterizes a family of policies ranging from very exploratory to purely exploitative. We propose an adaptive mechanism to choose which policy to prioritize throughout the training process. Additionally, we utilize a novel parameterization of the architecture that allows for more consistent and stable learning.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>The Arcade Learning Environment (ALE; <ref type="bibr" target="#b7">Bellemare et al., 2013)</ref> was proposed as a platform for empirically assessing agents designed for general competency across a wide range of games. ALE offers an interface to a diverse set of Atari 2600 game environments designed to be engaging and challenging for human players. As <ref type="bibr" target="#b7">Bellemare et al. (2013)</ref> put it, the Atari 2600 games are well suited for evaluating general competency in AI agents for three main reasons: (i) varied enough to claim generality, (ii) each interesting enough to be representative of settings that might be faced in practice, and (iii) each created by an independent party to be free of experimenter's bias.</p><p>Agents are expected to perform well in as many games as possible making minimal assumptions about the domain at hand and without the use of game-specific information. <ref type="bibr">Deep Q-Networks (DQN ;</ref><ref type="bibr">Mnih et al., 2015)</ref> was the first algorithm to achieve human-level control in a large num- ber of the Atari 2600 games, measured by human normalized scores (HNS). Subsequently, using HNS to assess performance on Atari games has become one of the most widely used benchmarks in deep reinforcement learning (RL), despite the human baseline scores potentially underestimating human performance relative to what is possible <ref type="bibr">(Toromanoff et al., 2019)</ref>. Nonetheless, human benchmark performance remains an oracle for "reasonable performance" across the 57 Atari games. Despite all efforts, no single RL algorithm has been able to achieve over 100% HNS on all 57 Atari games with one set of hyperparameters. Indeed, state of the art algorithms in model-based <ref type="bibr">RL, MuZero (Schrittwieser et al., 2019)</ref>, and in model-free <ref type="bibr">RL, R2D2 (Kapturowski et al., 2018)</ref> surpass 100% HNS on 51 and 52 games, respectively. While these algorithms achieve well above average human-level performance on a large fraction of the games (e.g. achieving more than 1000% HNS), in the games they fail to do so, they often fail to learn completely. These games showcase particularly important issues that a general RL algorithm should be able to tackle. Firstly, long-term credit assignment: which decisions are most deserving of credit for the positive (or negative) outcomes that follow? This problem is particularly hard when rewards are delayed and credit needs to be assigned over long sequences of actions, such as in the games of Skiing or Solaris. The game of Skiing is a canonical example due to its peculiar reward structure. The goal of the game is to run downhill through all gates as fast as possible. A penalty of five seconds is given for each missed gate. The reward, given only at the end, is proportional to the time elapsed. Therefore long-term credit assignment is needed to understand why an action taken early in the game (e.g. missing a gate) has a negative impact in the obtained reward. Secondly, exploration: efficient exploration can be critical to effective learning in RL. Games like Private Eye, Montezuma's Revenge, Pitfall! or Venture are widely considered hard exploration games <ref type="bibr" target="#b6">(Bellemare et al., 2016;</ref><ref type="bibr">Ostrovski et al., 2017)</ref> as hundreds of actions may be required before a first positive reward is seen. In order to succeed, the agents need to keep exploring the environment despite the apparent impossibility of finding positive rewards. These problems are particularly challenging in large high dimensional state spaces where function approximation is required.</p><p>Exploration algorithms in deep RL generally fall into three categories: randomized value functions <ref type="bibr">(Osband et al., 2016;</ref><ref type="bibr" target="#b13">Fortunato et al., 2017;</ref><ref type="bibr">Salimans et al., 2017;</ref><ref type="bibr">Plappert et al., 2017;</ref><ref type="bibr">Osband et al., 2018)</ref>, unsupervised policy learning <ref type="bibr" target="#b17">(Gregor et al., 2016;</ref><ref type="bibr" target="#b0">Achiam et al., 2018;</ref><ref type="bibr" target="#b11">Eysenbach et al., 2018)</ref> and intrinsic motivation <ref type="bibr">(Schmidhuber, 1991;</ref><ref type="bibr">Oudeyer et al., 2007;</ref><ref type="bibr" target="#b5">Barto, 2013;</ref><ref type="bibr" target="#b6">Bellemare et al., 2016;</ref><ref type="bibr">Ostrovski et al., 2017;</ref><ref type="bibr" target="#b15">Fu et al., 2017;</ref><ref type="bibr">Tang et al., 2017;</ref><ref type="bibr" target="#b8">Burda et al., 2018;</ref><ref type="bibr" target="#b9">Choi et al., 2018;</ref><ref type="bibr">Savinov et al., 2018;</ref><ref type="bibr">Puigdomènech Badia et al., 2020)</ref>. Other work combines handcrafted features, domain-specific knowledge or privileged pre-training to side-step the exploration problem, sometimes only evaluating on a few Atari games <ref type="bibr" target="#b3">(Aytar et al., 2018;</ref><ref type="bibr" target="#b10">Ecoffet et al., 2019)</ref>. Despite the encouraging results, no algorithm has been able to significantly improve performance on challenging games without deteriorating performance on the remaining games without relying on human demonstrations <ref type="bibr">(Pohlen et al., 2018)</ref>. Notably, amongst all this work, intrinsic motivation, and in particular, Never Give Up (NGU; Puigdomènech Badia et al., 2020) has shown significant recent promise in improving performance on hard exploration games. NGU achieves this by augmenting the reward signal with an internally generated intrinsic reward that is sensitive to novelty at two levels: short-term novelty within an episode and long-term novelty across episodes. It then learns a family of policies for exploring and exploiting (sharing the same parameters), with the end goal of obtain the highest score under the exploitative policy. However, NGU is not the most general agent: much like R2D2 and MuZero are able to perform strongly on all but few games, so too NGU suffers in that it performs strongly on a smaller, different set of games to agents such as MuZero and R2D2 (despite being based on R2D2). For example, in the game Surround R2D2 achieves the optimal score while NGU performs similar to a random policy. One shortcoming of NGU is that it collects the same amount of experience following each of its policies, regardless of their contribution to the learning progress. Some games require a significantly different degree of exploration to others. Intuitively, one would want to allocate the shared resources (both network capacity and data collection) such that end performance is maximized. We propose allowing NGU to adapt its exploration strategy over the course of an agent's lifetime, enabling specialization to the particular game it is learning. This is the first significant improvement we make to NGU to allow it to be a more general agent.</p><p>Recent work on long-term credit assignment can be categorized into roughly two types: ensuring that gradients correctly assign credit <ref type="bibr">(Ke et al., 2017;</ref><ref type="bibr">Weber et al., 2019;</ref><ref type="bibr" target="#b12">Ferret et al., 2019;</ref><ref type="bibr" target="#b14">Fortunato et al., 2019)</ref> and using values or targets to ensure correct credit is assigned <ref type="bibr" target="#b2">(Arjona-Medina et al., 2019;</ref><ref type="bibr" target="#b20">Hung et al., 2019;</ref><ref type="bibr">Liu et al., 2019;</ref><ref type="bibr" target="#b18">Harutyunyan et al., 2019)</ref>. NGU is also unable to cope with long-term credit assignment problems such as Skiing or Solaris where it fails to reach 100% HNS. Advances in credit assignment in RL often involve a mixture of both approaches, as values and rewards form the loss whilst the flow of gradients through a model directs learning.</p><p>In this work, we propose tackling the long-term credit assignment problem by improving the overall training stability, dynamically adjusting the discount factor, and increasing the backprop through time window. These are relatively simple changes compared to the approaches proposed in previous work, but we find them to be effective. Much recent work has explored this problem of how to dynamically adjust hyperparameters of a deep RL agent, e.g., approaches based upon evolution <ref type="bibr">(Jaderberg et al., 2017</ref><ref type="bibr">), gradients (Xu et al., 2018</ref> or multi-armed bandits <ref type="bibr">(Schaul et al., 2019)</ref>. Inspired by <ref type="bibr">Schaul et al. (2019)</ref>, we propose using a simple non-stationary multi-armed bandit <ref type="bibr" target="#b16">(Garivier &amp; Moulines, 2008)</ref> to directly control the exploration rate and discount factor to maximize the episode return, and then provide this information to the value network of the agent as an input. Unlike Schaul et al. (2019), 1) it controls the exploration rate and discount factor (helping with longterm credit assignment), and 2) the bandit controls a family of state-action value functions that back up the effects of exploration and longer discounts, rather than linearly tilting a common value function by a fixed functional form.</p><p>In summary, our contributions are as follows:</p><p>1. A new parameterization of the state-action value function that decomposes the contributions of the intrinsic and extrinsic rewards. As a result, we significantly increase the training stability over a large range of intrinsic reward scales.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2.</head><p>A meta-controller: an adaptive mechanism to select which of the policies (parameterized by exploration rate and discount factors) to prioritize throughout the training process. This allows the agent to control the exploration/exploitation trade-off by dedicating more resources to one or the other.</p><p>3. Finally, we demonstrate for the first time performance that is above the human baseline across all Atari 57 games. As part of these experiments, we also find that simply re-tuning the backprop through time window to be twice the previously published window for R2D2 led to superior long-term credit assignment (e.g., in Solaris) while still maintaining or improving overall performance on the remaining games.</p><p>These improvements to NGU collectively transform it into the most general Atari 57 agent, enabling it to outperform the human baseline uniformly over all Atari 57 games. Thus, we call this agent: Agent57.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Background: Never Give Up (NGU)</head><p>Our work builds on top of the NGU agent, which combines two ideas: first, the curiosity-driven exploration, and second, distributed deep RL agents, in particular R2D2.</p><p>NGU computes an intrinsic reward in order to encourage exploration. This reward is defined by combining perepisode and life-long novelty. The per-episode novelty, r episodic t , rapidly vanishes over the course of an episode, and it is computed by comparing observations to the contents of an episodic memory. The life-long novelty, α t , slowly vanishes throughout training, and it is computed by using a parametric model (in NGU and in this work Random Network Distillation <ref type="bibr" target="#b8">(Burda et al., 2018)</ref> is used to this end). With this, the intrinsic reward r i t is defined as follows:</p><formula xml:id="formula_0">r i t = r episodic t · min {max {α t , 1} , L} ,</formula><p>where L = 5 is a chosen maximum reward scaling. This leverages the long-term novelty provided by α t , while r episodic t continues to encourage the agent to explore within an episode. For a detailed description of the computation of r episodic t and α t , see <ref type="bibr">(Puigdomènech Badia et al., 2020)</ref>. At time t, NGU adds N different scales of the same intrinsic reward β j r i t (β j ∈ R + , j ∈ 0, . . . N − 1) to the extrinsic reward provided by the environment, r e t , to form N potential total rewards r j,t = r e t + β j r i t . Consequently, NGU aims to learn the N different associated optimal state-action value functions Q * rj associated with each reward function r j,t . The exploration rates β j are parameters that control the degree of exploration. Higher values will encourage exploratory policies and smaller values will encourage exploitative policies. Additionally, for purposes of learning long-term credit assignment, each Q * rj has its own associated discount factor γ j (for background and notations on Markov Decision Processes (MDP) see App. A). Since the intrinsic reward is typically much more dense than the extrinsic reward, {(β j , γ j )} N −1 j=0 are chosen so as to allow for long term horizons (high values of γ j ) for exploitative policies (small values of β j ) and small term horizons (low values of γ j ) for exploratory policies (high values of β j ).</p><p>To learn the state-action value function Q * rj , NGU trains a recurrent neural network Q(x, a, j; θ), where j is a onehot vector indexing one of N implied MDPs (in particular (β j , γ j )), x is the current observation, a is an action, and θ are the parameters of the network (including the recurrent state). In practice, NGU can be unstable and fail to learn an appropriate approximation of Q * rj for all the state-action value functions in the family, even in simple environments. This is especially the case when the scale and sparseness of r e t and r i t are both different, or when one reward is more noisy than the other. We conjecture that learning a common state-action value function for a mix of rewards is difficult when the rewards are very different in nature. Therefore, in Sec. 3.1, we propose an architectural modification to tackle this issue.</p><p>Our agent is a deep distributed RL agent, in the lineage of R2D2 and NGU. As such, it decouples the data collection and the learning processes by having many actors feed data to a central prioritized replay buffer. A learner can then sample training data from this buffer, as shown in <ref type="figure" target="#fig_1">Fig. 2</ref> (for implementation details and hyperparameters refer to App. E). More precisely, the replay buffer con- tains sequences of transitions that are removed regularly in a FIFO-manner. These sequences come from actor processes that interact with independent copies of the environment, and they are prioritized based on temporal differences errors <ref type="bibr">(Kapturowski et al., 2018)</ref>. The priorities are initialized by the actors and updated by the learner with the updated state-action value function Q(x, a, j; θ). According to those priorities, the learner samples sequences of transitions from the replay buffer to construct an RL loss. Then, it updates the parameters of the neural network Q(x, a, j; θ) by minimizing the RL loss to approximate the optimal state-action value function. Finally, each actor shares the same network architecture as the learner but with different weights. We refer as θ l to the parameters of the l−th actor. The learner weights θ are sent to the actor frequently, which allows it to update its own weights θ l . Each actor uses different values l , which are employed to follow an l -greedy policy based on the current estimate of the state-action value function Q(x, a, j; θ l ). In particular, at the beginning of each episode and in each actor, NGU uniformly selects a pair (β j , γ j ). We hypothesize that this process is sub-optimal and propose to improve it in Sec. 3.2 by introducing a meta-controller for each actor that adapts the data collection process.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Improvements to NGU</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">State-Action Value Function Parameterization</head><p>The proposed architectural improvement consists in splitting the state-action value function in the following way:</p><formula xml:id="formula_1">Q(x, a, j; θ) = Q(x, a, j; θ e ) + β j Q(x, a, j; θ i ),</formula><p>where Q(x, a, j; θ e ) and Q(x, a, j; θ i ) are the extrinsic and intrinsic components of Q(x, a, j; θ) respectively. The sets of weights θ e and θ i separately parameterize two neural networks with identical architecture and θ = θ i ∪ θ e . Both Q(x, a, j; θ e ) and Q(x, a, j; θ i ) are optimized separately in the learner with rewards r e and r i respectively, but with the same target policy π(x) = arg max a∈A Q(x, a, j; θ). More precisely, to train the weights θ e and θ i , we use the same sequence of transitions sampled from the replay, but with two different transformed Retrace loss functions <ref type="bibr" target="#b6">(Munos et al., 2016)</ref>. For Q(x, a, j; θ e ) we compute an extrinsic transformed Retrace loss on the sequence transitions with rewards r e and target policy π, whereas for Q(x, a, j; θ i ) we compute an intrinsic transformed Retrace loss on the same sequence of transitions but with rewards r i and target policy π. A reminder of how to compute a transformed Retrace loss on a sequence of transitions with rewards r and target policy π is provided in App. C.</p><p>In addition, in App. B, we show that this optimization of separate state-action values is equivalent to the optimization of the original single state-action value function with reward r e + β j r i (under a simple gradient descent optimizer). Even though the theoretical objective being optimized is the same, the parameterization is different: we use two different neural networks to approximate each one of these state-action values (a schematic and detailed figures of the architectures used can be found in App. F). By doing this, we allow each network to adapt to the scale and variance associated with their corresponding reward, and we also allow for the associated optimizer state to be separated for intrinsic and extrinsic state-action value functions.</p><p>Moreover, when a transformed Bellman operator <ref type="bibr">(Pohlen et al., 2018)</ref> with function h is used (see App. A), we can split the state-action value function in the following way:</p><p>Q(x, a, j; θ) = h h −1 (Q(x, a, j; θ e )) + β j h −1 (Q(x, a, j; θ i )) .</p><p>In App. B, we also show that the optimization of separated transformed state-action value functions is equivalent to the optimization of the original single transformed stateaction value function. In practice, choosing a simple or transformed split does not seem to play an important role in terms of performance (empirical evidence and an intuition behind this result can be found in App. H.3). In our experiments, we choose an architecture with a simple split which corresponds to h being the identity, but still use the transformed Retrace loss functions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.">Adaptive Exploration over a Family of Policies</head><p>The core idea of NGU is to jointly train a family of policies with different degrees of exploratory behaviour using a single network architecture. In this way, training these exploratory policies plays the role of a set of auxiliary tasks that can help train the shared architecture even in the absence of extrinsic rewards. A major limitation of this approach is that all policies are trained equally, regardless of their contribution to the learning progress. We propose to incorporate a meta-controller that can adaptively select which policies to use both at training and evaluation time. This carries two important consequences. Firstly, by selecting which policies to prioritize during training, we can allocate more of the capacity of the network to better represent the state-action value function of the policies that are most relevant for the task at hand. Note that this is likely to change throughout the training process, naturally building a curriculum to facilitate training. As mentioned in Sec. 2, policies are represented by pairs of exploration rate and discount factor, (β j , γ j ), which determine the discounted cumulative rewards to maximize. It is natural to expect policies with higher β j and lower γ j to make more progress early in training, while the opposite would be expected as training progresses. Secondly, this mechanism also provides a natural way of choosing the best policy in the family to use at evaluation time. Considering a wide range of values of γ j with β j ≈ 0, provides a way of automatically adjusting the discount factor on a per-task basis. This significantly increases the generality of the approach.</p><p>We propose to implement the meta-controller using a nonstationary multi-arm bandit algorithm running independently on each actor. The reason for this choice, as opposed to a global meta-controller, is that each actor follows a different l -greedy policy which may alter the choice of the optimal arm. Each arm j from the N -arm bandit is linked to a policy in the family and corresponds to a pair (β j , γ j ). At the beginning of each episode, say, the k-th episode, the meta-controller chooses an arm J k setting which policy will be executed. We use capital letters for the arm J k because it is a random variable. Then the l-th actor acts l -greedily with respect to the corresponding state-action value function, Q(x, a, J k ; θ l ), for the whole episode. The undiscounted extrinsic episode returns, noted R e k (J k ), are used as a reward signal to train the multi-arm bandit algorithm of the meta-controller.</p><p>The reward signal R e k (J k ) is non-stationary, as the agent changes throughout training. Thus, a classical bandit algorithm such as Upper Confidence Bound (UCB; Garivier &amp; Moulines, 2008) will not be able to adapt to the changes of the reward through time. Therefore, we employ a simplified sliding-window UCB with UCB -greedy exploration. With probability 1 − UCB , this algorithm runs a slight modification of classic UCB on a sliding window of size τ and selects a random arm with probability UCB (details of the algorithms are provided in App. D).</p><p>Note that the benefit of adjusting the discount factor through training and at evaluation could be applied even in the absence of intrinsic rewards. To show this, we propose augmenting a variant of R2D2 with a meta-controller. In order to isolate the contribution of this change, we evaluate a variant of R2D2 which uses the same RL loss as Agent57. Namely, a transformed Retrace loss as opposed to a transformed n-step loss as in the original paper. We refer to this variant as R2D2 (Retrace) throughout the paper. In all other aspects, R2D2 (Retrace) is exactly the same algorithm as R2D2. We incorporate the joint training of several policies parameterized by {γ j } N −1 j=0 to R2D2 (Retrace). We refer to this algorithm as R2D2 (bandit).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Experiments</head><p>We begin this section by describing our experimental setup. Following NGU, Agent57 uses a family of coefficients {(β j , γ j )} N −1 j=0 of size N = 32. The choice of discounts {γ j } N −1 j=0 differs from that of NGU to allow for higher values, ranging from 0.99 to 0.9999 (see App. G.1 for details). The meta-controller uses a window size of τ = 160 episodes and = 0.5 for the actors and a window size of τ = 3600 episodes and = 0.01. All the other hyperparameters are identical to those of NGU, including the standard preprocessing of Atari frames. For a complete description of the hyperparameters and preprocessing we use, please see App. G.3. For all agents we run (that is, all agents except MuZero where we report numbers presented in Schrittwieser et al. <ref type="formula">(2019)</ref>), we employ a separate evaluator process to continuously record scores. We record the undiscounted episode returns averaged over 3 seeds and using a windowed mean over 50 episodes. For our best algorithm, Agent57, we report the results averaged over 6 seeds on all games to strengthen the significance of the results. On that average, we report the maximum over training as their final score, as done in <ref type="bibr" target="#b13">Fortunato et al. (2017)</ref>; Puigdomènech Badia et al. <ref type="bibr">(2020)</ref>. Further details on our evaluation setup are described in App. E.</p><p>In addition to using human normalized scores HNS = Agent score −Randomscore Humanscore−Randomscore , we report the capped human normalized scores, CHNS = max{min{HNS, 1}, 0}. This measure is a better descriptor for evaluating general performance, as it puts an emphasis in the games that are below the average human performance benchmark. Furthermore, and avoiding any issues that aggregated metrics may have, we also provide all the scores that all the ablations obtain in all games we evaluate in App. H.1.</p><p>We structure the rest of this section in the following way: firstly, we show an overview of the results that Agent57 achieves. Then we proceed to perform ablations on each one of the improvements we propose for our model.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.">Summary of the Results</head><p>Tab. 1 shows a summary of the results we obtain on all 57 Atari games when compared to baselines. MuZero obtains the highest uncapped mean and median human normalized scores, but also the lowest capped scores. This is due to the fact that MuZero performs remarkably well in some games, such as Beam Rider, where it shows an uncapped score of 27469%, but at the same time catastrophically fails to learn in games such as Venture, achieving a score that is on par with a random policy. We see that the meta-controller improvement successfully transfers to R2D2: the proposed variant R2D2 (bandit) shows a mean, median, and CHNS that are much higher than R2D2 with the same Retrace loss. Finally, Agent57 achieves a median and mean that is greater than NGU and R2D2, but also its CHNS is 100%. This shows the generality of Agent57: not only it obtains a strong mean and median, but also it is able to obtain strong performance on the tail of games in which MuZero and R2D2 catastrophically fail. This is more clearly observed when looking at different percentiles: up to the 20th percentile, Agent57 shows much greater performance, only slightly surpassed by R2D2 (bandit) when we examine higher percentiles. In <ref type="figure" target="#fig_2">Fig. 3</ref> we report the performance of Agent57 in isolation on the 57 games. We show the last 6 games (in terms of number of frames collected by the agents) in which the algorithm surpasses the human performance benchmark. As shown, the benchmark over games is beaten in a long-tailed fashion, where Agent57 uses the first 5 billion frames to surpass the human benchmark on 51 games. After that, we find hard exploration games, such as Montezuma's Revenge, Pitfall!, and Private Eye. Lastly, Agent57 surpasses the human benchmark on Skiing after 78 billion frames. To be able to achieve such performance on Skiing, Agent57 uses a high discount (as we show in Sec. 4.4). This naturally leads to high variance in the returns, which leads to needing more data in order to learn to play the game. One thing to note is that, in the game of Skiing, the human baseline is very competitive, with a score of −4336.9, where −17098.1 is random and −3272 is the optimal score one can achieve.</p><p>In general, as performance in Atari keeps improving, it seems natural to concentrate on the tail of the distribution, i.e., pay attention to those games for which progress in the literature has been historically much slower than average. We now present results for a subset of 10 games that we call the challenging set. It consists of the six hard exploration games as defined in <ref type="bibr" target="#b6">(Bellemare et al., 2016)</ref>, plus games that require long-term credit assignment. More concretely, the games we use are: Beam Rider, Freeway, Montezuma's Revenge, Pitfall!, Pong, Private Eye, Skiing, Solaris, Surround, and Venture.</p><p>In <ref type="figure" target="#fig_3">Fig. 4</ref> we can see the performance progression obtained from incorporating each one of the improvements we make on top of NGU. Such performance is reported on the selection of 10 games mentioned above. We observe that each one of the improvements results in an increment in final performance. Further, we see that each one of the improvements that is part of Agent57 is necessary in order to obtain the consistent final performance of 100% CHNS. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.">State-Action Value Function Parameterization</head><p>We begin by evaluating the influence of the state-action value function parametrization on a minimalistic gridworld environment, called "random coin". It consists of an empty room of size 15 × 15 where a coin and an agent are randomly placed at the start of each episode. The agent can take four possible actions (up, down, left right) and episodes are at most 200 steps long. If the agent steps over the coin, it receives a reward of 1 and the episode terminates. In <ref type="figure" target="#fig_4">Fig. 5</ref> we see the results of NGU with and without the new parameterization of its state-action value functions. We report performance after 150 million frames. We compare the extrinsic returns for the policies that are the exploitative (β j = 0) and the most exploratory (with the largest β j in the family). Even for small values of the exploration rates (max j β j ), this setting induces very different exploratory and exploitative policies. Maximizing the discounted extrinsic returns is achieved by taking the shortest path towards the coin (obtaining an extrinsic return of one), whereas maximizing the augmented returns is achieved by avoiding the coin and visiting all remaining states (obtaining an extrinsic return of zero). In principle, NGU should be able to learn these policies jointly. However, we observe that the exploitative policy in NGU struggles to solve the task as intrinsic motivation reward scale increases. As we increase the scale of the intrinsic reward, its value becomes much greater than that of the extrinsic reward. As a consequence, the conditional state-action value network of NGU is required to represent very different values depending on the β j we condition on. This implies that the network is increasingly required to have more flexible representations. Using separate networks dramatically increases its robustness to the intrinsic reward weight that is used. Note that this effect would not occur if the episode did not terminate after collecting the coin. In such case, exploratory and exploitative policies would be allowed to be very similar: both could start by collecting the coin as quickly as possible. In <ref type="figure" target="#fig_3">Fig. 4</ref> we can see that this improvement also translates to the challenging set. NGU achieves a much lower average CHNS than its separate network counterpart. We also observe this phenomenon when we incorporate the meta-controller. Agent57 suffers a drop of performance that is greater than 20% when the separate network improvement is removed.</p><p>We can also see that it is a general improvement: it does not show worse performance on any of the 10 games of the challenging set. More concretely, the largest improvement is seen in the case of Surround, where NGU obtains a score on par with a random policy, whereas with the new parametrization it reaches a score that is nearly optimal. This is because Surround is a case that is similar to the "random coin" environment mentioned above: as the player makes progress in the game, they have the choice to surround the opponent snake, receive a reward, and start from the initial state, or keep wandering around without capturing the opponent, and thus visiting new states in the world. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.">Backprop Through Time Window Size</head><p>In this section we analyze the impact of having a backprop through time window size. More concretely, we analyze its impact on the base algorithm R2D2 to see its effect without NGU or any of the improvements we propose. Further, we also analyze its effect on Agent57, to see if any of the improvements on NGU overlap with this change. In both cases, we compare using backprop through time window sizes of 80 (default in R2D2) versus 160.</p><p>In aggregated terms over the challenging set, its effect seems to be the same for both R2D2 and Agent57: using a longer backprop through time window appears to be initially slower, but results in better overall stability and slightly higher final score. A detailed comparison over those 10 games is shown in App. H.2. This effect can be seen clearly in the game of Solaris, as observed in <ref type="figure" target="#fig_5">Fig. 6</ref>. This is also the game showing the largest improvement in terms of final score. This is again general improvement, as it enhances performance on all the challenging set games. For further details we report the scores in App. H.1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4.">Adaptive Exploration</head><p>In this section, we analyze the effect of using the metacontroller described in Sec. 3.1 in both the actors and the evaluator. To isolate the contribution of this improvement, we evaluate two settings: R2D2 and NGU with separate networks, with and without meta-controller. Results are shown in <ref type="figure" target="#fig_6">Fig. 7</ref>. Again, we observe that this is a general improvement in both comparisons. Firstly, we observe that there is a great value in this improvement on its own, enhancing the final performance of R2D2 by close to 20% CHNS. Secondly, we observe that the benefit on NGU with separate networks is more modest than for R2D2. This indicates that there is a slight overlap in the contributions of the separate network parameterization and the use of the meta-controller. The bandit algorithm can adaptively decrease the value of β when the difference in scale between intrinsic and extrinsic rewards is large. Using the metacontroller allows to include very high discount values in the set {γ j } N j=0 . Specifically, running R2D2 with a high discount factor, γ = 0.9999 surpasses the human baseline in the game of Skiing. However, using that hyperparameter across the full set of games, renders the algorithm very unstable and damages its end performance. All the scores in the challenging set for a fixed high discount (γ = 0.9999) variant of R2D2 are reported in App. H.1. When using a meta-controller, the algorithm does not need to make this compromise: it can adapt it in a per-task manner.</p><p>Finally, the results and discussion above show why it is beneficial to use different values of β and γ on a per-task basis. At the same time, in Sec. 3 we hypothesize it would also be useful to vary those coefficients throughout training. In <ref type="figure" target="#fig_7">Fig. 8</ref> we can see the choice of (β j , γ j ) producing highest returns on the meta-controller of the evaluator across training for several games. Some games clearly have a preferred mode: on Skiing the high discount combination is quickly picked up when the agent starts to learn, and on Hero a high β and low γ is generally preferred at all times. On the other hand, some games have different preferred modes throughout training: on Gravitar, Crazy Climber, Beam Rider, and Jamesbond, Agent57 initially chooses to focus on exploratory policies with low discount, and, as training progresses, the agent shifts into producing experience from higher discount and more exploitative policies.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Conclusions</head><p>We present the first deep reinforcement learning agent with performance above the human benchmark on all 57 Atari games. The agent is able to balance the learning of different skills that are required to be performant on such diverse set of games: exploration and exploitation and long-term credit assignment. To do that, we propose simple improvements to an existing agent, Never Give Up, which has good performance on hard-exploration games, but in itself does not have strong overall performance across all 57 games. These improvements are i) using a different parameterization of the state-action value function, ii) using a metacontroller to dynamically adapt the novelty preference and discount, and iii) the use of longer backprop-through time window to learn from using the Retrace algorithm.</p><p>This method leverages a great amount of computation to its advantage: similarly to NGU, it is able to scale well with increasing amounts of computation. This has also been the case with the many recent achievements in deep RL <ref type="bibr">(Silver et al., 2016;</ref><ref type="bibr" target="#b1">Andrychowicz et al., 2018;</ref><ref type="bibr">Vinyals et al., 2019)</ref>. While this enables our method to achieve strong performance, an interesting research direction is to pursue ways in which to improve the data efficiency of this agent. Additionally, this agent shows an average capped human normalized score of 100%. However, in our view this by no means marks the end of Atari research, not only in terms of efficiency as above, but also in terms of general performance. We offer two views on this: firstly, analyzing the performance among percentiles gives us new insights on how general algorithms are. While Agent57 achieves great results on the first percentiles of the 57 games and holds better mean and median performance than NGU or R2D2, as MuZero shows, it could still obtain much better average performance. Secondly, as pointed out by <ref type="bibr">Toromanoff et al. (2019)</ref>, all current algorithms are far from achieving optimal performance in some games. To that end, key improvements to use might be enhancements in the representations that Agent57 and NGU use for exploration, planning (as suggested by the results achieved by MuZero) as well as better mechanisms for credit assignment (as highlighted by the results seen in Skiing). </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Background on MDP</head><p>A Markov decision process (MDP; Puterman, 1990) is a tuple (X , A, P, r, γ), with X being the state space, A being the action space, P the state-transition distribution maps each state-action tuple (x, a) to a probability distribution over states (with P (y|x, a) denoting the probability of transitioning to state y from x by choosing action a), the reward function r ∈ R X ×A and γ ∈]0, 1[ the discount factor. A stochastic policy π maps each state to a distribution over actions (π(a|x) denotes the probability of choosing action a in state x). A deterministic policy π D ∈ X A can also be represented by a distribution over actions π such that π(π D (x)|x) = 1. We will use one or the other concept with the same notation π in the remaining when the context is clear.</p><p>Let <ref type="figure">T (x, a, π)</ref> be the distribution over trajectories τ = (X t , A t , R t , X t+1 ) t∈N generated by a policy π, with (X 0 , A 0 ) = (x, a), ∀t ≥ 1, A t ∼ π(.|X t ), ∀t ≥ 0, R t = r(X t , A t ) and ∀t ≥ 0, X t+1 ∼ P (.|X t , A t ). Then, the state-action value function Q π r (x, a) for the policy π and the state-action tuple (x, a) is defined as:</p><formula xml:id="formula_2">Q π r (x, a) = E τ ∼T (x,a,π)   t≥0 R t   .</formula><p>The optimal state-action value function Q * is defined as:</p><formula xml:id="formula_3">Q * r (x, a) = max π Q π r (x, a).</formula><p>where the max is taken over all stochastic policies.</p><p>Let define the one-step evaluation Bellman operator T π r , for all functions Q ∈ R X ×A and for all state-action tuples (x, a) ∈ X × A, as:</p><formula xml:id="formula_4">T π r Q(x, a) = r(x, a) + γ b∈A x ∈X π(b|x)P (x |x, a)Q(x , b).</formula><p>The one-step evaluation Bellman operator can also be written with vectorial notations:</p><formula xml:id="formula_5">T π r Q = r + γP π Q,</formula><p>where P π is a transition matrix representing the effect of acting according to π in a MDP with dynamics P . The evaluation Bellman operator is a contraction and its fixed point is Q π r . Finally let define the greedy operator G, for all functions Q ∈ R X ×A and for all state x ∈ X , as:</p><formula xml:id="formula_6">G(Q)(x) = arg max a∈A Q(x, a).</formula><p>Then, one can show <ref type="bibr">(Puterman, 1990)</ref>, via a fixed point argument, that the following discrete scheme:</p><formula xml:id="formula_7">∀k ≥ 0, π k = G (Q k ) , Q k+1 = T π k r Q k ,</formula><p>where Q 0 can be initialized arbitrarily, converges to Q * r . This discrete scheme is called the one-step value iteration scheme. Throughout the article, we also use transformed Bellman operators (see Sec. C.2). The one-step transformed evaluation Bellman operator T π r,h , for all functions Q ∈ R X ×A and for all state-action tuples (x, a) ∈ X × A, can be defined as:</p><formula xml:id="formula_8">T π r,h Q(x, a) = h r(x, a) + γ b∈A x ∈X π(b|x)P (x |x, a)h −1 (Q(x , b)) ,</formula><p>where h is a monotonically increasing and invertible squashing function that scales the state-action value function to make it easier to approximate for a neural network. In particular, we use the function h:</p><formula xml:id="formula_9">∀z ∈ R, h(z) = sign(z)( |z| + 1 − 1) + z, ∀z ∈ R, h −1 (z) = sign(z) 1 + 4 (|z| + 1 + ) − 1 2 − 1 ,</formula><p>with a small number. The one-step transformed evaluation Bellman operator can also be written with vectorial notations:</p><formula xml:id="formula_10">T π r,h Q = h r + γP π h −1 (Q) .</formula><p>Under some conditions on h (Pohlen et al., 2018) and via a contraction argument, one can show that the transformed one-step value iteration scheme:</p><formula xml:id="formula_11">∀k ≥ 0, π k = G (Q k ) , Q k+1 = T π k r,h Q k ,</formula><p>where Q 0 can be initialized arbitrarily, converges. We note this limit Q * r,h .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Extrinsic-Intrinsic Decomposition</head><p>For an intrinsically-motivated agent, the reward function r is a linear combination of the intrinsic reward r i and the extrinsic reward r e : r = r e + βr i .</p><p>One can compute the optimal state-action value function Q * r via the value iteration scheme:</p><formula xml:id="formula_12">∀k ≥ 0, π k = G (Q k ) , Q k+1 = T π k r Q k ,</formula><p>where Q 0 can be initialized arbitrarily.</p><p>Now, we want to show how we can also converge to Q * r using separate intrinsic and extrinsic state-action value functions. Indeed, let us consider the following discrete scheme:</p><formula xml:id="formula_13">∀k ≥ 0,   π k = G Q e k + βQ i k , Q i k+1 = Tπ k r i Q i k , Q e k+1 = Tπ k r e Q e k ,</formula><p>where the functions (Q e 0 , Q i 0 ) can be initialized arbitrarily. Our goal is simply to show that the linear combination of extrinsic and intrinsic state-action value functionQ k :</p><formula xml:id="formula_14">∀k ≥ 0,Q k = Q e k + βQ i k .</formula><p>verifies a one-step value iteration scheme with respect to the reward r = r e + βr i and therefore converges to Q * r . To show that let us rewriteQ k+1 :Q</p><formula xml:id="formula_15">k+1 = Q e k+1 + βQ i k+1 , = Tπ k r e Q e k + βTπ k r i Q i k , = r e + βr i + γPπ k (Q e k + βQ i k ), = Tπ k r e +βr i (Q e k + βQ i k ), = Tπ k rQk .</formula><p>Therefore we have thatQ k satisfies a value iteration scheme with respect to the reward r = r e + βr i :</p><formula xml:id="formula_16">∀k ≥ 0, π k = G Q k , Q k+1 = Tπ k rQk ,</formula><p>and by the contraction property: lim</p><formula xml:id="formula_17">k−→∞Q k = Q * r .</formula><p>This result means that we can compute separately Q e k and Q i k and then mix them to obtain the same behavior than if we had computed Q k directly with the mixed reward r e + βr i . This implies that we can separately compute the extrinsic and intrinsic component. Each architecture will need to learn their state-action value for different mixtures β and then act according to the greedy policy of the mixture of the state-action value functions. This result could also be thought as related to <ref type="bibr" target="#b4">Barreto et al. (2017)</ref> which may suggest potential future research directions.</p><p>The same type of result holds for the transformed state-action value functions. Indeed let us consider the optimal transformed state-action value function Q * r,h that can be computed via the following discrete scheme:</p><formula xml:id="formula_18">∀k ≥ 0, π k = G (Q k ) , Q k+1 = T π k r,h Q k ,</formula><p>where Q 0 can be initialized arbitrarily.</p><p>Now, we show how we can compute Q * r,h differently using separate intrinsic and extrinsic state-action value functions. Indeed, let us consider the following discrete scheme:</p><formula xml:id="formula_19">∀k ≥ 0,   π k = G h h −1 (Q e k ) + βh −1 (Q i k ) , Q i k+1 = Tπ k r i ,h Q i k , Q e k+1 = Tπ k r e ,h Q e k ,</formula><p>where the functions (Q e 0 , Q i 0 ) can be initialized arbitrarily. We want to show thatQ k defines as:</p><formula xml:id="formula_20">∀k ≥ 0,Q k = h h −1 (Q e k ) + βh −1 (Q i k ) ,</formula><p>verifies the one-step transformed value iteration scheme with respect to the reward r = r e + βr i and therefore converges to Q * r,h . To show that let us rewriteQ k+1 :</p><formula xml:id="formula_21">Q k+1 = h h −1 (Q e k+1 ) + βh −1 (Q i k+1 ) , = h h −1 (Tπ k r e ,h Q e k ) + βh −1 (Tπ k r i ,h Q i k ) , = h r e + γPπ k h −1 (Q e k ) + βr i + γPπ k βh −1 (Q i k ) , = h r e + βr i + γPπ k (h −1 (Q e k ) + βh −1 (Q i k )) , = h r + γPπ k h −1 (Q k ) = Tπ k r,hQ k .</formula><p>Thus we have thatQ k satisfies the one-step transformed value iteration scheme with respect to the reward r = r e + βr i :</p><formula xml:id="formula_22">∀k ≥ 0, π k = G Q k , Q k+1 = Tπ k r,h Q k ,</formula><p>and by contraction: lim</p><formula xml:id="formula_23">k−→∞Q k = Q * r,h .</formula><p>One can remark that when the transformation h is the identity, we recover the linear mix between intrinsic and extrinsic state-action value functions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Retrace and Transformed Retrace</head><p>Retrace <ref type="figure" target="#fig_0">(Munos et al., 2016)</ref> is an off-policy RL algorithm for evaluation or control. In the evaluation setting the goal is to estimate the state-action value function Q π of a target policy π from trajectories drawn from a behaviour policy µ.</p><p>In the control setting the goal is to build a sequence of target policies π k and state-action value functions Q k in order to approximate Q * .</p><p>The evaluation Retrace operator T µ,π r , that depends on µ and π, is defined as follows, for all functions Q ∈ R X ×A and for all state-action tuples (x, a) ∈ X × A:</p><formula xml:id="formula_24">T µ,π r Q(x, a) = E τ ∼T (x,a,µ)   Q(x, a) + t≥0 γ t t s=1 c s δ t   ,</formula><p>where the temporal difference δ t is defined as:</p><formula xml:id="formula_25">δ t = r t + γ a∈A π(a|X t+1 )Q(X t+1 , a) − Q(X t , A t ),</formula><p>and the trace coefficients c s as:</p><formula xml:id="formula_26">c s = λ min 1, π(A s |X s ) µ(A s |X s ) ,</formula><p>where λ is a fixed parameter ∈ [0, 1]. The operator T µ,π r is a multi-step evaluation operator that corrects the behaviour of µ to evaluate the policy π. It has been shown in Theorem 1 of <ref type="bibr" target="#b6">Munos et al. (2016)</ref> that Q π r is the fixed point of T µ,π r . In addition, Theorem 2 of <ref type="bibr" target="#b6">Munos et al. (2016)</ref> explains in which conditions the Retrace value iteration scheme:</p><formula xml:id="formula_27">∀k ≥ 0, π k = G (Q k ) , Q k+1 = T µ k ,π k r Q k ,</formula><p>converges to the optimal state-action value function Q * , where Q 0 is initialized arbitrarily and {µ k } k∈N is an arbitrary sequence of policies that may depend on Q k .</p><p>As in the case of the one-step Bellman operator, we can also define a transformed counterpart to the Retrace operator. More specifically, we can define the transformed Retrace operator T µ,π r,h , for all functions Q ∈ R X ×A and for all stateaction tuples (x, a) ∈ X × A:</p><formula xml:id="formula_28">T µ,π r,h Q(x, a) = h   E τ ∼T (x,a,µ)   h −1 (Q(x, a)) + t≥0 γ t t s=1 c s δ h t     ,</formula><p>where the temporal difference δ h t is defined as:</p><formula xml:id="formula_29">δ h t = r t + γ a∈A π(a|X t+1 )h −1 (Q(X t+1 , a)) − h −1 (Q(X t , A t )).</formula><p>As in the case of the Retrace operator, we can define the transformed Retrace value iteration scheme:</p><formula xml:id="formula_30">∀k ≥ 0, π k = G (Q k ) , Q k+1 = T µ k ,π k r,h Q k ,</formula><p>where Q 0 is initialized arbitrarily and {µ k } k∈N is an arbitrary sequence of policies.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C.1. Extrinsic-Intrinsic Decomposition for Retrace and Transformed Retrace</head><p>Following the same methodology than App .B, we can also show that the state-action value function can be decomposed in extrinsic and intrinsic components for the Retrace and transformed Retrace value iteration schemes when the reward is of the form r = r e + βr i .</p><p>Indeed if we define the following discrete scheme:</p><formula xml:id="formula_31">∀k ≥ 0,   π k = G Q e k + βQ i k , Q i k+1 = Tμ k ,π k r i Q i k , Q e k+1 = Tμ k ,π k r e Q e k ,</formula><p>where the functions (Q e 0 , Q i 0 ) can be initialized arbitrarily and {μ k } k∈N is an arbitrary sequence of policies. Then, it is straightforward to show that the linear combinationQ k :</p><formula xml:id="formula_32">∀k ≥ 0,Q k = Q e k + βQ i k ,</formula><p>verifies the Retrace value iteration scheme:</p><formula xml:id="formula_33">∀k ≥ 0, π k = G Q k , Q k+1 = Tμ k ,π k rQk ,</formula><p>Likewise, if we define the following discrete scheme:</p><formula xml:id="formula_34">∀k ≥ 0,     π k = G h h −1 (Q e k ) + βh −1 (Q i k ) , Q i k+1 = Tμ k ,π k r i ,h Q i k , Q e k+1 = Tμ k ,π k r e ,h Q e k ,</formula><p>where the functions (Q e 0 , Q i 0 ) can be initialized arbitrarily and {μ k } k∈N is an arbitrary sequence of policies. Then, it is also straightforward to show thatQ k defines as:</p><formula xml:id="formula_35">∀k ≥ 0,Q k = h h −1 (Q e k ) + βh −1 (Q i k ) ,</formula><p>verifies the transformed Retrace value iteration scheme:</p><formula xml:id="formula_36">∀k ≥ 0, π k = G Q k , Q k+1 = Tμ k ,π k r,h Q k ,</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C.2. Retrace and Transformed Retrace Losses for Neural Nets.</head><p>In this section, we explain how we approximate with finite data and neural networks the Retrace value iteration scheme. To start, one important thing to remark is that we can rewrite the evaluation step:</p><formula xml:id="formula_37">Q k+1 = T µ k ,π k r Q k , with: Q k+1 = arg min Q∈R X ×A T µ k ,π k r Q k − Q ,</formula><p>where . can be any norm over the function space R X ×A . This means that the evaluation step can be seen as an optimization problem over a functional space where the optimization consists in finding a function Q that matches the target T µ k ,π k r Q k .</p><p>In practice, we face two important problems. The search space R X ×A is too big and we cannot evaluate T µ k ,π k r Q k everywhere because we have a finite set of data. To tackle the former, a possible solution is to use function approximation such as neural networks. Thus, we parameterize the state action value function Q(x, a; θ) (where θ is the set of parameters of the neural network) also called online network. Concerning the latter, we are going to build sampled estimates of T µ k ,π k r Q k and use them as targets for our optimization problem. In practice, the targets are built from a previous and fixed set of parameters θ − of the neural network. Q(x, a; θ − ) is called the target network. The target network is updated to the value of the online network at a fixed frequency during the learning.</p><p>More precisely, let us consider a batch of size B of finite sampled sequences of size H:</p><formula xml:id="formula_38">D = {(x b s , a b s , µ b s = µ(a b s |x b s ), r b s , x b s+1 ) t+H−1 s=t } B−1 b=0 starting from (x b t , a b t )</formula><p>and then following the behaviour policy µ. Then, we can define the finite sampled-Retrace targets as:</p><formula xml:id="formula_39">T µ,π r Q(x b s , a b s ; θ − ) = Q(x b s , a b s ; θ − ) + t+H−1 j=s γ j−s j i=s+1 c i,b δ j,b c i,b = λ min 1, π(a b i |x b i ) µ b i , δ j,b = r b j + γ a∈A π(a|x b j+1 )Q(x b j+1 , a; θ − ) − Q(x b j , a b j ; θ − ),</formula><p>where π(a|x) is the target policy.</p><p>Once the targets are computed, the goal is to find a parameter θ that fits those targets by minimizing the following loss function:</p><formula xml:id="formula_40">L(D, θ, θ − , π, µ, r) = B−1 b=0 t+H−1 s=t Q(x b s , a b s ; θ) −T µ,π r Q(x b s , a b s ; θ − ) 2 .</formula><p>This is done by an optimizer such as gradient descent for instance. Once θ is updated by the optimizer, a new loss with new targets is computed and minimized until convergence.</p><p>Therefore in practice the evaluation step of the Retrace value iteration scheme Q k+1 = T µ k ,π k r Q k is approximated by minimizing the loss L(D, θ, π, µ) with an optimizer. The greedy step π k = G (Q k ) is realized by simply being greedy with respect to the online network and choosing the target policy as follows: π = G <ref type="figure">(Q(x, a; θ)</ref>).</p><p>In the case of a transformed Retrace operator, we have the following targets:</p><formula xml:id="formula_41">T µ,π r,h Q(x b s , a b s ; θ − ) = h   h −1 (Q(x b s , a b s ; θ − )) + t+H−1 j=s γ j−t j i=s+1 c i,b δ h s,b   c i,b = λ min 1, π(a b i |x b i ) µ b i , δ j,b = r b j + γ a∈A π(a|x b j+1 )h −1 (Q(x b j+1 , a; θ − )) − h −1 Q(x b j , a b j ; θ − ).</formula><p>And the transformed Retrace loss function is:</p><formula xml:id="formula_42">L(D, θ, θ − π, µ, r, h) = B−1 b=0 t+H−1 s=t Q(x b s , a b s ; θ) −T µ,π r,h Q(x b s , a b s ; θ − ) 2 .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Multi-arm Bandit Formalism</head><p>This section describes succinctly the multi-arm bandit (MAB) paradigm, upper confidence bound (UCB) algorithm and sliding-window UCB algorithm. For a more thorough explanation and analysis we refer the reader to <ref type="bibr" target="#b16">Garivier &amp; Moulines (2008)</ref>.</p><p>At each time k ∈ N, a MAB algorithm chooses an arm A k among the possible arms {0, . . . , N − 1} according to a policy π that is conditioned on the sequence of previous actions and rewards. Doing so, it receives a reward R k (A k ) ∈ R. In the stationary case, the rewards {R k (a)} k≥0 for a given arm a ∈ {0, . . . , N − 1} are modelled by a sequence of i.i.d random variables. In the non-stationary case, the rewards {R k (a)} k≥0 are modelled by a sequence of independent random variables but whose distributions could change through time.</p><p>The goal of a MAB algorithm is to find a policy π that maximizes the expected cumulative reward for a given horizon K:</p><formula xml:id="formula_43">E π K−1 k=0 R k (A k ) .</formula><p>In the stationary case, the UCB algorithm has been well studied and is commonly used. Let us define the number of times an arm a has been played after k steps:</p><formula xml:id="formula_44">N k (a) = k−1 m=0 1 {Am=a} .</formula><p>Let us also define the empirical mean of an arm a after k steps:</p><formula xml:id="formula_45">µ k (a) = 1 N k (a) k−1 m=0 R k (a)1 {Am=a} .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Agent57: Outperforming the Atari Human Benchmark</head><p>The UCB algorithm is then defined as follows:</p><formula xml:id="formula_46">∀0 ≤ k ≤ N − 1, A k = k ∀N ≤ k ≤ K − 1, A k = arg max 1≤a≤Nμk−1 (a) + β log (k−1) N k−1 (a)</formula><p>In the non-stationary case, the UCB algorithm cannot adapt to the change of reward distribution and one can use a slidingwindow UCB in that case. It is commonly understood that the window length τ ∈ N * should be way smaller that the horizon K. Let us define the number of times an arm a has been played after k steps for a window of length τ :</p><formula xml:id="formula_47">N k (a, τ ) = k−1 m=0∨k−τ 1 {Am=a} ,</formula><p>where 0 ∨ k − τ means max(0, k − τ ). Let define the empirical mean of an arm a after k steps for a window of length τ :</p><formula xml:id="formula_48">µ k (a, τ ) = 1 N k (a, τ ) k−1 m=0∨k−τ R k (a)1 {Am=a} .</formula><p>Then , the sliding window UCB can be defined as follows:</p><formula xml:id="formula_49">∀0 ≤ k ≤ N − 1, A k = k ∀N ≤ k ≤ K − 1, A k = arg max 1≤a≤Nμk−1 (a, τ ) + β log (k−1∧τ ) N k−1 (a,τ ) where k − 1 ∧ τ means min(k − 1, τ ).</formula><p>In our experiments, we use a simplified sliding window UCB with UCB -greedy exploration:</p><formula xml:id="formula_50">     ∀0 ≤ k ≤ N − 1, A k = k ∀N ≤ k ≤ K − 1 and U k ≥ UCB , A k = arg max 0≤a≤N −1μk−1 (a, τ ) + β 1 N k−1 (a,τ ) ∀N ≤ k ≤ K − 1 and U k &lt; UCB , A k = Y k</formula><p>where U k is a random value drawn uniformly from [0, 1] and Y k a random action drawn uniformly from {0, . . . , N − 1}.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E. Implementation details of the distributed setting</head><p>Replay buffer: it stores fixed-length sequences of transitions ξ = (ω s ) t+H−1 s=t along with their priorities p ξ . A transition is of the form ω s = (r e s−1 , r i s−1 , a s−1 , h s−1 , x s , a s , h s , µ s , j s , r e s , r i s , x s+1 ) . Such transitions are also called timesteps and the length of a sequence H is called the trace length. In addition, adjacent sequences in the replay buffer overlap by a number of timesteps called the replay period and the sequences never cross episode boundaries. Let us describe each element of a transition:</p><p>• r e s−1 : extrinsic reward at the previous time.</p><p>• r i s−1 : intrinsic reward at the previous time.</p><p>• a s−1 : action done by the agent at the previous time.</p><p>• h s−1 : recurrent state (in our case hidden state of the LSTM) at the previous time.</p><p>• x s : observation provided by the environment at the current time.</p><p>• a s : action done by the agent at the current time.</p><p>• h s : recurrent state (in our case hidden state of the LSTM) at the current time.</p><p>• µ s : the probability of choosing the action a s .</p><p>• j s = j: index of the pair (γ j , β j ) chosen at a beginning of an episode in each actor by the multi-arm bandit algorithm (fixed for the whole sequence).</p><p>• r e s : extrinsic reward at the current time.</p><p>• r i s : intrinsic reward at the current time • x s+1 : observation provided by the environment at the next time.</p><p>In our experiment, we choose a trace length of 160 with a replay period of 80 or a trace length of 80 with a replay period of 40. Please refer to <ref type="bibr">(Kapturowski et al., 2018)</ref> for a detailed experimental of trade-offs on different treatments of recurrent states in the replay. Finally, concerning the priorities, we followed the same prioritization scheme proposed by <ref type="bibr">Kapturowski et al. (2018)</ref> using a mixture of max and mean of the TD-errors in the sequence with priority exponent η = 0.9.</p><p>Actors: each of the L actors shares the same network architecture as the learner but with different weights θ l , with 0 ≤ l ≤ L − 1. The l-th actor updates its weights θ l every 400 frames by copying the weights of the learner. At the beginning of each episode, each actor chooses, via a multi-arm bandit algorithm, an index j that represents a pair (γ j , β j ) in the family of pairs ({β j , γ j )} N −1 j=0 . In addition, the recurrent state is initialized to zero. To act, an actor will need to do a forward pass on the network in order to compute the state-action value for all actions, noted Q(x t , ., j; θ l ). To do so the inputs of the network are :</p><p>• x t : the observation at time t.</p><p>• r e t−1 : the extrinsic reward at the previous time, initialized with r e −1 = 0.</p><p>• r i t−1 : the intrinsic reward at the previous time, initialized with r i −1 = 0.</p><p>• a t−1 : the action at the previous time, a −1 is initialized randomly.</p><p>• h t−1 : recurrent state at the previous time, is initialized with h −1 = 0.</p><p>• j t−1 = j: the index of the pair (β j , γ j ) chosen by the multi-arm bandit algorithm (fixed for all the episode).</p><p>At time t, the l−th actor acts l -greedy with respect to Q(x t , ., j; θ l ):</p><formula xml:id="formula_51">If: U t &lt; l , a t = Y t ,</formula><p>Else: a t = arg max a∈A Q(x t , a, j; θ l ),</p><p>where U t is a random value drawn uniformly from [0, 1] and Y t a random action drawn uniformly from A. The probability µ t associated to a t is therefore:</p><formula xml:id="formula_52">If: U t &lt; l , µ t = l |A| , Else: µ t = 1 − l |A|−1 |A| ,</formula><p>where |A| is the cardinal number of the action space, 18 in the case of Atari games. Then, the actor plays the action a t and computes the intrinsic reward r i t and the environment produces the next observation x t+1 and the extrinsic reward r e t . This process goes on until the end of the episode.</p><p>The value of the noise l is chosen according to the same formula established by <ref type="bibr" target="#b19">Horgan et al. (2018)</ref>: l = 1+α l L−1 where = 0.4 and α = 8. In our experiments, we fix the number of actors to L = 256. Finally, the actors send the data collected to the replay along with the priorities.</p><p>Evaluator: the evaluator shares the same network architecture as the learner but with different weights θ e . The evaluator updates its weights θ l every 5 episodes frames by copying the weights of the learner. Unlike the actors, the experience produced by the evaluator is not sent to the replay buffer. The evaluator alternates between the following states every 5 episodes:</p><p>• Training bandit algorithm: the evaluator chooses, via a multi-arm bandit algorithm, an index j that represents a pair (γ j , β j ) in the family of pairs ({β j , γ j )} N −1 j=0 . Then it proceeds to act in the same way as the actors, described above. At the end of the episode, the undiscounted returns are used to train the multi-arm bandit algorithm.</p><p>• Evaluation: the evaluator chooses the greedy choice of index j, arg max 1≤a≤Nμk−1 (a), so it acts with (γ j , β j ).</p><p>Then it proceeds to act in the same way as the actors, described above. At the end of 5 episodes and before switching to the other mode, the results of those 5 episodes are average and reported.</p><p>Learner: The learner contains two identical networks called the online and target networks with different weights θ and θ − respectively <ref type="bibr">(Mnih et al., 2015)</ref>. The target network's weights θ − are updated to θ every 1500 optimization steps. For our particular architecture, the weights θ = θ e ∪ θ i can be decomposed in a set of intrinsic weights θ e and θ i that have the same architecture. Likewise, we have θ − = θ −,e ∪ θ −,i . The intrinsic and extrinsic weights are going to be updated by their own transformed Retrace loss. θ e and θ i are updated by executing the following sequence of instructions:</p><p>• First, the learner samples a batch of size B of fixed-length sequences of transitions D = {ξ b = (ω b s ) t+H−1 s=t } B−1 b=0 from the replay buffer.</p><p>• Then, a forward pass is done on the online network and the target with inputs</p><formula xml:id="formula_53">{(x b s , r e,b s−1 , r i,b s−1 , j b , a b s−1 , h b s−1 ) t+H s=t } B−1 b=0 in order to obtain the state-action values {(Q(x b s , ., j b ; θ e ), Q(x b s , ., j b ; θ −,e ), Q(x b s , ., j b ; θ i ), Q(x b s , ., j b ; θ −,i )) t+H s=t } B−1 b=0 .</formula><p>• Once the state-action values are computed, it is now easy to compute the transformed Retrace losses L(D, θ e , θ −,e , π, µ, r e , h) and L(D, θ i , θ −,i , π, µ, r i , h) for each set of weights θ e and θ i , respectively, as shown in Sec .C. The target policy π is greedy with respect to Q(x b s , ., j b ; θ e ) + β j b s Q(x b s , ., j b ; θ i ) or with respect to h h −1 (Q(x b s , ., j b ; θ e )) + β j b s h −1 (Q(x b s , ., j b ; θ i )) in the case where we want to apply a transform h to the mixture of intrinsic and extrinsic state-action value functions.</p><p>• The transformed Retrace losses are optimized with an Adam optimizer.</p><p>• Like NGU, the inverse dynamics model and the random network distillation losses necessary to compute the intrinsic rewards are optimized with an Adam optimizer.</p><p>• Finally, the priorities are computed for each sampled sequence of transitions ξ b and updated in the replay buffer.</p><p>Computation used: in terms of hardware we train the agent with a single GPU-based learner, performing approximately 5 network updates per second (each update on a mini-batch of 64 sequences of length 160. We use 256 actors, with each one performing ∼ 260 environment steps per second on Atari.</p><p>Agent57: Outperforming the Atari Human Benchmark F. Network Architectures <ref type="figure">Figure 9</ref>. Sketch of the Agent57.</p><p>Agent57: Outperforming the Atari Human Benchmark The intuition between the choice of the set {(β j , γ j )} N −1 j=0 is the following. Concerning the β j we want to encourage policies which are very exploitative and very exploratory and that is why we choose a sigmoid as shown in <ref type="figure" target="#fig_0">Fig. 11(a)</ref>. Concerning the γ j we would like to allow for long term horizons (high values of γ j ) for exploitative policies (small values of β j ) and small term horizons (low values of γ j ) for exploratory policies (high values of β j ). This is mainly due to the sparseness of the extrinsic reward and the dense nature of the intrinsic reward. This motivates the choice done in <ref type="figure" target="#fig_0">Fig. 11(b)</ref>. where N = 32, γ 0 = 0.9999, γ 1 = 0.997 and γ 2 = 0.99.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>G.2. Atari pre-processing hyperparameters</head><p>In this section we detail the hyperparameters we use to pre-process the environment frames received from the Arcade Learning Environment. On Tab. 2 we detail such hyperparameters. ALE is publicly available at https://github. com/mgbellemare/Arcade-Learning-Environment.  <ref type="table">Table 2</ref>. Atari pre-processing hyperparameters.</p><p>Agent57: Outperforming the Atari Human Benchmark</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>G.3. Hyperparameters Used</head><p>The hyperparameters that we used in all experiments are exactly like those of NGU. However, for completeness, we detail them below in Tab. 3. We also include the hyperparameters we use for the windowed UCB bandit. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>G.4. Hyperparameters Search Range</head><p>The ranges we used to select the hyperparameters of Agent57 are displayed on Tab. 4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Hyperparameter</head><p>Value Bandit window size τ {160, 224, 320, 640} Bandit UCB {0.3, 0.5, 0.7} <ref type="table">Table 4</ref>. Range of hyperparameters sweeps. H.3. Identity versus h-transform mixes comparison <ref type="figure" target="#fig_0">Figure 13</ref>. Performance comparison for identity versus h-transform mixes on the 10-game challenging set. <ref type="figure">Fig H.</ref>3, choosing an identity or an h-transform mix does not seem to make a difference in terms of performance. The only real important thing is that a combination between extrinsic and intrinsic happens whether it is linear or not. In addition, one can remark that for extreme values of β (β = 0, β &gt;&gt; 1), the quantities Q e k (x, a) + βQ i k (x, a) and h −1 (Q e k (x, a)) + βh −1 (Q i k (x, a)) have the same arg max a∈A because h −1 is strictly increasing. Therefore, this means that on the extremes values of β, the transform and normal value iteration schemes converge towards the same policy. For in between values of β, this is not the case. But we can conjecture that when a transform operator and and identity mix are used, the value iteration scheme approximates a state-action value function that is optimal with respect to a non-linear combination of the intrinsic and extrinsic rewards r i , r e , respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>H.2. Backprop window length comparison</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>As shown in</head></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 .</head><label>1</label><figDesc>Number of games where algorithms are better than the human benchmark throughout training for Agent57 and state-ofthe-art baselines on the 57 Atari games.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 .</head><label>2</label><figDesc>A schematic depiction of a distributed deep RL agent.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 .</head><label>3</label><figDesc>Capped human normalized score where we observe at which point the agent surpasses the human benchmark on the last 6 games.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 .</head><label>4</label><figDesc>Performance progression on the 10-game challenging set obtained from incorporating each one of the improvements.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 .</head><label>5</label><figDesc>Extrinsic returns for the exploitative (β0 = 0) and most exploratory (β31 = β) on "random coin" for different values of the intrinsic reward weight, β. (Top) NGU(Bottom) NGU with Separate networks for intrinsic and extrinsic values.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 6 .</head><label>6</label><figDesc>Solaris learning curves with small and long backprop through time window sizes for both R2D2 and Agent57.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 7 .</head><label>7</label><figDesc>Performance comparison for adaptive exploration on the 10-game challenging set.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 8 .</head><label>8</label><figDesc>Best arm chosen by the evaluator of Agent57 over training for different games.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure</head><label></label><figDesc>Values of β and γ</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 11 .</head><label>11</label><figDesc>(a) Values taken by the {βi} N −1 i=0 (b) Values taken by the {γi} N −1 i=0 Values taken by the {βi} N −1 i=0 and the {γi} N −1 i=0 for N = 32 and β = 0.3.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 12 .</head><label>12</label><figDesc>Performance comparison for short and long backprob window length on the 10-game challenging set.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 .</head><label>1</label><figDesc>Number of games above human, mean capped, mean and median human normalized scores for the 57 Atari games.</figDesc><table><row><cell>Statistics</cell><cell>Agent57</cell><cell>R2D2 (bandit)</cell><cell>NGU</cell><cell>R2D2 (Retrace)</cell><cell>R2D2</cell><cell>MuZero</cell></row><row><cell>Capped mean</cell><cell>100.00</cell><cell>96.93</cell><cell>95.07</cell><cell>94.20</cell><cell>94.33</cell><cell>89.92</cell></row><row><cell>Number of games &gt; human</cell><cell>57</cell><cell>54</cell><cell>51</cell><cell>52</cell><cell>52</cell><cell>51</cell></row><row><cell>Mean</cell><cell>4766.25</cell><cell>5461.66</cell><cell>3421.80</cell><cell>3518.36</cell><cell>4622.09</cell><cell>5661.84</cell></row><row><cell>Median</cell><cell>1933.49</cell><cell>2357.92</cell><cell>1359.78</cell><cell>1457.63</cell><cell>1935.86</cell><cell>2381.51</cell></row><row><cell>40th Percentile</cell><cell>1091.07</cell><cell>1298.80</cell><cell>610.44</cell><cell>817.77</cell><cell>1176.05</cell><cell>1172.90</cell></row><row><cell>30th Percentile</cell><cell>614.65</cell><cell>648.17</cell><cell>267.10</cell><cell>420.67</cell><cell>529.23</cell><cell>503.05</cell></row><row><cell>20th Percentile</cell><cell>324.78</cell><cell>303.61</cell><cell>226.43</cell><cell>267.25</cell><cell>215.31</cell><cell>171.39</cell></row><row><cell>10th Percentile</cell><cell>184.35</cell><cell>116.82</cell><cell>107.78</cell><cell>116.03</cell><cell>115.33</cell><cell>75.74</cell></row><row><cell>5th Percentile</cell><cell>116.67</cell><cell>93.25</cell><cell>64.10</cell><cell>48.32</cell><cell>50.27</cell><cell>0.03</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>T., Dunning, I.,Simonyan, K., et  al. Population based training of neural networks. arXiv preprint arXiv:1711.09846, 2017. Kapturowski, S., Ostrovski, G., Quan, J., Munos, R., and Dabney, W. Recurrent experience replay in distributed reinforcement learning. In International Conference on Learning Representations, 2018. Večerík, M., et al. Observe and look further: Achieving consistent performance on atari. arXiv preprint arXiv:1805.11593, 2018. Vinyals, O., Babuschkin, I., Czarnecki, W. M., Mathieu, M., Dudzik, A., Chung, J., Choi, D. H., Powell, R., Ewalds, T., Georgiev, P., et al. Grandmaster level in starcraft ii using multi-agent reinforcement learning. Nature, 575(7782):350-354, 2019.</figDesc><table><row><cell></cell><cell>Puigdomènech Badia, A., Sprechmann, P., Vitvitskyi, A.,</cell></row><row><cell></cell><cell>Guo, D., Piot, B., Kapturowski, S., Tieleman, O., Ar-</cell></row><row><cell>Weber, T., Heess, N., Buesing, L., and Silver, D. Credit</cell><cell>jovsky, M., Pritzel, A., Bolt, A., and Blundell, C. Never</cell></row><row><cell>assignment techniques in stochastic computation graphs.</cell><cell>give up: Learning directed exploration strategies. In</cell></row><row><cell>arXiv preprint arXiv:1901.01761, 2019. Ke, N. R., Goyal, A., Bilaniuk, O., Binas, J., Charlin, L., Pal, C., and Bengio, Y. Sparse attentive back-Xu, Z., van Hasselt, H. P., and Silver, D. Meta-gradient re-</cell><cell>International Conference on Learning Representations, 2020.</cell></row><row><cell>tracking: Long-range credit assignment in recurrent net-works. arXiv preprint arXiv:1711.02326, 2017. inforcement learning. In Advances in neural information processing systems, pp. 2396-2407, 2018.</cell><cell>Puterman, M. L. Markov decision processes. Handbooks in operations research and management science, 2:331-</cell></row><row><cell>Liu, Y., Luo, Y., Zhong, Y., Chen, X., Liu, Q., and</cell><cell>434, 1990.</cell></row><row><cell>Peng, J. Sequence modeling of temporal credit assign-</cell><cell>Salimans, T., Ho, J., Chen, X., Sidor, S., and Sutskever,</cell></row><row><cell>ment for episodic reinforcement learning. arXiv preprint</cell><cell>I. Evolution strategies as a scalable alternative to rein-</cell></row><row><cell>arXiv:1905.13420, 2019.</cell><cell>forcement learning. arXiv preprint arXiv:1703.03864,</cell></row><row><cell>Mnih, V., Kavukcuoglu, K., Silver, D., Rusu, A. A., Ve-</cell><cell>2017.</cell></row><row><cell>ness, J., Bellemare, M. G., Graves, A., Riedmiller, M., Fidjeland, A. K., Ostrovski, G., et al. Human-level con-trol through deep reinforcement learning. Nature, 518 (7540):529, 2015.</cell><cell>Savinov, N., Raichuk, A., Marinier, R., Vincent, D., Polle-feys, M., Lillicrap, T., and Gelly, S. Episodic curiosity through reachability. arXiv preprint arXiv:1810.02274, 2018.</cell></row><row><cell></cell><cell>Schaul, T., Borsa, D., Ding, D., Szepesvari, D., Ostrovski,</cell></row><row><cell></cell><cell>G., Dabney, W., and Osindero, S. Adapting behaviour</cell></row><row><cell></cell><cell>for learning progress, 2019.</cell></row><row><cell>Osband, I., Blundell, C., Pritzel, A., and Van Roy, B. Deep exploration via bootstrapped dqn. In Advances In Neural Information Processing Systems, pp. 4026-4034, 2016.</cell><cell>Schmidhuber, J. A possibility for implementing curiosity and boredom in model-building neural controllers. In Proc. of the international conference on simulation of adaptive behavior: From animals to animats, pp. 222-</cell></row><row><cell>Osband, I., Aslanides, J., and Cassirer, A. Randomized</cell><cell>227, 1991.</cell></row><row><cell>prior functions for deep reinforcement learning. In Ad-vances in Neural Information Processing Systems, pp. 8617-8629, 2018.</cell><cell>Schrittwieser, J., Antonoglou, I., Hubert, T., Simonyan, K., Sifre, L., Schmitt, S., Guez, A., Lockhart, E., Hassabis, D., Graepel, T., et al. Mastering atari, go, chess and</cell></row><row><cell>Ostrovski, G., Bellemare, M. G., van den Oord, A., and</cell><cell>shogi by planning with a learned model. arXiv preprint</cell></row><row><cell>Munos, R. Count-based exploration with neural density</cell><cell>arXiv:1911.08265, 2019.</cell></row><row><cell>models. In Proceedings of the 34th International Confer-ence on Machine Learning-Volume 70, pp. 2721-2730. JMLR. org, 2017.</cell><cell>Silver, D., Huang, A., Maddison, C. J., Guez, A., Sifre, L., Van Den Driessche, G., Schrittwieser, J., Antonoglou, I., Panneershelvam, V., Lanctot, M., et al. Mastering the</cell></row><row><cell>Oudeyer, P.-Y., Kaplan, F., and Hafner, V. V. Intrinsic mo-</cell><cell>game of go with deep neural networks and tree search.</cell></row><row><cell>tivation systems for autonomous mental development.</cell><cell>nature, 529(7587):484-489, 2016.</cell></row><row><cell>IEEE transactions on evolutionary computation, 11(2): 265-286, 2007.</cell><cell>Tang, H., Houthooft, R., Foote, D., Stooke, A., Chen, O. X., Duan, Y., Schulman, J., DeTurck, F., and Abbeel,</cell></row><row><cell>Plappert, M., Houthooft, R., Dhariwal, P., Sidor, S., Chen,</cell><cell>P. # exploration: A study of count-based exploration for</cell></row><row><cell>R. Y., Chen, X., Asfour, T., Abbeel, P., and Andrychow-</cell><cell>deep reinforcement learning. In Advances in neural in-</cell></row><row><cell>icz, M. Parameter space noise for exploration. arXiv</cell><cell>formation processing systems, pp. 2753-2762, 2017.</cell></row><row><cell>preprint arXiv:1706.01905, 2017.</cell><cell></cell></row></table><note>Munos, R., Stepleton, T., Harutyunyan, A., and Bellemare, M. Safe and efficient off-policy reinforcement learning. In Advances in Neural Information Processing Systems, pp. 1046-1054, 2016.Pohlen, T., Piot, B., Hester, T., Azar, M. G., Horgan, D., Budden, D., Barth-Maron, G., Van Hasselt, H., Quan, J.,Toromanoff, M., Wirbel, E., and Moutarde, F. Is deep re- inforcement learning really superhuman on atari? arXiv preprint arXiv:1908.04683, 2019.</note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>We thank Daan Wierstra, Koray Kavukcuoglu, Vlad Mnih, Vali Irimia, Georg Ostrovski, Mohammad Gheshlaghi Azar, Rémi Munos, Bernardo Avila Pires, Florent Altché, Steph Hughes-Fitt, Rory Fitzpatrick, Andrea Banino, Meire Fortunato, Melissa Tan, Benigno Uria, Borja Ibarz, Andre Barreto, Diana Borsa, Simon Osindero, Tom Schaul, and many other colleagues at DeepMind for helpful discussions and comments on the manuscript.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We provide several videos in https://sites.google.com/corp/view/agent57. We show</p><p>• Agent57 on all 57 games: We provide an example video for each game in the Atari 57 sweep in which Agent57 surpasses the human baseline.</p><p>• State-action Value Function Parameterization: To illustrate the importance of the value function parametrization we show videos in two games Ice Hockey and Surround. We show videos for exploitative and exploratory policies for both NGU and Agent57. In Ice Hockey, exploratory and exploitative policies are quite achieving very different scores. Specifically the exploratory policy does not aim to score goals, it prefers to move around the court exploring new configurations. On the other hand, NGU with a single architecture is unable to learn both policies simultaneously, while Agent57 show very diverse performance. In the case of Surround NGU is again unable to learn. We conjecture that the exploratory policy chooses to loose a point in order to start afresh increasing the diversity of the observations. Agent57 is able to overcome this problem and both exploitative and exploratory policies are able to obtain scores surpassing the human baseline.</p><p>• Adaptive Discount Factor: We show example videos for R2D2 (bandit) and R2D2 (retrace) in the game James Bond. R2D2 (retrace) learns to clear the game with a final score in the order of 30,000 points. R2D2 (bandit) in contrast, learns to delay the end of the game to collect significantly more rewards with a score around 140,000 points. To achieve this, the adaptive mechanism in the meta-controller, selects policies with very high discount factors.</p><p>• Backprop Through Time Window Size: We provide videos showing example episodes for NGU and Agent57 on the game of Solaris. In order to achieve high scores, the agent needs to learn to move around the grid screen and look for enemies. This is a long term credit assignment problem as the agent needs to bind the actions taken on the grid screen with the reward achieved many time steps later.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Achiam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Edwards</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Amodei</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Abbeel</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1807.10299</idno>
		<title level="m">Variational option discovery algorithms</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Learning dexterous in-hand manipulation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Andrychowicz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Baker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Chociej</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Jozefowicz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Mcgrew</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Pachocki</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Petron</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Plappert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Powell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Ray</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1808.00177</idno>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Rudder: Return decomposition for delayed rewards</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">A</forename><surname>Arjona-Medina</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Gillhofer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Widrich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Unterthiner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Brandstetter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Hochreiter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems</title>
		<imprint>
			<date type="published" when="2019" />
			<biblScope unit="page" from="13544" to="13555" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Playing hard exploration games by watching youtube</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Aytar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Pfaff</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Budden</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Paine</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Freitas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems</title>
		<imprint>
			<date type="published" when="2018" />
			<biblScope unit="page" from="2930" to="2941" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Successor features for transfer in reinforcement learning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Barreto</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Dabney</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Munos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">J</forename><surname>Hunt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Schaul</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">P</forename><surname>Van Hasselt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Silver</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in neural information processing systems</title>
		<imprint>
			<date type="published" when="2017" />
			<biblScope unit="page" from="4055" to="4065" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Intrinsic motivation and reinforcement learning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">G</forename><surname>Barto</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Intrinsically motivated learning in natural and artificial systems</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2013" />
			<biblScope unit="page" from="17" to="47" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Unifying count-based exploration and intrinsic motivation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Bellemare</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Srinivasan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Ostrovski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Schaul</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Saxton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Munos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems</title>
		<imprint>
			<date type="published" when="2016" />
			<biblScope unit="page" from="1471" to="1479" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">The arcade learning environment: An evaluation platform for general agents</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">G</forename><surname>Bellemare</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Naddaf</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Veness</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Bowling</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Artificial Intelligence Research</title>
		<imprint>
			<biblScope unit="volume">47</biblScope>
			<biblScope unit="page" from="253" to="279" />
			<date type="published" when="2013-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Exploration by random network distillation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Burda</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Edwards</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Storkey</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Klimov</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1810.12894</idno>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Choi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Guo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Moczulski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Oh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Norouzi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Lee</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1811.01483</idno>
		<title level="m">Contingency-aware exploration in reinforcement learning</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Go-explore: a new approach for hardexploration problems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Ecoffet</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Huizinga</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Lehman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">O</forename><surname>Stanley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Clune</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename></persName>
		</author>
		<idno type="arXiv">arXiv:1901.10995</idno>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Eysenbach</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Ibarz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Levine</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Di</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1802.06070</idno>
		<title level="m">versity is all you need: Learning skills without a reward function</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Credit assignment as a proxy for transfer in reinforcement learning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Ferret</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Marinier</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Geist</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Pietquin</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1907.08027</idno>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Fortunato</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">G</forename><surname>Azar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Piot</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Menick</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Osband</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Graves</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Mnih</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Munos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Hassabis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Pietquin</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1706.10295</idno>
		<title level="m">Noisy networks for exploration</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Generalization of reinforcement learners with working and episodic memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Fortunato</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Tan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Faulkner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Hansen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">P</forename><surname>Badia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Buttimore</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Deck</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">Z</forename><surname>Leibo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Blundell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems</title>
		<imprint>
			<date type="published" when="2019" />
			<biblScope unit="page" from="12448" to="12457" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Exploration with exemplar models for deep reinforcement learning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Fu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Co-Reyes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Levine</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Ex2</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in neural information processing systems</title>
		<imprint>
			<date type="published" when="2017" />
			<biblScope unit="page" from="2577" to="2587" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">On upper-confidence bound policies for non-stationary bandit problems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Garivier</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Moulines</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Gregor</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">J</forename><surname>Rezende</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Wierstra</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1611.07507</idno>
		<title level="m">Variational intrinsic control</title>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Hindsight credit assignment</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Harutyunyan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Dabney</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Mesnard</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">G</forename><surname>Azar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Piot</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Heess</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">P</forename><surname>Van Hasselt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Wayne</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Singh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Precup</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in neural information processing systems</title>
		<imprint>
			<date type="published" when="2019" />
			<biblScope unit="page" from="12467" to="12476" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Horgan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Quan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Budden</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Barth-Maron</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Hessel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Van Hasselt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Silver</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1803.00933</idno>
		<title level="m">Distributed prioritized experience replay</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Optimizing agent behavior over long time scales by transporting value</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C.-C</forename><surname>Hung</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Lillicrap</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Abramson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Mirza</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Carnevale</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Ahuja</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wayne</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nature communications</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="12" />
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Jaderberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Dalibard</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Osindero</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">M</forename><surname>Czarnecki</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Donahue</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Razavi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Vinyals</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Green</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
