<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /nfs/home/kabenamualus/Research/task-dataset-metric-extraction/../grobid-0.6.0/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Augmented Neural ODEs</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Emilien</forename><surname>Dupont</surname></persName>
							<email>dupont@stats.ox.ac.uk</email>
							<affiliation key="aff0">
								<orgName type="institution">University of Oxford</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Arnaud</forename><surname>Doucet</surname></persName>
							<email>doucet@stats.ox.ac.uk</email>
							<affiliation key="aff1">
								<orgName type="institution">University of Oxford</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yee</forename><forename type="middle">Whye</forename><surname>Teh</surname></persName>
							<affiliation key="aff2">
								<orgName type="institution">University of Oxford</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Augmented Neural ODEs</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>

		<encodingDesc>
			<appInfo>
				<application version="0.6.0" ident="GROBID-SDO" when="2021-06-26T12:35+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid-sdo"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We show that Neural Ordinary Differential Equations (ODEs) learn representations that preserve the topology of the input space and prove that this implies the existence of functions Neural ODEs cannot represent. To address these limitations, we introduce Augmented Neural ODEs which, in addition to being more expressive models, are empirically more stable, generalize better and have a lower computational cost than Neural ODEs.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>The relationship between neural networks and differential equations has been studied in several recent works <ref type="bibr" target="#b18">(Weinan, 2017;</ref><ref type="bibr" target="#b13">Lu et al., 2017;</ref><ref type="bibr" target="#b8">Haber &amp; Ruthotto, 2017;</ref><ref type="bibr" target="#b16">Ruthotto &amp; Haber, 2018;</ref>. In particular, it has been shown that Residual Networks <ref type="bibr" target="#b9">(He et al., 2016)</ref> can be interpreted as discretized ODEs. Taking the discretization step to zero gives rise to a family of models called Neural ODEs . These models can be efficiently trained with backpropagation and have shown great promise on a number of tasks including modeling continuous time data and building normalizing flows with low computational cost <ref type="bibr" target="#b7">Grathwohl et al., 2018)</ref>.</p><p>In this work, we explore some of the consequences of taking this continuous limit and the restrictions this might create compared with regular neural nets. In particular, we show that there are simple classes of functions Neural ODEs (NODEs) cannot represent. While it is often possible for NODEs to approximate these functions in practice, the resulting flows are complex and lead to ODE problems that are computationally expensive to solve. To overcome these limitations, we introduce Augmented Neural ODEs (ANODEs) which are a simple extension of NODEs. ANODEs augment the space on which the ODE is solved, allowing the model to use the additional dimensions to learn more complex functions using simpler flows (see <ref type="figure">Fig. 1</ref>). In addition to being more expressive models, ANODEs significantly reduce the computational cost of both forward and backward passes of the model compared with NODEs. Our experiments also show that ANODEs generalize better, achieve lower losses with fewer parameters and are more stable to train.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Neural ODE</head><p>Augmented Neural ODE <ref type="figure">Figure 1</ref>: Learned flows for a Neural ODE and an Augmented Neural ODE. The flows (shown as lines with arrows) map input points to linearly separable features for binary classification. Augmented Neural ODEs learn simpler flows that are easier for the ODE solver to compute. NODEs are a family of deep neural network models that can be interpreted as a continuous equivalent of Residual Networks (ResNets). To see this, consider the transformation of a hidden state from a layer t to t + 1 in ResNets</p><formula xml:id="formula_0">h t+1 = h t + f t (h t )</formula><p>where h t ∈ R d is the hidden state at layer t and f t : R d → R d is some differentiable function which preserves the dimension of h t (typically a CNN). The difference h t+1 − h t can be interpreted as a discretization of the derivative h (t) with timestep ∆t = 1. Letting ∆t → 0, we see that</p><formula xml:id="formula_1">lim ∆t→0 h t+∆t − h t ∆t = dh(t) dt = f (h(t), t)</formula><p>so the hidden state can be parameterized by an ODE. We can then map a data point x into a set of features φ(x) by solving the Initial Value Problem (IVP)</p><formula xml:id="formula_2">dh(t) dt = f (h(t), t), h(0) = x</formula><p>to some time T . The hidden state at time T , i.e. h(T ), corresponds to the features learned by the model. The analogy with ResNets can then be made more explicit. In ResNets, we map an input x to some output y by a forward pass of the neural network. We then adjust the weights of the network to match y with some y true . In NODEs, we map an input x to an output y by solving an ODE starting from x. We then adjust the dynamics of the system (encoded by f ) such that the ODE transforms x to a y which is close to y true . ODE flows. We also define the flow associated to the vector field f (h(t), t) of the ODE. The flow φ t : R d → R d is defined as the hidden state at time t, i.e. φ t (x) = h(t), when solving the ODE from the initial condition h(0) = x. The flow measures how the states of the ODE at a given time t depend on the initial conditions x. We define the features of the ODE as φ(x) := φ T (x), i.e. the flow at the final time T to which we solve the ODE.</p><p>NODEs for regression and classification. We can use ODEs to map input data x ∈ R d to a set of features or representations φ(x) ∈ R d . However, we are often interested in learning functions from R d to R, e.g. for regression or classification. To define a model from R d to R, we follow the example given in <ref type="bibr" target="#b12">Lin &amp; Jegelka (2018)</ref> for ResNets. We define the NODE g : </p><formula xml:id="formula_3">R d → R as g(x) = L(φ(x)) where L : R d → R</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">A simple example in 1d</head><p>In this section, we introduce a simple function that ODE flows cannot represent, motivating many of the examples discussed later. Let g 1d : R → R be a function such that g 1d (−1) = 1 and g 1d (1) = −1. Proposition 1. The flow of an ODE cannot represent g 1d (x).</p><p>A detailed proof is given in the appendix. The intuition behind the proof is simple; the trajectories mapping −1 to 1 and 1 to −1 must intersect each other (see <ref type="figure">Fig. 3</ref>). However, ODE trajectories cannot cross each other, so the flow of an ODE cannot represent g 1d (x). This simple observation is at the core of all the examples provided in this paper and forms the basis for many of the limitations of NODEs.</p><p>Experiments. We verify this behavior experimentally by training an ODE flow on the identity mapping and on g 1d (x). The resulting flows are shown in <ref type="figure">Fig. 3</ref>. As can be seen, the model easily learns the identity mapping but cannot represent g 1d (x). Indeed, since the trajectories cannot cross, the model maps all input points to zero to minimize the mean squared error.</p><p>ResNets vs NODEs. NODEs can be interpreted as continuous equivalents of ResNets, so it is interesting to consider why ResNets can represent g 1d (x) but NODEs cannot. The reason for this is exactly because ResNets are a discretization of the ODE, allowing the trajectories to make discrete jumps to cross each other (see <ref type="figure">Fig. 3</ref>). Indeed, the error arising when taking discrete steps allows the ResNet trajectories to cross. In this sense, ResNets can be interpreted as ODE solutions with large errors, with these errors allowing them to represent more functions. We now introduce classes of functions in arbitrary dimension d which NODEs cannot represent. Let 0 &lt; r 1 &lt; r 2 &lt; r 3 and let g :</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Functions Neural ODEs cannot represent</head><formula xml:id="formula_4">R d → R be a function such that g(x) = −1 if x ≤ r 1 g(x) = 1 if r 2 ≤ x ≤ r 3 ,</formula><p>where · is the Euclidean norm. An illustration of this function for d = 2 is shown in <ref type="figure">Fig. 4</ref>. The function maps all points inside the blue sphere to −1 and all points in the red annulus to 1. Proposition 2. Neural ODEs cannot represent g(x).</p><p>A proof is given in the appendix. While the proof requires tools from ODE theory and topology, the intuition behind it is simple. In order for the linear layer to map the blue and red points to −1 and 1 respectively, the features φ(x) for the blue and red points must be linearly separable. Since the blue region is enclosed by the red region, points in the blue region must cross over the red region to become linearly separable, requiring the trajectories to intersect, which is not possible. In fact, we can make more general statements about which features Neural ODEs can learn. Proposition 3. The feature mapping φ(x) is a homeomorphism, so the features of Neural ODEs preserve the topology of the input space.</p><p>A proof is given in the appendix. This statement is a consequence of the flow of an ODE being a homeomorphism, i.e. a continuous bijection whose inverse is also continuous; see, e.g., <ref type="bibr" target="#b20">(Younes, 2010)</ref>. This implies that NODEs can only continuously deform the input space and cannot for example tear a connected region apart.</p><p>Discrete points and continuous regions. It is worthwhile to consider what these results mean in practice. Indeed, when optimizing NODEs we train on inputs which are sampled from the continuous regions of the annulus and the sphere (see <ref type="figure">Fig. 4</ref>). The flow could then squeeze through the gaps between sampled points making it possible for the NODE to learn a good approximation of the function. However, flows that need to stretch and squeeze the input space in such a way are likely to lead to ill-posed ODE problems that are numerically expensive to solve. In order to explore this, we run a number of experiments (the code to reproduce all experiments in this paper is available at https://github.com/EmilienDupont/augmented-neural-odes).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Experiments</head><p>We first compare the performance of ResNets and NODEs on simple regression tasks. To provide a baseline, we not only train on g(x) but also on data which can be made linearly separable without altering the topology of the space (implying that Neural ODEs should be able to easily learn this function). To ensure a fair comparison, we run large hyperparameter searches for each model and repeat each experiment 20 times to ensure results are meaningful across initializations (see appendix for details). We show results for experiments with d = 1 and d = 2 in <ref type="figure" target="#fig_2">Fig. 5</ref>. For d = 1, the ResNet easily fits the function, while the NODE cannot approximate g(x). For d = 2, the NODE eventually learns to approximate g(x), but struggles compared to ResNets. This problem is less severe for the separable function, presumably because the flow does not need to break apart any regions to linearly separate them.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Computational Cost and Number of Function Evaluations</head><p>One of the known limitations of NODEs is that, as training progresses and the flow gets increasingly complex, the number of steps required to solve the ODE increases <ref type="bibr" target="#b7">Grathwohl et al., 2018)</ref>. As the ODE solver evaluates the function f at each step, this problem is often referred to as the increasing number of function evaluations (NFE). In <ref type="figure">Fig. 6</ref>, we visualize the evolution of the feature space during training and the corresponding NFEs. The NODE initially tries to move the inner sphere out of the annulus by pushing against and stretching the barrier. Eventually, since we are mapping discrete points and not a continuous region, the flow is able to break apart the annulus to let the flow through. However, this results in a large increase in NFEs, implying that the ODE stretching the space to separate the two regions becomes more difficult to solve, making the computation slower. <ref type="figure">Figure 6</ref>: Evolution of the feature space as training progresses and the corresponding number of function evaluations required to solve the ODE. As the ODE needs to break apart the annulus, the number of function evaluations increases.</p><p>Motivated by our theory and experiments, we introduce Augmented Neural ODEs (ANODEs) which provide a simple solution to the problems we have discussed. We augment the space on which we learn and solve the ODE from R d to R d+p , allowing the ODE flow to lift points into the additional dimensions to avoid trajectories intersecting each other. Letting a(t) ∈ R p denote a point in the augmented part of the space, we can formulate the augmented ODE problem as d dt</p><formula xml:id="formula_5">h(t) a(t) = f ( h(t) a(t) , t), h(0) a(0) = x 0</formula><p>i.e. we concatenate every data point x with a vector of zeros and solve the ODE on this augmented space. We hypothesize that this will also make the learned (augmented) f smoother, giving rise to simpler flows that the ODE solver can compute in fewer steps. In the following sections, we verify this behavior experimentally and show both on toy and image datasets that ANODEs achieve lower losses, better generalization and lower computational cost than regular NODEs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Experiments</head><p>We first compare the performance of NODEs and ANODEs on toy datasets. As in previous experiments, we run large hyperparameter searches to ensure a fair comparison. As can be seen on <ref type="figure" target="#fig_3">Fig. 7</ref>, when trained on g(x) in different dimensions, ANODEs are able to fit the functions NODEs cannot and learn much faster than NODEs despite the increased dimension of the input. The corresponding flows learned by the model are shown in <ref type="figure" target="#fig_3">Fig. 7</ref>. As can be seen, in d = 1, the ANODE moves into a higher dimension to linearly separate the points, resulting in a simple, nearly linear flow. Similarly, in d = 2, the NODE learns a complicated flow whereas ANODEs simply lift out the inner circle to separate the data. This effect can also be visualized as the features evolve during training (see <ref type="figure" target="#fig_4">Fig. 8</ref>).</p><p>Computational cost and number of function evaluations. As ANODEs learn simpler flows, they would presumably require fewer iterations to compute. To test this, we measure the NFEs for NODEs and ANODEs when training on g(x). As can be seen in <ref type="figure" target="#fig_4">Fig. 8</ref>, the NFEs required by ANODEs hardly increases during training while it nearly doubles for NODEs. We obtain similar results when training NODEs and ANODEs on image datasets (see Section 5.2).</p><p>Generalization. As ANODEs learn simpler flows, we also hypothesize that they generalize better to unseen data than NODEs. To test this, we first visualize to which value each point in the input space gets mapped by a NODE and an ANODE that have been optimized to approximately zero training loss. As can be seen in <ref type="figure">Fig. 9</ref>, since NODEs can only continuously deform the input space, the learned flow must squeeze the points in the inner circle through the annulus, leading to poor  generalization. ANODEs, in contrast, map all points in the input space to reasonable values. As a further test, we can also create a validation set by removing random slices of the input space (e.g. removing all points whose angle is in [0, π 5 ]) from the training set. We train both NODEs and ANODEs on the training set and plot the evolution of the validation loss during training in <ref type="figure">Fig. 9</ref>. While there is a large generalization gap for NODEs, presumably because the flow moves through the gaps in the training set, ANODEs generalize much better and achieve near zero validation loss.</p><p>As we have shown, experimentally we obtain lower losses, simpler flows, better generalization and ODEs requiring fewer NFEs to solve when using ANODEs. We now test this behavior on image data by training models on MNIST, CIFAR10, SVHN and 200 classes of 64 × 64 ImageNet.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Image Experiments</head><p>We perform experiments on image datasets using convolutional architectures for f (h(t), t). As the input x is an image, the hidden state h(t) is now in R c×h×w where c is the number of channels and h and w are the height and width respectively. In the case where h(t) ∈ R d we augmented the space as h(t) ∈ R d+p . For images we augment the space as R c×h×w → R (c+p)×h×w , i.e. we add p channels of zeros to the input image. While there are other ways to augment the space, we found that increasing the number of channels works well in practice and use this method for all experiments. Full training and architecture details can be found in the appendix.</p><p>Results for models trained with and without augmentation are shown in <ref type="figure">Fig. 10</ref>. As can be seen, ANODEs train faster and obtain lower losses at a smaller computational cost than NODEs. On MNIST for example, ANODEs with 10 augmented channels achieve the same loss in roughly 10 times fewer iterations (for CIFAR10, ANODEs are roughly 5 times faster). Perhaps most interestingly, we can plot the NFEs against the loss to understand roughly how complex a flow (i.e. how many NFEs) are required to model a function that achieves a certain loss. For example, to compute a function which obtains a loss of 0.8 on CIFAR10, a NODE requires approximately 100 function evaluations whereas ANODEs only require 50. Similar observations can be made for other datasets, implying that ANODEs can model equally rich functions at half the computational cost of NODEs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Neural ODE</head><p>Augmented Neural ODE Parameter efficiency. As we augment the dimension of the ODEs, we also increase the number of parameters of the models, so it may be that the improved performance of ANODEs is due to the higher number of parameters. To test this, we train a NODE and an ANODE with the same number of parameters on MNIST (84k weights), CIFAR10 (172k weights), SVHN (172k weights) and 64 × 64 ImageNet (366k weights). We find that the augmented model achieves significantly lower losses with fewer NFEs than the NODE, suggesting that ANODEs use the parameters more efficiently than NODEs (see appendix for details and results). For all subsequent experiments, we use NODEs and ANODEs with the same number of parameters.</p><p>NFEs and weight decay. The increased computational cost during training is a known issue with NODEs and has previously been tackled by adding weight decay <ref type="bibr" target="#b7">(Grathwohl et al., 2018)</ref>. As ANODEs also achieve lower computational cost, we test models with various combinations of weight decay and augmentation (see appendix for detailed results). We find that ANODEs without weight decay significantly outperform NODEs with weight decay. However, using both weight decay and augmentation achieves the lowest NFEs at the cost of a slightly higher loss. Combining augmentation with weight decay may therefore be a fruitful avenue for further scaling NODE models.</p><p>Accuracy. <ref type="figure" target="#fig_6">Fig. 11</ref> shows training accuracy against NFEs for ANODEs and NODEs on MNIST, CIFAR10 and SVHN. As expected, ANODEs achieve higher accuracy at a lower computational cost than NODEs (similar results hold for ImageNet as shown in the appendix).</p><p>Generalization for images. As noted in Section 5.1, ANODEs generalize better than NODEs on simple datasets, presumably because they learn simpler and smoother flows. We also test this behavior on image datasets by training models with and without augmentation on the training set and calculating the loss and accuracy on the test set. As can be seen in <ref type="figure" target="#fig_0">Fig. 12</ref> and <ref type="table" target="#tab_3">Table 1</ref>, for MNIST, CIFAR10, and SVHN, ANODEs achieve lower test losses and higher test accuracies than NODEs, suggesting that ANODEs also generalize better on image datasets.  96.4% ± 0.5 98.2% ± 0.1 CIFAR10 53.7% ± 0.2 60.6% ± 0.4 SVHN 81.0% ± 0.6 83.5% ± 0.5 Stability. While experimenting with NODEs we found that the NFEs could often become prohibitively large (in excess of 1000, which roughly corresponds to a 1000-layer ResNet). For example, when overfitting a NODE on MNIST, the learned flow can become so ill posed the ODE solver requires timesteps that are smaller than machine precision resulting in underflow. Further, this complex flow often leads to unstable training resulting in exploding losses. As shown in <ref type="figure" target="#fig_9">Fig. 13</ref>, augmentation consistently leads to stable training and fewer NFEs, even when overfitting.</p><p>Scaling. To measure how well the models scale to larger datasets, we train NODEs and ANODEs on 200 classes of 64 × 64 ImageNet. As can be seen in <ref type="figure" target="#fig_9">Fig. 13</ref>, ANODEs scale better, achieve lower losses and train almost 10 times faster than NODEs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Relation to other models</head><p>In this section, we discuss how ANODEs compare to other relevant models.   Normalizing Flows. Similarly to NODEs, several models used for normalizing flows, such as RealNVP <ref type="bibr" target="#b6">(Dinh et al., 2016)</ref>, MAF <ref type="bibr" target="#b14">(Papamakarios et al., 2017)</ref> and Glow (Kingma &amp; Dhariwal, 2018) are homeomorphisms. The results presented in this paper may therefore also be relevant in this context. In particular, using augmentation for discrete normalizing flows may improve performance and is an interesting avenue for future research.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Scope and Future Work</head><p>In this section, we describe some limitations of ANODEs, outline potential ways they may be overcome and list ideas for future work. First, while ANODEs are faster than NODEs, they are still slower than ResNets. Second, augmentation changes the dimension of the input space which, depending on the application, may not be desirable. Finally, the augmented dimension can be seen as an extra hyperparameter to tune. While the model is robust for a range of augmented dimensions, we observed that for excessively large augmented dimensions (e.g. adding 100 channels to MNIST), the model tends to perform worse with higher losses and NFEs. We believe the ideas presented in this paper could create interesting avenues for future research, including:</p><p>Overcoming the limitations of NODEs. In order to allow trajectories to travel across each other, we augmented the space on which the ODE is solved. However, there may be other ways to achieve this, such as learning an augmentation (as in ResNets) or adding noise (similarly to <ref type="bibr" target="#b17">Wang et al. (2018)</ref>).</p><p>Augmentation for Normalizing Flows. The NFEs typically becomes prohibitively large when training continuous normalizing flow (CNF) models <ref type="bibr" target="#b7">(Grathwohl et al., 2018)</ref>. Adding augmentation to CNFs could likely mitigate this effect and we plan to explore this in future work.</p><p>Improved understanding of augmentation. It would be useful to provide more theoretical analysis for how and why augmentation improves the training of NODEs and to explore how this could guide our choice of architectures and optimizers for NODEs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusion</head><p>In this paper, we highlighted and analysed some of the limitations of Neural ODEs. We proved that there are classes of functions NODEs cannot represent and, in particular, that NODEs only learn features that are homeomorphic to the input space. We showed through experiments that this lead to slower learning and complex flows which are expensive to compute. To mitigate these issues, we proposed Augmented Neural ODEs which learn the flow from input to features in an augmented space. Our experiments show that ANODEs can model more complex functions using simpler flows while achieving lower losses, reducing computational cost, and improving stability and generalization.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A Proofs</head><p>Throughout this section, we refer to the following Initial Value Problem (IVP)</p><formula xml:id="formula_6">   dh(t) dt = f (h(t), t) h(0) = x (1) where h(t) ∈ R d and f : R d × R → R d is continuous in t and globally Lipschitz continuous in h, i.e. there is a constant C ≥ 0 such that f (h 2 (t), t) − f (h 1 (t), t) ≤ C h 2 (t) − h 1 (t)</formula><p>for all t ∈ R. These conditions imply the solutions of the IVP exist and are unique for all t (see e.g. Theorem 2.4.5 in <ref type="bibr" target="#b0">Ahmad &amp; Ambrosetti (2015)</ref>).</p><p>We define the flow φ t (x) associated to the vector field f (h(t), t) as the solution at time t of the ODE starting from the initial condition h(0) = x. The flow measures how the solutions of the ODE depend on the initial conditions. Following the analogy between ResNets and NODEs, we define the features φ(x) output by the ODE as the flow at the final time T to which we solve the ODE, i.e. φ(x) = φ T (x). Finally, we define the NODE model as the composition of the feature function φ : R d → R d and a linear map L : R d → R.</p><p>For clarity and completeness, we include proofs of all statements. Whenever propositions or theorems are already known we include references to proofs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.1 ODE trajectories do not intersect</head><p>This result is well known and proofs can be found in standard ODE textbooks (e.g. Proposition C.6 in Younes <ref type="formula">(2010)</ref>). Proposition. Let h 1 (t) and h 2 (t) be two solutions of the ODE (1) with different initial conditions, i.e. h 1 (0) = h 2 (0). Then, for all t ∈ (0, T ], h 1 (t) = h 2 (t). Informally, this proposition states that ODE trajectories cannot intersect.</p><p>Proof. Suppose there exists somet ∈ (0, T ] where h 1 (t) = h 2 (t). Define a new IVP with initial condition h(t) = h 1 (t) = h 2 (t) and solve it backwards to time t = 0. As the backwards IVP also satisfies the existence and uniqueness conditions, its solution h(t) is unique implying that its value at t = 0 is unique. This contradicts the assumption that h 1 (0) = h 2 (0) and so there is not ∈ (0, T ] such that h 1 (t) = h 2 (t).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.2 Gronwall's Lemma</head><p>We will make use of Gronwall's Lemma and state it here for completeness. We follow the statement as given in <ref type="bibr" target="#b10">Howard (1998)</ref>: </p><formula xml:id="formula_7">Theorem. Let U ⊂ R d be</formula><formula xml:id="formula_8">dh 1 (t) dt = f (h 1 (t), t), h 1 (0) = x 1 dh 2 (t) dt = f (h 2 (t), t), h 2 (0) = x 2</formula><p>Assume there is a constant C ≥ 0 such that</p><formula xml:id="formula_9">f (h 2 (t), t) − f (h 1 (t), t) ≤ C h 2 (t) − h 1 (t) Then for t ∈ [0, T ] h 2 (t) − h 1 (t) ≤ e Ct x 2 − x 1</formula><p>Proof. See e.g. <ref type="bibr" target="#b10">Howard (1998)</ref> or Theorem 3.8 in <ref type="bibr" target="#b20">Younes (2010)</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B Proof for 1d example</head><p>Let g 1d : R → R be a function such that g 1d (−1) = 1 g 1d (1) = −1 Proposition 1. The flow of an ODE cannot represent g 1d (x).</p><p>Proof. The proof follows two steps:</p><p>(a) Continuous trajectories mapping −1 to 1 and 1 to −1 must cross each other.</p><p>(b) Trajectories of ODEs cannot cross each other. This is a contradiction and implies the proposition. Part (b) was proved in Section A.1. All there is left to do is to prove part (a).</p><p>Suppose there exists an f such that there are trajectories h 1 (t) and h 2 (t) where</p><formula xml:id="formula_10">h 1 (0) = −1 h 1 (T ) = 1 h 2 (0) = 1 h 2 (T ) = −1</formula><p>As h 1 (t) and h 2 (t) are solutions of the IVP, they are continuous; see, e.g., <ref type="bibr" target="#b5">Coddington &amp; Levinson (1955)</ref>. Define the function h(t) = h 2 (t) − h 1 (t). Since both h 1 (t) and h 2 (t) are continuous, so is h(t). Now h(0) = 2 and h(T ) = −2, so by the Intermediate Value Theorem there is somet ∈ [0, T ] where h(t) = 0, i.e. where h 1 (t) = h 2 (t). So h 1 (t) and h 2 (t) intersect.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C Proof that φ t (x) is a homeomorphism</head><p>Since the following theorem plays a central part in the paper, we include a proof of it here for completeness. For a more general proof, we refer the reader to Theorem C.7 in <ref type="bibr" target="#b20">Younes (2010)</ref>.</p><p>Theorem. For all t ∈ [0, T ], φ t : R d → R d is a homeomorphism. Corollary. Features of Neural ODEs preserve the topology of the input space.</p><p>Proof. Since φ t (x) is a homeomorphism, so is φ(x) = φ T (x). Homeomorphims preserve topological properties, so Neural ODEs can only learn features which have the same topology as the input space.</p><p>This corollary implies for example that NODEs cannot break apart or create holes in a connected region of the input space.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D Proof that there are classes functions NODEs cannot represent</head><p>This section presents a proof of the main claim of the paper.</p><p>Let 0 &lt; r 1 &lt; r 2 &lt; r 3 and let g : R d → R be a function such that</p><formula xml:id="formula_11">g(x) = −1 if x ≤ r 1 g(x) = 1 if r 2 ≤ x ≤ r 3</formula><p>We denote the sphere where g(x) = −1 by A = {x : x ≤ r 1 } and the annulus where g(x) = 1 by B = {x : r 2 ≤ x ≤ r 3 } (see <ref type="figure" target="#fig_2">Fig. 15</ref>). For a set S, we write φ(S) = {y : y = φ(x), x ∈ S} to denote the feature transformation of the set. Proposition 2. Neural ODEs cannot represent g(x).</p><p>Proof. For a NODE to map points in A to −1 and points in B to +1, the linear map L must map the features in φ(A) to −1 and the features in φ(B) to +1, which implies that φ(A) and φ(B) must be linearly separable. We now show that this is not possible if φ is a homeomorphism. The feature transformation φ is a homeomorphism, so φ(int(D)) = int(φ(D)) and φ(∂D) = ∂(φ(D)), i.e. points on the boundary get mapped to points on the boundary and points in the interior to points in the interior <ref type="bibr" target="#b2">(Armstrong, 2013)</ref>. So it remains to show that int(φ(D)) and ∂(φ(D)) cannot be linearly separated. For notational convenience, we will write D = φ(D).</p><p>Suppose all points in ∂D lie above some hyperplane, i.e. suppose there exists a linear function L(x) = w T x and a constant C such that L(x) &gt; C for all x ∈ ∂D . If int(D ) were linearly separable from ∂D then L(x) &lt; C for all x ∈ int(D ). We now show that this is not the case.</p><p>Since D is a connected subset of R d (since D is connected and φ is a homeomorphism), every point x ∈ int(D ) can be written as a convex combination of points on the boundary ∂D (to see this consider a line passing through a point x in the interior and its intersection with the boundary). So if x ∈ int(D ), then</p><formula xml:id="formula_12">x = λx 1 + (1 − λ)x 2</formula><p>for some x 1 , x 2 ∈ ∂D and 0 &lt; λ &lt; 1. Now,</p><formula xml:id="formula_13">L(x) = w T x = w T (λx 1 + (1 − λ)x 2 ) = λw T x 1 + (1 − λ)w T x 2 ≥ λC + (1 − λ)C = C</formula><p>so all points in the interior are on the same side of the hyperplane as points on the boundary, that is the interior and the boundary are not linearly separable. This implies that the set of features φ(A) and φ(B) cannot be linearly separated and so that NODEs cannot represent g(x). </p><formula xml:id="formula_14">r 2 D ∂D (a) ∂D ∂D' D D' Φ (b) ℒ(x) = C x x 2 x 1 (c)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E Modeling NODEs and f (h(t), t)</head><p>In this section, we describe how to choose and model f . We first note that f can be parameterized by any standard neural net architecture, including ones with activation functions that are not everywhere differentiable such as ReLU. Existence and uniqueness of solutions to the ODE are still guaranteed and all results in this paper hold under these conditions. The function f (h(t), t) depends on both the time t and the hidden state h(t). Following the architecture used by , we model f as a CNN or an MLP with weights that are not a function of time, and instead encode the time dependency by passing a concatenated tensor (h(t), t) as input to the neural network. The architectures of the CNNs and MLPs we used are described in the following section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>F Experimental Details</head><p>We used the ODE solvers in the torchdiffeq 1 library for all experiments . We used the adaptive Dormand-Prince (Runge-Kutta 45) solver with an absolute and relative error tolerance of 1e-3. The code to reproduce all results in this paper can be found at https://github. com/EmilienDupont/augmented-neural-odes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>F.1 Architecture</head><p>Throughout all our experiments we used the ReLU activation function. We also experimented with softplus but found that this generally slowed down learning.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>F.1.1 Toy datasets</head><p>We parameterized f by an MLP with the following structure and dimensions</p><formula xml:id="formula_15">d input + 1 → d hidden → ReLU → d hidden → ReLU → d input</formula><p>where the additional dimension on the input layer is because we append the time t as an input. Choices for d input and d hidden are given for each model in the following section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>F.1.2 Image datasets</head><p>We parameterized f by a convolutional block with the following structure and dimensions • 1 × 1 conv, k filters, 0 padding.</p><p>• 3 × 3 conv, k filters, 1 padding.</p><formula xml:id="formula_16">• 1 × 1 conv, c filters, 0 padding.</formula><p>where k is specified for each architecture in the following sections and c is the number of channels (1 for MNIST and 3 for CIFAR10, SVHN and ImageNet). We append the time t as an extra channel on the feature map before each convolution.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>F.2 Hyperparameters</head><p>For the toy datasets, each experiment was repeated 20 times. The resulting plots show the mean and standard deviation for these runs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>F.2.1 Hyperparameter search</head><p>To ensure a fair comparison between models, we ran a large hyperparameter search for each model and chose the hyperparameters with the lowest loss to generate the plots in the paper. We used skorch and scikit-learn <ref type="bibr" target="#b15">(Pedregosa et al., 2011)</ref> to run the hyperparameter searches and ran 3 cross validations for each setting.</p><p>For d = 1 and d = 2 we trained on g(x) (i.e. on the dataset of concentric spheres), with 1000 points in the inner sphere and 2000 points in the outer annulus. We used r 1 = 0.5, r 2 = 1.0 and r 3 = 1.5 and trained for 50 epochs. The space of hyperparameters we searched were:</p><p>• Batch size: 64, 128</p><p>• Learning rate: 1e-3, 5-4, 1e-4</p><p>• Hidden dimension: 16, 32</p><p>• Number of layers (for ResNet): 2, 5, 10</p><p>• Number of augmented dimensions (for ANODE): 1, 2, 5</p><p>The best parameters for ResNets:</p><p>• d = 1: Batch size 64, learning rate 1e-3, hidden dimension 32, 5 layers • d = 2: Batch size 64, learning rate 1e-3, hidden dimension 32, 5 layers</p><p>The best parameters for Neural ODEs:</p><p>• d = 1: Batch size 64, learning rate 1e-3, hidden dimension 32</p><p>• d = 2: Batch size 64, learning rate 1e-3, hidden dimension 32</p><p>The best parameters for Augmented Neural ODEs:</p><p>• d = 1: Batch size 64, learning rate 1e-3, hidden dimension 32, augmented dimension 5</p><p>• d = 2: Batch size 64, learning rate 1e-3, hidden dimension 32, augmented dimension 5</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>F.2.2 Image experiments</head><p>For all image datasets, we used k = 64 filters and repeated each experiment 5 times. For models with approximately the same number of parameters we used, for MNIST </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>G Additional Results</head><p>In this section, we show additional results which were not included in the main paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>G.1 Feature space evolution</head><p>We visualize the evolution of the feature space when training a NODE on g(x) and on a separable function in <ref type="figure" target="#fig_3">Fig. 17</ref>. As can be seen, the NODE struggles to push the inner sphere out of the annulus for g(x). On the other hand, when training on the separable dataset, the NODE easily transforms the input space.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>G.2 Parameter efficiency</head><p>As noted in the main paper, when we augment the dimension of the ODEs, we also increase the number of parameters of the model. We test whether the improved performance of ANODEs is due to the higher number of parameters by training NODEs and ANODEs with the same number of parameters on MNIST and CIFAR10. As can be seen in <ref type="figure" target="#fig_4">Fig. 18</ref>, the augmented model achieves lower losses with fewer NFEs than a NODE with the same number of parameters, suggesting that ANODEs use the parameters more efficiently than NODEs. <ref type="bibr" target="#b7">Grathwohl et al. (2018)</ref> train NODE models with weight decay to reduce the NFEs. As ANODEs also achieve low NFEs, we test models with various combinations of weight decay and augmentation and show results in <ref type="figure">Fig. 19</ref>. We find that ANODEs significantly outperform NODEs even when using weight decay. However, using both weight decay and augmentation achieves the lowest NFEs at the cost of a slightly higher loss.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>G.3 Augmentation and weight decay</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>G.4 Comparing ResNets, NODEs and ANODEs</head><p>In the main paper, we compare the training time of ResNets with NODEs and the training time of NODEs with ANODEs. In <ref type="figure" target="#fig_0">Fig. 20</ref>, we compare all three methods in a single plot.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>G.5 Training accuracy</head><p>We include additional plots of training accuracy in <ref type="figure" target="#fig_0">Fig. 21</ref>. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Loss</head><p>NFEs vs Loss MNIST 84k params CIFAR10 172k params <ref type="figure" target="#fig_4">Figure 18</ref>: Losses, NFEs and NFEs vs Loss for various augmented models on MNIST and CIFAR10. Note that p indicates the size of the augmented dimension, so p = 0 corresponds to a regular NODE model.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>G.6 Additional test results for SVHN</head><p>The test loss and accuracy on SVHN as training progresses are shown in <ref type="figure" target="#fig_0">Fig. 22</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>G.7 Additional train results for SVHN</head><p>Additional results for SVHN which were not included in the main paper are shown in <ref type="figure" target="#fig_0">Fig. 23</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>G.8 Additional results for ImageNet</head><p>Additional results for ImageNet which were not included in the main paper are shown in <ref type="figure" target="#fig_0">Fig. 24</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>G.9 Examples of flows</head><p>We include further plots of flows learned by NODEs and ANODEs in <ref type="figure" target="#fig_0">Fig. 25</ref>. As can be seen, ANODEs consistently learn simple, nearly linear flows, while NODEs require more complicated flows to separate the data. <ref type="figure">Figure 19</ref>: Losses and NFEs for models with and without weight decay. ANODEs perform better than NODEs with weight decay but adding weight decay to ANODEs also reduces their NFEs at the cost of a slightly higher loss. <ref type="figure" target="#fig_0">Figure 20</ref>: Losses for various models trained on g(x) in d = 2. As can be seen, ANODEs are slightly slower than ResNets, but faster than NODEs.     NODEs, the bottom row shows results for ANODEs. The models in the left column were trained on separable data, whereas the models in the right column were trained on g(x). NODEs learn more complex flows, particularly on data which is not separable.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>ODEFigure 2 :</head><label>2</label><figDesc>Diagram of Neural ODE architecture.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>of g(x) for d = 2.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 5 :</head><label>5</label><figDesc>(a) g(x) in d = 1(b) g(x) in d = 2 (c) Separable function in d = 2Comparison of training losses of NODEs and ResNets. Compared to ResNets, NODEs struggle to fit g(x) both in d = 1 and d = 2. The difference between ResNets and NODEs is less pronounced for the separable function.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 7 :</head><label>7</label><figDesc>(Left) Loss plots for NODEs and ANODEs trained on g(x) in d = 1 (top) and d = 2 (bottom). ANODEs easily approximate the functions and are consistently faster than NODEs. (Right) Flows learned by NODEs and ANODEs. ANODEs learn simple nearly linear flows while NODEs learn complex flows that are difficult for the ODE solver to compute.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 8 :</head><label>8</label><figDesc>(Left) Evolution of features during training for ANODEs. The top left tile shows the feature space for a randomly initialized ANODE and the bottom right tile shows the features after training. (Right) Evolution of the NFEs during training for NODEs and ANODEs trained on g(x) in d = 1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 9 :Figure 10 :</head><label>910</label><figDesc>(Left) Plots of how NODEs and ANODEs map points in the input space to different outputs (both models achieve approximately the same zero training loss). As can be seen, the ANODE generalizes better. (Middle) Training and validation losses for NODE. (Right) Training and validation losses for ANODE. Training losses, NFEs and NFEs vs Loss for various augmented models on MNIST (top row) and CIFAR10 (bottom row). Note that p indicates the size of the augmented dimension, so p = 0 corresponds to a regular NODE model. Further results on SVHN and 64 × 64 ImageNet can be found in the appendix.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 11 :</head><label>11</label><figDesc>Accuracy vs NFEs for MNIST (left), CIFAR10 (middle) and SVHN (right).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 12 :</head><label>12</label><figDesc>Test accuracy (left) and loss (right) for MNIST (top) and CIFAR10 (bottom). NODE ANODE MNIST</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>Neural ODEs. Different architectures exist for training NODEs on images. for example, downsample MNIST twice with regular convolutions before applying a sequence of repeated ODE flows. These initial convolutions can be understood as implicitly augmenting the space (since they increase the number of channels). While combining NODEs with convolutions alleviates the representational limitations of NODEs, it also results in most of the attractive properties of NODEs being lost (including invertibility, ability to query state at any timestep, cheap Jacobian computations in normalizing flows and reduced number of parameters). In contrast, ANODEs overcome the representational weaknesses of NODEs while maintaining all their attractive properties.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 13 :</head><label>13</label><figDesc>Instabilities in the loss (left) and NFEs (right) when fitting NODEs to MNIST. In the latter stages of training, NODEs can become unstable and the loss and NFEs become erratic.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 14 :</head><label>14</label><figDesc>Accuracy (left) and loss (right) on 64 × 64 ImageNet for NODEs and ANODEs.ResNets. Since ResNets can be interpreted as discretized equivalents of NODEs, it is interesting to consider how augmenting the space could affect the training of ResNets. Indeed, most ResNet architectures<ref type="bibr" target="#b9">(He et al., 2016;</ref><ref type="bibr" target="#b19">Xie et al., 2017;</ref><ref type="bibr" target="#b21">Zagoruyko &amp; Komodakis, 2016)</ref> already employ a form of augmentation by performing convolutions with a large number of filters before applying residual blocks. This effectively corresponds to augmenting the space by the number of filters minus the number of channels in the original image. Further,<ref type="bibr" target="#b3">Behrmann et al. (2018)</ref> and<ref type="bibr" target="#b1">Ardizzone et al. (2018)</ref> also augment the input with zeros to build invertible ResNets and transformations. Our findings in the continuous case are consistent with theirs: augmenting the input with zeros improves performance. However, an important consequence of using augmentation for NODEs is the reduced computational cost, which does not have an analogy in ResNets.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head></head><label></label><figDesc>an open set. Let f : U × [0, T ] → R d be a continuous function and let h 1 , h 2 : [0, T ] → U satisfy the IVPs:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 15 :</head><label>15</label><figDesc>(a) Diagram of g(x) in 2d. (b) An example of the map φ(x) from input data to features necessary to represent g(x) (which NODEs cannot learn).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head></head><label></label><figDesc>Define a disk D ⊂ R d by D = {x ∈ R d : x ≤ r 2 } with boundary ∂D = {x ∈ R d : x = r 2 } and interior int(D) = {x ∈ R d : x &lt; r 2 }. Now A ⊂ int(D), A ∩ ∂D = ∅ and ∂D ⊂ B, that is all points in ∂D should be mapped to +1 (i.e. they are in B) and a subset of points in int(D) should be mapped to −1 (i.e. they are in A). So if φ(int(D)) and φ(∂D) are not linearly separable, then neither are φ(A) or φ(B).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Figure 16 :</head><label>16</label><figDesc>(a) Diagram of the disk D and its boundary. The boundary is equal to the inner boundary of B. (b) An example of how φ transforms the disk. (c)The boundary of the transformed set is above the hyperplane, which implies that all points on the interior must also be above the hyperplane.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Figure 17 :</head><label>17</label><figDesc>Evolution of the feature space during training. The leftmost tile shows the feature space for a randomly initialized NODE and the rightmost tile shows the feature space after training. The top row shows a model trained on g(x) and the bottow row a model trained on a separable function.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>Figure 21 :</head><label>21</label><figDesc>Training accuracy for MNIST (left), CIFAR10 (middle) and SVHN (right).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head>Figure 22 :</head><label>22</label><figDesc>Test loss and accuracy during training for SVHN.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_18"><head>Figure 23 :</head><label>23</label><figDesc>Loss, NFEs, loss vs NFEs during training for NODEs and ANODEs on SVHN.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_19"><head>Figure 24 :</head><label>24</label><figDesc>NFEs, loss vs NFEs and accuracy vs NFEs during training for NODEs and ANODEs on 64 × 64 ImageNet.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_20"><head>Figure 25 :</head><label>25</label><figDesc>Flows learned by NODEs and ANODEs trained on various datasets. The top row shows results for</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 1 :</head><label>1</label><figDesc></figDesc><table /><note>Test accuracies and their standard deviation over 5 runs on various image datasets.</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>•</head><label></label><figDesc>NODE: 92 filters → 84,395 parameters • ANODE: 64 filters, augmented dimension 5 → 84,816 parameters and for CIFAR10 and SVHN • NODE: 125 filters → 172,358 parameters • ANODE: 64 filters, augmented dimension 10 → 171,799 parameters For the ImageNet experiments, we used the Tiny ImageNet dataset consisting of 200 classes of 64 × 64 images. We also repeated each experiment 5 times. We used models with approximately the same number of parameters, specifically: • NODE: 164 filters → 366,269 parameters • ANODE: 64 filters, augmented dimension 5 → 365,714 parameters For all image experiments, we used a batch size of 256.</figDesc><table /><note></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1">https://github.com/rtqichen/torchdiffeq</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>We would like to thank Anthony Caterini, Daniel Paulin, Abraham Ng, Joost Van Amersfoort and Hyunjik Kim for helpful discussions and feedback. Emilien gratefully acknowledges his PhD funding from Google DeepMind. Arnaud Doucet acknowledges support of the UK Defence Science and Technology Laboratory (Dstl) and Engineering and Physical Research Council (EPSRC) under grant EP/R013616/1. This is part of the collaboration between US DOD, UK MOD and UK EPSRC under the Multidisciplinary University Research Initiative. Yee Whye Teh's research leading to these results has received funding from the European Research Council under the European Union's Seventh Framework Programme (FP7/2007-2013) ERC grant agreement no. 617071.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Proof. In order to prove that φ t is a homemorphism, we need to show that</p><p>Part (a). Consider two initial conditions of the ODE system, h 1 (0) = x and h 2 (0) = x + δ where δ is some perturbation. By Gronwall's Lemma, we have</p><p>Part (b). Suppose there exists initial conditions x 1 = x 2 such that φ t (x 1 ) = φ t (x 2 ). We define the IVP starting from φ t (x 1 ) and solve it backwards to time t = 0. The solution of the IVP is unique, so it cannot map φ t (x 1 ) back to both x 1 and x 2 . So for each x 1 = x 2 , we must have φ t (x 1 ) = φ t (x 2 ), that is the map between x and φ t (x) is one-to-one.</p><p>Part (c). To check that the inverse φ −1 t is continuous, we note that we can set the initial condition to h(t) = φ t (x) and solve the IVP backwards in time (as it satisfies the existence and uniqueness conditions). The same reasoning as part (a) then applies.</p><p>Therefore φ t is a continuous bijection and its inverse is continuous, i.e. it is a homeomorphism.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">A Textbook on Ordinary Differential Equations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shair</forename><surname>Ahmad</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Antonio</forename><surname>Ambrosetti</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2015" />
			<publisher>Springer</publisher>
			<biblScope unit="volume">88</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jakob</forename><surname>Lynton Ardizzone</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sebastian</forename><surname>Kruse</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Wirkert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eric</forename><forename type="middle">W</forename><surname>Rahner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ralf</forename><forename type="middle">S</forename><surname>Pellegrini</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lena</forename><surname>Klessen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Carsten</forename><surname>Maier-Hein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ullrich</forename><surname>Rother</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Köthe</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1808.04730</idno>
		<title level="m">Analyzing inverse problems with invertible neural networks</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Basic Topology</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Armstrong</forename><surname>Mark Anthony</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013" />
			<publisher>Springer Science &amp; Business Media</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jens</forename><surname>Behrmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Duvenaud</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jörn-Henrik</forename><surname>Jacobsen</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1811.00995</idno>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
	<note type="report_type">Invertible residual networks. arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Neural ordinary differential equations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yulia</forename><surname>Tian Qi Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jesse</forename><surname>Rubanova</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Bettencourt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Duvenaud</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">32nd Conference on Neural Information Processing Systems</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Theory of Ordinary Differential Equations. Tata McGraw-Hill Education</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Earl</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Norman</forename><surname>Coddington</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Levinson</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1955" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Laurent</forename><surname>Dinh</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1605.08803</idno>
		<title level="m">Jascha Sohl-Dickstein, and Samy Bengio. Density estimation using real nvp</title>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Will</forename><surname>Grathwohl</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">Q</forename><surname>Ricky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jesse</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ilya</forename><surname>Betterncourt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Sutskever</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Duvenaud</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1810.01367</idno>
		<title level="m">Ffjord: Free-form continuous dynamics for scalable reversible generative models</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Stable architectures for deep neural networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eldad</forename><surname>Haber</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lars</forename><surname>Ruthotto</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inverse Problems</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page">14004</biblScope>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Deep residual learning for image recognition</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kaiming</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xiangyu</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shaoqing</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jian</forename><surname>Sun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE conference on computer vision and pattern recognition</title>
		<meeting>the IEEE conference on computer vision and pattern recognition</meeting>
		<imprint>
			<date type="published" when="2016" />
			<biblScope unit="page" from="770" to="778" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">The Gronwall inequality</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ralph</forename><surname>Howard</surname></persName>
		</author>
		<ptr target="http://people.math.sc.edu/howard/Notes/gronwall.pdf" />
		<imprint>
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Glow: Generative flow with invertible 1x1 convolutions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Durk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Prafulla</forename><surname>Kingma</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Dhariwal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems</title>
		<imprint>
			<date type="published" when="2018" />
			<biblScope unit="page" from="10215" to="10224" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Resnet with one-neuron hidden layers is a universal approximator</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hongzhou</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stefanie</forename><surname>Jegelka</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">32nd Conference on Neural Information Processing Systems</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yiping</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Aoxiao</forename><surname>Zhong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Quanzheng</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bin</forename><surname>Dong</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1710.10121</idno>
		<title level="m">Beyond finite layer neural networks: Bridging deep architectures and numerical differential equations</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Masked autoregressive flow for density estimation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">George</forename><surname>Papamakarios</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Theo</forename><surname>Pavlakou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Iain</forename><surname>Murray</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems</title>
		<imprint>
			<date type="published" when="2017" />
			<biblScope unit="page" from="2338" to="2347" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Scikit-learn: Machine learning in python</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fabian</forename><surname>Pedregosa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gaël</forename><surname>Varoquaux</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alexandre</forename><surname>Gramfort</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vincent</forename><surname>Michel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bertrand</forename><surname>Thirion</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Olivier</forename><surname>Grisel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mathieu</forename><surname>Blondel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Prettenhofer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ron</forename><surname>Weiss</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vincent</forename><surname>Dubourg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of machine learning research</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="2825" to="2830" />
			<date type="published" when="2011-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lars</forename><surname>Ruthotto</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eldad</forename><surname>Haber</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1804.04272</idno>
		<title level="m">Deep neural networks motivated by partial differential equations</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bao</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Binjie</forename><surname>Yuan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zuoqiang</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stanley</forename><forename type="middle">J</forename><surname>Osher</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1811.10745</idno>
		<title level="m">Enresnet: Resnet ensemble via the Feynman-Kac formalism</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">A proposal on machine learning via dynamical systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Weinan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications in Mathematics and Statistics</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="11" />
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Aggregated residual transformations for deep neural networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Saining</forename><surname>Xie</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ross</forename><surname>Girshick</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Piotr</forename><surname>Dollár</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhuowen</forename><surname>Tu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kaiming</forename><surname>He</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition</title>
		<meeting>the IEEE Conference on Computer Vision and Pattern Recognition</meeting>
		<imprint>
			<date type="published" when="2017" />
			<biblScope unit="page" from="1492" to="1500" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Shapes and Diffeomorphisms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Laurent</forename><surname>Younes</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2010" />
			<publisher>Springer Science &amp; Business Media</publisher>
			<biblScope unit="volume">171</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sergey</forename><surname>Zagoruyko</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nikos</forename><surname>Komodakis</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1605.07146</idno>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
	<note type="report_type">Wide residual networks. arXiv preprint</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
