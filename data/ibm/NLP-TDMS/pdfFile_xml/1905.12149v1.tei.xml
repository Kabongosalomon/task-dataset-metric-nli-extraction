<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /nfs/home/kabenamualus/Research/task-dataset-metric-extraction/../grobid-0.6.0/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">SATNet: Bridging deep learning and logical reasoning using a differentiable satisfiability solver</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Po-Wei</forename><surname>Wang</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">School of Computer Science</orgName>
								<orgName type="institution">Carnegie Mellon University</orgName>
								<address>
									<settlement>Pittsburgh</settlement>
									<region>Pennsylvania</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Priya</forename><forename type="middle">L</forename><surname>Donti</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">School of Computer Science</orgName>
								<orgName type="institution">Carnegie Mellon University</orgName>
								<address>
									<settlement>Pittsburgh</settlement>
									<region>Pennsylvania</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">Department of Engineering &amp; Public Policy</orgName>
								<orgName type="institution">Carnegie Mellon University</orgName>
								<address>
									<settlement>Pittsburgh, Pennsyl-vania</settlement>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bryan</forename><surname>Wilder</surname></persName>
							<affiliation key="aff2">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Southern California</orgName>
								<address>
									<settlement>Los Angeles</settlement>
									<region>California</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zico</forename><surname>Kolter</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">School of Computer Science</orgName>
								<orgName type="institution">Carnegie Mellon University</orgName>
								<address>
									<settlement>Pittsburgh</settlement>
									<region>Pennsylvania</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
							<affiliation key="aff3">
								<orgName type="department">Bosch Center for Artificial Intelligence</orgName>
								<address>
									<settlement>Pittsburgh</settlement>
									<region>Pennsylvania</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">SATNet: Bridging deep learning and logical reasoning using a differentiable satisfiability solver</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<note>Cor-respondence to: Po-Wei Wang &lt;poweiw@cs.cmu.edu&gt;, Priya Donti &lt;pdonti@cmu.edu&gt;, Bryan Wilder &lt;bwilder@usc.edu&gt;, Zico Kolter &lt;zkolter@cs.cmu.edu&gt;. Proceedings of the 36 th International Conference on Machine Learning, Long Beach, California, PMLR 97, 2019. Copyright 2019 by the author(s).</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>

		<encodingDesc>
			<appInfo>
				<application version="0.6.0" ident="GROBID-SDO" when="2021-06-26T06:42+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid-sdo"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Integrating logical reasoning within deep learning architectures has been a major goal of modern AI systems. In this paper, we propose a new direction toward this goal by introducing a differentiable (smoothed) maximum satisfiability (MAXSAT) solver that can be integrated into the loop of larger deep learning systems. Our (approximate) solver is based upon a fast coordinate descent approach to solving the semidefinite program (SDP) associated with the MAXSAT problem. We show how to analytically differentiate through the solution to this SDP and efficiently solve the associated backward pass. We demonstrate that by integrating this solver into end-to-end learning systems, we can learn the logical structure of challenging problems in a minimally supervised fashion. In particular, we show that we can learn the parity function using single-bit supervision (a traditionally hard task for deep networks) and learn how to play 9 × 9 Sudoku solely from examples. We also solve a "visual Sudoku" problem that maps images of Sudoku puzzles to their associated logical solutions by combining our MAXSAT solver with a traditional convolutional architecture. Our approach thus shows promise in integrating logical structures within deep learning.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Although modern deep learning has produced groundbreaking improvements in a variety of domains, state-of-the-art methods still struggle to capture "hard" and "global" constraints arising from discrete logical relationships. Motivated by this deficiency, there has been a great deal of recent interest in integrating logical or symbolic reasoning into neural network architectures <ref type="bibr" target="#b15">(Palm et al., 2017;</ref><ref type="bibr">Yang et al., 2017;</ref><ref type="bibr" target="#b2">Cingillioglu &amp; Russo, 2018;</ref><ref type="bibr" target="#b6">Evans &amp; Grefenstette, 2018)</ref>. However, with few exceptions, previous work primarily focuses on integrating preexisting relationships into a larger differentiable system via tunable continuous parameters, not on discovering the discrete relationships that produce a set of observations in a truly end-to-end fashion. As an illustrative example, consider the popular logic-based puzzle game Sudoku, in which a player must fill in a 9 × 9 partially-filled grid of numbers to satisfy specific constraints. If the rules of Sudoku (i.e. the relationships between problem variables) are not given, then it may be desirable to jointly learn the rules of the game and learn how to solve Sudoku puzzles in an end-to-end manner.</p><p>We consider the problem of learning logical structure specifically as expressed by satisfiability problems -concretely, problems that are well-modeled as instances of SAT or MAXSAT (the optimization analogue of SAT). This is a rich class of domains encompassing much of symbolic AI, which has traditionally been difficult to incorporate into neural network architectures since neural networks rely on continuous and differentiable parameterizations. Our key contribution is to develop and derive a differentiable smoothed MAXSAT solver that can be embedded within more complex deep architectures, and show that this solver enables effective end-to-end learning of logical relationships from examples (without hard-coding of these relationships). More specifically, we build upon recent work in fast block coordinate descent methods for solving <ref type="bibr">SDPs (Wang et al., 2017)</ref> to build a differentiable solver for the smoothed SDP relaxation of MAXSAT. We provide an efficient mechanism to differentiate through the optimal solution of this SDP by using a similar block coordinate descent solver as used in the forward pass. Our module is amenable to GPU acceleration, greatly improving training scalability. <ref type="bibr">arXiv:1905.12149v1 [cs.</ref>LG] 29 May 2019</p><p>Using this framework, we are able to solve several problems that, despite their simplicity, prove essentially impossible for traditional deep learning methods and existing logical learning methods to reliably learn without any prior knowledge. In particular, we show that we can learn the parity function, known to be challenging for deep classifiers <ref type="bibr">(Shalev-Shwartz et al., 2017)</ref>, with only single bit supervision. We also show that we can learn to play 9 × 9 Sudoku, a problem that is challenging for modern neural network architectures <ref type="bibr" target="#b15">(Palm et al., 2017)</ref>. We demonstrate that our module quickly recovers the constraints that describe a feasible Sudoku solution, learning to correctly solve 98.3% of puzzles at test time without any hand-coded knowledge of the problem structure. Finally, we show that we can embed this differentiable solver into larger architectures, solving a "visual Sudoku" problem where the input is an image of a Sudoku puzzle rather than a binary representation. We show that, in a fully end-to-end setting, our method is able to integrate classical convolutional networks (for digit recognition) with the differentiable MAXSAT solver (to learn the logical portion). Taken together, this presents a substantial advance toward a major goal of modern AI: integrating logical reasoning into deep learning architectures.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Related work</head><p>Recently, the deep learning community has given increasing attention to the concept of embedding complex, "nontraditional" layers within deep networks in order to train systems end-to-end. Major examples have included logical reasoning modules and optimization layers. Our work combines research in these two areas by exploiting optimizationbased relaxations of logical reasoning structures, namely an SDP relaxation of MAXSAT. We explore each of these relevant areas of research in more detail below.</p><p>Logical reasoning in deep networks. Our work is closely related to recent interest in integrating logical reasoning into deep learning architectures <ref type="bibr" target="#b7">(Garcez et al., 2015)</ref>. Most previous systems have focused on creating differentiable modules from an existing set of known relationships, so that a deep network can learn the parameters of these relationships <ref type="bibr" target="#b3">(Dai et al., 2018;</ref><ref type="bibr" target="#b14">Manhaeve et al., 2018;</ref><ref type="bibr">Sourek et al., 2018;</ref><ref type="bibr" target="#b3">Xu et al., 2018;</ref><ref type="bibr" target="#b10">Hu et al., 2016;</ref><ref type="bibr">Yang et al., 2017;</ref><ref type="bibr" target="#b18">Selsam et al., 2018)</ref>. For example, <ref type="bibr" target="#b15">Palm et al. (2017)</ref> introduce a network that carries out relational reasoning using hand-coded information about which variables are allowed to interact, and test this network on 9 × 9 Sudoku. Similarly, <ref type="bibr" target="#b6">Evans &amp; Grefenstette (2018)</ref> integrate inductive logic programming into neural networks by constructing differentiable SAT-based representations for specific "rule templates." While these networks are seeded with prior information about the relationships between variables, our approach learns these relationships and their associated pa-rameters end-to-end. While other recent work has also tried to jointly learn rules and parameters, the problem classes captured by these architectures have been limited. For instance, <ref type="bibr" target="#b2">Cingillioglu &amp; Russo (2018)</ref> train a neural network to apply a specific class of logic programs, namely the binary classification problem of whether a given set of propositions entails a specific conclusion. While this approach does not rely on prior hand-coded structure, our method applies to a broader class of domains, encompassing any problem reducible to MAXSAT.</p><p>Differentiable optimization layers. Our work also fits within a line of research leveraging optimization as a layer in neural networks. For instance, previous work has introduced differentiable modules for quadratic programs <ref type="bibr" target="#b5">Donti et al., 2017)</ref>, submodular optimization problems <ref type="bibr" target="#b4">(Djolonga &amp; Krause, 2017;</ref><ref type="bibr">Tschiatschek et al., 2018;</ref><ref type="bibr">Wilder et al., 2018)</ref>, and equilibrium computation in zero-sum games <ref type="bibr" target="#b13">(Ling et al., 2018)</ref>. To our knowledge, ours is the first work to use differentiable SDP relaxations to capture relationships between discrete variables.</p><p>MAXSAT SDP relaxations. We build on a long line of research exploring SDP relaxations as a tool for solving MAXSAT and related problems. Classical work shows that such relaxations produce strong approximation guarantees for MAXCUT and MAX-2SAT <ref type="bibr" target="#b8">(Goemans &amp; Williamson, 1995)</ref>, and are empirically tighter than standard linear programming relaxations <ref type="bibr" target="#b9">(Gomes et al., 2006)</ref>. More recent work, e.g. <ref type="bibr">Wang et al. (2017)</ref>; Wang &amp; Kolter (2019), has developed low-rank SDP solvers for general MAXSAT problems. We extend the work of <ref type="bibr">Wang et al. (2017)</ref> to create a differentiable optimization-based MAXSAT solver that can be employed in the loop of deep learning.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">A differentiable satisfiability solver</head><p>The MAXSAT problem is the optimization analogue of the well-known satisfiability (SAT) problem, in which the goal is to maximize the number of clauses satisfied. We present a differentiable, smoothed approximate MAXSAT solver that can be integrated into modern deep network architectures. This solver uses a fast coordinate descent approach to solving an SDP relaxation of MAXSAT. We describe our MAXSAT SDP relaxation as well as the forward pass of our MAXSAT deep network layer (which employs this relaxation). We then show how to analytically differentiate through the MAXSAT SDP and efficiently solve the associated backward pass.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">Solving an SDP formulation of satisfiability</head><p>Consider a MAXSAT instance with n variables and m clauses. Letṽ ∈ {−1, 1} n denote binary assignments of the problem variables, whereṽ i is the truth value of</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>SDP relaxation (weights )</head><formula xml:id="formula_0"># ∈ ℝ &amp; for ∈ ( ∈ ℝ &amp; for ∈ # ∈ 0, 1 for ∈ ( ∈ 0, 1 for ∈ Inputs (discrete or probabilistic) relax round</formula><p>Outputs (discrete or probabilistic) MAXSAT Layer</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Relaxed inputs</head><p>Relaxed outputs <ref type="figure">Figure 1</ref>. The forward pass of our MAXSAT layer. The layer takes as input the discrete or probabilistic assignments of known MAXSAT variables, and outputs guesses for the assignments of unknown variables via a MAXSAT SDP relaxation with weights S.</p><p>variable i ∈ {1, . . . , n}, and defines i ∈ {−1, 0, 1} m for i ∈ {1, . . . , n}, wheres ij denotes the sign ofṽ i in clause j ∈ {1, . . . , m}. We then write the MAXSAT problem as</p><formula xml:id="formula_1">maximizẽ v∈{−1,1} n m j=1 n i=1 1{s ijṽi &gt; 0}.<label>(1)</label></formula><p>As derived in <ref type="bibr" target="#b8">Goemans &amp; Williamson (1995)</ref>; <ref type="bibr">Wang &amp; Kolter (2019)</ref>, to form a semidefinite relaxation of (1), we first relax the discrete variablesṽ i into associated continuous variables v i ∈ R k , v i = 1 with respect to some "truth direction" v ∈ R k , v = 1. Specifically, we relate the continuous v i to the discreteṽ i probabilistically via P (ṽ i = 1) = cos −1 (−v T i v ) /π based on randomized rounding <ref type="bibr" target="#b8">(Goemans &amp; Williamson (1995)</ref>; see Section 3.2.4). We additionally define a coefficient vectors = {−1} m associated with v . Our SDP relaxation of MAXSAT is then <ref type="bibr">n+1)</ref> . We note that this problem is a low-rank (but non-convex) formulation of MIN-UNSAT, which is equivalent to MAXSAT. This formulation can be rewritten as an SDP, and has been shown to recover the optimal SDP solution given k &gt; √ 2n <ref type="bibr" target="#b1">(Barvinok, 1995;</ref><ref type="bibr" target="#b17">Pataki, 1998)</ref>.</p><formula xml:id="formula_2">minimize V ∈R k×(n+1) S T S, V T V , subject to v i = 1, i = , 1, . . . , n (2) where V ≡ v v 1 . . . v n ∈ R k×(n+1) , and S ≡ s s 1 . . .s n diag( 1 / √ 4|sj |) ∈ R m×(</formula><p>Despite its non-convexity, problem (2) can then be solved optimally via coordinate descent for all i = , 1, . . . , n. In particular, the objective terms that depend on v i are given by v T i n j=0 s T i s j v j , where s i is the ith column vector of S. Minimizing this quantity over v i subject to the constraint that v i = 1 yields the coordinate descent update</p><formula xml:id="formula_3">v i = −g i / g i , where g i = V S T s i − s i 2 v i .<label>(3)</label></formula><p>These updates provably converge to the globally optimal fixed point of the SDP (2) <ref type="bibr">(Wang et al., 2017)</ref>. A more detailed derivation of this update can be found in Appendix A.</p><p>Algorithm 1 SATNet Layer The outputs Z O are generated from inputs Z I via the SDP (2), and the weights of our layer correspond to the SDP's low-rank coefficient matrix S. This forward pass procedure is pictured in <ref type="figure">Figure 1</ref>. We describe the steps of layer initialization and the forward pass in Algorithm 1, and in more detail below.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.1.">LAYER INITIALIZATION</head><p>When initializing SATNet, the user must specify a maximum number of clauses m that this layer can represent. It is often desirable to set m to be low; in particular, low-rank structure can prevent overfitting and thus improve generalization.</p><p>Given this low-rank structure, a user may wish to somewhat increase the layer's representational ability via auxiliary variables. The high-level intuition here follows from the conjunctive normal form (CNF) representation of boolean satisfaction problems; adding additional variables to a problem can dramatically reduce the number of CNF clauses needed to describe that problem, as these variables play a role akin to register memory that is useful for inference.</p><p>Finally, we set k = √ 2n + 1, where here n captures the number of actual problem variables in addition to auxiliary variables. This is the minimum value of k required for our MAXSAT relaxation (2) to recover the optimal solution of its associated SDP <ref type="bibr" target="#b1">(Barvinok, 1995;</ref><ref type="bibr" target="#b17">Pataki, 1998)</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.2.">STEP 1: RELAXING LAYER INPUTS</head><p>Our layer first relaxes its inputs Z I into continuous vectors for use in the SDP formulation (2). That is, we relax each layer input z ι , ι ∈ I to an associated random unit vector</p><formula xml:id="formula_4">v ι ∈ R k so that v T ι v = − cos(πz ι ).<label>(4)</label></formula><p>(This equation is derived from the probabilistic relationship described in Section 3.1 between discrete variables and their continuous relaxations.) Constraint (4) can be satisfied by</p><formula xml:id="formula_5">v ι = − cos(πz ι )v + sin(πz ι )(I k − v v T )v rand ι , (5) where v rand ι</formula><p>is a random unit vector. For simplicity, we use the notation V I ∈ R k×|I| (i.e. the I-indexed column subset of V ) to collectively refer to all relaxed layer inputs derived via Equation <ref type="formula">(5)</ref> Our coordinate descent algorithm for the forward pass is detailed in Algorithm 2. This algorithm maintains the term Ω = V S T needed to compute g o , and then modifies it via a rank-one update during each inner iteration. Accordingly, the per-iteration runtime is O(nmk) (and in practice, only a small number of iterations is required for convergence).</p><p>Algorithm 2 Forward pass coordinate descent <ref type="formula" target="#formula_3">(3)</ref> 8:</p><formula xml:id="formula_6">1: input V I // inputs for known variables 2: init v o with random vector v rand o , ∀o ∈ O. 3: compute Ω = V S T 4: while not converged do 5: for o ∈ O do // for all output variables 6: compute g o = Ωs o − s o 2 v o as in (3) 7: compute v o = −g o / g o as in</formula><p>update</p><formula xml:id="formula_7">Ω = Ω + (v o − v prev o )s T o 9: output V O // final guess for output cols of V 3.2.4. STEP 3: GENERATING DISCRETE OR PROBABILISTIC OUTPUTS</formula><p>Given the relaxed outputs V O from coordinate descent, our layer converts these outputs to discrete or probabilistic variable assignments Z O via either thresholding or randomized rounding (which we describe here).</p><p>The main idea of randomized rounding is that for every v o , o ∈ O, we can take a random hyperplane r from the unit sphere and assigñ</p><formula xml:id="formula_8">v o = 1 if sign(v T o r) = sign(v T r) −1 otherwise , o ∈ O,<label>(6)</label></formula><p>whereṽ o is the boolean output for v o . Intuitively, this scheme setsṽ o to "true" if and only if v o and the truth vector v are on the same side of the random hyperplane r. Given the correct weights S, this randomized rounding procedure assures an optimal expected approximation ratio for certain NP-hard problems <ref type="bibr" target="#b8">(Goemans &amp; Williamson, 1995)</ref>.</p><p>During training, we do not explicitly perform randomized rounding. We instead note that the probability that v o and v are on the same side of any given r is</p><formula xml:id="formula_9">P (ṽ o ) = cos −1 (−v T o v )/π,<label>(7)</label></formula><p>and thus set z o = P (ṽ o ) to equal this probability.</p><p>During testing, we can either output probabilistic outputs in the same fashion, or output discrete assignments via thresholding or randomized rounding. If using randomized rounding, we round multiple times, and then set z o to be the boolean solution maximizing the MAXSAT objective in Equation <ref type="formula" target="#formula_1">(1)</ref>. Prior work has observed that such repeated rounding improves approximation ratios in practice, especially for MAXSAT problems (Wang &amp; Kolter, 2019).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.">Computing the backward pass</head><p>We now derive backpropagation updates through our SAT-Net layer to enable its integration into a neural network. That is, given the gradients ∂ /∂Z O of the network loss with respect to the layer outputs, we must compute the gradients ∂ /∂Z I with respect to layer inputs and ∂ /∂S with respect to layer weights. As it would be inefficient in terms of time and memory to explicitly unroll the forward-pass computations and store intermediate Jacobians, we instead derive analytical expressions to compute the desired gradients directly, employing an efficient coordinate descent algorithm. The procedure for computing these gradients is summarized in Algorithm 1 and derived below.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.1.">FROM PROBABILISTIC OUTPUTS TO THEIR</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>CONTINUOUS RELAXATIONS</head><p>Given ∂ /∂Z O (with respect to the layer outputs), we first derive an expression for ∂ /∂V O (with respect to the output relaxations) by pushing gradients through the probability assignment mechanism described in Section 3.2.4. That is,</p><formula xml:id="formula_10">for each o ∈ O, ∂ ∂v o = ∂ ∂z o ∂z o ∂v o = ∂ ∂z o 1 π sin(πz o ) v ,<label>(8)</label></formula><p>where we obtain ∂zo /∂vo by differentiating through Equation (7) (or, more readily, by implicitly differentiating through its rearrangement cos</p><formula xml:id="formula_11">(πz o ) = −v T v o ).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.2.">BACKPROPAGATION THROUGH THE SDP</head><p>Given the analytical form for ∂ /∂V O (with respect to the output relaxations), we next seek to derive ∂ /∂V I (with respect to the input relaxations) and ∂ /∂S (with respect to the layer weights) by pushing gradients through our SDP solution procedure (Section 3.2.3). We describe the analytical form for the resultant gradients in Theorem 1.</p><formula xml:id="formula_12">Theorem 1. Define P o ≡ I k − v o v T o for each o ∈ O.</formula><p>Then, define U ∈ R k×n , where the columns U I = 0 and the columns U O are given by</p><formula xml:id="formula_13">vec(U O ) = (P ((C + D) ⊗ I k )P ) † vec ∂ ∂V O , (9) where P ≡ diag(P o ), where C ≡ S T O S O − diag( s o 2 ), and where D ≡ diag( g o ).</formula><p>Then, the gradient of the network loss with respect to the relaxed layer inputs is</p><formula xml:id="formula_14">∂ ∂V I = − o∈O u o s T o S I ,<label>(10)</label></formula><p>where S I is the I-indexed column subset of S, and the gradient with respect to the layer weights is</p><formula xml:id="formula_15">∂ ∂S = − o∈O u o s T o T V − (SV T )U.<label>(11)</label></formula><p>We defer the derivation of Theorem 1 to Appendix B. Although this derivation is somewhat involved, the concept </p><formula xml:id="formula_16">compute dg o = Ψs o − s o 2 u o − ∂ /∂v o . 7: compute u o = −P o dg o / g o . 8: update Ψ = Ψ + (u o − u prev o )s T o 9: output U O</formula><p>at a high level is quite simple: we differentiate the solution of the SDP problem (Section 3.1) with respect to the problem's parameters and input, which requires computing the (relatively large) matrix-vector solve given in Equation <ref type="formula">(9)</ref>.</p><p>To solve Equation <ref type="formula">(9)</ref>, we use a coordinate descent approach that closely mirrors the coordinate descent procedure employed in the forward pass, and which has similar fast convergence properties. This procedure, described in Algorithm 3, enables us to compute the desired gradients without needing to maintain intermediate Jacobians explicitly. Mirroring the forward pass, we use rank-one updates to maintain and modify the term Ψ = U S T needed to compute dg o , which again enables our algorithm to run in O(nmk) time.</p><p>We defer the derivation of Algorithm 3 to Appendix D.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.3.">FROM RELAXED TO ORIGINAL INPUTS</head><p>As a final step, we must use the gradient ∂ /∂V I (with respect to the input relaxations) to derive the gradient ∂ /∂Z I (with respect to the actual inputs) by pushing gradients through the input relaxation procedure described in Section 3.2.2. For each ι ∈ I, we see that</p><formula xml:id="formula_17">∂ ∂z ι = ∂ ∂z ι + ∂ ∂v ι T ∂v ι ∂z ι = ∂ ∂z ι − ∂v ι ∂z ι T o∈O u o s T o s ι<label>(12)</label></formula><p>where</p><formula xml:id="formula_18">∂v ι ∂z ι = π sin(πz ι )v + cos(πz ι )(I k − v v T )v rand ι ,<label>(13)</label></formula><p>and where ∂ /∂z ι captures any direct dependence of on z ι (as opposed to dependence through v ι ). Here, the expression for ∂ /∂vι comes from Equation <ref type="formula" target="#formula_1">(10)</ref>, and we obtain ∂vι /∂zι by differentiating Equation (5).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.">An efficient GPU implementation</head><p>The coordinate descent updates in Algorithms 2 and 3 dominate the computational costs of the forward and backward passes, respectively. We thus present an efficient, parallel GPU implementation of these algorithms to speed up training and inference. During the inner loop of coordinate descent, our implementation parallelizes the computation of all g o (dg o ) terms by parallelizing the computation of Ω (Ψ), as well as of all rank-one updates of Ω (Ψ). This underscores the benefit of using a low-rank SDP formulation in our MAXSAT layer, as traditional full-rank coordinate descent cannot be efficiently parallelized. We find in our preliminary benchmarks that our GPU CUDA-C implementation is up to 18 − 30x faster than the corresponding OpenMP implementation run on Xeon CPUs. Source code for our implementation is available at https://github.com/locuslab/SATNet.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Experiments</head><p>We test our MAXSAT layer approach in three domains that are traditionally difficult for neural networks: learning the parity function with single-bit supervision, learning 9 × 9 Sudoku solely from examples, and solving a "visual Sudoku" problem that generates the logical Sudoku solution given an input image of a Sudoku puzzle. We find that in all cases, we are able to perform substantially better on these tasks than previous deep learning-based approaches.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.">Learning parity (chained XOR)</head><p>This experiment tests SATNet's ability to differentiate through many successive SAT problems by learning to compute the parity function. The parity of a bit string is defined as one if there is an odd number of ones in the sequence and zero otherwise. The task is to map input sequences to their parity, given a dataset of example sequence/parity pairs. Learning parity functions from such single-bit supervision is known to pose difficulties for conventional deep learning approaches <ref type="bibr">(Shalev-Shwartz et al., 2017)</ref>. However, parity is simply a logic function -namely, a sequence of XOR operations applied successively to the input sequence.</p><p>Hence, for a sequence of length L, we construct our model to contain a sequence of L − 1 SATNet layers with tied weights (similar to a recurrent network). The first layer receives the first two binary values as input, and layer d receives value d along with the rounded output of layer d − 1. If each layer learns to compute the XOR function, the combined system will correctly compute parity. However, this requires the model to coordinate a long series of SAT problems without any intermediate supervision. &amp; Ba, 2015) with a learning rate of 10 −1 . We compare to an LSTM sequence classifier, which uses 100 hidden units and a learning rate of 10 −3 (we tried varying the architecture and learning rate but did not observe any improvement).</p><p>In each case, our model quickly learns the target function, with error on the held-out set converging to zero within 20 epochs. In contrast, the LSTM is unable to learn an appropriate representation, with only minor improvement over the course of 100 training epochs; across both input lengths, it achieves a testing error rate of at best 0.476 (where a random guess achieves value 0.5).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.">Sudoku (original and permuted)</head><p>In this experiment, we test SATNet's ability to infer and recover constraints simply from bit supervision (i.e. without any hard-coded specification of how bits are related). We demonstrate this property via Sudoku. In Sudoku, given a (typically) 9 × 9 partially-filled grid of numbers, a player must fill in the remaining empty grid cells such that each row, each column, and each of nine 3 × 3 subgrids contains exactly one of each number from 1 through 9. While this constraint satisfaction problem is computationally easy to solve once the rules of the game are specified, actually learning the rules of the game, i.e. the hard constraints of the puzzle, has proved challenging for traditional neural network architectures. In particular, Sudoku problems are often solved computationally via tree search, and while tree search cannot be easily performed by neural networks, it is easily expressible using SAT and MAXSAT problems.</p><p>We construct a SATNet model for this task that takes as input a logical (bit) representation of the initial Sudoku board along with a mask representing which bits must be learned (i.e. all bits in empty Sudoku cells). This input is vectorized, which means that our SATNet model cannot exploit the locality structure of the input Sudoku grid when learning to solve puzzles. Given this input, the SATNet layer then outputs a bit representation of the Sudoku board with guesses for the unknown bits. Our model architecture consists of a single SATNet layer with 300 auxiliary variables and low rank structure m = 600, and we train it to minimize a digitwise negative log likelihood objective (optimized via Adam with a 2 × 10 −3 learning rate). We compare our model to a convolutional neural network baseline modeled on that of <ref type="bibr" target="#b16">Park (2016)</ref>, which interprets the bit inputs as 9 input image channels (one for each square in the board) and uses a sequence of 10 convolutional layers (each with 512 3×3 filters) to output the solution. The ConvNet makes explicit use of locality in the input representation since it treats the nine cells within each square as a single image. We also compare to a version of the ConvNet which receives a binary mask indicating which bits need to be learned (ConvNetMask). The mask is input as a set of additional image channels in the same format as the board. We trained both architectures using mean squared error (MSE) loss (which gave better results than negative log likelihood for this architecture). The loss was optimized using Adam (learning rate 10 −4 ). We additionally tried to train an Opt-Net   . On the other hand, the ConvNet baseline does poorly. It learns to correctly solve 72.6% of puzzles in the training set but fails altogether to generalize: accuracy on the held-out set reaches at most 0.04%. The ConvNetMask baseline, which receives a binary mask denoting which entries must be completed, performs only somewhat better, correctly solving 15.1% of puzzles in the held-out set. We note that our test accuracy is qualitatively similar to the results obtained in <ref type="bibr" target="#b15">Palm et al. (2017)</ref>, but that our network is able to learn the structure of Sudoku without explicitly encoding the relationships between variables.</p><p>To underscore that our architecture truly learns the rules of the game, as opposed to overfitting to locality or other structure in the inputs, we test our SATNet architecture on permuted Sudoku boards, i.e. boards for which we apply a fixed permutation of the underlying bit representation (and adjust the corresponding input masks and labels accordingly). This removes any locality structure, and the resulting Sudoku boards do not have clear visual analogues that can be solved by humans. However, the relationships between bits are unchanged (modulo the permutation) and should therefore be discoverable by architectures that can truly learn the underlying logical structure. <ref type="table" target="#tab_3">Table 1</ref> shows results for this problem in comparison to the convolutional neural network baselines. Our architecture is again able to learn the rules of the (permuted) game, demonstrating the same 98.3% board-wise test accuracy as in the original game. In contrast, the convolutional neural network baselines perform even more poorly than in the original game (achieving 0% test accuracy even with the binary mask as input), as there is little locality structure to exploit. Overall, these results demonstrate that SATNet can truly learn the logical relationships between discrete variables.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.">Visual Sudoku</head><p>In this experiment, we demonstrate that SATNet can be integrated into larger deep network architectures for end-to-end training. Specifically, we solve the visual Sudoku problem: that is, given an image representation of a Sudoku board (as opposed to a one-hot encoding or other logical representation) constructed with MNIST digits, our network must output a logical solution to the associated Sudoku problem. An example input is shown in <ref type="figure" target="#fig_1">Figure 3</ref>. This problem cannot traditionally be represented well by neural network architectures, as it requires the ability to combine multiple neural network layers without hard-coding the logical structure of the problem into intermediate logical layers.</p><p>Our architecture for this problem uses a convolutional neural network connected to a SATNet layer. Specifically, we apply a convolutional layer for digit classification (which uses the LeNet architecture <ref type="bibr" target="#b12">(LeCun et al., 1998)</ref>) to each cell of the Sudoku input. Each cell-wise probabilistic output of this convolutional layer is then fed as logical input to the SATNet layer, along with an input mask (as in Section 4.2). This SATNet layer employs the same architecture and training parameters as described in the previous section. The whole model is trained end-to-end to minimize cross-entropy loss, and is optimized via Adam with learning rates 2 × 10 −3 for the SATNet layer and 10 −5 for the convolutional layer.</p><p>We compare our approach against a convolutional neural network which combines two sets of convolutional layers. First, the visual inputs are passed through the same convolutional layer as in our SATNet model, which outputs a probabilistic bit representation. Next, this representation is passed through the convolutional architecture that we compared to for the original Sudoku problem, which outputs a solution. We use the same training approach as above. ; additional plots are shown in Appendix F. We contextualize these results against the theoretical "best" testing accuracy of 74.7%, which accounts for the Sudoku digit classification accuracy of our specific convolutional architecture; that is, assuming boards with 36.2 out of 81 filled cells on average (as in our test set) and an MNIST model with 99.2% test accuracy <ref type="bibr" target="#b12">(LeCun et al., 1998)</ref>, we would expect a perfect Sudoku solver to output the correct solution 74.7% (= 0.992 36.2 ) of the time.</p><p>In 100 epochs, our model learns to correctly solve 63.2% of boards at test time, reaching 85% of this theoretical "best." Hence, our approach demonstrates strong performance in solving visual Sudoku boards end-to-end. On the other hand, the baseline convolutional networks make only minuscule improvements to the training loss over the course of 100 epochs, and fail altogether to improve out-of-sample performance. Accordingly, our SATNet architecture enables end-to-end learning of the "rules of the game" directly from pictorial inputs in a way that was not possible with previous architectures.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Conclusion</head><p>In this paper, we have presented a low-rank differentiable MAXSAT layer that can be integrated into neural network architectures. This layer employs block coordinate descent methods to efficiently compute the forward and backward passes, and is amenable to GPU acceleration. We show that our SATNet architecture can be successfully used to learn logical structures, namely the parity function and the rules of 9 × 9 Sudoku. We also show, via a visual Sudoku task, that our layer can be integrated into larger deep network architectures for end-to-end training. Our layer thus shows promise in allowing deep networks to learn logical structure without hard-coding of the relationships between variables.</p><p>More broadly, we believe that this work fills a notable gap in the regime spanning deep learning and logical reasoning. While many "differentiable logical reasoning" systems have been proposed, most of them still require fairly handspecified logical rules and groundings, and thus are somewhat limited in their ability to operate in a truly end-to-end fashion. Our hope is that by wrapping a powerful yet generic primitive such as MAXSAT solving within a differentiable framework, our solver can enable "implicit" logical reasoning to occur where needed within larger frameworks, even if the precise structure of the domain is unknown and must be learned from data. In other words, we believe that SATNet provides a step towards integrating symbolic reasoning and deep learning, a long-standing goal in artificial intelligence. A. Derivation of the forward pass coordinate descent update</p><p>Our MAXSAT SDP relaxation (described in Section 3.1) is given by</p><formula xml:id="formula_19">minimize V ∈R k×(n+1) S T S, V T V ,</formula><p>subject to v i = 1, i = 0, . . . , n,</p><formula xml:id="formula_20">(A.1)</formula><p>where S ∈ R m×(n+1) and v i is the ith column vector of V .</p><p>We rewrite the objective of (A.1) as S T S, V T V ≡ tr((S T S) T (V T V )) = tr(V T V S T S) by noting that S T S is symmetric and by cycling matrices within the trace. We then observe that the objective terms that depend on any given v i are given by</p><formula xml:id="formula_21">v T i n j=0 s T j s i v j = v T i n j=0 (j =i) s T j s i v j + v T i s T i s i v i , (A.2)</formula><p>where s i is the ith column vector of S. Observe v T i v i in the last term cancels to 1, and the remaining coefficient</p><formula xml:id="formula_22">g i ≡ n j=0 (j =i) s T j s i v j = V S T s i − s i 2 v i (A.3)</formula><p>is constant with respect to v i . Thus, (A.2) can be simply rewritten as v </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Details on backpropagation through the MAXSAT SDP</head><p>Given the result ∂ /∂V O , we next seek to compute ∂ /∂V I and ∂ /∂S by pushing gradients through the SDP solution procedure described in Section 3.1. We do this by taking the total differential through our coordinate descent updates <ref type="formula" target="#formula_3">(3)</ref> for each output o ∈ O at the optimal fixed-point solution to which these updates converge.</p><p>Computing the total differential. Computing the total differential of the updates <ref type="formula">(</ref> </p><formula xml:id="formula_23">diag( g o ) ⊗ I k + P C ⊗ I k vec(dV O ) = −P vec(ξ o ) ⇒ vec(dV O ) = − P ( diag( g o ) + C ⊗ I k )P † vec(ξ o ), (B.3) where C = S T O S O − diag( s o 2 ), P = diag(P o )</formula><p>, and the second step follows from the lemma presented in Appendix C.</p><p>We then see that by the chain rule, the gradients ∂ /∂V I and ∂ /∂S are given by the left matrix-vector product</p><formula xml:id="formula_24">∂ ∂ vec(VO) T vec(dVO) = − ∂ ∂ vec(VO) T P ( diag( go ) + C ⊗ I k )P † vec(ξo) (B.4)</formula><p>where the second equality comes from plugging in the result of (B.3). Now, define U ∈ R k×n , where the columns U I = 0 and the columns U O are given by</p><formula xml:id="formula_25">vec(U O ) = P ( diag( g o )+C ⊗I k )P † vec ∂ ∂ vec(V O )</formula><p>.</p><p>(B.5) Then, we see that (B.4) can be written as</p><formula xml:id="formula_26">∂ ∂ vec(V O ) T vec(dV O ) = − vec(U O ) T vec(ξ o ), (B.6)</formula><p>which is the implicit linear form for our gradients.</p><p>Computing desired gradients from implicit linear form. Once we have obtained U O (via coordinate descent), we can explicitly compute the desired gradients ∂ /∂V I and ∂ /∂S from the implicit form (B.6). For instance, to compute the gradient ∂ /∂vι for some ι ∈ I, we would set dv ι = 1 and all other gradients to zero in Equation (B.6) (where these gradients are captured within the terms ξ o ).</p><p>Explicitly, we compute each ∂ /∂vιj by setting dv ιj = 1 and all other gradients to zero, i.e. Similarly, we compute each ∂ /∂Si,j by setting dS i,j = 1 and all other gradients to zero, i.e.</p><formula xml:id="formula_27">∂ ∂S i,j = − o∈O u T o ξ o = − o∈O u T o v i s oj − u T i (V S T ) j + u T i (s ij P i v i ) = −v T i ( o∈O u o s oj ) − u T i (V S T ) j .</formula><p>(B.8) In matrix form, these gradients are</p><formula xml:id="formula_28">∂ ∂V I = − o∈O u o s T o S I , (B.9) ∂ ∂S = − o∈O u o s T o T V − (SV T )U, (B.10)</formula><p>where u i is the ith column of U , and where S I denotes the I-indexed column subset of S.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Proof of pseudoinverse computations</head><p>We prove the following lemma, used to derive the implicit total differential for vec(dV O ).</p><formula xml:id="formula_29">Lemma C.1. The quantity vec(dV O ) = (P ((D + C) ⊗ I k ) P ) † vec(ξ o ) (C.1)</formula><p>is the solution of the linear system Proof. Examining the equation with respect to dv i gives</p><formula xml:id="formula_30">(D ⊗ I k + P C ⊗ I k ) vec(dV O ) = P vec(ξ o ), (C.2) where P = diag(I k − v o v T o ), C = S T O S O − diag( s o 2 ), D = diag( g i ),</formula><formula xml:id="formula_31">g i dv i + P i   j c ij dv j − ξ j   = 0, (C.3)</formula><p>which implies that for all i, dv i = P i y i for some y i . Substituting y i into the equality gives Note that the first equation comes from the idempotence property of P (that is, P P = P ). Substituting vec(dV O ) = P vec(Y ) back gives the solution of dV O .</p><formula xml:id="formula_32">(D ⊗ I k + P C ⊗ I k )P vec(y i ) (C.4) =P ((D + C) ⊗ I k )P vec(y i ) = P vec(ξ o ).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Derivation of the backward pass coordinate descent algorithm</head><p>Consider solving for U O as mentioned in Equation (B.5):</p><formula xml:id="formula_33">P ( diag( g o )+C ⊗I k )P vec(U O ) = vec ∂ ∂ vec(V O ) , where C = S T O S O − diag( s o 2 ).</formula><p>The linear system can be computed using block coordinate descent. Specifically, observe this linear system with respect to only the u o variable. Since we start from U O = 0, we can assume that P vec(U o ) = vec(U o ). This yields</p><formula xml:id="formula_34">g o P o u o + P o U O S T O s o − s o 2 u o = P o ∂ ∂v o . (D.1) Let Ψ = (U O )S T O . Then we have g o P o u o = −P o (Ψs o − s o 2 u o − ∂ /∂v o ). (D.2)</formula><p>Define −dg i to be the terms contained in parentheses in the right-hand side of the above equation  <ref type="figure">Figure E</ref>.1. We note that our architecture converges quickly -in just two epochs -to 100% board-wise test accuracy.</p><p>OptNet takes slightly longer to converge to similar performance, in terms of both time and epochs. In particular, we see that OptNet takes 3-4 epochs to converge (as opposed to 1 epoch for SATNet). Further, in our preliminary benchmarks, OptNet required 12 minutes to run 20 epochs on a GTX 1080 Ti GPU, whereas SATNet took only 2 minutes to run the same number of epochs. In other words, we see that SATNet requires fewer epochs to converge and takes less time per epoch than OptNet. 0 10 20 30 40 50 60 70 Epoch 10 1 10 3 10 5 10 7 10 9 Mean NLL Loss 0 10 20 30 40 50 60 70 Epoch F. Convergence plots for 9 × 9 Sudoku experiments</p><p>Convergence plots for our 9 × 9 Sudoku experiments (original and permuted) are shown in <ref type="figure">Figure F</ref>.1. SATNet performs nearly identically in both the original and permuted settings, generalizing well to the test set at every epoch without overfitting to the training set. The ConvNet and ConvNetMask, on the other hand, do not generalize well.</p><p>In the original setting, both architectures overfit to the training set, showing little-to-no improvement in generalization performance over the course of training. In the permuted setting, both ConvNet and ConvNetMask make little progress even on the training set, as they are not able to rely on spatial locality of inputs.</p><p>Convergence plots for the visual Sudoku experiments are shown in <ref type="figure">Figure F</ref>.2. Here, we see that SATNet generalizes well in terms of loss throughout the training process, and generalizes somewhat well in terms of whole-board accuracy. The difference in generalization performance between the logical and visual Sudoku settings can be attributed to the generalization performance of the MNIST classifier trained end-to-end with our SATNet layer. The ConvNetMask architecture overfits to the training set, and the ConvNet architecture makes little-to-no progress even on the training set.  </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 2 Figure 2 .</head><label>22</label><figDesc>shows that our model accomplishes this task for input sequences of length L = 20 and L = 40. For each sequence length, we generate a dataset of 10K random examples (9K training and 1K testing). We train our model using cross-entropy loss and the Adam optimizer (Kingma Error rate for the parity task with L = 20 (top) and L = 40 (bottom). Solid lines denote test values, while dashed lines represent training values.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 .</head><label>3</label><figDesc>An example visual Sudoku image input, i.e. an image of a Sudoku board constructed with MNIST digits. Cells filled with the numbers 1-9 are fixed, and zeros represent unknowns.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>T i g i + s T i s i . (A.4)Minimizing this expression over v i with respect to the constraint v i = 1 yields the block coordinate descent update v i = −g i / g i . (A.5)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>and ξ o is as defined in Equation (B.2).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>last equation comes form D ⊗ I k P = D ⊗ I k P P = P (D ⊗ I k )P due to the block diagonal structure of the projection P . Thus, by the properties of projectors and the pseudoinverse, vec(Y ) = (P ((D + C) ⊗ I k )P ) † P vec(ξ o ) (C.6) = (P ((D + C) ⊗ I k )P ) † vec(ξ o ). (C.7)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure F. 2 .</head><label>2</label><figDesc>Results for our visual Sudoku experiments. Lower loss (mean NLL loss and mean MSE loss) and higher whole-board accuracy (% puzzles correct) are better. The theoretical "best" test accuracy plotted is for our specific choice of MNIST classifier architecture.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>. 3.2.3. STEP 2: GENERATING CONTINUOUS RELAXATIONS OF OUTPUTS VIA SDP Given the continuous input relaxations V I , our layer employs the coordinate descent updates (3) to compute values for continuous output relaxations v o , o ∈ O (which we collectively refer to as V O ∈ R k×|O| ). Notably, coordinate descent updates are only computed for output variables, i.e. are not computed for variables whose assignments are given as input to the layer.</figDesc><table /><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>Algorithm 3 Backward pass coordinate descent 1: input { ∂ /∂vo | o ∈ O} // grads w.r.t. relaxed outputs 2: // Compute U O from Equation (9) 3: init U O = 0 and Ψ = (U O )S T O = 0 4: while not converged do</figDesc><table><row><cell>5:</cell><cell>for o ∈ O do // for all output variables</cell></row><row><cell>6:</cell><cell></cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 1 .</head><label>1</label><figDesc>Results for 9 × 9 Sudoku experiments with 9K train/1K test examples. We compare our SATNet model against a vanilla convolutional neural network (ConvNet) as well as one that receives a binary mask indicating which bits need to be learned (ConvNetMask).</figDesc><table><row><cell>Model</cell><cell>Train</cell><cell>Test</cell><cell>Model</cell><cell>Train</cell><cell>Test</cell><cell>Model</cell><cell>Train</cell><cell>Test</cell></row><row><cell>ConvNet</cell><cell cols="2">72.6% 0.04%</cell><cell>ConvNet</cell><cell>0%</cell><cell>0%</cell><cell>ConvNet</cell><cell>0.31%</cell><cell>0%</cell></row><row><cell cols="3">ConvNetMask 91.4% 15.1%</cell><cell cols="2">ConvNetMask 0.01%</cell><cell>0%</cell><cell>ConvNetMask</cell><cell>89%</cell><cell>0.1%</cell></row><row><cell cols="3">SATNet (ours) 99.8% 98.3%</cell><cell cols="3">SATNet (ours) 99.7% 98.3%</cell><cell cols="3">SATNet (ours) 93.6% 63.2%</cell></row><row><cell cols="2">(a) Original Sudoku.</cell><cell></cell><cell cols="2">(b) Permuted Sudoku.</cell><cell></cell><cell cols="3">(c) Visual Sudoku. (Note: the theoretical</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="3">"best" test accuracy for our architecture is</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>74.7%.)</cell><cell></cell><cell></cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>model for comparison, but this model made little progress even after a few days of training. (We compare our method to OptNet on a simpler 4 × 4 version of the Sudoku problem in Appendix E.) Our results for the traditional 9 × 9 Sudoku problem (over 9K training examples and 1K test examples) are shown in Table 1. (Convergence plots for this experiment are shown in Appendix F.) Our model is able to learn the constraints of the Sudoku problem, achieving high accuracy early in the training process (95.0% test accuracy in 22 epochs/37 minutes on a GTX 1080 Ti GPU), and demonstrating 98.3% board-wise test accuracy after 100 training epochs (172 minutes)</figDesc><table /><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 1</head><label>1</label><figDesc></figDesc><table><row><cell>summarizes our experimental results (over 9K train-</cell></row><row><cell>ing examples and 1K test examples)</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head></head><label></label><figDesc>Zhang, Z., Friedman, T., Liang, Y., and den Broeck, G. V. A semantic loss function for deep learning with symbolic knowledge. In Proceedings of the 35th International Conference on MachineLearning, pp. 5498-5507,  2018. URL http://proceedings.mlr.press/ v80/xu18h.html.</figDesc><table><row><cell>Xu, J., Yang, F., Yang, Z., and Cohen, W. W. Differentiable learn-</cell></row><row><cell>ing of logical rules for knowledge base reasoning. In</cell></row><row><cell>Advances in Neural Information Processing Systems, pp.</cell></row><row><cell>2319-2328, 2017.</cell></row><row><cell>Shalev-Shwartz, S., Shamir, O., and Shammah, S. Failures</cell></row><row><cell>of gradient-based deep learning. In Proceedings of the</cell></row><row><cell>34th International Conference on Machine Learning, pp.</cell></row><row><cell>3067-3075, 2017.</cell></row><row><cell>Sourek, G., Aschenbrenner, V., Zelezny, F., Schockaert,</cell></row><row><cell>S., and Kuzelka, O. Lifted relational neural networks:</cell></row><row><cell>Efficient learning of latent relational structures. Journal</cell></row><row><cell>of Artificial Intelligence Research, 62:69-100, 2018.</cell></row><row><cell>Tschiatschek, S., Sahin, A., and Krause, A. Differ-</cell></row><row><cell>entiable submodular maximization. arXiv preprint</cell></row><row><cell>arXiv:1803.01785, 2018.</cell></row><row><cell>Wang, P.-W. and Kolter, J. Z. Low-rank semidefinite pro-</cell></row><row><cell>gramming for the max2sat problem. In AAAI Conference</cell></row><row><cell>on Artificial Intelligence, 2019.</cell></row><row><cell>Wang, P.-W., Chang, W.-C., and Kolter, J. Z. The mixing</cell></row><row><cell>method: coordinate descent for low-rank semidefinite</cell></row><row><cell>programming. arXiv preprint arXiv:1706.00476, 2017.</cell></row><row><cell>Wilder, B., Dilkina, B., and Tambe, M. Melding the data-</cell></row><row><cell>decisions pipeline: Decision-focused learning for combi-</cell></row><row><cell>natorial optimization. In AAAI Conference on Artificial</cell></row><row><cell>Intelligence, 2018.</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head></head><label></label><figDesc>≡ I k − v o v T o , o ∈ O and I ≡ { } ∪ I.Rewriting as a linear system. Rewriting Equation B.1 over all o ∈ O as a linear system, we obtain</figDesc><table><row><cell></cell><cell></cell><cell>and where P o</cell></row><row><cell></cell><cell cols="2">3) and rearranging, we see that</cell></row><row><cell cols="2">for every o ∈ O,</cell></row><row><cell cols="2">go I k − so 2 Po dvo + Po</cell><cell>s T o sjdvj = −Poξo, (B.1)</cell></row><row><cell></cell><cell>j∈O</cell></row><row><cell>where</cell><cell></cell></row><row><cell>ξo ≡</cell><cell cols="2">s T o sjdvj + V dS T so + V S T dso − 2ds T o sovo ,</cell></row><row><cell>j∈I</cell><cell></cell></row><row><cell></cell><cell></cell><cell>(B.2)</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head></head><label></label><figDesc>. Note that dg i does not depend on the variable u o . Thus, we have the closed-form feasible solutionu o = −P o dg o / g o .The above procedure is summarized in Algorithm 3. Further, we can verify that the assumption P vec(U O ) = vec(U O ) still holds after each update by the projection P o . E. Results for the 4 × 4 Sudoku problem</figDesc><table><row><cell></cell><cell>(D.3)</cell></row><row><cell cols="2">After updating u o , we can maintain the term Ψ by replacing the old u prev o with the new u o . This yields the rank 1 update</cell></row><row><cell>Ψ := Ψ + (u o − u prev o )s T o .</cell><cell>(D.4)</cell></row><row><cell cols="2">We compare the performance of our SATNet architecture</cell></row><row><cell cols="2">on a 4 × 4 reduced version of the Sudoku puzzle against</cell></row><row><cell cols="2">OptNet (Amos &amp; Kolter, 2017) and a convolutional neural</cell></row><row><cell cols="2">network architecture. These results (over 9K training and</cell></row><row><cell>1K testing examples) are shown in</cell><cell></cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9"><head></head><label></label><figDesc>Results for 4 × 4 Sudoku. Lower loss (mean NLL loss and mean MSE loss) and higher whole-board accuracy (% puzzles correct) are better.Both our SATNet architecture and OptNet outperform the traditional convolutional neural network in this setting, as the ConvNet somewhat overfits to the training set and therefore does not generalize as well to the test set (achieving 93% accuracy). The ConvNetMask, which additionally receives a binary input mask, performs much better (99% test accuracy) but does not achieve perfect performance as in the case of OptNet and SATNet.</figDesc><table><row><cell></cell><cell>10 1 10 2 10 3 Mean MSE Loss</cell><cell cols="2">Epoch 0 10 20 30 40 50 60 70 0 20 40 60 80 100 % Puzzles Correct</cell></row><row><cell>SATNet (train) SATNet (test)</cell><cell>ConvNet (train) ConvNet (test)</cell><cell>ConvNetMask (train) ConvNetMask (test)</cell><cell>OptNet (train) OptNet (test)</cell></row><row><cell>Figure E.1.</cell><cell></cell><cell></cell><cell></cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_10"><head></head><label></label><figDesc>Sudoku Figure F.1. Results for our 9 × 9 Sudoku experiments. Lower loss (mean NLL loss and mean MSE loss) and higher whole-board accuracy (% puzzles correct) are better.</figDesc><table><row><cell>10 1 10 2 Mean NLL Loss</cell><cell cols="2">0 20 40 60 80 100 Epoch Mean MSE Loss 10 1 10 2 10 3 10 4</cell><cell cols="2">0 20 40 60 80 100 Epoch</cell><cell>Epoch 0 20 40 60 80 100 0 20 40 60 80 100 % Puzzles Correct</cell></row><row><cell></cell><cell></cell><cell>SATNet (train) SATNet (test)</cell><cell>ConvNet (train) ConvNet (test)</cell><cell>ConvNetMask (train) ConvNetMask (test)</cell></row><row><cell></cell><cell></cell><cell></cell><cell>(a) Original 9 × 9 Sudoku</cell></row><row><cell>10 1 10 2 Mean NLL Loss</cell><cell cols="2">0 20 40 60 80 100 Epoch Mean MSE Loss 10 1 10 2</cell><cell cols="2">0 20 40 60 80 100 Epoch % Puzzles Correct 100 0 20 40 60 80 100 Epoch 0 20 40 60 80</cell></row><row><cell></cell><cell></cell><cell>SATNet (train) SATNet (test)</cell><cell>ConvNet (train) ConvNet (test)</cell><cell>ConvNetMask (train) ConvNetMask (test)</cell></row><row><cell>10 1 10 2 Mean NLL Loss</cell><cell cols="4">(b) Permuted 9 × 9 0 20 40 60 80 100 Epoch 0 20 40 60 80 100 Epoch 10 1 10 2 10 3 10 4 Mean MSE Loss</cell><cell>Epoch 0 20 40 60 80 100 0 20 40 60 80 100 % Puzzles Correct</cell></row><row><cell></cell><cell>SATNet (train) SATNet (test)</cell><cell>ConvNet (train) ConvNet (test)</cell><cell>ConvNetMask (train) ConvNetMask (test)</cell><cell>Theoretical "best" test accuracy</cell></row></table><note></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>Po-Wei Wang is supported by a grant from the Bosch Center for AI; Priya Donti is supported by the Department of Energy's Computational Science Graduate Fellowship under grant number DE-FG02-97ER25308; and Bryan Wilder is supported by the National Science Foundation Graduate Research Fellowship.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Amos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">Z</forename><surname>Kolter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Optnet</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1703.00443</idno>
		<title level="m">Differentiable optimization as a layer in neural networks</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Problems of distance geometry and convex properties of quadratic maps</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">I</forename><surname>Barvinok</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Discrete &amp; Computational Geometry</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="189" to="202" />
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Cingillioglu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Russo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Deeplogic</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1805.07433</idno>
		<title level="m">End-to-end logical reasoning</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W.-Z</forename><surname>Dai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Q.-L</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhou</forename></persName>
		</author>
		<idno type="arXiv">arXiv:1802.01173</idno>
		<title level="m">Tunneling neural perception and logic reasoning through abductive learning</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Differentiable learning of submodular models</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Djolonga</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Krause</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems</title>
		<imprint>
			<date type="published" when="2017" />
			<biblScope unit="page" from="1013" to="1023" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Task-based endto-end model learning in stochastic optimization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">L</forename><surname>Donti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Amos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">Z</forename><surname>Kolter</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1703.04529</idno>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Learning explanatory rules from noisy data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Evans</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Grefenstette</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Artificial Intelligence Research</title>
		<imprint>
			<biblScope unit="volume">61</biblScope>
			<biblScope unit="page" from="1" to="64" />
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Neural-symbolic learning and reasoning: contributions and challenges</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Garcez</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">R</forename><surname>Besold</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>De Raedt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Földiak</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Hitzler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Icard</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K.-U</forename><surname>Kühnberger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">C</forename><surname>Lamb</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Miikkulainen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">L</forename><surname>Silver</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the AAAI Spring Symposium on Knowledge Representation and Reasoning: Integrating Symbolic and Neural Approaches</title>
		<meeting>the AAAI Spring Symposium on Knowledge Representation and Reasoning: Integrating Symbolic and Neural Approaches<address><addrLine>Stanford</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Improved approximation algorithms for maximum cut and satisfiability problems using semidefinite programming</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">X</forename><surname>Goemans</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">P</forename><surname>Williamson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM (JACM)</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1115" to="1145" />
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">The power of semidefinite programming relaxations for max-sat</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">P</forename><surname>Gomes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W.-J</forename><surname>Van Hoeve</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Leahu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Integration of Artificial Intelligence (AI) and Operations Research (OR) Techniques in Constraint Programming</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006" />
			<biblScope unit="page" from="104" to="118" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Harnessing deep neural networks with logic rules</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Hovy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Xing</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 54th Annual Meeting of the Association for Computational Linguistics</title>
		<meeting>the 54th Annual Meeting of the Association for Computational Linguistics</meeting>
		<imprint>
			<date type="published" when="2016" />
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="2410" to="2420" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Amethod for stochastic optimization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">P</forename><surname>Kingma</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">L</forename><surname>Ba</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Adam</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Learning Representations</title>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Gradientbased learning applied to document recognition. Proceedings of the IEEE</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Lecun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Bottou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Bengio</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Haffner</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998" />
			<biblScope unit="volume">86</biblScope>
			<biblScope unit="page" from="2278" to="2324" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">What game are we playing? end-to-end learning in normal and extensive form games</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">K</forename><surname>Ling</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Fang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">Z</forename><surname>Kolter</surname></persName>
		</author>
		<idno type="DOI">10.24963/ijcai.2018/55</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-Seventh International Joint Conference on Artificial Intelligence</title>
		<meeting>the Twenty-Seventh International Joint Conference on Artificial Intelligence</meeting>
		<imprint>
			<date type="published" when="2018" />
			<biblScope unit="page" from="396" to="402" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Deepproblog: Neural probabilistic logic programming</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Manhaeve</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Dumancic</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Kimmig</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Demeester</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">De</forename><surname>Raedt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems</title>
		<imprint>
			<date type="published" when="2018" />
			<biblScope unit="page" from="3749" to="3759" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">B</forename><surname>Palm</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">U</forename><surname>Paquet</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Winther</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1711.08028</idno>
		<title level="m">Recurrent relational networks</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Can neural networks crack sudoku?</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Park</surname></persName>
		</author>
		<ptr target="https://github.com/Kyubyong/sudoku" />
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">On the rank of extreme matrices in semidefinite programs and the multiplicity of optimal eigenvalues</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Pataki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mathematics of operations research</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="339" to="358" />
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Selsam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Lamm</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Bunz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Liang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>De Moura</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">L</forename><surname>Dill</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1802.03685</idno>
		<title level="m">Learning a sat solver from single-bit supervision</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
