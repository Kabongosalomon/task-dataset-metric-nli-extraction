<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /nfs/home/kabenamualus/Research/task-dataset-metric-extraction/../grobid-0.6.0/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Graph Convolutional Gaussian Processes</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ian</forename><surname>Walker</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ben</forename><surname>Glocker</surname></persName>
						</author>
						<title level="a" type="main">Graph Convolutional Gaussian Processes</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>

		<encodingDesc>
			<appInfo>
				<application version="0.6.0" ident="GROBID-SDO" when="2021-06-26T10:20+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid-sdo"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We propose a novel Bayesian nonparametric method to learn translation-invariant relationships on non-Euclidean domains. The resulting graph convolutional Gaussian processes can be applied to problems in machine learning for which the input observations are functions with domains on general graphs. The structure of these models allows for high dimensional inputs while retaining expressibility, as is the case with convolutional neural networks. We present applications of graph convolutional Gaussian processes to images and triangular meshes, demonstrating their versatility and effectiveness, comparing favorably to existing methods, despite being relatively simple models.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>We present a new Gaussian process (GP) model called the graph convolutional GP (GCGP) model. This model learns translation-invariant relationships that mimic the behavior of a convolutional layer on images, but extends this property to general graphs. Since this is a GP model, the patch response function learned will be nonlinear and nonparametric, which may aid in expressibility and make more efficient use of small datasets. Additionally, since this is a Bayesian technique, it allows for the rigorous treatment of uncertainties for predictions, useful in many application domains, but difficult for existing convolutional models.</p><p>The main point of attempting to utilize general convolutions is to reduce the complexity of the model while maintaining expressibility. Indeed, standard GP models can suffer from the curse of dimensionality, making stable estimation difficult on high-dimensional inputs <ref type="bibr" target="#b20">(Rasmussen, 2004)</ref>. This work seeks to create a convolutional model for general graphs, such as images, social networks, or 3D meshes, that focuses attention on local patches to substantially reduce Proceedings of the 36 th International Conference on Machine Learning, Long Beach, California, PMLR 97, 2019. Copyright 2019 by the author(s). the dimensionality of the input in a principled manner, inspired by recent work in geometric deep learning . In this way, GP models can be applied to highdimensional inputs that live on non-Euclidean domains. To the best of our knowledge, this is the first work to propose spatial graph convolutions with Gaussian processes.</p><p>We present applications of GCGPs to graphs which are Euclidean sampling grids (images) and further demonstrate the GCGP's performance when learning on non-Euclidean domains for classification tasks. We apply our method to triangular meshes and to an MNIST superpixel dataset, where each image is represented as a distinct graph. While graph convolutional GPs are shallow, though wide, the results are promising for such relatively terse models, and indicate that GCGPs can provide a simple and effective foundation for more complex models in the future.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Background</head><p>A comprehensive overview of related graph kernel methods is given by <ref type="bibr" target="#b24">Vishwanathan et al. (2010)</ref> with some recent work by <ref type="bibr" target="#b17">Neumann et al. (2016)</ref> proposing kernels for graphs with node features and other work employing deep learning <ref type="bibr" target="#b25">(Zhang et al., 2018;</ref><ref type="bibr" target="#b7">Duvenaud et al., 2015)</ref>. We focus on the task of classifying signals that live on general graphs, leaving regression tasks as a straightforward extension of the methodology. We further constrain our focus to domains which are the same size for each signal to be classified. Thus, our datasets will comprise of general graphs, which are composed of the same number of vertices. However, they do not necessarily have the same edge structures. This is an important difference to recent Graph GPs <ref type="bibr" target="#b18">(Ng et al., 2018)</ref> and other approaches <ref type="bibr" target="#b23">(Venkitaraman et al., 2018)</ref> operating in the spectral domain using the graph Laplacian which requires all observations to lie on the same graph (implying the same edge structure).</p><p>The dataset D = {G, Ψ, Y } comprises a collection of signals Ψ with associated labels Y , which live on a corresponding domain in G. Let G ∈ G be one such domain. This G = V, E is comprised of a set of V vertices and E ⊆ V × V edges. The corresponding signal ψ ∈ Ψ is some function ψ : V → R d on the vertices of the graph.</p><p>We wish to learn some function f which accepts ψ as input arXiv:1905.05739v1 <ref type="bibr">[cs.</ref>LG] 14 May 2019 and produces an output which will be used for classification, for example passed through a sigmoidal function. It is this function f which we want to model using a Gaussian process prior. Initially, we might view the function of interest as f : R |V|×d → R and select a general covariance function such as a radial basis function (RBF) kernel for the GP prior on f . This produces an expressive model, but will suffer from two major drawbacks. First, it completely ignores the underlying graph structures of the inputs, which may contain valuable information for the classification task and may differ substantially between input signals. Second, as |V| or d increase, a kernel such as the RBF will become more difficult to estimate as it attempts to model the relationships between every input dimension and every vertex, and thus suffers from the curse of dimensionality, a problem common to many expressive models with high-dimensional inputs.</p><p>To reduce the complexity of the problem while maintaining expressibility, we will construct kernel functions that focus only on subsets of the input dimensions. These subsets will be defined to take into account the underlying structure of the input graph on which the signal is defined. In particular, we wish to model relationships between nearby vertices while ignoring distant relations, the same intuition that is the basis for convolutional models.</p><p>In the context of Gaussian processes, recent work by <ref type="bibr" target="#b22">van der Wilk et al. (2017)</ref> provides a framework for estimating a convolutional GP for classification on Euclidean sampling grids such as images. This work relies fundamentally on additive GP models <ref type="bibr" target="#b6">(Duvenaud et al., 2011)</ref>. The basic insight of these models is that if Ω defines a set of subsets of the input dimensions, and we model our function of interest as the sum of functions on these subsets f (x) = ω∈Ω g ω (ω), where each g ω defines some unique function for each ω modelled using a GP prior g ω ∼ GP(0, k ω (·, ·)), then f has an induced GP prior with a covariance function defined by the sum of the respective covariance functions of the constituent g ω s.</p><p>If we focus on the case where G is the same Euclidean sampling grid (image structure) for all observations and constrain Ω to consist of all n-neighborhoods on the interior of the image and g ω to be the same g for all ω ∈ Ω, we obtain the convolutional Gaussian process model proposed by <ref type="bibr" target="#b22">van der Wilk et al. (2017)</ref>. To be more precise, the subsets in the convolutional GP model when applied to images are easily defined as the m × m pixel values around each pixel p. These are referred to by x <ref type="bibr">[p]</ref> in their paper with |x [p] | = m 2 . Image borders can be ignored by only defining subgroups at pixels on the interior of the image, yielding (w − m + 1) · (h − m + 1) number of pixels p for which there is a x [p] ⊂ x. We can restate this as follows: let the image be represented by the collection of random variables x = {x 1 , . . . , x wh } arranged on an undirected graph with edge weights γ : E → R defined as γ(e) = 1 for all e ∈ E. We can state the definition of x <ref type="bibr">[p]</ref> as:</p><formula xml:id="formula_0">x [p] = {x j ∈ x|d(x j , x p ) ≤ n} (1)</formula><p>where d : V ×V → R + denotes the distance metric between two vertices defined as:</p><formula xml:id="formula_1">d(x i , x j ) = min π∈P e∈π γ(e)<label>(2)</label></formula><p>where P is the set of all paths connecting x i and x j and e is an edge in a given path.</p><p>If g is given a GP prior, a GP prior will be induced on f</p><formula xml:id="formula_2">g ∼ GP (0, k g (t, t )) , f (x) = p g x [p] , =⇒ f ∼ GP   0, P p=1 P p =1 k g x [p] , x [p ]   (3)</formula><p>where P is the set of pixels and x <ref type="bibr">[p]</ref> indicates the p th patch of the vector x. (In this literature, what we refer to as ψ is referred to as x). Since the subsets are constrained to constitute the same neighborhoods across the image and g is constrained to be the same function on every patch, g becomes a nonlinear, nonparametric patch response function that is translation-invariant. It is this property that mimics the behavior of CNNs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Graph Convolutional Gaussian Processes</head><p>We now generalize the convolutional GP model to general, non-regular graphs in the spatial domain, so that the model can be applied to a wider range of problems. As mentioned in the previous section, we restrict our focus to a set of graphs in D that have the same number of vertices. On an arbitrary graph, we can define the same method for grouping the random variables into subsets as set out in Eq. (1). The only difference between the settings is that now the underlying graphs do not have the same regular lattice structure as in an image grid. This is a problem because it means that there is no guarantee that |x <ref type="bibr">[p]</ref> | is the same for all p, indeed, there is no guarantee that |x [p] | = |x [p ] | for any v, v ∈ V for an arbitrary undirected graph G. An additive GP model could be applied to the set of subsets that are created</p><formula xml:id="formula_3">g p ∼ GP 0, k gp (x i , x j ) ∀p, f (x) = p g p x [p]<label>(4)</label></formula><p>We would get a GP prior over f , but this would require a separate g p for every p, and would thus not represent a terse, translation-invariant model. Hence, we need to devise a strategy to ensure that |x [p] | = |x [p ] | for all p, p . One way of doing this is to throw away all p such that |x [p] | = c for some c, but on a general graph this may result in throwing away almost all of the random variables. One could instead find the minimum connectivity of the graph, m, and use this to find the m-nearest neighbors for each p and then associate these neighbours, along with p itself, to p as x <ref type="bibr">[p]</ref> . However, this would also mean throwing away information if the graph is sparsely connected in some areas, but densely connected in others.</p><p>To overcome this challenge, we appeal to the literature on graph convolutions (see <ref type="bibr" target="#b19">Niepert et al. (2016)</ref>, <ref type="bibr" target="#b10">Kipf &amp; Welling (2016)</ref> or <ref type="bibr" target="#b1">Bronstein et al. (2017)</ref> for a review of recent work). Spatial-domain charting methods offer the most direct way forward, as they focus on producing a convolution operator, which, when applied to signals on the graph, produces a transformed output with the same dimensionality for every vertex in the graph independent of its connectedness. For a continuous manifold X , the convolution operator can be defined as:</p><formula xml:id="formula_4">D j (x)f = X f (x )u j (x, x ) dx ∀x ∈ X , j = 1 . . . J<label>(5)</label></formula><p>On a discrete graph this becomes:</p><formula xml:id="formula_5">D j (v)f = V f (v )u j (v, v ) ∀v ∈ V, j = 1 . . . J<label>(6)</label></formula><p>where u j is some weighting function and J plays the role of the number of bins selected manually. (In this literature, what we refer to as ψ is referred to as f ). Several possible weighting functions u j have been proposed in the literature . For example, the geodesic polar weighting function <ref type="bibr" target="#b14">(Masci et al., 2015)</ref>, which will be used in subsequent sections for demonstration purposes, is:</p><formula xml:id="formula_6">u j,k (x, x ) = e − (ρ(x )−ρ k ) 2 2σ 2 ρ e − (θ(x )−θ j ) 2 2σ 2 θ , j = 1 . . . J, k = 1 . . . K (7)</formula><p>where ρ(·) measures the intrinsic radial distance and θ(·) measures the intrinsic angular distance from x to x . This collection of all u jk forms a system of polar coordinate bins.</p><p>There are many potential forms for the weighting functions, however, such as a simpler diffusion function that solely tracks the intrinsic radial distance, anisotropic weighting functions that modify the spread of the weights in certain directions, or general mixtures of Gaussians <ref type="bibr" target="#b16">(Monti et al., 2017)</ref>. What these weighting functions all share is the use of some type of coordinates or pseudo-coordinates for the location of the vertices in the graph and some method for finding a distance between these coordinates that is used to create a pairwise importance weighting. How this is implemented is discussed further in the subsequent section.</p><p>The GCGP model can be applied to general graphs by appropriate selection of the weighting function u j found in Eq. (6). Choice and design of this weighting function is one of the main research directions in geometric deep learning and some have been proposed for general graphs. For example, <ref type="bibr" target="#b16">Monti et al. (2017)</ref> </p><formula xml:id="formula_7">use u j = e − 1 2 (u(x,y)−µj ) Σ −1 j (u(x,y)−µj ) where, for a gen- eral graph, one can use pseudo-coordinates u(x, y) = 1 √ deg(x) , 1 √ deg(y)</formula><p>, where deg(·) denotes the degree of a vertex. Selecting a different u j is valid for the underlying machinery of the GP model presented here, provided that the transformation remains linear.</p><p>We can now state the GCGP model. Let ψ, ψ ∈ D be |V| × d matrices, and let their respective discrete G, G have |V| = |V |. A single u j,k (x, x ) is a real value which is the weighting between two vertices, x and x , for a particular set of hyperparameter values, ρ k and θ j , of which there are K and J respectively. We then define the tensor U to be (J · K) × |V| × |V|, where each element along the first dimension is a |V| × |V| pairwise weight matrix for a particular set of hyperparameter values. Each element of the weighting matrix is u j,k given some set of hyperparameters.</p><p>Since the convolution operator is a summation, we can rewrite it as a matrix of inner products we call the convolution patch matrix, Z. This will be |V| × (JK · d). To get a single element of the Z matrix, we take one element along the first dimension of U (|V| × |V|), and then take one row of that (1 × |V|). From the signal matrix ψ (|V| × d), we take one column (|V| × 1). Taking the inner product of these gets us a 1×1, which is a single element of Z (cf. <ref type="figure" target="#fig_1">Fig. 2</ref>).</p><p>We organize the columns of Z first by dimension of the signal and then by hyperparameter values, so the first JK columns correspond to the first signal dimension, the next JK columns correspond to the second, and so on, appending d JK-sized blocks. The size of each column is |V|. The function we aim to learn is f : R |V|×d → R, with input ψ, which will be used for classification. We can think of f as a composition of h : R |V|×(JKd) → R and Z :</p><formula xml:id="formula_8">R |V|×d → R |V|×(JKd) , for which ψ → Z, thus f (ψ) = h (Z (ψ)) = h (Z).</formula><p>To reduce the dimensionality of the problem and to mimic the translation invariance property we desire, we can now model this h as the summation of a patch response function g : R JKd → R, which decomposes as the application of this g to each row of Z, i.e. f (ψ) = h(Z) = i∈V g(z <ref type="bibr">[i]</ref> ). It is this g that we model using a GP prior with mean zero and some kernel function k g , and thanks to the properties of additive GPs, this will induce a GP prior on f :</p><formula xml:id="formula_9">g ∼ GP (0, k g (t, t )) ⇒ f ∼ GP   0, |V| i=1 |V | j=1 k g z [i] , z [j]  <label>(8)</label></formula><p>The k g can be any valid kernel function, but for illustrative purposes an RBF kernel is used. However, this is an interesting choice point for the user since as the number of bins grows and the number of signal dimensions grows, this may suffer from the curse of dimensionality as well, so kernels that further decompose on the patches may become necessary. Since this formulation can be applied to signals on any graphs of the same number of vertices, and g is constrained to be the same patch response function on each extracted local patch, Eq. (8) can be thought of as a graph convolutional kernel. It is important to note that a similar kernel was proposed for use with support vector machines, but its application was limited to images <ref type="bibr" target="#b13">(Mairal et al., 2014)</ref>.</p><p>There are several benefits of our formulation. First, while there are numerous potential choices for the weighting functions, the convolution operator itself is linear in the variables that make up the input space. Since the convolution operator is a linear transformation of the collection of random variables, the machinery developed for efficient estimation of the convolutional GP can be applied in our setting as well. This efficient estimation technique relies on the use of interdomain GPs to place inducing points in the space of patches instead of in the input space <ref type="bibr" target="#b12">(Lázaro-Gredilla &amp; Figueiras-Vidal, 2009</ref>).</p><p>Second, the weighting function makes the assumptions about the shape of the convolution on the graph explicit.</p><p>The standard convolution that we think of on an image is an indicator function that defines membership in a rectangular area the size of which is determined by the investigator. With more general weighting functions, shapes can include rings, ellipses, or more general shapes, making this another interesting choice to explore, as different problems may require different formulations even in the Euclidean domain.</p><p>Finally, because the application of the convolution operator is a transformation of the input prior to the application of a valid kernel function, the parameters of the weighting functions u j,k can be treated as hyperparameters of the kernel function. This is because the GCGP forms a manifold GP <ref type="bibr" target="#b2">(Calandra et al., 2016)</ref>, meaning that the hyperparameters can also be learned at training time, allowing the data to inform the shape of the convolution operator.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">Estimation of GCGPs</head><p>In the experiments that follow, we estimate the GCGPs using the same estimation technique as used in van der Wilk et al. <ref type="bibr">(2017)</ref>. This method relies on the variational framework for approximation of GPs as proposed in <ref type="bibr" target="#b8">Hensman et al. (2015)</ref> which has a computational complexity of O(N M 2 ), where N is the number of observations and M is the number of inducing points, and M is chosen such that M N .</p><p>One may be concerned with the computational complexity of GP methods in general. However, as the overarching motivation is to learn effectively from few training examples, this is not a major practical problem for many interesting applications. Indeed, the often rather small size of datasets that are comprised of objects like meshes is one of the reasons why we think that Bayesian nonparametrics is a promising way forward, even more so when equipped with expressive convolutional feature learning.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Applications</head><p>In this section, we present applications of GCGPs to both regular domains (images) and non-regular domains (general graphs, meshes). In each application, we use an RBF kernel for the patch response function g and use the polar geodesic weighting function in the construction of the patches. The main challenge in applying GCGPs to different domains is defining the ρ and θ functions, which measure the radial and angular distance between vertices, respectively. The construction of these will be discussed in more detail in subsequent sections. All experiments were implemented using the GPFlow package <ref type="bibr" target="#b15">(Matthews et al., 2017)</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.">MNIST Classification</head><p>We first consider classification of the standard MNIST dataset in order to illustrate that while the proposed method is general and can handle non-Euclidean domain inputs, it can also be applied to standard datasets with regular sampling grids like images. An image from MNIST is a 28 × 28 sampling grid of greyscale pixel values. These pixel values play the role of the signal that lives on the vertices of the graph. We consider the graph structure of an image to be the standard eight-neighbour connectivity, with edge weights equal to 1 everywhere. We define the ρ function in Eq. <ref type="formula">(7)</ref> to be the same graph distance as in Eq.</p><p>(2). We define the θ function in Eq. <ref type="formula">(7)</ref> to be the arctangent of the vertical difference between vertex v and vertex v over the horizontal difference between the two. Defining these two functions is easy in this setting because we know the orientation of the images, and the orientation remains stable across images. The configuration of the pixels also does not change.</p><p>Our main intention here is to compare the performance of our GCGPs to the closest existing Gaussian process model in the literature, which is the convolutional GP model by van der Wilk et al. <ref type="bibr">(2017)</ref>. We follow the same general setup as used in that paper. In their experiments on the MNIST dataset, they use a 5 × 5 patch operator, which produces a 25-dimensional patch response function, modeled using an RBF kernel. To keep comparisons as fair as possible, we use three radial bins and eight angular bins, for a total of a 24-dimensional patch response function. The input signals ψ : V → R are the pixel values that constitute an image. Note that the dimensionality of ψ here is one (d = 1) as the input is simply a greyscale image. To demonstrate the ability to learn the shape of the convolution, we treat the hyperparameters ρ k and σ ρ as hyperparameters of the kernel function, while leaving the θ j and σ θ fixed. The ρ k s were initialized to {0, 1, 2}, such that the radial bins would be centered on a given pixel, plus the rings one and two pixels away. The σ ρ was initialized to 1, so 68% of the weight is within one pixel distance from the centeral vertex.</p><p>During training, mini-batches of size 200 were used along with 750 inducing points and a learning rate of 0.001. The error rate converges to 1.7%. This compares favorably to the strictly translation-invariant convolutional GP, which attains an error rate of 2.1%. An RBF kernel, which models all 784 </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.">MNIST Superpixels</head><p>To demonstrate the performance of GCGPs on general graphs, we apply the model to the 75-vertex MNIST superpixel dataset, following the methodology of <ref type="bibr" target="#b16">Monti et al. (2017)</ref>. This dataset decomposes each MNIST image into a 75-vertex graph with a unique edge structure. This dataset is constructed from the MNIST dataset as follows: for each image, pixels are divided into 'background' and 'foreground', denoting a pixel value of 0 and greater than 0 respectively. Then, for each group, k-mean clustering is performed on the pixel locations, the (x,y) index of the pixel, and pixel values. The parameter k is chosen for each group such that their sum is the desired number of superpixels, in this case 75, and so that the split is two thirds foreground and one third background. The resulting centroids give the location of the superpixel in Euclidean coordinates and the value of the superpixel. The value of the superpixels serve as the input signal ψ : V → R d , with d = 1, which is to be classified. Finally, the graph structure is determined by choosing a threshold value of the Euclidean distance between the centroids and adding an edge if the distance is below the threshold. This produces a unique graph structure for each image. The resulting dataset follows the same training and test set split as the standard MNIST dataset with 60,000 and 10,000 observations in each respectively. The GCGP is set up and trained in precisely the same way as in Section 4.1.</p><p>The GCGP converges to an error rate of 4.2% on this task, which is a substantial improvement over the ChebNet architecture proposed by <ref type="bibr" target="#b5">Defferrard et al. (2016)</ref> that obtains 24.4%, and the MoNet architecture that obtains 8.9% on this task <ref type="bibr" target="#b16">(Monti et al. (2017)</ref>). The improvement against ChebNet is to be expected, as ChebNet is based on learning filters in the spectral domain, which means it will struggle with a task that learns across graphs with different structure, while the GCGP is based on spatial convolutions that can handle such settings. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.">Triangular 3D Mesh Classification</head><p>For our next test, we classify triangular meshes. As before, the number of vertices remains the same, but connectivity and embedding in three-dimensional space may be different for each graph.</p><p>The data is a collection of 100 meshes from the MPI Faust dataset 1 <ref type="bibr" target="#b0">(Bogo et al., 2014)</ref>. This includes ten different poses for each of ten different individuals. We use a training set of 70 meshes where we randomly select 7 poses for each individual. The remaining three poses for each individual comprise the test set (30 observations). Each mesh is comprised of 6800 vertices. These were downsampled to 2500, 1000, and 500 vertices using quadric edge collapse decimation in MeshLab <ref type="bibr" target="#b3">(Cignoni et al., 2008)</ref> to test the sensitivity of the GCGP to the quality of the meshing.</p><p>1 http://faust.is.tue.mpg.de/  The goal is to learn the identity of the individual, making this a 10-class classification task. To the best of the authors' knowledge, Gaussian processes have not been employed in a similar task with such types of data.</p><p>The input data is a geometric descriptor vector that describes the intrinsic geometry of the mesh, as in <ref type="bibr" target="#b11">Kokkinos et al. (2012)</ref>. For the purposes of this example, we use only the first four descriptors. For each mesh we have an input signal ψ : V → R 4 which is to be classified. We choose 16 angular and 5 radial bins for a total of 80 geodesic polar bins. When combined with the dimensionality of the input, this produces a 320-dimensional patch for each vertex.</p><p>We must define the ρ(·) and θ(·) functions in Eq. <ref type="formula">(7)</ref>. This is a more difficult problem than in the Euclidean domain above.</p><p>We begin by discussing how to compute the ρ(·) function, and subsequently discuss the construction of the θ(·) function, which is more involved. Any graph pre-processing step in this section was implemented in C++ for efficiency.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.1.">RADIAL DISTANCE BETWEEN VERTICES</head><p>Computing the radial distance between two vertices on a triangular mesh is relatively straightforward, and we follow the same methodology laid out by <ref type="bibr" target="#b14">Masci et al. (2015)</ref>. We find the intrinsic distance between two vertices on the triangular mesh by using the Fast Marching Method on triangular domains <ref type="bibr" target="#b21">(Sethian, 1996;</ref><ref type="bibr" target="#b9">Kimmel &amp; Sethian, 1998)</ref>. This method computes the time of arrival for a wave front traveling outwards from a group of initial conditions at a constant rate along the surface of the triangular mesh. By using each vertex as a starting point for the wave front separately, we are able to compute a measure of the intrinsic distance from each vertex to every other vertex, which produces a |V|×|V| matrix of intrinsic distances between the vertices. This can be precomputed for each mesh and does not represent too much of a computational overhead thanks to the O(n log n) complexity of the Fast Marching Method. This matrix of distances for each mesh will be used to look up the radial component of the weighting function for each specific pair of vertices in Eq. (7).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.2.">ANGULAR DISTANCE BETWEEN VERTICES</head><p>To compute θ(v, v ), we must first compute for each vertex v a set of J geodesic rays emanating from v. By this we mean a set of rays starting at the central vertex of interest drawn along the surface of the mesh.</p><p>We begin by taking J rays emanating from a central point and equally dividing 2π radians between them. We then take these J rays and project them down onto the one-ring of triangles that surround the central vertex v. This is done by computing the total angle of the angles that are adjacent to the central vertex, aligning one of the geodesic rays with one of the existing edges of the mesh, and continuing around the central vertex by equally-spaced increments that are proportional to the total angle sum. In this way, each of the J rays will now be a ray lying on one of the faces adjacent to the central vertex. We will now focus on one specific ray and explain how to continue it along adjacent triangles.</p><p>We extend the ray to find its intersection point with the edge opposite the central vertex from which it emanates. We now begin a process known as unfolding. This is done by treating the original triangle as lying in a two-dimensional "unfolding plane". We then take the triangle from the mesh that shares the edge that the geodesic ray intersects and reconstruct a congruent triangle in the two-dimensional unfolding plane. An alternative way to visualize this is to rotate (around the shared edge) the adjacent triangle in three-dimensional space into the same plane as the starting triangle. We then extend the ray and find the edge of this unfolded triangle with which it intersects. We continue the process of extending the ray along the mesh, unfolding each successive triangle and keeping track of the vertex it passes closest to with each intersection. This process continues until it makes a complete circuit of the mesh, hits the mesh boundary, if one exists, or stops after a designated length.</p><p>At this stage, for each of the J geodesic rays, there should be a list of vertices which are the vertices to which the geodesic passed the closest. To create the value of the θ function from each vertex to every other vertex, we use this list as the initial conditions for Fast Marching and compute the time of arrival for every vertex from this starting point. Once this process is complete, there will be a J × |V| × |V| tensor that serves as a look-up table for the θ value for the jth angular bin from a given vertex to every other vertex.</p><p>If the θ j parameters are fixed by the investigator, this can once again be precomputed for each mesh in the dataset. Not fixing the parameters presents an implementation difficulty because if the angular parameters are changed, then it is necessary to recompute all of the geodesics at every update step for the hyperparameters since the θ parameters control the angles at which the geodesics emanate from the central vertex. Note that this is not a problem for the radial bins since the ρ function, which is simply the intrinsic distances between the vertices on the mesh, remains fixed regardless of the settings of the ρ parameters, which control the midpoint of the radial bin along the surface of the mesh. In the presentation of our results we keep all hyperparameters of the weighting function fixed, which means that we can now use the computed ρ and θ functions to compute the weight tensors via Eq. <ref type="formula">(7)</ref>. Using this, we can transform each signal into a pseudo-image that is |V| × (JK · d), which will then be used in the learning task.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.3.">RESULTS</head><p>The results of these experiments are presented in <ref type="table" target="#tab_3">Table 3</ref>. When performing a 10-way classification on the 2500-vertex task, the graph convolutional GP converges to an error of 3.33%, which represents one misclassification. As expected, reducing the resolution of the mesh decreases accuracy. It is difficult to compare these results to a standard GP model as these must be applied to high-dimensional inputs and few examples per class. Without taking into account any spatial information, these would have 10,000 input dimensions for 2500 vertices, which would be difficult for a standard RBF model to estimate. Indeed, an RBF modeling all 10,000 input dimensions fails to stably learn anything in this case.</p><p>For these experiments we use a batch size of 30 along with 750 inducing points and a learning rate of 0.001. The results provide some useful, albeit qualitative, insights about the model. In particular, the GCGP model struggles to distinguish between individuals 4 and 8 ( <ref type="figure" target="#fig_4">Figure 5)</ref>, especially at the 500-vertex resolution, where it misclassifies every example of one as the other, which can be explained by the high visual similarity of these two subjects.</p><p>We also attempted to compare the GCGP performance on the mesh classification task with MoNet as a representative of recent geometric deep learning methods. To this end, we reimplemented MoNet to be able to directly apply it to the 3D mesh data. We initially tried to closely follow the setup as described in <ref type="bibr" target="#b16">(Monti et al., 2017)</ref>, i.e., using three graph convolutional layers but with the final layer replaced with a 10 dimensional softmax layer to classify the individual subjects. This model, however, overfitted immediately to the training data of 70 meshes for each of the 10 individuals, yielding a test accuracy close to random guessing. We also explored a less complex MoNet with only one graph convolutional layer for which the best performance we could obtain was an error rate of 33.33% on the 2500-vertex task. We believe that the small amount of training data is insufficient to properly train this deep learning method, but further investigation into this issue may be required.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Conclusion</head><p>Computer vision and imaging applications have led to significant progress with convolutional methods that excel when data lives on Euclidean domains. The drawback of these methods is that they require large amounts of training data and provide little means of capturing uncertainty when making predictions. Gaussian processes, on the other hand, are an attractive Bayesian approach that can learn from few data points on non-Euclidean domains and provide useful uncertainty estimates. So far, we have seen links between convolutional methods and GPs, leading to convolutional GPs. We have also seen approaches that bring convolutional methods to non-Euclidean domains in the form of graph CNNs, an area also known as geometric deep learning. Here, for the first time, we connect those three areas by combining convolutional methods with GPs on non-Euclidean domains. We believe that graph convolutional GPs provide a powerful new framework enabling exciting new applications and avenues for future research. We believe that the results of the experiments presented here support this, as they demonstrate the GCGP can improve accuracy and make more efficient use of smaller datasets relative to deep learning methods.</p><p>We envision augmenting GCGPs to become hierarchical models with recent work on deep GPs <ref type="bibr" target="#b4">(Damianou &amp; Lawrence, 2013)</ref> as a main directions of future research. This is because the strict translation invariance of the patch response function may not be enough in all situations, which may require combinations of responses across the graph. A simple step is to weigh each response with a set of learnable parameters as in .</p><p>Another area for improving the model is relaxing the requirement for a fixed number of vertices. In the method presented here, the function that is learned, f : R |V|×d → R, for classification, of the signals ψ : V → R d is decomposed in a principled manner into the sum of the responses of a patch response function g across the graph. Modelling g with a GP prior induces a GP prior on f , but if |V| is different for different inputs this setup fails by definition. While there are many situations in which the inputs are signals on graphs with the same number of vertices with potentially different structure, other problems may require the analysis of graphs which have different structure and number of vertices, such as classification of molecules. We hope the method presented here can serve as a foundation for GP models that relax this requirement.</p><p>An interesting direction to explore further is the choice of the coordinates/pseudo-coordinates that need not to be the ones used in this paper, and many interesting alternatives exist for meshes and for graphs more generally that are worth investigating. Finally, a nice feature of the GCGP that allows it to be easily tailored to different applications is the selection for the kernel function that describes the patch response function g. This is mentioned in the discussion above, but not explored. For example, it may be the case that modelling the patch response function in Section 4.3 with a 320 dimensional RBF kernel is too expressive for the task and the number of observations resulting in suboptimal performance. Performance may therefore be improved by decomposing the patch response function to produce an additive kernel whose components only utilise subsets of the inputs, the same principle that underpins the GCGP.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 .</head><label>1</label><figDesc>(R) The geodesic polar weighting functions in Eq. (7) on an Euclidean sampling grid, with the origin as x, and J = 8, K = 3. (L) shows the radial weights, equivalent to the diffusion weighting function. (M) shows the angular weights.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 .</head><label>2</label><figDesc>Let z[i]  be the i th row of the matrix Z. This represents the Diagram of the construction of patch matrix Z from signal matrix ψ and the weight tensor U . local geodesic polar patch for vertex i of the d-dimensional signal ψ as a weighted average along each dimension at each of the JK bin locations.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 .</head><label>3</label><figDesc>Example meshes from the MPI Faust dataset where different people are shown in different poses.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 .</head><label>4</label><figDesc>MPI Faust meshes resampled to 2500, 1000, and 500 vertices being used in our experiment in Sec. 4.3 to investigate the effect of resolution (cf. Tab. 3).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 .</head><label>5</label><figDesc>Individuals 4 and 8 from MPI Faust with full resolution (left) and 500 vertices (right). GCGP consistently confuses the identity of these two individuals at low resolution, which can be explained by their remarkably high visual similarity.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 .</head><label>1</label><figDesc>Error rates on MNIST classification</figDesc><table><row><cell>Method</cell><cell>Error rate</cell></row><row><cell>MNIST</cell><cell></cell></row><row><cell>Conv. GP (25-dim)  † RBF GP (784-dim)  † GCGP (24-dim)</cell><cell>2.1% 1.9% 1.7%</cell></row><row><cell>MNIST Superpixel 75</cell><cell></cell></row><row><cell>ChebNet (Defferrard et al., 2016)</cell><cell>24.4%</cell></row><row><cell>MoNet (Monti et al., 2017)</cell><cell>8.9%</cell></row><row><cell>GCGP</cell><cell>4.2%</cell></row><row><cell>† (van der Wilk et al., 2017)</cell><cell></cell></row><row><cell cols="2">input dimensions, attains a 1.9% error rate (van der Wilk</cell></row><row><cell cols="2">et al., 2017). It is important to note that both the convolu-</cell></row><row><cell cols="2">tional GP and our GCGP are not hierarchical models, and</cell></row><row><cell cols="2">to increase expressibility, van der Wilk et al. (2017) include</cell></row><row><cell cols="2">learnable weights which multiply the patch response func-</cell></row><row><cell cols="2">tion for each patch. This increases classification accuracy</cell></row><row><cell cols="2">but means that it is no longer strictly translation-invariant.</cell></row></table><note>Our GCGP model can similarly be extended, but this is left for future work. The hyperparameters ρ k and σ ρ converge to {1.312, 2.331, 4.034} and 0.392.</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 2 .</head><label>2</label><figDesc>Ablation study on Superpixel 75 error rates</figDesc><table><row><cell>Examples per class</cell><cell>100</cell><cell>500</cell><cell>1000</cell></row><row><cell>Error rate</cell><cell cols="3">13.7% 8.3% 6.3%</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 3 .</head><label>3</label><figDesc>Error rates on MPI Faust mesh classification</figDesc><table><row><cell>Number of vertices</cell><cell>500</cell><cell>1000</cell><cell>2500</cell></row><row><cell>MoNet</cell><cell cols="3">40.00% 33.33% 33.33%</cell></row><row><cell>GCGP</cell><cell cols="3">23.33% 10.00% 3.33%</cell></row></table><note></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>This project received funding from the European Research Council (ERC) under the European Union's Horizon 2020 research and innovation programme (grant agreement No  757173, project MIRA, ERC-2017-STG). IW is supported by the Natural Environment Research Council (NERC).</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Dataset and evaluation for 3D mesh registration</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Bogo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Romero</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Loper</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">J</forename><surname>Black</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Faust</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings IEEE Conf. on Computer Vision and Pattern Recognition (CVPR)</title>
		<meeting>IEEE Conf. on Computer Vision and Pattern Recognition (CVPR)<address><addrLine>Piscataway, NJ, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2014-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Geometric deep learning: Going beyond euclidean data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">M</forename><surname>Bronstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Bruna</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Lecun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Szlam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Vandergheynst</surname></persName>
		</author>
		<idno type="DOI">10.1109/MSP.2017.2693418</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Signal Processing Magazine</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="18" to="42" />
			<date type="published" when="2017-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Manifold Gaussian processes for regression</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Calandra</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Peters</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">E</forename><surname>Rasmussen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">P</forename><surname>Deisenroth</surname></persName>
		</author>
		<idno type="DOI">10.1109/IJCNN.2016.7727626</idno>
	</analytic>
	<monogr>
		<title level="m">2016 International Joint Conference on Neural Networks (IJCNN)</title>
		<imprint>
			<date type="published" when="2016-07" />
			<biblScope unit="page" from="3338" to="3345" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">MeshLab: an opensource mesh processing tool</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Cignoni</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Callieri</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Corsini</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Dellepiane</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Ganovelli</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Ranzuglia</surname></persName>
		</author>
		<idno>978-3-905673-68-5. doi: 10.2312</idno>
	</analytic>
	<monogr>
		<title level="m">Eurographics Italian Chapter Conference. The Eurographics Association</title>
		<editor>Scarano, V., Chiara, R. D., and Erra, U.</editor>
		<imprint>
			<date type="published" when="2008" />
			<biblScope unit="page" from="129" to="136" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Deep gaussian processes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Damianou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Lawrence</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Artificial Intelligence and Statistics</title>
		<imprint>
			<date type="published" when="2013" />
			<biblScope unit="page" from="207" to="215" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Convolutional neural networks on graphs with fast localized spectral filtering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Defferrard</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Bresson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Vandergheynst</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems</title>
		<editor>Lee, D. D., Sugiyama, M., Luxburg, U. V., Guyon, I., and Garnett, R.</editor>
		<imprint>
			<publisher>Curran Associates, Inc</publisher>
			<date type="published" when="2016" />
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="page" from="3844" to="3852" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Additive Gaussian processes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Duvenaud</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Nickisch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">E</forename><surname>Rasmussen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems</title>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="226" to="234" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Convolutional networks on graphs for learning molecular fingerprints</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">K</forename><surname>Duvenaud</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Maclaurin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Iparraguirre</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Bombarell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Hirzel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Aspuru-Guzik</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">P</forename><surname>Adams</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in neural information processing systems</title>
		<imprint>
			<date type="published" when="2015" />
			<biblScope unit="page" from="2224" to="2232" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Scalable Variational Gaussian Process Classification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Hensman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Matthews</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Ghahramani</surname></persName>
		</author>
		<idno>PMLR</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Eighteenth International Conference on Artificial Intelligence and Statistics</title>
		<editor>Lebanon, G. and Vishwanathan, S. V. N.</editor>
		<meeting>the Eighteenth International Conference on Artificial Intelligence and Statistics<address><addrLine>San Diego, California, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015-05" />
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="page" from="9" to="12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Computing geodesic paths on manifolds</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Kimmel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">A</forename><surname>Sethian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the National Academy of Sciences of the United States of America</title>
		<meeting>the National Academy of Sciences of the United States of America</meeting>
		<imprint>
			<date type="published" when="1998" />
			<biblScope unit="volume">95</biblScope>
			<biblScope unit="page" from="8431" to="8435" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Semi-supervised classification with graph convolutional networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">N</forename><surname>Kipf</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Welling</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1609.02907</idno>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Intrinsic shape context descriptors for deformable shapes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Kokkinos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">M</forename><surname>Bronstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Litman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">M</forename><surname>Bronstein</surname></persName>
		</author>
		<idno type="DOI">10.1109/CVPR.2012.6247671</idno>
	</analytic>
	<monogr>
		<title level="m">2012 IEEE Conference on Computer Vision and Pattern Recognition</title>
		<imprint>
			<date type="published" when="2012-06" />
			<biblScope unit="page" from="159" to="166" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Interdomain Gaussian processes for sparse inference using inducing features</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Lázaro-Gredilla</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">R</forename><surname>Figueiras-Vidal</surname></persName>
		</author>
		<idno>978-1-61567-911-9</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 22Nd International Conference on Neural Information Processing Systems, NIPS&apos;09</title>
		<meeting>the 22Nd International Conference on Neural Information Processing Systems, NIPS&apos;09<address><addrLine>USA</addrLine></address></meeting>
		<imprint>
			<publisher>Curran Associates Inc</publisher>
			<date type="published" when="2009" />
			<biblScope unit="page" from="1087" to="1095" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Convolutional kernel networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Mairal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Koniusz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Harchaoui</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Schmid</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems</title>
		<imprint>
			<publisher>Curran Associates, Inc</publisher>
			<date type="published" when="2014" />
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="2627" to="2635" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Geodesic convolutional neural networks on Riemannian manifolds</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Masci</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Boscaini</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">M</forename><surname>Bronstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Vandergheynst</surname></persName>
		</author>
		<idno type="DOI">10.1109/ICCVW.2015.112</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2015 IEEE International Conference on Computer Vision Workshop (ICCVW), ICCVW &apos;15</title>
		<meeting>the 2015 IEEE International Conference on Computer Vision Workshop (ICCVW), ICCVW &apos;15<address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2015" />
			<biblScope unit="page" from="832" to="840" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">A Gaussian process library using TensorFlow</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">G D G</forename><surname>Matthews</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Van Der Wilk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Nickson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Fujii</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Boukouvalas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>León-Villagrá</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Ghahramani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Hensman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Gpflow</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Machine Learning Research</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">40</biblScope>
			<biblScope unit="page" from="1" to="6" />
			<date type="published" when="2017-04" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Geometric deep learning on graphs and manifolds using mixture model CNNs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Monti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Boscaini</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Masci</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Rodol</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Svoboda</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">M</forename><surname>Bronstein</surname></persName>
		</author>
		<idno type="DOI">10.1109/CVPR.2017.576</idno>
	</analytic>
	<monogr>
		<title level="m">2017 IEEE Conference on Computer Vision and Pattern Recognition (CVPR)</title>
		<imprint>
			<date type="published" when="2017-07" />
			<biblScope unit="page" from="5425" to="5434" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Propagation kernels: efficient graph kernels from propagated information</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Neumann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Garnett</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Bauckhage</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Kersting</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Machine Learning</title>
		<imprint>
			<date type="published" when="2016" />
			<biblScope unit="volume">102</biblScope>
			<biblScope unit="page" from="209" to="245" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Bayesian semisupervised learning with graph gaussian processes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><forename type="middle">C</forename><surname>Ng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Colombo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Silva</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems</title>
		<imprint>
			<date type="published" when="2018" />
			<biblScope unit="page" from="1683" to="1694" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Learning convolutional neural networks for graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Niepert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Ahmed</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Kutzkov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International conference on machine learning</title>
		<imprint>
			<date type="published" when="2016" />
			<biblScope unit="page" from="2014" to="2023" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Gaussian processes in machine learning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">E</forename><surname>Rasmussen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advanced lectures on machine learning</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2004" />
			<biblScope unit="page" from="63" to="71" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">A fast marching level set method for monotonically advancing fronts</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">A</forename><surname>Sethian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the National Academy of Sciences of the United States of America</title>
		<meeting>the National Academy of Sciences of the United States of America</meeting>
		<imprint>
			<date type="published" when="1996-02" />
			<biblScope unit="volume">93</biblScope>
			<biblScope unit="page" from="1591" to="1596" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Convolutional Gaussian processes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Van Der Wilk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">E</forename><surname>Rasmussen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Hensman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems</title>
		<imprint>
			<publisher>Curran Associates, Inc</publisher>
			<date type="published" when="2017" />
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="2849" to="2858" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">Gaussian processes over graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Venkitaraman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Chatterjee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Haendel</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1803.05776</idno>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Graph kernels</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">V N</forename><surname>Vishwanathan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><forename type="middle">N</forename><surname>Schraudolph</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Kondor</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">M</forename><surname>Borgwardt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Machine Learning Research</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="1201" to="1242" />
			<date type="published" when="2010-04" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">An end-toend deep learning architecture for graph classification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Cui</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Neumann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chen</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Thirty-Second AAAI Conference on Artificial Intelligence</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
