<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /nfs/home/kabenamualus/Research/task-dataset-metric-extraction/../grobid-0.6.0/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">THE NEURO-SYMBOLIC CONCEPT LEARNER: INTERPRETING SCENES, WORDS, AND SENTENCES FROM NATURAL SUPERVISION</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jiayuan</forename><surname>Mao</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chuang</forename><surname>Gan</surname></persName>
							<email>ganchuang@csail.mit.edu</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pushmeet</forename><forename type="middle">Kohli</forename><surname>Deepmind</surname></persName>
							<email>pushmeet@google.com</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joshua</forename><forename type="middle">B</forename><surname>Tenenbaum</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jiajun</forename><surname>Wu</surname></persName>
							<email>jiajunwu@mit.edu</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">MIT CSAIL and IIIS</orgName>
								<orgName type="institution" key="instit2">Tsinghua University</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">MIT-IBM Watson AI Lab</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="laboratory">MIT BCS, CBMM</orgName>
								<address>
									<region>CSAIL</region>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="department">MIT CSAIL</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">THE NEURO-SYMBOLIC CONCEPT LEARNER: INTERPRETING SCENES, WORDS, AND SENTENCES FROM NATURAL SUPERVISION</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<note>Published as a conference paper at ICLR 2019</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>

		<encodingDesc>
			<appInfo>
				<application version="0.6.0" ident="GROBID-SDO" when="2022-11-12T14:59+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid-sdo"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We propose the Neuro-Symbolic Concept Learner (NS-CL), a model that learns visual concepts, words, and semantic parsing of sentences without explicit supervision on any of them; instead, our model learns by simply looking at images and reading paired questions and answers. Our model builds an object-based scene representation and translates sentences into executable, symbolic programs. To bridge the learning of two modules, we use a neuro-symbolic reasoning module that executes these programs on the latent scene representation. Analogical to human concept learning, the perception module learns visual concepts based on the language description of the object being referred to. Meanwhile, the learned visual concepts facilitate learning new words and parsing new sentences. We use curriculum learning to guide the searching over the large compositional space of images and language. Extensive experiments demonstrate the accuracy and efficiency of our model on learning visual concepts, word representations, and semantic parsing of sentences. Further, our method allows easy generalization to new object attributes, compositions, language concepts, scenes and questions, and even new program domains. It also empowers applications including visual question answering and bidirectional image-text retrieval.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Humans are capable of learning visual concepts by jointly understanding vision and language <ref type="bibr" target="#b12">(Fazly et al., 2010;</ref><ref type="bibr" target="#b8">Chrupa?a et al., 2015;</ref><ref type="bibr" target="#b15">Gauthier et al., 2018)</ref>. Consider the example shown in <ref type="figure" target="#fig_4">Figure 1</ref>-I. Imagine that someone with no prior knowledge of colors is presented with the images of the red and green cubes, paired with the questions and answers. They can easily identify the difference in objects' visual appearance (in this case, color), and align it to the corresponding words in the questions and answers (Red and Green). Other object attributes (e.g., shape) can be learned in a similar fashion. Starting from there, humans are able to inductively learn the correspondence between visual concepts and word semantics (e.g., spatial relations and referential expressions, <ref type="figure" target="#fig_4">Figure 1</ref>-II), and unravel compositional logic from complex questions assisted by the learned visual concepts <ref type="figure" target="#fig_4">(Figure 1</ref>-III, also see <ref type="bibr" target="#b0">Abend et al. (2017)</ref>).</p><p>Motivated by this, we propose the neuro-symbolic concept learner (NS-CL), which jointly learns visual perception, words, and semantic language parsing from images and question-answer pairs. NS-CL has three modules: a neural-based perception module that extracts object-level representations from the scene, a visually-grounded semantic parser for translating questions into executable programs, and a symbolic program executor that reads out the perceptual representation of objects, classifies their attributes/relations, and executes the program to obtain an answer.</p><p>Project page: http://nscl.csail.mit.edu <ref type="figure" target="#fig_4">Figure 1</ref>: Humans learn visual concepts, words, and semantic parsing jointly and incrementally. I. Learning visual concepts (red vs. green) starts from looking at simple scenes, reading simple questions, and reasoning over contrastive examples <ref type="bibr" target="#b12">(Fazly et al., 2010)</ref>. II. Afterwards, we can interpret referential expressions based on the learned object-based concepts, and learn relational concepts (e.g., on the right of, the same material as). III Finally, we can interpret complex questions from visual cues by exploiting the compositional structure.</p><p>NS-CL learns from natural supervision (i.e., images and QA pairs), requiring no annotations on images or semantic programs for sentences. Instead, analogical to human concept learning, it learns via curriculum learning. NS-CL starts by learning representations/concepts of individual objects from short questions (e.g., What's the color of the cylinder?) on simple scenes (?3 objects). By doing so, it learns object-based concepts such as colors and shapes. NS-CL then learns relational concepts by leveraging these object-based concepts to interpret object referrals (e.g., Is there a box right of a cylinder?). The model iteratively adapts to more complex scenes and highly compositional questions.</p><p>NS-CL's modularized design enables interpretable, robust, and accurate visual reasoning: it achieves state-of-the-art performance on the CLEVR dataset <ref type="bibr">(Johnson et al., 2017a)</ref>. More importantly, it naturally learns disentangled visual and language concepts, enabling combinatorial generalization w.r.t. both visual scenes and semantic programs. In particular, we demonstrate four forms of generalization. First, NS-CL generalizes to scenes with more objects and longer semantic programs than those in the training set. Second, it generalizes to new visual attribute compositions, as demonstrated on the CLEVR-CoGenT <ref type="bibr">(Johnson et al., 2017a)</ref> dataset. Third, it enables fast adaptation to novel visual concepts, such as learning a new color. Finally, the learned visual concepts transfer to new tasks, such as image-caption retrieval, without any extra fine-tuning.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">RELATED WORK</head><p>Our model is related to research on joint learning of vision and natural language. In particular, there are many papers that learn visual concepts from descriptive languages, such as image-captioning or visually-grounded question-answer pairs <ref type="bibr">(Kiros et al., 2014;</ref><ref type="bibr">Shi et al., 2018;</ref><ref type="bibr">Mao et al., 2016;</ref><ref type="bibr">Vendrov et al., 2016;</ref><ref type="bibr" target="#b14">Ganju et al., 2017)</ref>, dense language descriptions for scenes <ref type="bibr">(Johnson et al., 2016)</ref>, video-captioning <ref type="bibr" target="#b10">(Donahue et al., 2015)</ref> and video-text alignment <ref type="bibr">(Zhu et al., 2015)</ref>.</p><p>Visual question answering (VQA) stands out as it requires understanding both visual content and language. The state-of-the-art approaches usually use neural attentions <ref type="bibr">(Malinowski &amp; Fritz, 2014;</ref><ref type="bibr" target="#b6">Chen et al., 2015;</ref><ref type="bibr">Yang et al., 2016;</ref><ref type="bibr">Xu &amp; Saenko, 2016)</ref>. Beyond question answering, <ref type="bibr">Johnson et al. (2017a)</ref> proposed the CLEVR (VQA) dataset to diagnose reasoning models. CLEVR contains synthetic visual scenes and questions generated from latent programs. <ref type="table" target="#tab_1">Table 1</ref> compares our model with state-of-the-art visual reasoning models <ref type="bibr" target="#b2">(Andreas et al., 2016;</ref><ref type="bibr">Suarez et al., 2018;</ref><ref type="bibr">Santoro et al., 2017)</ref>   <ref type="bibr">Recently, Yi et al. (2018)</ref> explored an interpretable, object-based visual representation for visual reasoning. It performs well, but requires fully-annotated scenes during training. Our model also adopts an object-based visual representation, but the representation is learned only based on natural supervision (questions and answers). <ref type="bibr" target="#b1">Anderson et al. (2018)</ref> also proposed to represent the image as a collection of convolutional object features and gained substantial improvements on VQA. Their model encodes questions with neural   <ref type="figure" target="#fig_7">Figure 2</ref>: We propose to use neural symbolic reasoning as a bridge to jointly learn visual concepts, words, and semantic parsing of sentences. networks and answers the questions by question-conditioned attention over the object features. In contrast, NS-CL parses question inputs into programs and executes them on object features to get the answer. This makes the reasoning process interpretable and supports combinatorial generalization over quantities (e.g., counting objects). Our model also learns general visual concepts and their association with symbolic representations of language. These learned concepts can then be explicitly interpreted and deployed in other vision-language applications such as image caption retrieval.</p><p>There are two types of approaches in semantic sentence parsing for visual reasoning: implicit programs as conditioned neural operations (e.g., conditioned convolution and dual attention) <ref type="bibr">(Perez et al., 2018;</ref><ref type="bibr">Hudson &amp; Manning, 2018)</ref> and explicit programs as sequences of symbolic tokens <ref type="bibr" target="#b2">(Andreas et al., 2016;</ref><ref type="bibr">Johnson et al., 2017b;</ref><ref type="bibr">Mascharka et al., 2018)</ref>. As a representative, <ref type="bibr" target="#b2">Andreas et al. (2016)</ref> build modular and structured neural architectures based on programs for answering questions. Explicit programs gain better interpretability, but usually require extra supervision such as groundtruth program annotations for training. This restricts their application. We propose to use visual grounding as distant supervision to parse questions in natural languages into explicit programs, with zero program annotations. Given the semantic parsing of questions into programs, <ref type="bibr" target="#b19">Yi et al. (2018)</ref> proposed a purely symbolic executor for the inference of the answer in the logic space. Compared with theirs, we propose a quasi-symbolic executor for VQA.</p><p>Our work is also related to learning interpretable and disentangled representations for visual scenes using neural networks. <ref type="bibr">Kulkarni et al. (2015)</ref> proposed convolutional inverse graphics networks for learning and inferring pose of faces, while <ref type="bibr">Yang et al. (2015)</ref> learned disentangled representation of pose of chairs from images. <ref type="bibr">Wu et al. (2017)</ref> proposed the neural scene de-rendering framework as an inverse process of any rendering process. <ref type="bibr">Siddharth et al. (2017);</ref><ref type="bibr">Higgins et al. (2018)</ref> learned disentangled representations using deep generative models. In contrast, we propose an alternative representation learning approach through joint reasoning with language.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">NEURO-SYMBOLIC CONCEPT LEARNER</head><p>We present our neuro-symbolic concept learner, which uses a symbolic reasoning process to bridge the learning of visual concepts, words, and semantic parsing of sentences without explicit annotations  <ref type="figure">Figure 3</ref>: We treat attributes such as Shape and Color as neural operators. The operators map object representations into a visual-semantic space. We use similarity-based metric to classify objects.</p><p>for any of them. We first use a visual perception module to construct an object-based representation for a scene, and run a semantic parsing module to translate a question into an executable program. We then apply a quasi-symbolic program executor to infer the answer based on the scene representation. We use paired images, questions, and answers to jointly train the visual and language modules. <ref type="figure" target="#fig_7">Figure 2</ref>, given an input image, the visual perception module detects objects in the scene and extracts a deep, latent representation for each of them. The semantic parsing module translates an input question in natural language into an executable program given a domain specific language (DSL). The generated programs have a hierarchical structure of symbolic, functional modules, each fulfilling a specific operation over the scene representation. The explicit program semantics enjoys compositionality, interpretability, and generalizability.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Shown in</head><p>The program executor executes the program upon the derived scene representation and answers the question. Our program executor works in a symbolic and deterministic manner. This feature ensures a transparent execution trace of the program. Our program executor has a fully differentiable design w.r.t. the visual representations and the concept representations, which supports gradient-based optimization during training.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">MODEL DETAILS</head><p>Visual perception. Shown in <ref type="figure" target="#fig_7">Figure 2</ref>, given the input image, we use a pretrained Mask R-CNN <ref type="bibr">(He et al., 2017)</ref> to generate object proposals for all objects. The bounding box for each single object paired with the original image is then sent to a <ref type="bibr">ResNet-34 (He et al., 2015)</ref> to extract the region-based (by RoI Align) and image-based features respectively. We concatenate them to represent each object.</p><p>Here, the inclusion of the representation of the full scene adds the contextual information, which is essential for the inference of relative attributes such as size or spatial position.</p><p>Concept quantization. Visual reasoning requires determining an object's attributes (e.g., its color or shape). We assume each visual attribute (e.g., shape) contains a set of visual concept (e.g., Cube). In NS-CL, visual attributes are implemented as neural operators , mapping the object representation into an attribute-specific embedding space. <ref type="figure">Figure 3</ref> shows an inference an object's shape. Visual concepts that belong to the shape attribute, including Cube, Sphere and Cylinder, are represented as vectors in the shape embedding space. These concept vectors are also learned along the process. We measure the cosine distances ?, ? between these vectors to determine the shape of the object. Specifically, we compute the probability that an object o i is a cube by ? ShapeOf(o i ), v Cube ? ? ? , where ShapeOf(?) denotes the neural operator, v Cube the concept embedding of Cube and ? the Sigmoid function. ? and ? are scalar constants for scaling and shifting the values of similarities. We classify relational concepts (e.g., Left) between a pair of objects similarly, except that we concatenate the visual representations for both objects to form the representation of their relation.</p><p>DSL and semantic parsing. The semantic parsing module translates a natural language question into an executable program with a hierarchy of primitive operations, represented in a domain-specific language (DSL) designed for VQA. The DSL covers a set of fundamental operations for visual reasoning, such as filtering out objects with certain concepts or query the attribute of an object. The operations share the same input and output interface, and thus can be compositionally combined to form programs of any complexity. We include a complete specification of the DSL used by our framework in the Appendix A.  Our semantic parser generates the hierarchies of latent programs in a sequence to tree manner <ref type="bibr" target="#b11">(Dong &amp; Lapata, 2016)</ref>. We use a bidirectional GRU <ref type="bibr" target="#b7">(Cho et al., 2014)</ref> to encode an input question, which outputs a fixed-length embedding of the question. A decoder based on GRU cells is applied to the embedding, and recovers the hierarchy of operations as the latent program. Some operations takes concepts their parameters, such as Filter( Red ) and Query( Shape ). These concepts are chosen from all concepts appeared in the input question. <ref type="figure" target="#fig_1">Figure 4</ref>(B) shows an example, while more details can be found in Appendix B.</p><p>Quasi-symbolic program execution. Given the latent program recovered from the question in natural language, a symbolic program executor executes the program and derives the answer based on the object-based visual representation. Our program executor is a collection of deterministic functional modules designed to realize all logic operations specified in the DSL. <ref type="figure" target="#fig_1">Figure 4</ref>(B) shows an illustrative execution trace of a program.</p><p>To make the execution differentiable w.r.t. visual representations, we represent the intermediate results in a probabilistic manner: a set of objects is represented by a vector, as the attention mask over all objects in the scene. Each element, Mask i ? [0, 1] denotes the probability that the i-th object of the scene belongs to the set. For example, shown in <ref type="figure" target="#fig_1">Figure 4</ref>(B), the first Filter operation outputs a mask of length 4 (there are in total 4 objects in the scene), with each element representing the probability that the corresponding object is selected out (i.e., the probability that each object is a green cube). The output "mask" on the objects will be fed into the next module (Relate in this case) as input and the execution of programs continues. The last module outputs the final answer to the question. We refer interested readers to Appendix C for the implementation of all operators.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">TRAINING PARADIGM</head><p>Optimization objective. The optimization objective of NS-CL is composed of two parts: concept learning and language understanding. Our goal is to find the optimal parameters ? v of the visual perception module Perception (including the ResNet-34 for extracting object features, attribute operators. and concept embeddings) and ? s of the semantic parsing module SemanticParse, to maximize the likelihood of answering the question Q correctly:</p><formula xml:id="formula_0">? v , ? s ? arg max ?v,?s E P [Pr[A = Executor(Perception(S; ? v ), P )]],<label>(1)</label></formula><p>where P denotes the program, A the answer, S the scene, and Executor the quasi-symbolic executor. The expectation is taken over P ? SemanticParse(Q; ? s ).</p><p>Recall the program executor is fully differentiable w.r.t. the visual representation. We compute the gradient w.</p><formula xml:id="formula_1">r.t. ? v as ? ?v E P [D KL (Executor(Perception(S; ? v ), P ) A)].</formula><p>We use <ref type="bibr">RE-INFORCE (Williams, 1992)</ref> to optimize the semantic parser ? s :</p><formula xml:id="formula_2">? ?s = E P [r ? log Pr[P = SemanticParse(Q; ? s )]]</formula><p>, where the reward r = 1 if the answer is correct and 0 otherwise. We also use off-policy search to reduce the variance of REINFORCE, the detail of which can be found in Appendix D.</p><p>Curriculum visual concept learning. Motivated by human concept learning as in <ref type="figure" target="#fig_4">Figure 1</ref>, we employ a curriculum learning approach to help joint optimization. We heuristically split the training samples into four stages <ref type="figure" target="#fig_1">(Figure 4</ref>(A)): first, learning object-level visual concepts; second, learning relational questions; third, learning more complex questions with perception modules fixed; fourth, joint fine-tuning of all modules. We found that this is essential to the learning of our neuro-symbolic concept learner. We include more technical details in Appendix E.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">EXPERIMENTS</head><p>We demonstrate the following advantages of our NS-CL. First, it learns visual concepts with remarkable accuracy; second, it allows data-efficient visual reasoning on the CLEVR dataset (Johnson et al., 2017a); third, it generalizes well to new attributes, visual composition, and language domains.</p><p>We train NS-CL on 5K images (&lt;10% of CLEVR's 70K training images). We generate 20 questions for each image for the entire curriculum learning process. The Mask R-CNN module is pretrained on 4K generated CLEVR images with bounding box annotations, following Yi et al. <ref type="bibr">(2018)</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">VISUAL CONCEPT LEARNING</head><p>Classification-based concept evaluation. Our model treats attributes as neural operators that map latent object representations into an attribute-specific embedding space ( <ref type="figure">Figure 3</ref>). We evaluate the concept quantization of objects in the CLEVR validation split. Our model can achieve near perfect classification accuracy (?99%) for all object properties, suggesting it effectively learns generic concept representations. The result for spatial relations is relatively lower, because CLEVR does not have direct queries on the spatial relation between objects. Thus, spatial relation concepts can only be learned indirectly.</p><p>Count-based concept evaluation. The SOTA methods do not provide interpretable representation on individual objects <ref type="bibr">(Johnson et al., 2017a;</ref><ref type="bibr">Hudson &amp; Manning, 2018;</ref><ref type="bibr">Mascharka et al., 2018)</ref> .</p><p>To evaluate the visual concepts learned by such models, we generate a synthetic question set. The diagnostic question set contains simple questions as the following form: "How many red objects are there?". We evaluate the performance on all concepts appeared in the CLEVR dataset.  <ref type="bibr" target="#b19">, 2018;</ref><ref type="bibr">Hudson &amp; Manning, 2018)</ref>. Our approach outperforms IEP by a significant margin (8%) and attention-based baselines by &gt;2%, suggesting object-based visual representations and symbolic reasoning helps to interpret visual concepts.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">DATA-EFFICIENT AND INTERPRETABLE VISUAL REASONING</head><p>NS-CL jointly learns visual concepts, words and semantic parsing by watching images and reading paired questions and answers. It can be directly applied to VQA.  <ref type="table" target="#tab_4">Table 2</ref>: We also evaluate the learned visual concepts using a diagnostic question set containing simple questions such as "How many red objects are there?". NS-CL outperforms both convolutional and attentional baselines. The suggested object-based visual representation and symbolic reasoning approach perceives better interpretation of visual concepts.   Here, the visual perception module is pre-trained on ImageNet <ref type="bibr" target="#b9">(Deng et al., 2009)</ref>. Without pretraining, the concept learning accuracies drop by 0.2% on average and the QA accuracy drops by 0.5%. Meanwhile, NS-CL recovers the underlying programs of questions accurately (&gt; 99.9% accuracy). NS-CL can also detect ambiguous or invalid programs and indicate exceptions. Please see Appendix F for more details. NS-CL can also be applied to other visual reasoning testbeds. Please refer to Appendix G.1 for our results on the Minecraft dataset <ref type="bibr" target="#b19">(Yi et al., 2018)</ref>.</p><p>For a systematic study on visual features and data efficiency, we implement two variants of the baseline models: TbD-Object and MAC-Object. Inspired by <ref type="bibr" target="#b1">(Anderson et al., 2018)</ref>, instead of the input image, TbD-Object and MAC-Object take a stack of object features as input. TbD-Mask and MAC-Mask integrate the masks of objects by using them to guide the attention over the images.   Generalizing to new visual concepts. We expect the process of concept learning can take place in an incremental manner: having learned 7 different colors, humans can learn the 8-th color incrementally and efficiently. To this end, we build a synthetic split of the CLEVR dataset to replicate the setting of incremental concept learning. Split A contains only images without any purple objects, while split B contains images with at least one purple object. We train all the models on split A first, and finetune them on 100 images from split B. We report the final QA performance on split B's validation set. All models use a pre-trained semantic parser on the full CLEVR dataset. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">COMBINATORIAL GENERALIZATION TO NEW SCENES AND QUESTIONS</head><p>Having learned visual concepts on small-scale scenes (containing only few objects) and simple questions (only single-hop questions), we humans can easily generalize the knowledge to larger-scale scenes and to answer complex questions. To evaluate this, we split the CLEVR dataset into four parts: Split A contains only scenes with less than 6 objects, and questions whose latent programs having a depth less than 5; Split B contains scenes with less than 6 objects, but arbitrary questions; Split C contains arbitrary scenes, but restricts the program depth being less than 5; Split D contains arbitrary scenes and questions. <ref type="figure" target="#fig_2">Figure 6</ref> shows some illustrative samples.</p><p>As VQA baselines are unable to count a set of objects of arbitrary size, for a fair comparison, all programs containing the "count" operation over &gt; 6 objects are removed from the set. For</p><p>Caption: There is a big yellow cylinder in front of a gray object.</p><p>(a) An illustrative pair of image and caption in our synthetic dataset.  methods using explicit program semantics, the semantic parser is pre-trained on the full dataset and fixed. Methods with implicit program semantics (Hudson &amp; Manning, 2018) learn an entangled representation for perception and reasoning, and cannot trivially generalize to more complex programs. We only use the training data from the Split A and then quantify the generalization ability on other three splits. Shown in <ref type="table" target="#tab_13">Table 5</ref>, our NS-CL leads to almost-perfect generalization to larger scenes and more complex questions, outperforming all baselines by at least 4% in QA accuracy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Model</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">EXTENDING TO OTHER PROGRAM DOMAIN</head><p>The learned visual concepts can also be used in other domains such as image retrieval. With the visual scenes fixed, the learned visual concepts can be directly transferred into the new domain. We only need to learn the semantic parsing of natural language into the new DSL.</p><p>We build a synthetic dataset for image retrieval and adopt a DSL from scene graph-based image retrieval <ref type="bibr">(Johnson et al., 2015)</ref>. The dataset contains only simple captions: "There is an &lt;object A&gt; &lt;relation&gt; &lt;object B&gt;." (e.g., There is a box right of a cylinder). The semantic parser learns to extract corresponding visual concepts (e.g., box, right, and cylinder) from the sentence. The program can then be executed on the visual representation to determine if the visual scene contains such relational triples.</p><p>For simplicity, we treat retrieval as classifying whether a relational triple exists in the image. This functionality cannot be directly implemented on the CLEVR VQA program domain, because questions such as "Is there a box right of a cylinder" can be ambiguous if there exist multiple cylinders in the scene. Due to the entanglement of the visual representation with the specific DSL, baselines trained on CLEVR QA can not be directly applied to this task. For a fair comparison with them, we show the result in <ref type="table" target="#tab_13">Table 5b</ref> on a subset of the generated image-caption pairs where the underlying programs have no ambiguity regarding the reference of object B. A separate semantic parser is trained for the VQA baselines, which translates captions into a CLEVR QA-compatible program (e.g., Exist(Filter(Box, Relate(Right, Filter(Cylinder))).  <ref type="bibr" target="#b13">(Gan et al., 2017)</ref>. VQS contains a subset of images and questions from the original VQA 1.0 dataset <ref type="bibr" target="#b3">(Antol et al., 2015)</ref>. All questions in the VQS dataset can be visually grounded: each question is associated with multiple image regions, annotated by humans as essential for answering the question. <ref type="figure">Figure 7</ref> illustrates an execution trace of NS-CL on VQS.</p><p>We use a syntactic dependency parser to extract programs and concepts from language <ref type="bibr" target="#b2">(Andreas et al., 2016;</ref><ref type="bibr">Schuster et al., 2015)</ref>. The object proposals and features are extracted from models pre-trained on the MS-COCO dataset and the ImageNet dataset, respectively. Illustrated in <ref type="figure">Figure 7</ref>, our model  In this paper, we focus on a neuro-symbolic framework that learns visual concepts about object properties and relations. Indeed, visual question answering requires AI systems to reason about more general concepts such as events or activities <ref type="bibr">(Levin, 1993)</ref>. We leave the extension of NS-CL along this direction and its application to general VQA datasets <ref type="bibr" target="#b3">(Antol et al., 2015)</ref> as future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">DISCUSSION AND FUTURE WORK</head><p>We presented a method that jointly learns visual concepts, words, and semantic parsing of sentences from natural supervision. The proposed framework, NS-CL, learns by looking at images and reading paired questions and answers, without any explicit supervision such as class labels for objects. Our model learns visual concepts with remarkable accuracy. Based upon the learned concepts, our model achieves good results on question answering, and more importantly, generalizes well to new visual compositions, new visual concepts, and new domain specific languages.</p><p>The design of NS-CL suggests multiple research directions. First, constructing 3D object-based representations for realistic scenes needs further exploration <ref type="bibr" target="#b1">(Anderson et al., 2018;</ref><ref type="bibr" target="#b5">Baradel et al., 2018)</ref>. Second, our model assumes a domain-specific language for describing formal semantics. The integration of formal semantics into the processing of complex natural language would be meaningful future work <ref type="bibr" target="#b4">(Artzi &amp; Zettlemoyer, 2013;</ref><ref type="bibr">Oh et al., 2017)</ref>. We hope our paper could motivate future research in visual concept learning, language learning, and compositionality.</p><p>Our framework can also be extended to other domains such as video understanding and robotic manipulation. Here, we would need to discover semantic representations for actions and interactions (e.g., push) beyond static spatial relations. Along this direction, researchers have studied building symbolic representations for skills <ref type="bibr">(Konidaris et al., 2018)</ref> and learning instruction semantics from interaction <ref type="bibr">(Oh et al., 2017)</ref> in constrained setups. Applying neuro-symbolic learning frameworks for concepts and skills would be meaningful future work toward robotic learning in complex interactive environments.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A CLEVR DOMAIN-SPECIFIC LANGUAGE AND IMPLEMENTATIONS</head><p>We first introduce the domain-specific language (DSL) designed for the CLEVR VQA dataset <ref type="bibr">(Johnson et al., 2017a)</ref>. <ref type="table">Table 6</ref> shows the available operations in the DSL, while CGreaterThan (ObjectSet, ObjectSet) ?? Bool (Counting GreaterThan) Query if the number of objects in the first input set is greater than the one of the second set.</p><p>CEqual (ObjectSet, ObjectSet) ?? Bool (Counting Equal) Query if the number of objects in the first input set is the same as the one of the second set. <ref type="table">Table 6</ref>: All operations in the domain-specific language for CLEVR VQA.</p><p>We note that some function takes Object as its input instead of ObjectSet. These functions require the uniqueness of the referral object. For example, to answer the question "What's the color of the red object?", there should be one and only one red object in the scene. During the program execution, the input object set will be implicitly cast to the single object (if the set is non-empty and there is only one object in the set  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B SEMANTIC PARSING</head><p>As shown in Appendix A, a program can be viewed as a hierarchy of operations which take concepts as their parameters. Thus, NS-CL generates the hierarchies of latent programs in a sequence to tree manner <ref type="bibr" target="#b11">(Dong &amp; Lapata, 2016)</ref>. The semantic parser adopts an encoder-decoder architecture, which contains four neural modules: (1) a bidirectional GRU encoder IEncoder <ref type="bibr" target="#b7">(Cho et al., 2014)</ref> to encode an input question into a fixed-length embedding, <ref type="formula" target="#formula_8">(2)</ref> an operation decoder OpDecoder that determines the operation tokens, such as Filter, in the program based on the sentence embedding, (3) a concept decoder ConceptDecoder that selects concepts appeared in the input question as the parameters for certain operations (e.g., Filter takes an object-level concept parameter while Query takes an attribute), and (4) a set of output encoders {OEncoder i } which encode the decoded operations by OpDecoder and output the latent embedding for decoding the next operation. The operation decoder, the concept decoder, and the output encoders work jointly and recursively to generate the hierarchical program layout. Algorithm 1 illustrates the algorithmic outline of the semantic parser. The concept set {c i } is extracted using hand-coded rules. We assume that each concept (including object-level concepts, relational concepts, and attributes) is associated with a single word in the question. For example, the word "red" is associated with the object-level concept Red, while the word "shape" is associated with the attribute Shape. Informally, we call these words concept words. For a given question Q, the corresponding concept set {c i } is composed of all occurrences of the concept words in Q. The set of concept words is known for the CLEVR dataset. For natural language questions, one could run POS tagging to find all concept words <ref type="bibr" target="#b2">(Andreas et al., 2016;</ref><ref type="bibr">Schuster et al., 2015)</ref>. We leave the automatic discovery of concept words as a future work <ref type="bibr" target="#b15">(Gauthier et al., 2018)</ref>. We use the word embedding of the concept words as the representation for the concepts {c i }. Note that, these "concept embeddings" are only for the program parsing. The visual module has separate concept embeddings for aligning object features with concepts in the visual-semantic space.</p><p>We now delve into the main function parse(f, {c i }): we first decode the root operation op of the hierarchy by OpDecoder(f ). If op requires a concept parameter (an object-level concept, a relational concept, or an attribute), ConceptDecoder will be invoked to choose a concept from all concepts {c i }. Assuming op takes two non-concept inputs (e.g., the operation Intersection takes two object sets as its input), there will be two branches for this root node. Thus, two output encoders OEncoder 0 and OEncoder 1 will be applied to transform the current state f into two sub-states f 1 and f 2 . parse will be recursively invoked based on f 1 and f 2 to generate the two branches respectively. In the DSL, the number of non-concept inputs for any operation is at most 2.</p><p>In our implementation, the input encoder IEncoder first maps each word in the question into an embedding space. The word embeddings are composed of two parts: a randomly initialized word embedding of dimension 256 and a positional embedding of dimension 128 <ref type="bibr" target="#b16">(Gehring et al., 2017)</ref>. For a concept word, its word embedding only depends on which type it belongs to (i.e. object-level, relational or attribute). Thus, after being trained on a fixed dataset, the semantic parser can parse questions with novel (unseen) concept words. The sequence of word embeddings is then encoded by a two-layer GRU with a hidden dimension of 256 * 2 (bidirectional). The function parse starts from the last hidden state of the GRU, and works recursively to generate the hierarchical program layout. Both OpDecoder and ConceptDecoder are feed-forward networks. ConceptDecoder performs attentions over the representations of all concepts {c i } to select the concepts. Output encoders OEncoder 0 and OEncoder 1 are implemented as GRU cells.</p><p>Another pre-processing of the sentence is to group consecutive object-level concept words into a group and treat them together as a single concept, inspired by the notion of "noun phrases" in natural languages. The computational intuition behind this grouping is that, the latent programs of CLEVR questions usually contain multiple consecutive Filter tokens. During the program parsing and execution, we aim to fuse all such Filters into a single Filter operation that takes multiple concepts as its parameter.</p><p>A Running Example As a running example, consider again the question "What is the color of the cube right of the red matte object?". We first process the sentence (by rules) as: "What is the &lt;Attribute 1 (color)&gt; of the &lt;(ObjConcept 1 (cube)&gt; &lt;RelConcept 1 (right)&gt; of the &lt;ObjConcept 2 (red matte object)&gt;?". The expected parsing result of this sentence is:</p><formula xml:id="formula_3">Query(&lt;Attribute 1&gt;,</formula><p>Filter(&lt;ObjConcept 1&gt;, Relate(&lt;RelConcept 1&gt;, Filter(&lt;ObjConcept 2&gt;, Scene) ) ) ).</p><p>The semantic parser encode the word embeddings with IEncoder. The last hidden state of the GRU will be used as f 0 . The word embeddings of the concept words form the set {c i } = {Attribute 1, ObjConcept 1, RelConcept 1, ObjConcept 2}. The function parse is then invoked recursively to generate the hierarchical program layout. <ref type="table" target="#tab_19">Table 8</ref> illustrates the decoding process step-by-step.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C PROGRAM EXECUTION</head><p>In this section, we present the implementation of all operations listed in <ref type="table">Table 6</ref>. We start from the implementation of Object-typed and ObjectSet-typed variables. Next, we discuss how to classify objects by object-level concepts or relational concept, followed by the implementation details of all operations.</p><p>Object-typed and ObjectSet-typed variables. We consider a scene with n objects. An Objecttyped variable can be represented as a vector Object of length n, where Object i ? [0, 1] and i Object i = 1. Object i can be interpreted as the probability that the i-th object of the scene is being referred to. Similarly, an ObjectSet-typed variable can be represented as a vector ObjectSet of length n, where ObjectSet i ? [0, 1]. ObjectSet i can be interpreted as the probability that the i-the object is in the set. To cast an ObjectSet-typed variable ObjectSet as an Object-typed variable</p><p>Step Inputs Outputs</p><p>Recursive Invocation</p><formula xml:id="formula_4">1 f 0 OpDecoder(f 0 ) ? Query; ConceptDecoder(f 0 ) ?&lt; Attribute 1 &gt;; OEncoder 0 (f 0 , Query) ? f 1 parse(f 1 ) 2 f 1 OpDecoder(f 1 ) ? Filter; ConceptDecoder(f 1 ) ?&lt; ObjConcept 1 &gt;; OEncoder 0 (f 1 , Filter) ? f 2 parse(f 2 ) 3 f 2 OpDecoder(f 2 ) ? Relate; ConceptDecoder(f 2 ) ?&lt; RelConcept 1 &gt;; OEncoder 0 (f 2 , Relate) ? f 3 parse(f 3 ) 4 f 3 OpDecoder(f 3 ) ? Filter; ConceptDecoder(f 3 ) ?&lt; ObjConcept 2 &gt;; OEncoder 0 (f 3 , Filter) ? f 4 parse(f 4 ) 5 f 4 OpDecoder(f 3 ) ? Scene;</formula><p>(End of branch.) Object (i.e., the Unique operation), we compute: Object = softmax(? ?1 (ObjectSet)), where ? ?1 (x) = log(x/ <ref type="figure" target="#fig_4">(1 ? x)</ref>) is the logit function.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Concept quantization.</head><p>Denote o i as the visual representation of the i-th object, OC the set of all object-level concepts, and A the set of all object-level attributes. Each object-level concept oc (e.g., Red) is associated with a vector embedding v oc and a L1-normalized vector b oc of length |A|. b oc represents which attribute does this object-level concept belong to (e.g., the concept Red belongs to the attribute Color). All attributes a ? A are implemented as neural operators, denoted as u a (e.g., u Color ). To classify the objects as being Red or not, we compute:</p><formula xml:id="formula_5">Pr[object i is Red] = ? a?A b Red a ? u a (o i ), v Red ? ? ? ,</formula><p>where ? denotes the Sigmoid function, ?, ? the cosine distance between two vectors. ? and ? are scalar constants for scaling and shifting the values of similarities. By applying this classifier on all objects we will obtain a vector of length n, denoted as ObjClassify(Red). Similarly, such classification can be done for relational concepts such as Left. This will result in an n ? n matrix RelClassify(Left), where RelClassify(Left) j,i is the probability that the object i is left of the object j.</p><p>To classify whether two objects have the same attribute (e.g., have the same Color), we compute:</p><formula xml:id="formula_6">Pr[object i has the same Color as object j] = ? u Color (o i ), u Color (o j ) ? ? ? ,</formula><p>We can obtain a matrix AEClassify(Color) by applying this classifier on all pairs of objects, where AEClassifier(Color) j,i is the probability that the object i and j have the same Color.</p><p>Quasi-symbolic program execution. Finally, <ref type="table">Table 9</ref> summarizes the implementation of all operators. In practice, all probabilities are stored in the log space for better numeric stability.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D OPTIMIZATION OF THE SEMANTIC PARSER</head><p>To tackle the optimization in a non-smooth program space, we apply an off-policy program search process <ref type="bibr">(Sutton et al., 2000)</ref> to facilitate the learning of the semantic parser. Denote P(s) as the set of all valid programs in the CLEVR DSL for the input question s. We want to compute the gradient w.r.t. ? s , the parameters of the semantic parser:</p><formula xml:id="formula_7">? ?s = ? ?s E P [r ? log Pr[P ]],</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Signature Implementation</head><p>Scene() ? out: ObjectSet outi := 1</p><p>Filter(in: ObjectSet, oc: ObjConcept) ? out: ObjectSet outi := min(ini, ObjClassify(oc)i)</p><p>Relate(in: Object, rc: RelConcept) ? out: ObjectSet outi := j (inj ? RelClassify(rc)j,i)) AERelate(in: Object, a: Attribute) ? out: ObjectSet outi := j (inj ? AEClassify(a)j,i))</p><p>Intersection(in <ref type="bibr" target="#b17">(1)</ref> : ObjectSet, in <ref type="bibr" target="#b18">(2)</ref> : ObjectSet) ? out: ObjectSet outi := min(in <ref type="bibr" target="#b17">(1)</ref> i , in</p><p>i )</p><p>Union(in <ref type="bibr" target="#b17">(1)</ref> : ObjectSet, in <ref type="bibr" target="#b18">(2)</ref> : ObjectSet) ? out: ObjectSet outi := max(in <ref type="bibr" target="#b17">(1)</ref> i , in</p><p>i ) Query(in: Object, a: Attribute) ? out: ObjConcept Pr[out = oc] := i ini ? ObjClassify(oc)i ? b oc a oc ObjClassify(oc )i ? b oc a AEQuery(in <ref type="bibr" target="#b17">(1)</ref> : Object, in <ref type="bibr" target="#b18">(2)</ref> : Object, a: Attribute) ? b:</p><formula xml:id="formula_10">Bool b := i j (in (1) i ? in<label>(2)</label></formula><p>j ? AEClassify(a)j,i))</p><formula xml:id="formula_11">Exist(in: ObjectSet) ? b: Bool b := maxi ini Count(in: ObjectSet) ? i: Integer i := i ini CLessThan(in (1) : ObjectSet, in (2) : ObjectSet) ? b: Bool b := ? ( i in (2) i ? i in (1) i ? 1 + ?c)/?c CGreaterThan(in (1) : ObjectSet, in (2) : ObjectSet) ? b: Bool b := ? ( i in (1) i ? i in (2) i ? 1 + ?c)/?c CEqual(in (1) : ObjectSet, in (2) : ObjectSet) ? b: Bool b := ? (?| i in (1) i ? i in<label>(2)</label></formula><p>i | + ?c)/(?c ? ?c)  where P ? SemanticParse(s; ? s ). In REINFORCE, we approximate this gradient via Monte Carlo sampling.</p><p>An alternative solution is to exactly compute the gradient. Note that in the definition of the reward r, only the set of programs Q(s) leading to the correct answer will contribute to the gradient term.</p><p>With the perception module fixed, the set Q can be efficiently determined by an off-policy exhaustive search of all possible programs P(s). In the third stage of the curriculum learning, we search for the set Q offline based on the quantified results of concept classification and compute the exact gradient ?? s . An intuitive explanation of the off-policy search is that, we enumerate all possible programs, execute them on the visual representation, and find the ones leading to the correct answer. We use Q(s) as the "groundtruth" program annotation for the question, to supervise the learning, instead of running the Monte Carlo sampling-based REINFORCE.</p><p>Spurious program suppression. However, directly using Q(s) as the supervision by computing = p?Q(S) ? log Pr(p) can be problematic, due to the spuriousness or the ambiguity of the programs. This comes from two aspects: 1) intrinsic ambiguity: two programs are different but equivalent. For example P1: AEQuery(Color, Filter(Cube), Filter(Sphere)) and P2: Exist(Filter(Sphere, AERelate(Color, Filter(Cube)))) are equivalent. 2) extrinsic spuriousness: one of the program is incorrect, but also leads to the correct answer in a specific scene. For example, P1: Filter(Red, Relate(Left, Filter(Sphere))) and P2: Filter(Red, Relate(Left, Filter(Cube))) may refer to the same red object in a specific scene. Motivated by the REINFORCE process, to suppress such spurious programs, we use the loss function: The corresponding gradient ? ?s is,</p><formula xml:id="formula_12">? ?s = p?Q Pr[p] ? ? ?s (r ? log Pr[P ]) = ? ?s ? ? p?Q r ? Pr[p] ? ? .</formula><p>The key observation is that, given a sufficiently large set of scenes, a program can be identified as spurious if there exists at least one scene where the program leads to a wrong answer. As the training goes, spurious programs will get less update due to the sampling importance term Pr[p] which weights the likelihood maximization term.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E CURRICULUM LEARNING SETUP</head><p>During the whole training process, we gradually add more visual concepts and more complex question examples into the model. Summarized in <ref type="figure" target="#fig_1">Figure 4(A)</ref>, in general, the whole training process is split into 3 stages. First, we only use questions from lesson 1 to let the model learn object-level visual concepts. Second, we train the model to parse simple questions and to learn relational concepts. In this step, we freeze the neural operators and concept embeddings of object-level concepts. Third, the model gets trained on the full question set (lesson 3), learning to understand questions of different complexities and various format. For the first several iterations in this step, we freeze the parameters in the perception modules. In addition, during the training of all stages, we gradually increase the number of objects in the scene: from 3 to 10.</p><p>We select questions for each lesson in the curriculum learning by their depth of the latent program layout. For eaxmple, the program "Query(Shape, Filter(Red, Scene))" has the depth of 3, while the program "Query(Shape, Filter(Cube, Relate(Left, Filter(Red, Scene))))" has the depth of 5. Since we have fused consecutive Filter operations into a single one, the maximum depth of all programs is 9 on the CLEVR dataset. We now present the detailed split of our curriculum learning lessons:</p><p>For lesson 1, we use only programs of depth 3. It contains three types of questions: querying an attribute of the object, querying the existence of a certain type of objects, count a certain type of objects, and querying if two objects have the same attribute (e.g., of the same color). These questions are almost about fundamental object-based visual concepts. For each image, we generate 5 questions of lesson 1.</p><p>For lesson 2, we use programs of depth less than 5, containing a number of questions regarding relations, such as querying the attribute of an object that is left of another object. We found that in the original CLEVR dataset, all Relate operations are followed by a Filter operation. This setup degenerates the performance of the learning of relational concepts such as Left. Thus, we add a new question template into the original template set: Count(Relate( ? , Filter( ? , Scene))) (e.g., "What's the number of objects that are left of the cube?"). For each image, we generate 5 questions of lesson 2.</p><p>For lesson 3, we use the full CLEVR question set.</p><p>Curriculum learning is crucial for the learning of our neuro-symbolic concept learner. We found that by removing the curriculum setup w.r.t. the number of object in the scenes, the visual perception module will get stuck at an accuracy that is similar to a random-guess model, even if we only use stage-1 questions. If we remove the curriculum setup w.r.t. the complexity of the programs, the joint training of the visual perception module and the semantic parser can not converge.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>F ABLATION STUDY</head><p>We conduct ablation studies on the accuracy of semantic parsing, the impacts of the ImageNet pretraining of visual perception modules, the data efficiency of our model, and the usage of object-based representations.</p><p>F.1 SEMANTIC PARSING ACCURACY.</p><p>We evaluate how well our model recovers the underlying programs of questions. Due to the intrinsic equivalence of different programs, we evaluate the accuracy of programs by executing them on the ground-truth annotations of objects. Invalid or ambiguous programs are also considered as incorrect. Our semantic parser archives &gt; 99.9% QA accuracy on the validation split. The only extra supervision of the visual perception module comes from the pre-training of the perception modules on ImageNet <ref type="bibr" target="#b9">(Deng et al., 2009)</ref>. To quantify the influence of this pre-training, we conduct ablation experiments where we randomly initialize the perception module following <ref type="bibr">He et al. (2015)</ref>. The classification accuracies of the learned concepts almost remain the same except for Shape. The classification accuracy of Shape drops from 98.7 to 97.5 on the validation set while the overall QA accuracy on the CLEVR dataset drops to 98.2 from 98.9. We speculate that large-scale image recognition dataset can provide prior knowledge of shape.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>F.3 DATA EFFICIENCY AND OBJECT-BASED REPRESENTATIONS</head><p>In this section, we study whether and how the number of training samples and feature representations affect the overall performance of various models on the CLEVR dataset. Specifically, we compare the proposed NS-CL against two strong baselines: TbD <ref type="bibr">(Mascharka et al., 2018)</ref> and <ref type="bibr">MAC (Hudson &amp; Manning, 2018)</ref>.</p><p>Baselines. For comparison, we implement two variants of the baseline models: TbD-Object and MAC-Object. Inspired by <ref type="bibr" target="#b1">Anderson et al. (2018)</ref>, instead of using a 2D convolutional feature map, TbD-Object and MAC-Object take a stack of object features as inputs, whose shape is k ? d obj . k is the number of objects in the scene, and d obj is the feature dimension for a single object. In our experiments, we fix k = 12 as a constant value. If there are fewer than 12 objects in the scene, we add "null" objects whose features are all-zero vectors.</p><p>We extract object features in the same way as NS-CL. Features are extracted from a pre-trained ResNet-34 network before the last residual block for a feature map with high resolution. For each object, its feature is composed of two parts: region-based (by RoI Align) and image-based features. We concatenate them to represent each object. As discussed, the inclusion of the representation of the full scene is essential for the inference of relative attributes such as size or spatial position on the CLEVR domain.</p><p>TbD and MAC networks are originally designed to use image-level attention for reasoning. Thus, we implement two more baselines: TbD-Mask and MAC-Mask. Specifically, we replace the original attention module on images with a mask-guided attention. Denotes the union of all object masks as M . Before the model applies the attention on the input image, we multiply the original attention map computed by the model with this mask M . The multiplication silences the attention on pixels that are not part of any objects.</p><p>Results. <ref type="table" target="#tab_7">Table 3</ref> summarizes the results. We found that TbD-Object and MAC-Object approach show inferior results compared with the original model. We attribute this to the design of the network architectures. Take the Relate operation (e.g., finds all objects left of a specific object x) as an example. TbD uses a stack of dilated convolutional layers to propagate the attention from object x to others. In TbD-Object, we replace the stack of 2D convolutions by several 1D convolution layers, operating over the k ? d obj object features. This ignores the equivalence of objects (the order of objects should not affect the results). In contrast, MAC networks always use the attention mechanism to extract information from the image representation. This operation is invariant to the order of objects, but is not suitable for handling quantities (e.g., counting objects).</p><p>As for TbD-Mask and MAC-Mask, although the mask-guided attention does not improve the overall performance, we have observed noticeably faster convergence during model training. TbD-Mask and MAC-Mask leverage the prior knowledge of object masks to facilitate the attention. Such prior has also been verified to be effective in the original TbD model: TbD employs an attention regularization during training, which encourages the model to attend to smaller regions.</p><p>In general, NS-CL is more data-efficient than MAC networks and TbD. Recall that NS-CL answers questions by executing symbolic programs on the learned visual concepts. Only visual concepts (such as Red and Left) and the interpretation of questions (how to translate questions into executable programs) need to be learned from data. In contrast, both TbD and MAC networks need to additionally learn to execute (implicit or explicit) programs such as counting.</p><p>For the experiments on the full CLEVR training set, we split 3,500 images (5% of the training data) as the hold-out validation set to tune the hyperparameters and select the best model. We then apply this model to the CLEVR validation split and report the testing performance. Our model reaches an accuracy of 99.2% using the CLEVR training set.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>G EXTENDING TO OTHER SCENE AND LANGUAGE DOMAINS G.1 MINECRAFT DATASET</head><p>We also extend the experiments to a new reasoning testbed: Minecraft worlds <ref type="bibr" target="#b19">(Yi et al., 2018)</ref>. The Minecraft reasoning dataset differs from CLEVR in both visual appearance and question types. <ref type="figure" target="#fig_8">Figure 9</ref> gives an example instance from the dataset.  <ref type="bibr">(2017)</ref>. Each image contains 3 to 6 objects. The objects are chosen from 12 categories, with 4 different facing directions (front, back, left and right). They stand on a 2D plane.</p><p>Besides different 3D visual appearance and image contexts, the Minecraft reasoning dataset introduces two new types of reasoning operations. We add them to our domain-specific language:  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>G.2 VQS DATASET</head><p>We conduct experiments on the VQS dataset <ref type="bibr" target="#b13">(Gan et al., 2017)</ref>. VQS is a subset of the VQA 1.0 dataset <ref type="bibr" target="#b3">(Antol et al., 2015)</ref>. It contains questions that can be visually grounded: each question is associated with multiple image regions, annotated by humans as necessary for answering the question.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Q: Does this man have any pens on him?</head><p>A: Yes. P: Exist(Filter(Man, Relate(Have, Filter(Pen)) )) <ref type="figure" target="#fig_4">Figure 10</ref>: An example image from the VQS dataset. The orange bounding boxes are object proposals. On the right, we show the original question and answer in natural language, as well as the latent program recovered by our parser. To answer this question, models are expected to attend to the man and his pen in the pocket.</p><p>Setup. All models are trained on the first 63,509 images of the training set, and tested on the test split. For hyper-parameter tuning and model selection, the rest 5,000 images from the training set are used for validation. We use the multiple-choice setup for VQA: the models choose their most confident answer from 18 candidate answers for each question.</p><p>To obtain the latent programs from natural languages, we use a pre-trained syntactic dependency parser <ref type="bibr" target="#b2">(Andreas et al., 2016;</ref><ref type="bibr">Schuster et al., 2015)</ref> for extracting programs and concepts that need to be learned. A sample question and the program obtained by our parser is shown in <ref type="figure" target="#fig_4">Figure 10</ref>. The concept embeddings are initialized by the bag of words (BoW) over the GloVe word embeddings <ref type="bibr">(Pennington et al., 2014)</ref>.</p><p>Baselines. We compare our model against two representative baselines: <ref type="bibr">MLP (Jabri et al., 2016)</ref> and <ref type="bibr">MAC (Hudson &amp; Manning, 2018)</ref>.</p><p>MLP is a standard baseline for visual-question answering, which treats the multiple-choice task as a ranking problem. For a specific candidate answer, a multi-layer perceptron (MLP) model is used to encode a tuple of the image, the question, and the candidate answer. The MLP outputs a score for each tuple, and the answer to the question is the candidate with the highest score. We encode the image with a ResNet-34 pre-trained on ImageNet and use BoW over the GloVe word embeddings for the question and option encoding.</p><p>We slightly modify the MAC network for the VQS dataset. For each candidate answer, we concatenate the question and the answer as the input to the model. The MAC model outputs a score from 0 to 1 and the answer to the question is the candidate with the highest score. The image features are extracted from the same ResNet-34 model.</p><p>Results. <ref type="table" target="#tab_16">Table 7</ref> summarizes the results. NS-CL achieves comparable results with the MLP baseline and the MAC network designed for visual reasoning. Our model also brings transparent reasoning over natural images and language. Example execution traces generated by NS-CL are shown in <ref type="figure" target="#fig_4">Figure 13</ref>. Besides, the symbolic reasoning process helps us to inspect the model and diagnose the error sources. See the caption for details.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>H VISUALIZATION OF EXECUTION TRACES AND VISUAL CONCEPTS</head><p>Another appealing benefit is that our reasoning model enjoys full interpretability. <ref type="figure" target="#fig_4">Figure 11, Figure 12</ref>, and <ref type="figure" target="#fig_4">Figure 13</ref> show NS-CL's execution traces on CLEVR, Minecraft, and VQS, respectively. As a side product, our system detects ambiguous and invalid programs and throws out exceptions. As an example <ref type="figure" target="#fig_4">(Figure 11</ref>), the question "What's the color of the cylinder?" can be ambiguous if there are multiple cylinders or even invalid if there are no cylinders. <ref type="figure" target="#fig_1">Figure 14</ref> and <ref type="figure" target="#fig_4">Figure 15</ref> include qualitative visualizations of the concepts learned from the CLEVR and Minecraft datasets, including object categories, attributes, and relations. We choose samples from the validation or test split of each dataset by generating queries of the corresponding concepts. We set a threshold to filter the returned images and objects. For quantitative evaluations of the learned concepts on the CLEVR dataset, please refer to <ref type="table" target="#tab_4">Table 2</ref> and <ref type="table" target="#tab_13">Table 5</ref>.</p><p>Q: Do the cyan cylinder that is behind the gray cylinder and the gray cylinder have the same material?  <ref type="figure" target="#fig_4">Figure 11</ref>: Visualization of the execution trace generated by our Neuro-Symbolic Concept Learner on the CLEVR dataset. Example A and B are successful executions that generate correct answers. In example C, the execution aborts at the first operator. To inspect the reason why the execution engine fails to find the corresponding object, we can read out the visual representation of the object, and locate the error source as the misclassification of the object material. Example D shows how our symbolic execution engine can detect invalid or ambiguous programs during the execution by performing sanity checks.  Our model effectively learns visual concepts from data. The symbolic reasoning process brings transparent execution trace and can easily handle quantities (e.g., object counting in Example A). In Example C, although NS-CL answers the question correctly, it locates the wrong object during reasoning: a dish instead of the cake. In Example D, our model misclassifies the sport as frisbee.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>AEQuery</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Concept: Wolf</head><p>Concept: Animal That Faces Right</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Concept: Closest Living Thing</head><p>Concept: Villager Closer Than Pig <ref type="figure" target="#fig_4">Figure 15</ref>: Concepts learned on the Minecraft dataset.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>along four directions: visual features, semantics, inference, and the requirement of extra labels. For visual representations, Johnson et al. (2017b) encoded visual scenes into a convolutional feature map for program operators. Mascharka et al. (2018); Hudson &amp; Manning (2018) used attention as intermediate representations for transparent program execution.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 4 :</head><label>4</label><figDesc>A. Demonstration of the curriculum learning of visual concepts, words, and semantic parsing of sentences by watching images and reading paired questions and answers. Scenes and questions of different complexities are illustrated to the learner in an incremental manner. B. Illustration of our neuro-symbolic inference model for VQA. The perception module begins with parsing visual scenes into object-based deep representations, while the semantic parser parse sentences into executable programs. A symbolic execution process bridges two modules.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 6 :</head><label>6</label><figDesc>Samples collected from four splits in Section 4.3 for illustration. Models are trained on split A but evaluated on all splits for testing the combinatorial generalization.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 8 :</head><label>8</label><figDesc>Concepts learned from VQS, including object categories, attributes, and relations. shows competitive performance on QA accuracy, comparable with the MLP baseline (Jabri et al., 2016) and the MAC network (Hudson &amp; Manning, 2018). Additional illustrative execution traces of NS-CL are in Appendix H. Beyond answering questions, NS-CL effectively learns visual concepts from data. Figure 8 shows examples of the learned visual concepts, including object categories, attributes, and relations. Experiment setup and implementation details are in Appendix G.2.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Algorithm 1 :</head><label>1</label><figDesc>The String-to-Tree Semantic Parser. Function parse(f , {c i }): program ? EmptyProgram(); program.op ? OpDecoder(f ); if program.op requires a concept parameter then program.concept ? ConceptDecoder(f, {c i }); for i = 0, 1, ? ? ? number of non-concept inputs of program.op do program.input[i] ? parse ( OEncoder i (f , program.op) ,{c i } ); return programThe function parse takes two inputs: the current decoding state f and all concepts appeared in the question, as a set {c i }. The parsing procedure begins with encoding the input question by IEncoder as f 0 , extracting the concept set {c i } from the input question, and invoking parse(f 0 , {c i }).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>9: All operations in the domain-specific language for CLEVR VQA. ? c = 0.5 and ? c = 0.25 are constants for scaling and shift the probability. During inference, one can quantify all operations as Yi et al. (2018).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>Pr[p]) ? (? log Pr[p]).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>F. 2</head><label>2</label><figDesc>IMPACTS OF THE IMAGENET PRE-TRAINING.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Q:Figure 9 :</head><label>9</label><figDesc>What direction is the closest creature facing? An example image and a related question-answering pair from the Minecraft dataset. Setup. Following Yi et al. (2018), we generate 10,000 Minecraft scenes using the officially opensourced tools by Wu et al.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 13 :</head><label>13</label><figDesc>Illustrative execution trace generated by our Neuro-Symbolic Concept Learner on the VQS dataset. Execution traces A and B shown in the figure leads to the correct answer to the question.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 :</head><label>1</label><figDesc>Comparison with other frameworks on the CLEVR VQA dataset, w.r.t. visual features, implicit or explicit semantics and supervisions.</figDesc><table><row><cell>1</cell><cell>3 4</cell><cell>2</cell><cell>? #</cell><cell cols="2">Obj 3 Obj 2 Visual Representation Obj 1</cell><cell>Sphere Concept Embeddings</cell><cell>??</cell><cell>Symbolic Reasoning Back-propagation</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>Obj 4</cell><cell></cell><cell cols="2">Back-propagation</cell><cell>Answer: Cylinder</cell></row><row><cell cols="4">sphere? the red object left of the Q: What is the shape of</cell><cell>? "</cell><cell cols="4">?? ? Exist(AERelate(Shape, Filter(Red, Relate(Left, Filter(Sphere))))) ? Query(Shape, Filter(Sphere, Relate(Left, Filter(Red)))) ? Query(Shape, Filter(Red, Relate(Left, Filter(Sphere)))) Semantic Parsing (Candidate Interpretations)</cell><cell>REINFORCE Groundtruth: Box</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>ShapeOf( ) =</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>Cube</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>Sphere</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>Cylinder</cell></row><row><cell></cell><cell cols="2">Similarity( ShapeOf(Obj1) Cube ,</cell><cell>) = 0.99</cell></row><row><cell>Visual Perception Module</cell><cell>Visual Attribute Operators</cell><cell cols="2">Visual-Semantic Space</cell><cell>Concept Embeddings</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 2 summarizes</head><label>2</label><figDesc></figDesc><table /><note>the results compared with strong baselines, including methods based on con- volutional features (Johnson et al., 2017b) and those based on neural attentions (Mascharka et al.</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>Visual Mean Color Mat. Shape Size IEP Conv. 90.6 91.0 90.0 89.9 90.6 MAC Attn. 95.9 98.0 91.4 94.4 94.2 TbD (hres.) Attn. 96.5 96.6 92.2 95.4 92.6</figDesc><table><row><cell>NS-CL</cell><cell>Obj. 98.7 99.0 98.7 98.1 99.1</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head>Table 3 :</head><label>3</label><figDesc>We compare different variants of baselines for a systematic study on visual features and data efficiency. Using only 10% of the training images, our model is able to achieve a comparable results with the baselines trained on the full dataset. See the text for details.</figDesc><table /><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head>Table 4</head><label>4</label><figDesc></figDesc><table /><note>summarizes results on the CLEVR validation split. Our model achieves the state-of-the- art performance among all baselines using zero program annotations, including MAC (Hudson &amp; Manning, 2018) and FiLM (Perez et al., 2018). Our model achieves comparable performance with the strong baseline TbD-Nets (Mascharka et al., 2018), whose semantic parser is trained using 700K programs in CLEVR (ours need 0). The recent NS-VQA model from Yi et al. (2018) achieves better performance on CLEVR; however, their system requires annotated visual attributes and program traces during training, while our NS-CL needs no extra labels.</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9"><head>Table 3</head><label>3</label><figDesc>summarizes the results. Our model outperforms all baselines on data efficiency. This comes from the full disentanglement of visual concept learning and symbolic reasoning: how to execute program instructions based on the learned concepts is programmed. TbD-Object and MAC-Object demonstrate inferior results in our experiments. We attribute this to the design of model architectures and have a detailed analysis in Appendix F.3. Although TbD-Mask and MAC-Mask do not perform better than the originals, we find that using masks to guide attentions speeds up the training.Besides achieving a competitive performance on the visual reasoning testbeds, by leveraging both object-based representation and symbolic reasoning, out model learns fully interpretable visual concepts: see Appendix H for qualitative results on various datasets.4.3 GENERALIZATION TO NEW ATTRIBUTES AND COMPOSITIONSGeneralizing to new visual compositions. The CLEVR-CoGenT dataset is designed to evaluate models' ability to generalize to new visual compositions. It has two splits: Split A only contains gray, blue, brown and yellow cubes, but red, green, purple, and cyan cylinders; split B imposes the opposite color constraints on cubes and cylinders. If we directly learn visual concepts on split A, it overfits to classify shapes based on the color, leading to a poor generalization to split B.Our solution is based on the idea of seeing attributes as operators. Specifically, we jointly train the concept embeddings (e.g., Red, Cube, etc.) as well as the semantic parser on split A, keeping pretrained, frozen attribute operators. As we learn distinct representation spaces for different attributes, our model achieves an accuracy of 98.8% on split A and 98.9% on split B.</figDesc><table><row><cell>Model</cell><cell>Prog. Anno.</cell><cell>Overall Count</cell><cell>Cmp. Num.</cell><cell>Exist</cell><cell>Query Attr.</cell><cell>Cmp. Attr.</cell></row><row><cell>Human</cell><cell cols="6">N/A 92.6 86.7 86.4 96.6 95.0 96.0</cell></row><row><cell>NMN</cell><cell cols="6">700K 72.1 52.5 72.7 79.3 79.0 78.0</cell></row><row><cell cols="7">N2NMN 700K 88.8 68.5 84.9 85.7 90.0 88.8</cell></row><row><cell>IEP</cell><cell cols="6">700K 96.9 92.7 98.7 97.1 98.1 98.9</cell></row><row><cell cols="7">DDRprog 700K 98.3 96.5 98.4 98.8 99.1 99.0</cell></row><row><cell>TbD</cell><cell cols="6">700K 99.1 97.6 99.4 99.2 99.5 99.6</cell></row><row><cell>RN</cell><cell>0</cell><cell cols="5">95.5 90.1 93.6 97.8 97.1 97.9</cell></row><row><cell>FiLM</cell><cell>0</cell><cell cols="5">97.6 94.5 93.8 99.2 99.2 99.0</cell></row><row><cell>MAC</cell><cell>0</cell><cell cols="5">98.9 97.2 99.4 99.5 99.3 99.5</cell></row><row><cell>NS-CL</cell><cell>0</cell><cell cols="5">98.9 98.2 99.0 98.8 99.3 99.1</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_10"><head>Table 4 :</head><label>4</label><figDesc>Our model outperforms all baselines using no program annotations. It achieves comparable results with models trained by full program annotations such as TbD.</figDesc><table><row><cell>Model</cell><cell></cell><cell cols="2">Test</cell><cell></cell></row><row><cell></cell><cell cols="4">Split A Split B Split C Split D</cell></row><row><cell>MAC</cell><cell>97.3</cell><cell>N/A</cell><cell>92.9</cell><cell>N/A</cell></row><row><cell>IEP</cell><cell>96.1</cell><cell>92.1</cell><cell>91.5</cell><cell>90.9</cell></row><row><cell>TbD</cell><cell>98.8</cell><cell>94.5</cell><cell>94.3</cell><cell>91.9</cell></row><row><cell cols="2">NS-CL 98.9</cell><cell>98.9</cell><cell>98.7</cell><cell>98.8</cell></row><row><cell cols="5">Figure 5: We test the combinatorial gen-</cell></row><row><cell cols="5">eralization w.r.t. the number of objects</cell></row><row><cell cols="5">in scenes and the complexity of ques-</cell></row><row><cell cols="5">tions (i.e. the depth of the program trees).</cell></row><row><cell cols="5">We makes four split of the data contain-</cell></row><row><cell cols="5">ing various complexities of scenes and</cell></row><row><cell cols="5">questions. Our object-based visual repre-</cell></row><row><cell cols="5">sentation and explicit program semantics</cell></row><row><cell cols="5">enjoys the best (and almost-perfect) com-</cell></row><row><cell cols="5">binatorial generalization compared with</cell></row><row><cell cols="2">strong baselines.</cell><cell></cell><cell></cell><cell></cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_11"><head></head><label></label><figDesc>Our model performs a 93.9% accuracy on the QA test in Split B, outperforming the convolutional baseline IEP (Johnson et al., 2017b) and the attentional baseline TbD (Mascharka et al., 2018) by 4.6% and 6.1% respectively. The acquisition of Color operator brings more efficient learning of new visual concepts.</figDesc><table /><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_13"><head>Table 5 :</head><label>5</label><figDesc>We introduce a new simple DSL for image-caption retrieval to evaluate how well the learned visual concepts transfer. Due to the difference between VQA and caption retrieval, VQA baselines are only able to infer the result on a partial set of data. The learned object-based visual concepts can be directly transferred into the new domain for free.</figDesc><table /><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_14"><head>Table 5c</head><label>5c</label><figDesc>compares our NS-CL against typical image-text retrieval baselines on the full image-caption dataset. Without any annotations of the sentence semantics, our model learns to parse the captions into the programs in the new DSL. It outperforms the CNN-LSTM baseline by 30%.4.6 EXTENDING TO NATURAL IMAGES AND LANGUAGEWe further conduct experiments onMS-COCO (Lin et al., 2014)  images. Results are presented on the VQS dataset</figDesc><table /><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_15"><head></head><label></label><figDesc>Left: An example image-question pair from the VQS dataset and the corresponding execution trace of NS-CL. Right: Results on the VQS test set. Our model achieves a comparable results with the baselines.</figDesc><table><row><cell>Filter:</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>Fire_Hydrant</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell>Yellow (0.87)</cell><cell>?</cell><cell cols="2">Model Accuracy</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>MLP</cell><cell>43.9</cell></row><row><cell></cell><cell></cell><cell>Program</cell><cell></cell><cell>MAC</cell><cell>46.2</cell></row><row><cell>Q: What color is the fire hydrant?</cell><cell>Filter</cell><cell>Query</cell><cell></cell><cell>NS-CL</cell><cell>44.3</cell></row><row><cell></cell><cell>Fire_Hydrant</cell><cell>Color</cell><cell></cell><cell></cell></row><row><cell>Figure 7: Concept: Horse</cell><cell></cell><cell cols="2">Concept: Person On a Skateboard</cell><cell></cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_16"><head>Table 7</head><label>7</label><figDesc></figDesc><table><row><cell>explains the type</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_18"><head>Table 7 :</head><label>7</label><figDesc>The type system of the domain-specific language for CLEVR VQA.</figDesc><table /><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_19"><head>Table 8 :</head><label>8</label><figDesc></figDesc><table /><note>A step-by-step running example of the recursive parsing procedure. The parameter {c i } is omitted for better visualization.</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_20"><head>Table</head><label></label><figDesc></figDesc><table /><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_22"><head>Table 10 :</head><label>10</label><figDesc>Our model achieves comparable results on the Minecraft dataset with baselines trained by full program annotations.</figDesc><table /><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_23"><head></head><label></label><figDesc>What is the color of the big box left of the blue metal cylinder?</figDesc><table><row><cell cols="2">Example A.</cell><cell></cell><cell></cell><cell></cell><cell cols="2">Example B.</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>Q: There is a small blue object</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>that is to the right of the small red</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>matte object; what shape is it?</cell></row><row><cell>Concept</cell><cell></cell><cell>Program</cell><cell>Result</cell><cell></cell><cell>Concept</cell><cell>Program</cell><cell>Result</cell></row><row><cell>Gray Cylinder</cell><cell></cell><cell>Filter</cell><cell></cell><cell></cell><cell>Small Red</cell><cell>Filter</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>Matte Object</cell></row><row><cell>Behind</cell><cell></cell><cell>Relate</cell><cell></cell><cell></cell><cell>Right</cell><cell>Relate</cell></row><row><cell cols="2">Cyan Cylinder</cell><cell>Filter</cell><cell></cell><cell></cell><cell>Small Blue</cell><cell>Filter</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>Object</cell></row><row><cell>Gray Cylinder</cell><cell></cell><cell>Filter</cell><cell></cell><cell></cell><cell>Shape</cell><cell>Query</cell><cell>Cube (0.85)</cell></row><row><cell>Material</cell><cell></cell><cell></cell><cell>Yes (0.92)</cell><cell></cell><cell></cell></row><row><cell cols="3">Example C. Failure Case</cell><cell></cell><cell></cell><cell cols="2">Example D. Ambiguous Program Case</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>Q: What is the color of the big</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>metal object?</cell></row><row><cell>Concept</cell><cell></cell><cell>Program</cell><cell>Result</cell><cell></cell><cell>Concept</cell><cell>Program</cell><cell>Result</cell></row><row><cell>Blue Metal</cell><cell></cell><cell>Filter</cell><cell cols="2">No such object found!</cell><cell>Big Metal</cell><cell>Filter</cell></row><row><cell>Cylinder</cell><cell cols="2">Execution</cell><cell></cell><cell></cell><cell>Object</cell><cell>Execution</cell></row><row><cell></cell><cell></cell><cell>Abort</cell><cell></cell><cell></cell><cell></cell><cell>Abort</cell></row><row><cell>Left</cell><cell></cell><cell>Relate</cell><cell></cell><cell></cell><cell>Color</cell><cell>Query</cell><cell>Ambiguous Referral!</cell></row><row><cell>Big Box</cell><cell></cell><cell>Filter</cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell>Color: Blue</cell><cell>?</cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell cols="2">Material: Rubber ?</cell><cell></cell></row><row><cell>Color</cell><cell></cell><cell>Query</cell><cell cols="2">Shape: Cylinder ?</cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell>Size: Small</cell><cell>?</cell><cell></cell></row></table><note>Q:</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_24"><head></head><label></label><figDesc>Exemplar execution trace generated by our Neuro-Symbolic Concept Learner on the Minecraft reasoning dataset. Example A, B and C are successful execution. Example C demonstrates the semantics of the FilterMost operation. Example D shows a failure case: the detection model fails to detect a pig hiding behind the big tree. What is the sharp object on the table? : How many zebras are there? What are the kids doing?</figDesc><table><row><cell>Published as a conference paper at ICLR 2019</cell></row><row><cell>Q: Are there sheep near the wolf? Exist Filter Relate Filter No (0.98) Program Result Q: Which direction is the closest animal facing? Face FilterMost Filter Program Result Right ? ? Filter Program Result Count 3 ? Q: What kind of desert is plated? Wolf Near Sheep Example A. Concept Example C. Animal Closest Direction Concept Example A. Zebra Concept Filter Desert, Plated Example C. Concept Program Result Figure 12: Example B. Pig Closer Animal Example B. Concept Pig Concept Detected Missed Example D. Failure Case Q: How many animals are closer to the camera than the pig? Filter Count Relate Filter 1 Program Result Q: How many pigs are there? Count Filter 1 Program Result ? ? Filter Relate Filter Table On Concept Program Result Shape Object Query What Knife (0.85) ? Example D. Filter Kids Concept Program Result Query Kind Cake (0.68) Query What Playing_Frisbee (0.70) ? ? Groundtruth: Playing_Baseball</cell></row></table><note>Q:QQ:</note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgements. We thank Kexin Yi, Haoyue Shi, and Jon Gauthier for helpful discussions and suggestions. This work was supported in part by the Center for Brains, Minds and Machines (NSF STC award CCF-1231216), ONR MURI N00014-16-1-2007, MIT-IBM Watson AI Lab, and Facebook.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0" />			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Bootstrapping language acquisition</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Omri</forename><surname>Abend</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tom</forename><surname>Kwiatkowski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nathaniel</forename><forename type="middle">J</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sharon</forename><surname>Goldwater</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mark</forename><surname>Steedman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Cognition</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Bottom-up and top-down attention for image captioning and visual question answering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xiaodong</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chris</forename><surname>Buehler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Damien</forename><surname>Teney</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mark</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stephen</forename><surname>Gould</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lei</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CVPR</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Learning to compose neural networks for question answering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jacob</forename><surname>Andreas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marcus</forename><surname>Rohrbach</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Trevor</forename><surname>Darrell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dan</forename><surname>Klein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NAACL-HLT</title>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">VQA: Visual question answering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stanislaw</forename><surname>Antol</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Aishwarya</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jiasen</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Margaret</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dhruv</forename><surname>Batra</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lawrence</forename><surname>Zitnick</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Devi</forename><surname>Parikh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICCV</title>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Weakly supervised learning of semantic parsers for mapping instructions to actions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yoav</forename><surname>Artzi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Luke</forename><surname>Zettlemoyer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013" />
			<publisher>TACL</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Object level visual reasoning in videos</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fabien</forename><surname>Baradel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Natalia</forename><surname>Neverova</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christian</forename><surname>Wolf</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Julien</forename><surname>Mille</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Greg</forename><surname>Mori</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ECCV</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Abc-cnn: An attention based convolutional neural network for visual question answering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kan</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jiang</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Liang-Chieh</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Haoyuan</forename><surname>Gao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wei</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ram</forename><surname>Nevatia</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1511.05960</idno>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Learning phrase representations using rnn encoder-decoder for statistical machine translation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kyunghyun</forename><surname>Cho</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bart</forename><surname>Van Merri?nboer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Caglar</forename><surname>Gulcehre</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dzmitry</forename><surname>Bahdanau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fethi</forename><surname>Bougares</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Holger</forename><surname>Schwenk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yoshua</forename><surname>Bengio</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EMNLP</title>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Learning language through pictures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Grzegorz</forename><surname>Chrupa?a</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Akos</forename><surname>K?d?r</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Afra</forename><surname>Alishahi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACL</title>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Imagenet: A large-scale hierarchical image database</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jia</forename><surname>Deng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wei</forename><surname>Dong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Richard</forename><surname>Socher</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Li-Jia</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kai</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Li</forename><surname>Fei-Fei</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CVPR</title>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Long-term recurrent convolutional networks for visual recognition and description</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jeffrey</forename><surname>Donahue</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lisa</forename><forename type="middle">Anne</forename><surname>Hendricks</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sergio</forename><surname>Guadarrama</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marcus</forename><surname>Rohrbach</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Subhashini</forename><surname>Venugopalan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kate</forename><surname>Saenko</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Trevor</forename><surname>Darrell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CVPR</title>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Language to logical form with neural attention</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Li</forename><surname>Dong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mirella</forename><surname>Lapata</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACL</title>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A probabilistic computational model of cross-situational word learning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Afsaneh</forename><surname>Fazly</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Afra</forename><surname>Alishahi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Suzanne</forename><surname>Stevenson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Cognit. Sci</title>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">VQS: Linking segmentations to questions and answers for supervised attention in vqa and question-focused semantic segmentation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chuang</forename><surname>Gan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yandong</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Haoxiang</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chen</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Boqing</forename><surname>Gong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICCV</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">What&apos;s in a question: Using visual questions as a form of supervision</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Siddha</forename><surname>Ganju</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Olga</forename><surname>Russakovsky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Abhinav</forename><surname>Gupta</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CVPR</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Word learning and the acquisition of syntacticsemantic overhypotheses</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jon</forename><surname>Gauthier</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Roger</forename><surname>Levy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joshua</forename><forename type="middle">B</forename><surname>Tenenbaum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In CogSci</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Convolutional sequence to sequence learning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jonas</forename><surname>Gehring</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Auli</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Grangier</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Denis</forename><surname>Yarats</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yann N</forename><surname>Dauphin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Given a set of objects, finds the &quot;most&quot; one. For example, FilterMost(Closest, set) locates the object in the</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">(</forename><surname>Filtermost</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Objectset</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">) ?</forename><surname>Concept</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Objectset</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>input set that is cloest to the camera (e.g., what is the direction of the closest animal?</note>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">ObjectSet) ? Bool: Query if the input object belongs to a set</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">(</forename><surname>Belongto</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Object</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">which uses strong supervision for both scene representation (e.g., object categories and positions) and program traces. In contrast, our method learns both by looking at images and reading question-answering pairs. NS-CL outperforms NS-VQA by 5% in overall accuracy. We attribute the inferior results of NS-VQA to its derendering module. Because objects in the Minecraft world usually occlude with each other, the detected object bounding boxes are inevitably noisy. During the training of the derendering module, each detected bounding box is matched with one of the ground-truth bounding boxes and uses its class and pose as supervision</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yi</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Results. Table 10 summarizes the results and Figure 12 shows sample execution traces. We compare our method against the NS-VQA baseline</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
	<note>Poorly localized bounding boxes lead to noisy labels and hurt the accuracy of the derendering module. This further influences the overall performance of NS-VQA</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
