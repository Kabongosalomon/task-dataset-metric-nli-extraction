<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /nfs/home/kabenamualus/Research/task-dataset-metric-extraction/../grobid-0.6.0/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Embedding Logical Queries on Knowledge Graphs</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">William</forename><forename type="middle">L</forename><surname>Hamilton</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Payal</forename><surname>Bajaj</surname></persName>
							<email>pbajaj@stanford.edu</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marinka</forename><surname>Zitnik</surname></persName>
							<email>marinka@cs.stanford.edu</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dan</forename><surname>Jurafsky</surname></persName>
							<email>jurafsky@stanford.edu</email>
							<affiliation key="aff1">
								<orgName type="department">Department of Linguistics</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jure</forename><surname>Leskovec</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Stanford University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Embedding Logical Queries on Knowledge Graphs</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>

		<encodingDesc>
			<appInfo>
				<application version="0.6.0" ident="GROBID-SDO" when="2022-11-12T15:28+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid-sdo"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Learning low-dimensional embeddings of knowledge graphs is a powerful approach used to predict unobserved or missing edges between entities. However, an open challenge in this area is developing techniques that can go beyond simple edge prediction and handle more complex logical queries, which might involve multiple unobserved edges, entities, and variables. For instance, given an incomplete biological knowledge graph, we might want to predict what drugs are likely to target proteins involved with both diseases X and Y?-a query that requires reasoning about all possible proteins that might interact with diseases X and Y.</p><p>Here we introduce a framework to efficiently make predictions about conjunctive logical queries-a flexible but tractable subset of first-order logic-on incomplete knowledge graphs. In our approach, we embed graph nodes in a low-dimensional space and represent logical operators as learned geometric operations (e.g., translation, rotation) in this embedding space. By performing logical operations within a low-dimensional embedding space, our approach achieves a time complexity that is linear in the number of query variables, compared to the exponential complexity required by a naive enumeration-based approach. We demonstrate the utility of this framework in two application studies on real-world datasets with millions of relations: predicting logical relationships in a network of drug-gene-disease interactions and in a graph-based representation of social interactions derived from a popular web forum.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>A wide variety of heterogeneous data can be naturally represented as networks of interactions between typed entities, and a fundamental task in machine learning is developing techniques to discover or predict unobserved edges using this graph-structured data. Link prediction <ref type="bibr" target="#b24">[25]</ref>, recommender systems <ref type="bibr" target="#b47">[48]</ref>, and knowledge base completion <ref type="bibr" target="#b27">[28]</ref> are all instances of this common task, where the goal is to predict unobserved edges between nodes in a graph using an observed set of training edges.</p><p>However, an open challenge in this domain is developing techniques to make predictions about more complex graph queries that involve multiple unobserved edges, nodes, and even variables-rather than just single edges.</p><p>One particularly useful set of such graph queries, and the focus of this work, are conjunctive queries, which correspond to the subset of first-order logic using only the conjunction and existential quantification operators <ref type="bibr" target="#b0">[1]</ref>. In terms of graph structure, conjunctive queries allow one to reason about the existence of subgraph relationships between sets of nodes, which makes conjunctive queries a natural focus for knowledge graph applications. For example, given an incomplete biological knowledge graph-containing known interactions between drugs, diseases, and proteins-one could pose the conjunctive query: "what protein nodes are likely to be associated with diseases that have both symptoms X and Y?" In this query, the disease node is an existentially quantified variablei.e., we only care that some disease connects the protein node to these symptom nodes X and Y. "Predict communities C? in which user u is likely to upvote a post"</p><p>"Predict drugs C? that might target proteins that are associated with the given disease nodes d1 and d2 " ta rg et t a r g e t ta rg et C?.9P : assoc(d1, P )^assoc(d2, P )^target(P, C?) <ref type="figure" target="#fig_1">Figure 1</ref>: Two example conjunctive graph queries. In the boxes we show the query, its natural language interpretation, and the DAG that specifies this query's structure. Below these boxes we show subgraphs that satisfy the query (solid lines), but note that in practice, some of these edges might be missing, and we need to predict these missing edges in order for the query to be answered. Dashed lines denote edges that are irrelevant to the query. The example on the left shows a path query on the Reddit data; note that there are multiple nodes that satisfy this query, as well as multiple paths that reach the same node. The example on the right shows a more complex query with a polytree structure on the biological interaction data.</p><p>Valid answers to such a query correspond to subgraphs. However, since any edge in this biological interaction network might be unobserved, naively answering this query would require enumeration over all possible diseases.</p><p>In general, the query prediction task-where we want to predict likely answers to queries that can involve unobserved edges-is difficult because there are a combinatorial number of possible queries of interest, and any given conjunctive query can be satisfied by many (unobserved) subgraphs ( <ref type="figure" target="#fig_1">Figure  1</ref>). For instance, a naive approach to make predictions about conjunctive queries would be the following: First, one would run an edge prediction model on all possible pairs of nodes, and-after obtaining these edge likelihoods-one would enumerate and score all candidate subgraphs that might satisfy a query. However, this naive enumeration approach could require computation time that is exponential in the number of existentially quantified (i.e., bound) variables in the query <ref type="bibr" target="#b11">[12]</ref>.</p><p>Here we address this challenge and develop graph query embeddings (GQEs), an embedding-based framework that can efficiently make predictions about conjunctive queries on incomplete knowledge graphs. The key idea behind GQEs is that we embed graph nodes in a low-dimensional space and represent logical operators as learned geometric operations (e.g., translation, rotation) in this embedding space. After training, we can use the model to predict which nodes are likely to satisfy any valid conjunctive query, even if the query involves unobserved edges. Moreover, we can make this prediction efficiently, in time complexity that is linear in the number of edges in the query and constant with respect to the size of the input network. We demonstrate the utility of GQEs in two application studies involving networks with millions of edges: discovering new interactions in a biomedical drug interaction network (e.g., "predict drugs that might treat diseases associated with protein X") and predicting social interactions on the website Reddit (e.g., "recommend posts that user A is likely to downvote, but user B is likely to upvote").</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Related Work</head><p>Our framework builds upon a wealth of previous research at the intersection of embedding methods, knowledge graph completion, and logical reasoning.</p><p>Logical reasoning and knowledge graphs. Recent years have seen significant progress in using machine learning to reason with relational data <ref type="bibr" target="#b15">[16]</ref>, especially within the context of knowledge graph embeddings <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b27">28,</ref><ref type="bibr" target="#b28">29,</ref><ref type="bibr" target="#b44">45]</ref>, probabilistic soft logic <ref type="bibr" target="#b2">[3]</ref>, and differentiable tensor-based logic <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b32">33]</ref>. However, existing work in this area primarily focuses on using logical reasoning to improve edge prediction in knowledge graphs <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b26">27]</ref>, for example, by using logical rules as regularization <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b34">35,</ref><ref type="bibr" target="#b36">37]</ref>. In contrast, we seek to directly make predictions about conjunctive logical queries. Another well-studied thread in this space involves leveraging knowledge graphs to improve natural language question answering (QA) <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b46">47]</ref>. However, the focus of these QA approaches is understanding natural language, whereas we focus on queries that are in logical form.  <ref type="figure" target="#fig_2">Figure 2</ref>: Schema diagrams for the biological interaction network and the Reddit data. Note that in the Reddit data words are only used as features for posts and are not used in any logical queries. Note also that for directed relationships, we add the inverses of these relationships to allow for a richer query space.</p><p>Probabilistic databases. Our research also draws inspiration from work on probabilistic databases <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b11">12]</ref>. The primary distinction between our work and probabilistic databases is the following: Whereas probabilistic databases take a database containing probabilistic facts and score queries, we seek to predict unobserved logical relationships in a knowledge graph. Concretely, a distinguishing challenge in our setting is that while we are given a set of known edge relationships (i.e., facts), all missing edge relationships could possibly be true.</p><p>Neural theorem proving. Lastly, our work builds closely upon recent advancements in neural theorem proving <ref type="bibr" target="#b33">[34,</ref><ref type="bibr" target="#b42">43]</ref>, which have demonstrated how neural networks can prove first-order logic statements in toy knowledge bases <ref type="bibr" target="#b35">[36]</ref>. Our main contribution in this space is providing an efficient approach to embed a useful subset of first-order logic, demonstrating scalability to real-world network data with millions of edges.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Background and Preliminaries</head><p>We consider knowledge graphs (or heterogeneous networks) G = (V, E) that consists of nodes v ? V and directed edges e ? E of various types. We will usually denote edges e ? E as binary predicates e = ? (u, v), ? ? R, where u, v ? V are nodes with types ? 1 , ? 2 , ? ?, respectively, and ? : ? 1 ? ? 2 ? {true, false} is the edge relation. When referring generically to nodes we use the letters u and v (with varying subscripts); however, in cases where type information is salient we will use distinct letters to denote nodes of different types (e.g., d for a disease node in a biological network), and we omit subscripts whenever possible. Finally, we use lower-case script (e.g., v i ) for the actual graph nodes and upper-case script for variables whose domain is the set of graph nodes (e.g., V i ). Throughout this paper we use two real-world networks as running examples:</p><p>Example 1: Drug interactions <ref type="figure" target="#fig_2">(Figure 2</ref>.a). A knowledge graph derived from a number from public biomedical databases (Appendix B). It consists of nodes corresponding to drugs, diseases, proteins, side effects, and biological processes. There are 42 different edge types, including multiple edge types between proteins (e.g., co-expression, binding interactions), edges denoting known drug-disease treatment pairs, and edges denoting experimentally documented side-effects of drugs. In total this dataset contains over 8 million edges between 97,000 nodes.</p><p>Example 2: Reddit dynamics <ref type="figure" target="#fig_2">(Figure 2</ref>.b). We also consider a graph-based representation of Reddit, one of the most popular websites in the world. Reddit allows users to form topical communities, within which users can create and comment on posts (e.g., images, or links to news stories). We analyze all activity in 105 videogame related communities from May 1-5th, 2017 (Appendix B). In total this dataset contains over 4 million edges denoting interactions between users, communities and posts, with over 700,000 nodes in total (see <ref type="figure" target="#fig_2">Figure 2</ref>.b for the full schema). Edges exist to denote that a user created,"upvoted", or "downvoted" a post, as well as edges that indicate whether a user subscribes to a community</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Conjunctive graph queries</head><p>In this work we seek to make predictions about conjunctive graph queries ( <ref type="figure" target="#fig_1">Figure 1</ref>). Specifically, the queries q ? Q(G) that we consider can be written as:</p><formula xml:id="formula_0">q = V ? . ?V 1 , ..., V m : e 1 ? e 2 ? ... ? e n ,<label>(1)</label></formula><formula xml:id="formula_1">where e i = ? (v j , V k ), V k ? {V ? , V 1 , ..., V m }, v j ? V, ? ? R or e i = ? (V j , V k ), V j , V k ? {V ? , V 1 , ..., V m }, j = k, ? ? R.</formula><p>In Equation <ref type="formula" target="#formula_0">(1)</ref>, V ? denotes the target variable of the query, i.e., the node that we want the query to return, while V 1 , ..., V m are existentially quantified bound variable nodes. The edges e i in the query can involve these variable nodes as well as anchor nodes, i.e., non-variable/constant nodes that form the input to the query, denoted in lower-case as v j .</p><p>To give a concrete example using the biological interaction network <ref type="figure" target="#fig_2">(Figure 2</ref>.a), consider the query "return all drug nodes that are likely to target proteins that are associated with a given disease node d."</p><p>We would write this query as:</p><formula xml:id="formula_2">q = C ? .?P : ASSOC(d, P ) ? TARGET(P, C ? ),<label>(2)</label></formula><p>and we say that the answer or denotation of this query q is the set of all drug nodes that are likely to be connected to node d on a length-two path following edges that have types TARGET and ASSOC, respectively. Note that d is an anchor node of the query: it is the input that we provide. In contrast, the upper-case nodes C ? and P , are variables defined within the query, with the P variable being existentially quantified. In terms of graph structure, Equation <ref type="formula" target="#formula_2">(2)</ref> corresponds to a path. <ref type="figure" target="#fig_1">Figure 1</ref> contains a visual illustration of this idea.</p><p>Beyond paths, queries of the form in Equation <ref type="formula" target="#formula_0">(1)</ref> can also represent more complex relationships. For example, the query "return all drug nodes that are likely to target proteins that are associated with the given disease nodes d 1 and d 2 " would be written as:</p><formula xml:id="formula_3">C ? .?P : ASSOC(d 1 , P ) ? ASSOC(d 2 , P ) ? TARGET(P, C ? ).</formula><p>In this query we have two anchor nodes d 1 and d 2 , and the query corresponds to a polytree ( <ref type="figure" target="#fig_1">Figure 1</ref>).</p><p>In general, we define the dependency graph of a query q as the graph with edges E q = {e 1 , ..., e n } formed between the anchor nodes v 1 , ..., v k and the variable nodes V ? , V 1 , ..., V m <ref type="figure" target="#fig_1">(Figure 1</ref>). For a query to be valid, its dependency graph must be a directed acyclic graph (DAG), with the anchor nodes as the source nodes of the DAG and the query target as the unique sink node. The DAG structure ensures that there are no contradictions or redundancies.</p><p>Note that there is an important distinction between the query DAG, which contains variables, and a subgraph structure in the knowledge graph that satisfies this query, i.e., a concrete assignment of the query variables (see <ref type="figure" target="#fig_1">Figure 1</ref>). For instance, it is possible for a query DAG to be satisfied by a subgraph that contains cycles, e.g., by having two bound variables evaluate to the same node.</p><p>Observed vs. unobserved denotation sets. If we view edge relations as binary predicates, the graph queries defined by Equation <ref type="formula" target="#formula_0">(1)</ref> correspond to a standard conjunctive query language <ref type="bibr" target="#b0">[1]</ref>, with the restriction that we allow at most one free variable. However, unlike standard queries on relational databases, we seek to discover or predict unobserved relationship and not just answer queries that exactly satisfy a set of observed edges. Formally, we assume that every query q ? Q(G) has some unobserved denotation set q that we are trying to predict, and we assume that q is not fully observed in our training data. To avoid confusion on this point, we also introduce the notion of the observed denotation set of a query, denoted q train , which corresponds to the set of nodes that exactly satisfy q according to our observed, training edges. Thus, our goal is to train using example queryanswer pairs that are known in the training data, i.e., (q, v * ), v * ? q train , so that we can generalize to parts of the graph that involve missing edges, i.e., so that we can make predictions for query-answer pairs that rely on edges which are unobserved in the training data (q, v * ), v * ? q \ q train .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Proposed Approach</head><p>The key idea behind our approach is that we learn how to embed any conjunctive graph query into a low-dimensional space. This is achieved by representing logical query operations as geometric</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Query DAG</head><p>Operations in an embedding space</p><formula xml:id="formula_4">P I P P q z d1 z d2</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Input query</head><p>Nearest neighbor lookup to finds nodes that satisfy the query <ref type="figure">Figure 3</ref>: Overview of GQE framework. Given an input query q, we represent this query according to its DAG structure, then we use Algorithm 1 to generate an embedding of the query based on this DAG. Algorithm 1 starts with the embeddings of the query's anchor nodes and iteratively applies geometric operations P and I to generate an embedding q that corresponds to the query. Finally, we can use the generated query embedding to predict the likelihood that a node satisfies the query, e.g., by nearest neighbor search in the embedding space.</p><formula xml:id="formula_5">d 1 d 2 C? P C ? .9P : target(C ? , P )^assoc(P, d 2 )^assoc(P, d 2 )</formula><p>operators that are jointly optimized on a low-dimensional embedding space along with a set of node embeddings. The core of our framework is Algorithm 1, which maps any conjunctive input query q to an embedding q ? R d using two differentiable operators, P and I, described below. The goal is to optimize these operators-along with embeddings for all graph nodes z v ? R d , ?v ? V-so that the embedding q for any query q can be generated and used to predict the likelihood that a node v satisfies the query q. In particular, we want to generate query embeddings q and node embeddings z v , so that the likelihood or "score" that v ? q is given by the distance between their respective embeddings:</p><formula xml:id="formula_6">1 score(q, z v ) = q ? z v q z v .<label>(3)</label></formula><p>Thus, our goal is to generate an embedding q of a query that implicitly represents its denotation q ; i.e., we want to generate query embeddings so that score(q, z v ) = 1, ?v ? q and score(q, z v ) = 0, ?v / ? q . At inference time, we take a query q, generate its corresponding embedding q, and then perform nearest neighbor search-e.g., via efficient locality sensitive hashing <ref type="bibr" target="#b20">[21]</ref>-in the embedding space to find nodes likely to satisfy this query ( <ref type="figure">Figure 3</ref>).</p><p>To generate the embedding q for a query q using Algorithm 1, we (i) represent the query using its DAG dependency graph, (ii) start with the embeddings z v1 , ..., z vn of its anchor nodes, and then (iii) we apply geometric operators, P and I (defined below) to these embeddings to obtain an embedding q of the query. In particular, we introduce two key geometric operators, both of which can be interpreted as manipulating the denotation set associated with a query in the embedding space.</p><p>Geometric projection operator, P:. Given a query embedding q and an edge type ? , the projection operator P outputs a new query embedding q = P(q, ? ) whose corresponding denotation is</p><formula xml:id="formula_7">q = ? v? q N (v, ? ), where N (v, ? )</formula><p>denotes the set of nodes connected to v by edges of type ? . Thus, P takes an embedding corresponding to a set of nodes q and produces a new embedding that corresponds to the union of all the neighbors of nodes in q , by edges of type ? . Following a long line of successful work on encoding edge and path relationships in knowledge graphs <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b27">28,</ref><ref type="bibr" target="#b28">29]</ref>, we implement P as follows:</p><formula xml:id="formula_8">P(q, ? ) = R ? q,<label>(4)</label></formula><p>where R d?d ? is a trainable parameter matrix for edge type ? . In the base case, if P is given a node embedding z v and edge type ? as input, then it returns an embedding of the neighbor set N (v, ? ).</p><p>Geometric intersection operator, I:. Suppose we are given a set of query embeddings q 1 , ..., q n , all of which correspond to queries with the same output node type ?. The geometric intersection operator I takes this set of query embeddings and produces a new embedding q whose denotation corresponds to q = ? i=1,...,n q i , i.e., it performs set intersection in the embedding space. While path projections of the form in Equation <ref type="formula" target="#formula_8">(4)</ref> have been considered in previous work on edge and path prediction, no previous work has considered such a geometric intersection operation. Motivated by recent advancements in deep learning on sets <ref type="bibr" target="#b31">[32,</ref><ref type="bibr" target="#b45">46]</ref>, we implement I as:</p><formula xml:id="formula_9">I({q 1 , ..., q n }) = W ? ? (NN k (q i ), ?i = 1, ...n}) ,<label>(5)</label></formula><p>where NN k is a k-layer feedforward neural network, ? is a symmetric vector function (e.g., an elementwise mean or min of a set over vectors), and W ? is a trainable transformation matrix for each node type ? ? ?. In principle, any sufficiently expressive neural network that operates on sets could be also employed as the intersection operator, as long as this network is permutation invariant on its inputs <ref type="bibr" target="#b45">[46]</ref>.</p><p>Query inference using P and I. Given the geometric projection operator P <ref type="figure">(Equation 4</ref>) and the geometric intersection operator I (Equation 5) we can use Algorithm 1 to efficiently generate an embedding q that corresponds to any DAG-structured conjunctive query q on the network. To generate a query embedding, we start by projecting the anchor node embeddings according to their outgoing edges; then if a node has more than one incoming edge in the query DAG, we use the intersection operation to aggregate the incoming information, and we repeat this process as necessary until we reach the target variable of the query. In the end, Algorithm 1 generates an embedding q of a query in O(d 2 E) operations, where d is the embedding dimension and E is the number of edges in the query DAG. Using the generated embedding q we can predict nodes that are likely to satisfy this query by doing a nearest neighbor search in the embedding space. Moreover, since the set of nodes is known in advance, this nearest neighbor search can be made highly efficient (i.e., sublinear in |V|) using locality sensitive hashing, at a small approximation cost <ref type="bibr" target="#b20">[21]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Theoretical analysis</head><p>Formally, we can show that in an ideal setting Algorithm 1 can exactly answer any conjunctive query on a network. This provides an equivalence between conjunctive queries on a network and sequences of geometric projection and intersection operations in an embedding space. </p><formula xml:id="formula_10">score(q, z v ) = 0 if v / ? q train ? &gt; 0 if v ? q train ,</formula><p>i.e., the observed denotation set of the query q train can be exactly computed in the embeddings space by Algorithm 1 using O(E) applications of the geometric operators P and I.</p><p>Theorem 1 is a consequence of the correspondence between tensor algebra and logic <ref type="bibr" target="#b10">[11]</ref> combined with the efficiency of DAG-structured conjunctive queries <ref type="bibr" target="#b0">[1]</ref>, and the full proof is in Appendix A.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Node embeddings</head><p>In principle any efficient differentiable algorithm that generates node embeddings can be used as the base of our query embeddings. Here we use a standard "bag-of-features" approach <ref type="bibr" target="#b43">[44]</ref>. We assume that every node of type ? has an associated binary feature vector x u ? Z m? , and we compute the node embedding as</p><formula xml:id="formula_11">z u = Z ? x u |x u | ,<label>(6)</label></formula><p>where Z ? ? R d?m? is a trainable embedding matrix. In our experiments, the x u vectors are one-hot indicator vectors (e.g., each node gets its own embedding) except for posts in Reddit, where the features are binary indicators of what words occur in the post.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Other variants of our framework</head><p>Above we outlined one concrete implementation of our GQE framework. However, in principle, our framework can be implemented with alternative geometric projection P and intersection I operators.</p><p>In particular, the projection operator can be implemented using any composable, embedding-based edge prediction model, as defined in Guu et al., 2015 <ref type="bibr" target="#b17">[18]</ref>. For instance, we also consider variants of the geometric projection operator based on DistMult <ref type="bibr" target="#b44">[45]</ref> and TransE <ref type="bibr" target="#b5">[6]</ref>. In the DistMult model the matrices in Equation <ref type="formula" target="#formula_8">(4)</ref> are restricted to be diagonal, whereas in the TransE variant we replace Equation (4) with a translation operation, P TransE (q, ? ) = q + r ? . Note, however, that our proof of Theorem 1 relies on specific properties of projection operator described in Equation <ref type="formula" target="#formula_8">(4)</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Model training</head><p>The geometric projection operator P, intersection operator I, and node embedding parameters can be trained using stochastic gradient descent on a max-margin loss. To compute this loss given a training query q, we uniformly sample a positive example node v * ? q train and negative example node v N / ? q train from the training data and compute:</p><formula xml:id="formula_12">L(q) = max (0, 1 ? score(q, z v * ) + score(q, z v N )) .</formula><p>For queries involving intersection operations, we use two types of negative samples: "standard" negative samples are randomly sampled from the subset of nodes that have the correct type for a query; in contrast, "hard" negative samples correspond to nodes that satisfy the query if a logical conjunction is relaxed to a disjunction. For example, for the query "return all drugs that are likely to treat disease d 1 and d 2 ", a hard negative example would be diseases that treat d 1 but not d 2 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Experiments</head><p>We run experiments on the biological interaction (Bio) and Reddit datasets <ref type="figure" target="#fig_2">(Figure 2</ref>). Code and data is available at https://github.com/williamleif/graphqembed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Baselines and model variants</head><p>We consider variants of our framework using the projection operator in Equation 4 (termed Bilinear), as well as variants using TransE and DistMult as the projection operators (see Section 4.3). All variants use a single-layer neural network in Equation <ref type="bibr" target="#b4">(5)</ref>. As a baseline, we consider an enumeration approach that is trained end-to-end to perform edge prediction (using Bilinear, TransE, or DistMult) and scores possible subgraphs that could satisfy a query by taking the product (i.e., a soft-AND) of their individual edge likelihoods (using a sigmoid with a learned scaling factor to compute the edge likelihoods). However, this enumeration approach has exponential time complexity w.r.t. to the number of bound variables in a query and is intractable in many cases, so we only include it as a comparison point on the subset of queries with no bound variables. (A slightly less naive baseline variant where we simply use one-hot embeddings for nodes is similarly intractable due to having quadratic complexity w.r.t. to the number of nodes.) As additional ablations, we also consider simplified variants of our approach where we only train the projection operator P on edge prediction and where the intersection operator I is just an elementwise mean or min. This tests how well Algorithm 1 can answer conjunctive queries using standard node embeddings that are only trained to perform edge prediction. For all baselines and variants, we used PyTorch <ref type="bibr" target="#b29">[30]</ref>, the Adam optimizer, an embedding dimension d = 128, a batch size of 256, and tested learning rates {0.1, 0.01, 0.001}.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Dataset of train and test queries</head><p>To test our approach, we sample sets of train/test queries from a knowledge graph, i.e., pairs (q, v * ), where q is a query and v * is a node that satisfies this query. In our sampling scheme, we sample a fixed number of example queries for each possible query DAG structure <ref type="figure">(Figure 4, bottom)</ref>. For each possible DAG structure, we sampled queries uniformly at random using a simple rejection sampling approach (described below).</p><p>To sample training queries, we first remove 10% of the edges uniformly at random from the graph and then perform sampling on this downsampled training graph. To sample test queries, we sample from the original graph (i.e., the complete graph without any removed edges), but we ensure that the test query examples are not directly answerable in the training graph. In other words, we ensure that every test query relies on at least one deleted edge (i.e., that for every test query example (q, v * ), v * / ? q train ). This train/test setup ensures that a trivial baseline-which simply tries to answer a query by template matching on the observed training edges-will have an accuracy that is no better random guessing on the test set, i.e., that every test query can only be answered by inferring unobserved relationships.</p><p>Sampling details. In our sampling scheme, we sample a fixed number of example queries for each possible query DAG structure. In particular, given a DAG structure with E edges-specified by a vector d = [d 1 , d 2 , ..., d E ] of node out degrees, which are sorted in topological order <ref type="bibr" target="#b41">[42]</ref> -we sample edges using the following procedure: First we sample the query target node (i.e., the root of the DAG); next, we sample d 1 out-edges from this node and we add each of these sampled nodes to a queue; we then iteratively pop nodes from the queue, sampling d i+1 neighbors from the ith node popped from the queue, and so on. If a node has d i = 0, then this corresponds to an anchor node in the query. We use simple rejection sampling to cope with cases where the sampled nodes cannot satisfy a particular DAG structure, i.e., we repeatedly sample until we obtain S example queries satisfying a particular query DAG structure.</p><p>Training, validation, and test set details. For training we sampled 10 6 queries with two edges and 10 6 queries with three edges, with equal numbers of samples for each different type of query DAG structure. For testing, we sampled 10,000 test queries for each DAG structure with two or three edges and ensured that these test queries involved missing edges (see above). We further sampled 1,000 test queries for each possible DAG structure to use for validation (e.g., for early stopping). We used all edges in the training graph as training examples for size-1 queries (i.e., edge prediction), and we used a 90/10 split of the deleted edges to form the test and validation sets for size-1 queries.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Evaluation metrics</head><p>For a test query q we evaluate how well the model ranks a node v * that does satisfy this query v * ? q compared to negative example nodes that do not satisfy it, i.e., v N / ? q . We quantify this performance using the ROC AUC score and average percentile rank (APR). For the APR computation, we rank the true node against min(1000, |{v / ? q |) negative examples (that have the correct type for the query) and compute the percentile rank of the true node within this set. For queries containing intersections, we run both these metrics using both standard and "hard" negative examples to compute the ranking/classification scores, where"hard" negative examples are nodes that satisfy the query if a logical conjunction is relaxed to a disjunction. <ref type="table" target="#tab_1">Table 1</ref> contains the performance results for three variants of GQEs based on bilinear transformations (i.e., <ref type="figure">Equation 4</ref>), DistMult, and TransE, as well as the ablated models that are only trained on edge prediction (denoted Edge Training). <ref type="bibr" target="#b1">2</ref> Overall, we can see that the full Bilinear model performs the best, with an AUC of 91.0 on the Bio data and an AUC of 76.4 on the Reddit data (macro-averaged across all query DAG structures of size 1-3). In <ref type="figure">Figure 4</ref> we breakdown performance across different types of query dependency graph structures, and we can see that its performance on complex queries is very strong (relative to its performance on simple edge prediction), with long paths being the most difficult type of query. <ref type="table" target="#tab_2">Table 2</ref> compares the best-performing GQE model to the best-performing enumeration-based baseline. The enumeration baseline is computationally intractable on queries with bound variables, so this comparison is restricted to the subset of queries with no bound variables. Even in this restricted setting, we see that GQE consistently outperforms the baseline. This demonstrates that performing logical operations in the embedding space is not only more efficient, it is also an effective alternative to enumerating the product of edge-likelihoods, even in cases where the latter is feasible.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Results and discussion</head><p>The importance of training on complex queries. We found that explicitly training the model to predict complex queries was necessary to achieve strong performance <ref type="table" target="#tab_1">(Table 1)</ref>. Averaging across all model variants, we observed an average AUC improvement of 13.3% on the Bio data and 13.9% on the Reddit data (both p &lt; 0.001, Wilcoxon signed-rank test) when using full GQE training compared to Edge Training. This shows that training on complex queries is a useful way to impose a meaningful logical structure on an embedding space and that optimizing for edge prediction alone does not necessarily lead to embeddings that are useful for more complex logical queries.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusion</head><p>We proposed a framework to embed conjunctive graph queries, demonstrating how to map a practical subset of logic to efficient geometric operations in an embedding space. Our experiments showed that our approach can make accurate predictions on real-world data with millions of relations. Of course, there are limitations of our framework: for instance, it cannot handle logical negation or disjunction, and we also do not consider features on edges. Natural future directions include generalizing the space of logical queries-for example, by learning a geometric negation operator-and using graph neural networks <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b18">19]</ref> to incorporate richer feature information on nodes and edges.</p><p>2. If the next operation is an intersection of the set of sets {S 1 , ..., S n }, then we compute it as z = min ({z S1 , ..., z Sn }), and by definition z will have non-zero entries only in positions where every one of the input vectors z S1 , ..., z Sn has a non-zero. That is,</p><formula xml:id="formula_13">score(z vi , I({z S1 , ..., z Sn })) = 0 if v i / ? S 1 ?, ..., ?, S n ? &gt; 0 if v i ? S 1 ?, ..., ?, S n .</formula><p>Finally, for the base case we have that the input anchor embeddings z v1 , ..., z vn represent the sets {v 1 }, ..., {v n } by definition. Proof. Algorithm 1 is identical to Kahn's algorithm for topologically sorting a DAG <ref type="bibr" target="#b21">[22]</ref>, with the addition that we (i) apply P whenever we remove an edge from the DAG and (ii) run I whenever we pop a node from the queue. Thus, by direct analogy to Kahn's algorithm we require exactly E applications of P and V applications of I, where V is the number of nodes in the query DAG. Since V is always less than E, we have O(E) overall.</p><p>Lemma 3. The denotation of any DAG-structured conjunctive query on a network can be obtained in a sequence of O(E) applications of the following two operations:</p><p>? Set projections, with one defined for each edge type, ? and which map a set of nodes S to the set ? vi?S N (?, v i ).</p><p>? Set intersection (i.e., the basic set intersection operator) which takes a set of sets {S 1 , ..., S n } and returns S 1 ?, ..., ?, S n .</p><p>Proof. Consider the two following simple cases:</p><p>1. For a query C ? : ? (v, C ? ) the denotation is N (v, ? ) by definition. This is simply a set projection.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">For a query C</head><formula xml:id="formula_14">? : ? (v 1 , C ? ) ? ? (v 2 , C ? ) ? ....? (v n , C ? ) the denotation is ? vi?{v1,...,vn} N (v i , ? )</formula><p>by definition. This is a sequence of n set projections followed by a set intersection. Now, suppose we process the query variables in a topological order and we perform induction on this ordering. Our inductive assumption is that after processing k nodes in this ordering, for every variable V j , j ? k in the query, we have a set S(V j ) of possible nodes that could be assigned to this variable.</p><p>Now, when we process the node V i , we consider all of its incoming edges, and we have that:</p><formula xml:id="formula_15">S(V i ) = ? ? l (Vj ,V k )?Eq:V k =Vi ? v?S(Vj ) N (v, ? ) ,<label>(7)</label></formula><p>by definition. Moreover, by the inductive assumption the set S(V j ) for all nodes that have an outgoing edge to V i is known (because they must be earlier in the topological ordering). And Equation <ref type="formula" target="#formula_15">(7)</ref> requires only set projection and intersection operations, as defined above.</p><p>Finally, for the base case the set of possible assignments for the anchor nodes is given, and these nodes are guaranteed to be first in the DAG's topological ordering, by definition.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix B: Further dataset details</head><p>Bio data</p><p>The biological interaction network contains interactions between five types of biological entities (proteins, diseases, biological processes, side effects, and drugs). The network records 42 distinct types of biologically relevant molecular interactions between these entities, which we describe below.</p><p>Protein-protein interaction links describe relationships between proteins. We used the human proteinprotein interaction (PPI) network compiled by <ref type="bibr" target="#b25">[26]</ref> and <ref type="bibr" target="#b9">[10]</ref>, integrated with additional PPI information from <ref type="bibr" target="#b39">[40]</ref>, and <ref type="bibr" target="#b37">[38]</ref>. The network contains physical interactions experimentally documented in humans, such as metabolic enzyme-coupled interactions and signaling interactions.</p><p>Drug-protein links describe the proteins targeted by a given drug. We obtained relationships between proteins and drugs from the STITCH database, which integrates various chemical and protein networks <ref type="bibr" target="#b38">[39]</ref>. Drug-drug interaction network contains 29 different types of edges (one for each type of polypharmacy side effects) and describes which drug pairs lead to which side effects <ref type="bibr" target="#b48">[49]</ref>. We also pulled from databases detailing side effects (e.g., nausea, vomiting, headache, diarrhoea, and dermatitis) of individual drugs. The SIDER database contains drug-side effect associations <ref type="bibr" target="#b23">[24]</ref> obtained by mining adverse events from drug label text. We integrated it with the OFFSIDES database, which details off-label associations between drugs and side effects <ref type="bibr" target="#b40">[41]</ref>.</p><p>Disease-protein links describe proteins that, when mutated or otherwise genomically altered, lead to the development of a given disease. We obtained relationships between proteins and diseases from the DisGeNET database <ref type="bibr" target="#b30">[31]</ref>, which integrates data from expert-curated repositories. Drug-disease links describe diseases that a given drug treats. We used the RepoDB database <ref type="bibr" target="#b7">[8]</ref> to obtain drug-disease links for all FDA-approved drugs in the U.S.</p><p>Finally, protein-process links describe biological processes (e.g., intracellular transport of molecules) that each protein is involved in. We obtained these links from the Gene Ontology database <ref type="bibr" target="#b1">[2]</ref> and we only considered experimentally verified links. Process-process links describe relationships between biological processes and were retrieved from the Gene Ontology graph.</p><p>We ignore in experiments any relation/edge-type with less than 1000 edges. Preprocessed versions of these datasets are publicly available at: http://snap.stanford.edu/biodata/.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Reddit data</head><p>Reddit is one of the largest websites in the world. As described in the main text we analyzed all activity (posts, comments, upvotes, downvotes, and user subscriptions) in 105 videogame related communities from May 1-5th, 2017. For the word features in the posts, we did not use a frequency threshold and included any word that occurs at least once in the data. We selected the subset of videogame communities by crawling the list of communities from the subreddit "/r/ListOfSubreddits", which contains volunteer curated lists of communities that have at least 50,000 subscribers. We selected all communities that were listed as being about specific videogames. All usernames were hashed prior to our analyses. This dataset cannot be made publicly available at this time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix C: Further details on empirical evaluation</head><p>As noted in the main text, the code for our model is available at: https://github.com/ williamleif/graphqembed</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Hyperparameter tuning</head><p>As noted in the main text, we tested all models using different learning rates and symmetric vector aggregation functions ?, selecting the best performing model on the validation set. The other important hyperparameter for the methods is the embedding dimension d, which was set to d = 128 in all experiments. We chose d = 128 based upon early validation datasets on a subset of the Bio data. We tested embedding dimensions of 16, 64, 128, and 256; in these tests, we found performance increased until the dimension of 128 and then plateaued.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Further training details</head><p>During training of the full GQE framework, we first trained the model to convergence on edge prediction, and then trained on more complex queries, as we found that this led to better convergence. After training on edge prediction, in every batch of size B we trained on B queries of each type using standard negative samples and B queries using hard negative samples. We weighted the contribution of path queries to the loss function with a factor of 0.01 and intersection queries with a factor of 0.005, as we found this was necessary to prevent exploding/diverging gradient estimates. We performed validation every 5000 batches to test for convergence. All of these settings were determined in early validation studies on a subset of the Bio data. Note that in order to effectively batch on the GPU, in every batch we only select queries that have the same edges/relations and DAG structure. This means that for some query types batches can be smaller than B on occasion.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Compute resources</head><p>We trained the models on a server with 16 x Intel(R) Xeon(R) CPU E5-2623 v4 @ 2.60GHz processors, 512 GB RAM, and four NVIDIA Titan X Pascal GPUs with 12 GB of memory. This was a shared resource environment. Each model takes approximately 3 hours and three models could be concurrently run on a single GPU without significant slowdown. We expect all our experiments could be replicated in 48 hours or less on a single GPU, with sufficient RAM.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Inverse edges</head><p>Note that following <ref type="bibr" target="#b17">[18]</ref>, we explicitly parameterize every edge as both the original edge and the inverse edge. For instance, if there is an edge TARGET(u, v) in the network then we also add an edge TARGET ?1 (v, u) and the two relations TARGET and TARGET ?1 have separate parameterizations in the projection operator P. This is necessary to obtain high performance on path queries because relations can be many-to-one and not necessarily perfect inverses. However, note also that whenever we remove an edge from the training set, we also remove the inverse edge, to prevent the existence of trivial test queries.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>32ndC</head><label></label><figDesc>Conference on Neural Information Processing Systems (NeurIPS 2018), Montr?al, Canada. arXiv:1806.01445v4 [cs.SI] 29 Oct 2019 ? .9P : upvote(u, P )^belong(P, C ? )</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Theorem 1 .</head><label>1</label><figDesc>Given a network G = (V, E), there exists a set of node embeddings z v ? R d , ?v ? V, geometric projection parameters R ? ? R d?d , ?? ? R, and geometric intersection parameters W ? , B ? ? R d?d , ?? ? ? with d = O(|V |) such that for all DAG-structured queries q ? Q(G) containing E edges the following holds: Algorithm 1 can compute an embedding q of q using O(E) applications of the geometric operators P and I such that</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Lemma 2 .</head><label>2</label><figDesc>Algorithm 1 terminates in O(E) operations, where E is the number of edges in the query DAG.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 :</head><label>1</label><figDesc>Performance on test queries for different variants of our framework. Results are macro-averaged across queries with different DAG structures (Figure 4, bottom). For queries involving intersections, we evaluate both using standard negative examples as well as "hard" negative examples (Section 4.4), giving both measures equal weight in the macro-average. Figure 4 breaks down the performance of the best model by query type. AUC of the Bilinear GQE model on both datasets, broken down according to test queries with different dependency graph structures, as well as test queries using standard or hard negative examples.</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell>Bio data</cell><cell></cell><cell></cell><cell>Reddit data</cell><cell></cell></row><row><cell></cell><cell></cell><cell cols="3">Bilinear DistMult TransE</cell><cell cols="3">Bilinear DistMult TransE</cell></row><row><cell>GQE training</cell><cell>AUC APR</cell><cell>91.0 91.5</cell><cell>90.7 91.3</cell><cell>88.7 89.9</cell><cell>76.4 78.7</cell><cell>73.3 74.7</cell><cell>75.9 78.4</cell></row><row><cell>Edge training</cell><cell>AUC APR</cell><cell>79.2 78.6</cell><cell>86.7 87.5</cell><cell>78.3 81.6</cell><cell>59.8 60.1</cell><cell>72.2 73.5</cell><cell>73.0 75.5</cell></row><row><cell>AUC</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell cols="2">Query dependency graph</cell><cell cols="3">EVALUATING ON HARD NEGATIVE EXAMPLES</cell></row><row><cell>Figure 4:</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 2 :</head><label>2</label><figDesc>Comparing GQE to an enumeration baseline that performs edge prediction and then computes logical conjunctions as products of edge likelihoods. AUC values are reported (with analogous results holding for the APR metric). Bio-H and Reddit-H denote evaluations where hard negative examples are used (see Section 5.3).</figDesc><table><row><cell></cell><cell>Bio</cell><cell cols="3">Bio-H Reddit Reddit-H</cell></row><row><cell cols="3">Enum. Baseline 0.985 0.731</cell><cell>0.910</cell><cell>0.643</cell></row><row><cell>GQE</cell><cell cols="2">0.989 0.743</cell><cell>0.948</cell><cell>0.645</cell></row></table><note></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1">We use the cosine distance, but in general other distance measures could be used.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2">We selected the best ? function and learning rate for each variant on the validation set.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>The authors thank Alex Ratner, Stephen Bach, and Michele Catasta for their helpful discussions and comments on early drafts. This research has been supported in part by NSF IIS-1149837, DARPA SIMPLEX, Stanford Data Science Initiative, Huawei, and Chan Zuckerberg Biohub. WLH was also supported by the SAP Stanford Graduate Fellowship and an NSERC PGS-D grant.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix A: Proof of Theorem 1</head><p>We restate Theorem 1 for completeness: Theorem 2. Given a network G = (V, E), there exists a set of node embeddings z v ? R d , ?v ? V, geometric projection parameters R ? ? R d?d , ?? ? R, and geometric intersection parameters W ? , B ? ? R d?d , ?? ? ? with d = O(|V |) such that for all DAG-structured queries q ? Q(G) containing E edges the following holds: Algorithm 1 can compute an embedding q of q using O(E) applications of the geometric operators P and I such that:</p><p>i.e., the observed denotation set of the query q train can be exactly computed in the embeddings space by Algorithm 1 using O(E) applications of the geometric operators P and I.</p><p>The proof of this theorem follows directly from two lemmas:</p><p>? Lemma 1 shows that any conjunctive query can be exactly represented in an embedding space of dimension d = O(|V|). ? Lemma 2 notes that Algorithm 1 terminates in O(E) steps.</p><p>such that for any DAG-structured query q ? Q(G) an embedding q can be computed using P and I such that the following holds:</p><p>Proof. Without loss of generality, we order all nodes by integer labels from 1...|V |. Moreover, for simplicity, the subscript i in our notation for a node v i will denote its index in this ordering. Next, we set the embedding for every node to be a one-hot indicator vector, i.e., z vi is a vector with all zeros except with a one at position i. Next, we set all the projection matrices R ? ? R |V |?|V | to be binary adjacency matrices, i.e., R ? (i, j) = 1 iff ? (v i , v j ) = true. Finally, we set all the weight matrices in I to be the identity and set ? = min, i.e., I is just an elementwise min over the input vectors. Now, by Lemma 3 the denotation set q of a DAG-structured conjunctive query q can be computed in a sequence S of two kinds of set operations, applied to the initial input sets {v 1 }, ..., {v n }-where v 1 , ..., v n are the anchor nodes of the query-and where the final output set is the query denotation:</p><p>? Set projections, with one defined for each edge type, ? and which map a set of nodes S to the set ? vi?S N (?, v i ).</p><p>? Set intersection (i.e., the basic set intersection operator) which takes a set of sets {S 1 , ..., S n } and returns S 1 ?, ..., ?, S n .</p><p>And we can easily show that P and I perform exactly these operations, when using the parameter settings outlined above, and we can complete our proof by induction. In particular, our inductive assumption is that sets S i at step k of the sequence S are all represented as binary vectors z S with non-zeroes in the entries corresponding to the nodes in this set. Under this assumption, we have two cases, corresponding to what our next operation is in the sequence S:</p><p>1. If the next operation is a projection on a set S using edge relation ? , then we can compute it as R ? z S , and by definition R ? z S will have a non-zero entry at position j iff there is at least one non-zero entry i in z S . That is, we will have that:</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Foundations of databases: The logical level</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Hull</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Vianu</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995" />
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Gene Ontology: tool for the unification of biology</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Ashburner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Ball</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Blake</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Botstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Butler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Cherry</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Davis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Dolinski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Dwight</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Eppig</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nature Genetics</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page">25</biblScope>
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Hinge-loss Markov random fields and probabilistic soft logic</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Bach</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Broecheler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Getoor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">JMRL</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">109</biblScope>
			<biblScope unit="page" from="1" to="67" />
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Semantic parsing on freebase from question-answer pairs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Berant</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Chou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Frostig</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Liang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EMNLP</title>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Question answering with subgraph embeddings</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Bordes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Chopra</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Weston</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EMNLP</title>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Translating embeddings for modeling multi-relational data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Bordes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Usunier</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Garcia-Duran</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Weston</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Yakhnenko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NIPS</title>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Geometric deep learning: Going beyond Euclidean data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">M</forename><surname>Bronstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Bruna</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Lecun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Szlam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Vandergheynst</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Signal Processing Magazine</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="18" to="42" />
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">A standard database for drug repositioning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Brown</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Patel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Scientific Data</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page">170029</biblScope>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">The theory of probabilistic databases</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Cavallo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Pittarelli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="1987" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">The BioGRID interaction database: 2015 update</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Chatr-Aryamontri</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nucleic Acids Res</title>
		<imprint>
			<biblScope unit="volume">43</biblScope>
			<biblScope unit="issue">D1</biblScope>
			<biblScope unit="page" from="470" to="478" />
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Cohen</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1605.06523</idno>
		<title level="m">Tensorlog: A differentiable deductive database</title>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Efficient query evaluation on probabilistic databases</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Dalvi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Suciu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Go for a walk and arrive at the answer: Reasoning over paths in knowledge bases using reinforcement learning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Das</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Dhuliawala</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Zaheer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Vilnis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Durugkar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Krishnamurthy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Smola</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Mccallum</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2018" />
			<publisher>ICLR</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Chains of reasoning over entities, relations, and text using recurrent neural networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Das</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Neelakantan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Belanger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Mccallum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EACL</title>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Lifted rule injection for relation embeddings</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Demeester</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Rockt?schel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Riedel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EMNLP</title>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Introduction to Statistical Relational Learning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Getoor</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Taskar</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007" />
			<publisher>MIT press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Neural message passing for quantum chemistry</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Gilmer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Schoenholz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">F</forename><surname>Riley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Vinyals</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">E</forename><surname>Dahl</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Traversing knowledge graphs in vector space</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Guu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Liang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">EMNLP</title>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Representation learning on graphs: Methods and applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Hamilton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Ying</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Leskovec</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Data Engineering Bulletin</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Harnessing deep neural networks with logic rules</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Hovy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Xing</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACL</title>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Approximate nearest neighbors: towards removing the curse of dimensionality</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Indyk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Motwani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In ACM Symp. Theory Comput</title>
		<imprint>
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Topological sorting of large networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Kahn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="558" to="562" />
			<date type="published" when="1962" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Querying factorized probabilistic triple databases</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Krompa?</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Nickel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Tresp</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Semantic Web Conference</title>
		<meeting><address><addrLine>Cham</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014" />
			<biblScope unit="page" from="114" to="129" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">The SIDER database of drugs and side effects</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Kuhn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nucleic Acids Res</title>
		<imprint>
			<biblScope unit="volume">44</biblScope>
			<biblScope unit="issue">D1</biblScope>
			<biblScope unit="page" from="1075" to="1079" />
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">The link-prediction problem for social networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Liben-Nowell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Kleinberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Assoc. Inform. Sci. and Technol</title>
		<imprint>
			<biblScope unit="volume">58</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="1019" to="1031" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Uncovering disease-disease relationships through the incomplete interactome</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Menche</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science</title>
		<imprint>
			<biblScope unit="volume">347</biblScope>
			<biblScope unit="issue">6224</biblScope>
			<biblScope unit="page">1257601</biblScope>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Compositional vector space models for knowledge base inference</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Neelakantan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Roth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Mccallum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">AAAI</title>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">A review of relational machine learning for knowledge graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Nickel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Murphy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Tresp</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Gabrilovich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE</title>
		<meeting>IEEE</meeting>
		<imprint>
			<date type="published" when="2016" />
			<biblScope unit="volume">104</biblScope>
			<biblScope unit="page" from="11" to="33" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">A three-way model for collective learning on multirelational data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Nickel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Tresp</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Kriegel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICML</title>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Automatic differentiation in PyTorch</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Paszke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Gross</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Chintala</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Chanan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Devito</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Desmaison</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Antiga</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Lerer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NIPS Autodiff Workshop</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">DisGeNET: a discovery platform for the dynamical exploration of human diseases and their genes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ja</forename><surname>Pi?ero</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Queralt-Rosinach</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">?</forename><surname>Bravo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Deu-Pons</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Bauer-Mehren</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Baron</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Sanz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Furlong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Database</title>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Pointnet: Deep learning on point sets for 3d classification and segmentation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Qi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Su</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Mo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Guibas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CVPR</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Towards a model theory for distributed representations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Ramanathan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">AAAI Spring Symposium Series</title>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title level="m" type="main">Combining representation learning with logic for language processing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename></persName>
		</author>
		<idno type="arXiv">arXiv:1712.09687</idno>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Low-dimensional embeddings of logic</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Rockt?schel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Bo?njak</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Singh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Riedel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACL Semantic Parsing</title>
		<imprint>
			<date type="published" when="2014" />
			<biblScope unit="page" from="45" to="49" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">End-to-end differentiable proving</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Rockt?schel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Riedel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NIPS</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Injecting logical background knowledge into embeddings for relation extraction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Rockt?schel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Singh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Riedel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NAACL HLT</title>
		<imprint>
			<date type="published" when="2015" />
			<biblScope unit="page" from="1119" to="1129" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">A proteome-scale map of the human interactome network</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Rolland</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Cell</title>
		<imprint>
			<biblScope unit="volume">159</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="1212" to="1226" />
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">STITCH 5: augmenting protein-chemical interaction networks with tissue and affinity data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Szklarczyk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nucleic Acids Res</title>
		<imprint>
			<biblScope unit="volume">44</biblScope>
			<biblScope unit="issue">D1</biblScope>
			<biblScope unit="page" from="380" to="384" />
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">The STRING database in 2017: quality-controlled protein-protein association networks, made broadly accessible</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Szklarczyk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nucleic Acids Res</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="issue">D1</biblScope>
			<biblScope unit="page" from="362" to="368" />
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Data-driven prediction of drug effects and interactions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Tatonetti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science Translational Medicine</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">125</biblScope>
			<biblScope unit="page">12531</biblScope>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<monogr>
		<title level="m" type="main">Graphs: theory and algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Thulasiraman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Madisetti</forename><forename type="middle">N</forename><surname>Swamy</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2011" />
			<publisher>John Wiley &amp; Sons</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Premise selection for theorem proving by deep graph embedding</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Deng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NIPS</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Fisch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Chopra</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Adams</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Bordes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Weston</surname></persName>
		</author>
		<title level="m">Starspace: Embed all the things! In AAAI</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<monogr>
		<title level="m" type="main">Embedding entities and relations for learning and inference in knowledge bases</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Bi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Yih</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Gao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Deng</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2015" />
			<publisher>ICLR</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Deep sets</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Zaheer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Kottur</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Ravanbakhsh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Poczos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">J</forename><surname>Salakhutdinov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Smola</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NIPS</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<monogr>
		<title level="m" type="main">Variational reasoning for question answering with knowledge graph</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Dai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Kozareva</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Smola</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Song</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2018" />
			<publisher>AAAI</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Bipartite network projection and personal recommendation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Medo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Phys. Rev. E</title>
		<imprint>
			<biblScope unit="volume">76</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page">46115</biblScope>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Modeling polypharmacy side effects with graph convolutional networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Zitnik</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Leskovec</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
