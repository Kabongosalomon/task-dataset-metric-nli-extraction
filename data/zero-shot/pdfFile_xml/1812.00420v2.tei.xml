<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /nfs/home/kabenamualus/Research/task-dataset-metric-extraction/../grobid-0.6.0/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">EFFICIENT LIFELONG LEARNING WITH A-GEM</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Arslan</forename><surname>Chaudhry</surname></persName>
							<email>arslan.chaudhry@eng.ox.ac.uk</email>
							<affiliation key="aff0">
								<orgName type="institution">University of Oxford</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Aurelio</forename><surname>Marc&amp;apos;</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Ranzato</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">Facebook AI Research</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marcus</forename><surname>Rohrbach</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">Facebook AI Research</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mohamed</forename><surname>Elhoseiny</surname></persName>
							<email>elhoseiny@fb.com</email>
							<affiliation key="aff1">
								<orgName type="department">Facebook AI Research</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">EFFICIENT LIFELONG LEARNING WITH A-GEM</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<note>Published as a conference paper at ICLR 2019</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>

		<encodingDesc>
			<appInfo>
				<application version="0.6.0" ident="GROBID-SDO" when="2022-11-11T19:46+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid-sdo"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>In lifelong learning, the learner is presented with a sequence of tasks, incrementally building a data-driven prior which may be leveraged to speed up learning of a new task. In this work, we investigate the efficiency of current lifelong approaches, in terms of sample complexity, computational and memory cost. Towards this end, we first introduce a new and a more realistic evaluation protocol, whereby learners observe each example only once and hyper-parameter selection is done on a small and disjoint set of tasks, which is not used for the actual learning experience and evaluation. Second, we introduce a new metric measuring how quickly a learner acquires a new skill. Third, we propose an improved version of GEM (Lopez-Paz &amp; Ranzato, 2017), dubbed Averaged GEM (A-GEM), which enjoys the same or even better performance as GEM, while being almost as computationally and memory efficient as EWC  and other regularizationbased methods. Finally, we show that all algorithms including A-GEM can learn even more quickly if they are provided with task descriptors specifying the classification tasks under consideration. Our experiments on several standard lifelong learning benchmarks demonstrate that A-GEM has the best trade-off between accuracy and efficiency. 1 1 The code is available at httpsPublished as a conference paper at ICLR 2019 the LLL scenario. While some algorithms may work well in a single-pass setting, they unfortunately require a lot of computation <ref type="bibr" target="#b15">(Lopez-Paz &amp; Ranzato, 2017)</ref> or their memory scales with the number of tasks , which greatly impedes their actual deployment in practical applications.</p><p>In this work, we propose an evaluation methodology and an algorithm that better match our desiderata, namely learning efficiently -in terms of training samples, time and memory -from a stream of tasks. First, we propose a new learning paradigm, whereby the learner performs cross validation on a set of tasks which is disjoint from the set of tasks actually used for evaluation (Sec. 2). In this setting, the learner will have to learn and will be tested on an entirely new sequence of tasks and it will perform just a single pass over this data stream. Second, we build upon GEM <ref type="bibr" target="#b15">(Lopez-Paz &amp; Ranzato, 2017)</ref>, an algorithm which leverages a small episodic memory to perform well in a single pass setting, and propose a small change to the loss function which makes GEM orders of magnitude faster at training time while maintaining similar performance; we dub this variant of GEM, A-GEM (Sec. 4). Third, we explore the use of compositional task descriptors in order to improve the fewshot learning performance within LLL showing that with this additional information the learner can pick up new skills more quickly (Sec. 5). Fourth, we introduce a new metric to measure the speed of learning, which is useful to quantify the ability of a learning algorithm to learn a new task (Sec. 3). And finally, using our new learning paradigm and metric, we demonstrate A-GEM on a variety of benchmarks and against several representative baselines (Sec. 6). Our experiments show that A-GEM has a better trade-off between average accuracy and computational/memory cost. Moreover, all algorithms improve their ability to quickly learn a new task when provided with compositional task descriptors, and they do so better and better as they progress through the learning experience.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Intelligent systems, whether they are natural or artificial, must be able to quickly adapt to changes in the environment and to quickly learn new skills by leveraging past experiences. While current learning algorithms can achieve excellent performance on a variety of tasks, they strongly rely on copious amounts of supervision in the form of labeled data.</p><p>The lifelong learning (LLL) setting attempts at addressing this shortcoming, bringing machine learning closer to a more realistic human learning by acquiring new skills quickly with a small amount of training data, given the experience accumulated in the past. In this setting, the learner is presented with a stream of tasks whose relatedness is not known a priori. The learner has then the potential to learn more quickly a new task, if it can remember how to combine and re-use knowledge acquired while learning related tasks of the past. Of course, for this learning setting to be useful, the model needs to be constrained in terms of amount of compute and memory required. Usually this means that the learner should not be allowed to merely store all examples seen in the past (in which case this reduces the lifelong learning problem to a multitask problem) nor should the learner be engaged in computations that would not be feasible in real-time, as the goal is to quickly learn from a stream of data.</p><p>Unfortunately, the established training and evaluation protocol as well as current algorithms for lifelong learning do not satisfy all the above desiderata, namely learning from a stream of data using limited number of samples, limited memory and limited compute. In the most popular training paradigm, the learner does several passes over the data <ref type="bibr" target="#b1">Aljundi et al., 2018;</ref><ref type="bibr" target="#b22">Schwarz et al., 2018)</ref>, while ideally the model should need only a handful of samples and these should be provided one-by-one in a single pass <ref type="bibr" target="#b15">(Lopez-Paz &amp; Ranzato, 2017)</ref>. Moreover, when the learner has several hyper-parameters to tune, the current practice is to go over the sequence of tasks several times, each time with a different hyper-parameter value, again ignoring the requirement of learning from a stream of data and, strictly speaking, violating the assumption of 2 LEARNING PROTOCOL Currently, most works on lifelong learning <ref type="bibr" target="#b23">Shin et al., 2017;</ref><ref type="bibr" target="#b16">Nguyen et al., 2018)</ref> adopt a learning protocol which is directly borrowed from supervised learning. There are T tasks, and each task consists of a training, validation and test sets. During training the learner does as many passes over the data of each task as desired. Moreover, hyperparameters are tuned on the validation sets by sweeping over the whole sequence of tasks as many times as required by the cross-validation grid search. Finally, metrics of interest are reported on the test set of each task using the model selected by the previous cross-validation procedure.</p><p>Since the current protocol violates our stricter definition of LLL for which the learner can only make a single pass over the data, as we want to emphasize the importance of learning quickly from data, we now introduce a new learning protocol.</p><p>We consider two streams of tasks, described by the following ordered sequences of datasets D CV = {D 1 , ? ? ? , D T CV } and D EV = {D T CV +1 , ? ? ? , D T }, where D k = {(x k i , t k i , y k i ) n k i=1 } is the dataset of the k-th task, T CV &lt; T (in all our experiments T CV = 3 while T = 20), and we assume that all datasets are drawn from the same distribution over tasks. To avoid cluttering of the notation, we let the context specify whether D k refers to the training or test set of the k-th dataset. D CV is the stream of datasets which will be used during cross-validation; D CV allows the learner to replay all samples multiple times for the purposes of model hyper-parameter selection. Instead, D EV is the actual dataset used for final training and evaluation on the test set; the learner will observe training examples from D EV once and only once, and all metrics will be reported on the test sets of D EV . Since the regularization-based approaches for lifelong learning <ref type="bibr" target="#b29">Zenke et al., 2017)</ref> are rather sensitive to the choice of the regularization hyper-parameter, we introduced the set D CV , as it seems reasonable in practical applications to have similar tasks that can be used for tuning the system. However, the actual training and testing are then performed on D EV using a single pass over the data. See Algorithm 1 for a summary of the training and evaluation protocol.</p><p>Each example in any of these dataset consists of a triplet defined by an input (x k ? X ), task descriptor (t k ? T , see Sec. 5 for examples) and a target vector (y k ? y k ), where y k is the set of labels specific to task k and y k ? Y. While observing the data, the goal is to learn a predictor f ? : X ? T ? Y, parameterized by ? ? R P (a neural network in our case), that can map any test pair (x, t) to a target y. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 1 Learning and Evaluation Protocols</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">METRICS</head><p>Below we describe the metrics used to evaluate the LLL methods studied in this work. In addition to Average Accuracy (A) and Forgetting Measure (F ) <ref type="bibr" target="#b4">(Chaudhry et al., 2018)</ref>, we define a new measure, the Learning Curve Area (LCA), that captures how quickly a model learns.</p><p>The training dataset of each task, D k , consists of a total B k mini-batches. After each presentation of a mini-batch of task k, we evaluate the performance of the learner on all the tasks using the corresponding test sets. Let a k,i,j ? [0, 1] be the accuracy evaluated on the test set of task j, after the model has been trained with the i-th mini-batch of task k. Assuming the first learning task in the continuum is indexed by 1 (it will be T CV + 1 for D EV ) and the last one by T (it will be T CV for D CV ), we define the following metrics:</p><p>Average Accuracy (A ? [0, 1]) Average accuracy after the model has been trained continually with all the mini-batches up till task k is defined as:</p><formula xml:id="formula_0">A k = 1 k k j=1 a k,B k ,j<label>(1)</label></formula><p>In particular, A T is the average accuracy on all the tasks after the last task has been learned; this is the most commonly used metric used in LLL.</p><p>Forgetting Measure (F ? [?1, 1]) <ref type="bibr" target="#b4">(Chaudhry et al., 2018)</ref> Average forgetting after the model has been trained continually with all the mini-batches up till task k is defined as:</p><formula xml:id="formula_1">F k = 1 k ? 1 k?1 j=1 f k j (2)</formula><p>where f k j is the forgetting on task 'j' after the model is trained with all the mini-batches up till task k and computed as:</p><formula xml:id="formula_2">f k j = max l?{1,??? ,k?1} a l,B l ,j ? a k,B k ,j<label>(3)</label></formula><p>Measuring forgetting after all tasks have been learned is important for a two-fold reason. It quantifies the accuracy drop on past tasks, and it gives an indirect notion of how quickly a model may learn a new task, since a forgetful model will have little knowledge left to transfer, particularly so if the new task relates more closely to one of the very first tasks encountered during the learning experience.</p><p>Learning Curve Area (LCA ? [0, 1]) Let us first define an average b-shot performance (where b is the mini-batch number) after the model has been trained for all the T tasks as:</p><formula xml:id="formula_3">Z b = 1 T T k=1 a k,b,k<label>(4)</label></formula><p>LCA at ? is the area of the convergence curve Z b as a function of b ? [0, ?]:</p><formula xml:id="formula_4">LCA ? = 1 ? + 1 ? 0 Z b db = 1 ? + 1 ? b=0 Z b<label>(5)</label></formula><p>LCA has an intuitive interpretation. LCA 0 is the average 0-shot performance, the same as forward transfer in <ref type="bibr" target="#b15">Lopez-Paz &amp; Ranzato (2017)</ref>. LCA ? is the area under the Z b curve, which is high if the 0-shot performance is good and if the learner learns quickly. In particular, there could be two models with the same Z ? or A T , but very different LCA ? because one learns much faster than the other while they both eventually obtain the same final accuracy. This metric aims at discriminating between these two cases, and it makes sense for relatively small values of ? since we are interested in models that learn from few examples.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">AVERAGED GRADIENT EPISODIC MEMORY (A-GEM)</head><p>So far we discussed a better training and evaluation protocol for LLL and a new metric to measure the speed of learning. Next, we review GEM <ref type="bibr" target="#b15">(Lopez-Paz &amp; Ranzato, 2017)</ref>, which is an algorithm that has been shown to work well in the single epoch setting. Unfortunately, GEM is very intensive in terms of computational and memory cost, which motivates our efficient variant, dubbed A-GEM. In Sec. 5, we will describe how compositional task descriptors can be leveraged to further speed up learning in the few shot regime. GEM avoids catastrophic forgetting by storing an episodic memory M k for each task k. While minimizing the loss on the current task t, GEM treats the losses on the episodic memories of tasks k &lt; t, given by (f ? , M k ) = 1 |M k | (xi,k,yi)?M k (f ? (x i , k), y i ), as inequality constraints, avoiding their increase but allowing their decrease. This effectively permits GEM to do positive backward transfer which other LLL methods do not support. Formally, at task t, GEM solves for the following objective:</p><formula xml:id="formula_5">minimize ? (f ? , D t ) s.t. (f ? , M k ) ? (f t?1 ? , M k ) ?k &lt; t<label>(6)</label></formula><p>Where f t?1 ? is the network trained till task t ? 1. To inspect the increase in loss, GEM computes the angle between the loss gradient vectors of previous tasks g k , and the proposed gradient update on the current task g. Whenever the angle is greater than 90?with any of the g k 's, it projects the proposed gradient to the closest in L2 norm gradientg that keeps the angle within the bounds. Formally, the optimization problem GEM solves is given by:</p><formula xml:id="formula_6">minimizeg 1 2 ||g ?g|| 2 2 s.t. g, g k ? 0 ?k &lt; t<label>(7)</label></formula><p>Eq.7 is a quadratic program (QP) in P -variables (the number of parameters in the network), which for neural networks could be in millions. In order to solve this efficiently, GEM works in the dual space which results in a much smaller QP with only t ? 1 variables:</p><formula xml:id="formula_7">minimize v 1 2 v GG v + g G v s.t. v ? 0<label>(8)</label></formula><p>where G = ?(g 1 , ? ? ? , g t?1 ) ? R (t?1)?P is computed at each gradient step of training. Once the solution v * to Eq. 8 is found, the projected gradient update can be computed asg = G v * + g.</p><p>While GEM has proven very effective in a single epoch setting <ref type="bibr" target="#b15">(Lopez-Paz &amp; Ranzato, 2017)</ref>, the performance gains come at a big computational burden at training time. At each training step, GEM computes the matrix G using all samples from the episodic memory, and it also needs to solve the QP of Eq. 8. Unfortunately, this inner loop optimization becomes prohibitive when the size of M and the number of tasks is large, see Tab. 7 in Appendix for an empirical analysis. To alleviate the computational burden of GEM, next we propose a much more efficient version of GEM, called Averaged GEM (A-GEM).</p><p>Whereas GEM ensures that at every training step the loss of each individual previous tasks, approximated by the samples in episodic memory, does not increase, A-GEM tries to ensure that at every training step the average episodic memory loss over the previous tasks does not increase. Formally, while learning task t, the objective of A-GEM is:</p><formula xml:id="formula_8">minimize ? (f ? , D t ) s.t. (f ? , M) ? (f t?1 ? , M) where M = ? k&lt;t M k<label>(9)</label></formula><p>The corresponding optimization problem reduces to:</p><formula xml:id="formula_9">minimizeg 1 2 ||g ?g|| 2 2 s.t.g g ref ? 0<label>(10)</label></formula><p>where g ref is a gradient computed using a batch randomly sampled from the episodic memory,</p><formula xml:id="formula_10">(x ref , y ref ) ? M,</formula><p>of all the past tasks. In other words, A-GEM replaces the t ? 1 constraints of GEM with a single constraint, where g ref is the average of the gradients from the previous tasks computed from a random subset of the episodic memory.</p><p>The constrained optimization problem of Eq. 10 can now be solved very quickly; when the gradient g violates the constraint, it is projected via:</p><formula xml:id="formula_11">g = g ? g g ref g ref g ref g ref<label>(11)</label></formula><p>The formal proof of the update rule of A-GEM (Eq. 11) is given in Appendix C. This makes A-GEM not only memory efficient, as it does not need to store the matrix G, but also orders of magnitude faster than GEM because 1) it is not required to compute the matrix G but just the gradient of a random subset of memory examples, 2) it does not need to solve any QP but just an inner product, and 3) it will incur in less violations particularly when the number of tasks is large (see Tab. 7 and <ref type="figure" target="#fig_4">Fig. 6</ref> in Appendix for empirical evidence). All together these factors make A-GEM faster while not hampering its good performance in the single pass setting.</p><p>Intuitively, the difference between GEM and A-GEM loss functions is that GEM has better guarantess in terms of worst-case forgetting of each individual task since (at least on the memory examples) it prohibits an increase of any task-specific loss, while A-GEM has better guaratees in terms of average accuracy since GEM may prevent a gradient step because of a task constraint violation although the overall average loss may actually decrease, see Appendix Sec. D.1 and D.2 for further analysis and empirical evidence. The pseudo-code of A-GEM is given in Appendix Alg. 2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">JOINT EMBEDDING MODEL USING COMPOSITIONAL TASK DESCRIPTORS</head><p>In this section, we discuss how we can improve forward transfer for all the LLL methods including A-GEM. In order to speed up learning of a new task, we consider the use of compositional task descriptors where components are shared across tasks and thus allow transfer. Examples of compositional task descriptors are, for instance, a natural language description of the task under consideration or a matrix specifying the attribute values of the objects to be recognized in the task.</p><p>In our experiments, we use the latter since it is provided with popular benchmark datasets <ref type="bibr" target="#b26">(Wah et al., 2011;</ref><ref type="bibr" target="#b12">Lampert et al., 2009)</ref>. For instance, if the model has already learned and remembers about two independent properties (e.g., color of feathers and shape of beak), it can quickly recognize a new class provided a descriptor specifying the values of its attributes (yellow feathers and red beak), although this is an entirely unseen combination.</p><p>Borrowing ideas from literature in few-shot learning <ref type="bibr" target="#b13">(Lampert et al., 2014;</ref><ref type="bibr" target="#b30">Zhang et al., 2018;</ref><ref type="bibr" target="#b5">Elhoseiny et al., 2017;</ref><ref type="bibr" target="#b27">Xian et al., 2018)</ref>, we learn a joint embedding space between image features and the attribute embeddings. Formally, let x k ? X be the input (e.g., an image), t k be the task descriptor in the form of a matrix of size C k ? A, where C k is the number of classes in the kth task and A is the total number of attributes for each class in the dataset. The joint embedding model consists of a feature extraction module, ? ? :</p><formula xml:id="formula_12">x k ? ? ? (x k ), where ? ? (x k ) ? R D , and a task embedding module, ? ? : t k ? ? ? (t k ), where ? ? (t k ) ? R C k ?D .</formula><p>In this work, ? ? (.) is implemented as a standard multi-layer feed-forward network (see Sec. 6 for the exact parameterization), whereas ? ? (.) is implemented as a parameter matrix of dimensions A ? D. This matrix can be interpreted as an attribute look-up table as each attribute is associated with a D dimensional vector, from which a class embedding vector is constructed via a linear combination of the attributes present in the class; the task descriptor embedding is then the concatenation of the embedding vectors of the classes present in the task (see Appendix <ref type="figure">Fig. 9</ref> for the pictorial description of the joint embedding model).</p><p>During training, the parameters ? and ? are learned by minimizing the cross-entropy loss:</p><formula xml:id="formula_13">k (?, ?) = 1 N N i=1 ? log(p(y k i |x k i , t k ; ?, ?))<label>(12)</label></formula><p>where (x k i , t k , y k i ) is the i-th example of task k. If y k i = c, then the distribution p(.) is given by:</p><formula xml:id="formula_14">p(c|x k i , t k ; ?, ?) = exp([? ? (x k i )? ? (t k ) ] c ) j exp([? ? (x k i )? ? (t k ) ] j )<label>(13)</label></formula><p>where [a] i denotes the i-th element of the vector a. Note that the architecture and loss functions are general, and apply not only to A-GEM but also to any other LLL model (e.g., regularization based approaches). See Sec. 6 for the actual choice of parameterization of these functions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">EXPERIMENTS</head><p>We consider four dataset streams, see Tab.1 in Appendix Sec. A for a summary of the statistics. Permuted MNIST ) is a variant of MNIST (LeCun, 1998) dataset of handwritten digits where each task has a certain random permutation of the input pixels which is applied to all the images of that task. Split CIFAR <ref type="bibr" target="#b29">(Zenke et al., 2017)</ref> consists of splitting the original CIFAR-100 dataset <ref type="bibr" target="#b11">(Krizhevsky &amp; Hinton, 2009)</ref> into 20 disjoint subsets, where each subset is constructed by randomly sampling 5 classes without replacement from a total of 100 classes. Similarly to Split CIFAR, Split CUB is an incremental version of the fine-grained image classification dataset CUB <ref type="bibr" target="#b26">(Wah et al., 2011)</ref> of 200 bird categories split into 20 disjoint subsets of classes. Split AWA, on the other hand, is the incremental version of the AWA dataset (Lampert et al., 2009) of 50 animal categories, where each task is constructed by sampling 5 classes with replacement from the total 50 classes, constructing 20 tasks. In this setting, classes may overlap among multiple tasks, but within each task they compete against different set of classes. Note that to make sure each training example is only seen once, the training data of a each class is split into disjoint sets depending on the frequency of its occurrence in different tasks. For Split AWA, the classifier weights of each class are randomly initialized within each head without any transfer from the previous occurrence of the class in past tasks. Finally, while on Permuted MNIST and Split CIFAR we provide integer task descriptors, on Split CUB and Split AWA we stack together the attributes of the classes (specifying for instance the type of beak, the color of feathers, etc.) belonging to the current task to form a descriptor.</p><p>In terms of architectures, we use a fully-connected network with two hidden layers of 256 ReLU units each for Permuted MNIST, a reduced ResNet18 for Split CIFAR like in <ref type="bibr" target="#b15">Lopez-Paz &amp; Ranzato (2017)</ref>, and a standard ResNet18 <ref type="bibr" target="#b8">(He et al., 2016)</ref> for Split CUB and Split AWA. For a given dataset stream, all models use the same architecture, and all models are optimized via stochastic gradient descent with mini-batch size equal to 10. We refer to the joint-embedding model version of these models by appending the suffix '-JE' to the method name.</p><p>As described in Sec. 2 and outlined in Alg. 1, in order to cross validate we use the first 3 tasks, and then report metrics on the remaining 17 tasks after doing a single training pass over each task in sequence.</p><p>Lastly, we compared A-GEM against several baselines and state-of-the-art LLL approaches which we describe next. VAN is a single supervised learning model, trained continually without any regularization, with the parameters of a new task initialized from the parameters of the previous task. ICARL <ref type="bibr" target="#b17">(Rebuffi et al., 2017</ref>) is a class-incremental learner that uses nearest-exemplar-based classifier and avoids catastrophic forgetting by regularizing over the feature representation of previous tasks using a knowledge distillation loss. EWC , whereby a new "column" with lateral connections to previous hidden layers is added once a new task arrives. GEM (Lopez-Paz &amp; Ranzato, 2017) described in Sec. 4 is another natural baseline of comparison since A-GEM builds upon it. The amount of episodic memory per task used in ICARL, GEM and A-GEM is set to 250, 65, 50, and 100, and the batch size for the computation of g ref (when the episodic memory is sufficiently filled) in A-GEM is set to 256, 1300, 128 and 128 for MNIST, CIFAR, CUB and AWA, respectively. While populating episodic memory, the samples are chosen uniformly at random for each task. Whereas the network weights are randomly initialized for MNIST, CIFAR and AWA, on the other hand, for CUB, due to the small dataset size, a pre-trained ImageNet model is used. Finally, we consider a multi-task baseline, MULTI-TASK, trained on a single pass over shuffled data from all tasks, and thus violating the LLL assumption. It can be seen as an upper bound performance for average accuracy.</p><p>6.1 RESULTS <ref type="figure">Fig. 1 and 2</ref> show the overall results on all the datasets we considered (for brevity we show only representative methods, see detailed results in Appendix Tab. 4, 5, 6 and 7). First, we observe that A-GEM achieves the best average accuracy on all datasets, except Permuted MNIST, where PROG-NN works better. The reason is because on this dataset each task has a large number of training examples, which enables PROG-NN to learn its task specific parameters and to leverage its lateral connections. However, notice how PROG-NN has the worst memory cost by the end of training -as its number of parameters grows super-linearly with the number of tasks. In particular, in large scale setups (Split CUB and AWA), PROG-NN runs out of memory during training due to its large size. Also, PROG-NN does not learn well on datasets where tasks have fewer training examples. Second, A-GEM and GEM perform comparably in terms of average accuracy, but A-GEM has much lower time (about 100 times faster) and memory cost (about 10 times lower), comparable to regularizationbased approaches like EWC. Third, EWC and similar methods perform only slightly better than VAN on this single pass LLL setting. The analysis in Appendix Sec. F demonstrates that EWC requires several epochs and over-parameterized architectures in order to work well. Fourth, PROG-NN has no forgetting by construction and A-GEM and GEM have the lowest forgetting among methods that use a fixed capacity architecture. Next, all methods perform similarly in terms of LCA, with PROG-NN being the worst because of its ever growing number of parameters and A-GEM slightly better than all the other approaches. And finally, the use of task descriptors improves average accuracy across the board as shown in <ref type="figure">Fig.2</ref>, with A-GEM a bit better than all the other methods we tried. All joint-embedding models using task descriptors have better LCA performance, although this is the same across all methods including A-GEM. Overall, we conclude that A-GEM offers the best trade-off between average accuracy performance and efficiency in terms of sample, memory and computational cost. different methods are best in terms of LCA, although A-GEM is always top-performing. <ref type="figure">Fig. 4</ref> shows in more detail the gain brought by task descriptors which greatly speed up learning in the few-shot regime. On these datasets, A-GEM performs the best or on par to the best.</p><p>Finally, in <ref type="figure">Fig. 5</ref>, we report the 0-shot performance of LLL methods on Split CUB and Split AWA datasets over time, showing a clear advantage of using compositional task descriptors with joint embedding models, which is more significant for A-GEM. Interestingly, the zero-shot learning performance of joint embedding models improves over time, indicating that these models get better at forward transfer or, in other words, become more efficient over time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">RELATED WORK</head><p>Continual <ref type="bibr" target="#b18">(Ring, 1997)</ref> or Lifelong Learning (LLL) <ref type="bibr" target="#b25">(Thrun, 1998)</ref> have been the subject of extensive study over the past two decades. One approach to LLL uses modular compositional models <ref type="bibr" target="#b6">(Fernando et al., 2017;</ref><ref type="bibr" target="#b0">Aljundi et al., 2017;</ref><ref type="bibr" target="#b19">Rosenbaum et al., 2018;</ref><ref type="bibr" target="#b3">Chang et al., 2018;</ref><ref type="bibr" target="#b28">Xu &amp; Zhu, 2018;</ref><ref type="bibr" target="#b7">Ferran Alet, 2018)</ref>, which limit interference among tasks by using different subset of modules for each task. Unfortunately, these methods require searching over the space of architectures which is not sample efficient with current methods. Another approach is to regularize parameters important to solve past tasks <ref type="bibr" target="#b29">Zenke et al., 2017;</ref><ref type="bibr" target="#b4">Chaudhry et al., 2018)</ref>, which has been proven effective for over-parameterized models in the multiple epoch setting (see Appendix Sec. F), while we focus on learning from few examples using memory efficient models. Methods based on episodic memory <ref type="bibr" target="#b17">(Rebuffi et al., 2017;</ref><ref type="bibr" target="#b15">Lopez-Paz &amp; Ranzato, 2017)</ref> require a little bit more memory at training time but can work much better in the single pass setting we considered <ref type="bibr" target="#b15">(Lopez-Paz &amp; Ranzato, 2017</ref>).</p><p>The use of task descriptors for LLL has already been advocated by <ref type="bibr" target="#b9">Isele et al. (2016)</ref> but using a sparse coding framework which is not obviously applicable to deep nets in a computationally efficient way, and also by <ref type="bibr" target="#b15">Lopez-Paz &amp; Ranzato (2017)</ref> although they did not explore the use of compositional descriptors. More generally, tasks descriptors have been used in Reinforcement Learning with similar motivations by several others <ref type="bibr" target="#b24">(Sutton et al., 2011;</ref><ref type="bibr" target="#b21">Schaul et al., 2015;</ref><ref type="bibr" target="#b2">Baroni et al., 2017)</ref>, and it is also a key ingredient in all the zero/few-shot learning algorithms <ref type="bibr" target="#b13">(Lampert et al., 2014;</ref><ref type="bibr" target="#b27">Xian et al., 2018;</ref><ref type="bibr" target="#b5">Elhoseiny et al., 2017;</ref><ref type="bibr" target="#b26">Wah et al., 2011;</ref><ref type="bibr" target="#b12">Lampert et al., 2009</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">CONCLUSION</head><p>We studied the problem of efficient Lifelong Learning (LLL) in the case where the learner can only do a single pass over the input data stream. We found that our approach, A-GEM, has the best tradeoff between average accuracy by the end of the learning experience and computational/memory cost. Compared to the original GEM algorithm, A-GEM is about 100 times faster and has 10 times less memory requirements; compared to regularization based approaches, it achieves significantly higher average accuracy. We also demonstrated that by using compositional task descriptors all methods can improve their few-shot performance, with A-GEM often being the best.</p><p>Our detailed experiments reported in Appendix E also show that there is still a substantial performance gap between LLL methods, including A-GEM, trained in a sequential learning setting and the same network trained in a non-sequential multi-task setting, despite seeing the same data samples. Moreover, while task descriptors do help in the few-shot learning regime, the LCA performance gap between different methods is very small; suggesting a poor ability of current methods to transfer knowledge even when forgetting has been eliminated. Addressing these two fundamental issues will be the focus of our future research.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>APPENDIX</head><p>In Sec. A we report the summary of datasets used for the experiments. Sec. B details our A-GEM algorithm and Sec. C provides the proof of update rule of A-GEM discussed in Sec. 4 of the main paper. In Sec. D, we analyze the differences between A-GEM and GEM, and describe another variation of GEM, dubbed Stochastic GEM (S-GEM). The detailed results of the experiments which were used to generate <ref type="figure">Fig 1 and 2</ref> in the main paper are given in Sec. E. In Sec. F, we provide empirical evidence to the conjecture that regularization-based approaches like EWC require over-parameterized architectures and multiple passes over data in order to perform well as discussed in the Sec. 6.1 of the main paper. In Sec. G, we provide the grid used for the cross-validation of different hyperparameters and report the optimal values for different models. Finally, in Sec. H, we pictorially describe the joint embedding model discussed in Sec. 5. A ? 0 ? R T ?T 4:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A DATASET STATISTICS</head><p>for t = {1, ? ? ? , T } do 5:</p><p>for (x, y) ? D train t do 6:</p><formula xml:id="formula_15">(x ref , y ref ) ? M 7: g ref ? ? ? (f ? (x ref , t), y ref ) 8: g ? ? ? (f ? (x, t), y) 9:</formula><p>if g g ref ? 0 then 10:g ? g 11: else 12:g ? g ? a ? 0 ? R T 3:</p><p>for t = {1, ? ? ? , T } do 4:</p><p>at ? 0 5:</p><p>for (x, y) ? D test t do 6:</p><p>at ? at + ACCURACY(f ? (x, t), y) 7: end for 8:</p><p>at ? a t len(D test t ) 9: end for 10:</p><p>return a 11: end procedure Proof. The optimization objective of A-GEM as described in the Eq. 10 of the main paper, is:</p><formula xml:id="formula_16">minimizeg 1 2 ||g ?g|| 2 2 s.t.g g ref ? 0</formula><p>(14) Replacingg with z and rewriting Eq. 14 yields:</p><formula xml:id="formula_17">minimize z 1 2 z z ? g z s.t. ? z g ref ? 0<label>(15)</label></formula><p>Note that we discard the term g g from the objective and change the sign of the inequality constraint. The Lagrangian of the constrained optimization problem defined above can be written as:</p><formula xml:id="formula_18">L(z, ?) = 1 2 z z ? g z ? ?z g ref<label>(16)</label></formula><p>Now, we pose the dual of Eq. 16 as:</p><formula xml:id="formula_19">? D (?) = min z L(z, ?)<label>(17)</label></formula><p>Lets find the value z * that minimizes the L(z, ?) by setting the derivatives of L(z, ?) w.r.t. to z to zero:</p><formula xml:id="formula_20">? z L(z, ?) = 0 z * = g + ?g ref<label>(18)</label></formula><p>The simplified dual after putting the value of z * in Eq. 17 can be written as:</p><formula xml:id="formula_21">? D (?) = 1 2 (g g + 2?g g ref + ? 2 g ref g ref ) ? g g ? 2?g g ref ? ? 2 g ref g ref = ? 1 2 g g ? ?g g ref ? 1 2 ? 2 g ref g ref</formula><p>The solution ? * = max ?;?&gt;0 ? D (?) to the dual is given by:</p><formula xml:id="formula_22">? ? ? D (?) = 0 ? * = ? g g ref g ref g ref</formula><p>By putting ? * in Eq. 18, we recover the A-GEM update rule:</p><formula xml:id="formula_23">z * = g ? g g ref g ref g ref g ref =g</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D ANALYSIS OF GEM AND A-GEM</head><p>In this section, we empirically analyze the differences between A-GEM and GEM, and report experiments with another computationally efficient but worse performing version of GEM. <ref type="figure" target="#fig_4">Fig. 6</ref> shows the frequency of constraint violations (see Eq. 8 and 10) on Permuted MNIST and Split CIFAR datasets. Note that, the number of gradient updates (training steps) per task on MNIST and CIFAR are 5500 and 250, respectively. As the number of tasks increase, GEM violates the optimization constraints at almost each training step, whereas A-GEM plateaus to a much lower value. Therefore, the computational efficiency of A-GEM not only stems from the fact that it avoids solving a QP at each training step (which is much more expensive than a simple inner product) but also from the fewer number of constraint violations. From the figure, we can also infer that as the number of tasks grows the gap between GEM and A-GEM would grow further. Thus, the computational and memory overhead of GEM over A-GEM, see also Tab. 7, gets worse as the number of tasks increases. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D.1 FREQUENCY OF CONSTRAINT VIOLATIONS</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D.2 AVERAGE ACCURACY AND WORST-CASE FORGETTING</head><p>In Tab. 2, we empirically demonstrate the different properties induced by the objective functions of GEM and A-GEM. GEM enjoys lower worst-case task forgetting while A-GEM enjoys better overall average accuracy. This is particularly true on the training examples stored in memory, as on the test set the result is confounded by the generalization error.  In this section we report experiments with another variant of GEM, dubbed Stochastic GEM (S-GEM). The main idea in S-GEM is to randomly sample one constraint, at each training step, from the possible t ? 1 constraints of GEM. If that constraint is violated, the gradient is projected only taking into account that constraint. Formally, the optimization objective of S-GEM is given by:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Methods</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>MNIST CIFAR</head><formula xml:id="formula_24">M D EV M D EV A T F wst A T F wst A T F wst A T F wst</formula><formula xml:id="formula_25">minimizeg 1 2 ||g ?g|| 2 2 s.t. g, g k ? 0 where k ? {1, ? ? ? , t ? 1}<label>(19)</label></formula><p>In other words, at each training step, S-GEM avoids the increase in loss of one of the previous tasks sampled randomly. In Tab. 3 we report the comparison of GEM, S-GEM and A-GEM on Permuted MNIST and Split CIFAR.</p><p>Although, S-GEM is closer in spirit to GEM, as it requires randomly sampling one of the GEM constraints to satisfy, compared to A-GEM, which defines the constraint as the average gradient of the previous tasks, it perform slightly worse than GEM, as can be seen from Tab. 3. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E RESULT TABLES</head><p>In Tab. 4, 5, 6 and 7 we report the detailed results which were used to generate <ref type="figure">Fig.1</ref> and 2.     In this section we provide empirical evidence to the conjecture that regularization-based approaches like EWC need over-parameterized architectures and multiple passes over the samples of each task in order to perform well. The intuition as to why models need to be over-parameterized is because it is easier to avoid cross-task interference when the model has additional capacity. In the single-pass setting and when each task does not have very many training samples, regularization-based appraches also suffer because regularization parameters cannot be estimated well from a model that has not fully converged. Moreover, for tasks that do not have much data, rgularization-based approaches do not enable any kind of positive backward transfer <ref type="bibr" target="#b15">(Lopez-Paz &amp; Ranzato, 2017)</ref> which further hurts performance as the predictor cannot leverage knowledge acquired later to improve its prediction on past tasks. Finally, regularization-based approaches perform much better in the multi-epoch setting simply because in this setting the baseline un-regularized model performs much worse, as it overfits much more to the data of the current task, every time unlearning what it learned before.</p><p>We consider Permuted MNIST and Split CIFAR datasets as described in Sec. 6 of the main paper. For MNIST, the two architecture variants that we experiment with are; 1) two-layer fully-connected network with 256 units in each layer (denoted by ?S suffix), and 2) two-layer fully-connected network with 2000 units in each layer (denoted by ?B suffix).</p><p>For CIFAR, the two architecture variants are; 1) ResNet-18 with 3 times less feature maps in all the layers (denoted by ?S suffix), and 2) Standard ResNet-18 (denoted by ?B token).</p><p>We run the experiments on <ref type="bibr">VAN</ref> and EWC with increasing the number of epochs from 1 to 10 for Permuted MNIST and from 1 to 30 for CIFAR. For instance, when epoch is set to 10, it means that the training samples of task t are presented 10 times before showing examples from task t + 1. In <ref type="figure">Fig. 7 and 8</ref> we plot the Average Accuracy (Eq. 1) and Forgetting (Eq. 2) on Permuted MNIST and Split CIFAR, respectively.</p><p>We observe that the average accuracy significantly improves with the number of epochs only when EWC is applied to the big network. In particular, in the single epoch setting, EWC peforms similarly to the baseline <ref type="bibr">VAN</ref>  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>G HYPER-PARAMETER SELECTION</head><p>Below we report the hyper-parameters grid considered for different experiments. Note, as described in the Sec. 6 of the main paper, to satisfy the requirement that a learner does not see the data of a task more than once, first T CV tasks are used to cross-validate the hyper-parameters. In all the datasets, the value of T CV is set to '3'. The best setting for each experiment is reported in the parenthesis. </p><formula xml:id="formula_26">x k t k C k ? A ? ? ( . ) P ? ? ( . ) A?D y k ? D ? C k ?D ? C k</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Image Embedding Attribute Embedding</head><p>Softmax Classifier Input = <ref type="figure">Figure 9</ref>: Pictorial description of the joint embedding model discussed in the Sec. 5 of the main paper. Modules; ? ? (.) and ? ? (.) are implemented as feed-forward neural networks with P and A ? D parameters, respectively. The descriptor of task k (t k ) is a matrix of dimensions C k ? A, shared among all the examples of the task, constructed by concatenating the A-dimensional class attribute vectors of C k classes in the task.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :Figure 2 :</head><label>12</label><figDesc>PI<ref type="bibr" target="#b29">(Zenke et al., 2017)</ref>,RWALK  <ref type="bibr" target="#b4">(Chaudhry et al., 2018)</ref> andMAS  <ref type="bibr" target="#b1">(Aljundi et al., 2018)</ref> are regularization-based approaches aiming at avoiding catastrophic forgetting by limiting learning of parameters critical to the performance of past tasks. Progressive Networks (PROG-NN) (Rusu et al., 2016) is a modular approach AT (?) Performance of LLL models across different measures on Permuted MNIST and Split CIFAR. For Accuracy (A T ) and Learning Curve Measure (LCA 10 ) the higher the number (indicated by ?) the better is the model. For Forgetting (F T ), Time and Memory the lower the number (indicated by ?) the better is the model. For Time and Memory, the method with the highest complexity is taken as a reference (value of 1) and the other methods are reported relative to that method. A T , F T and LCA 10 values and confidence intervals are computed over 5 runs. A-GEM provides the best trade-off across different measures and dimensions. Other baselines are given in Tab. 4 and 7 in the Appendix, which are used to generate the plots. Performance of LLL models across different measures on Split CUB and Split AWA. On both the datasets, PROG-NN runs out of memory. The memory and time complexities of joint embedding models are the same as those of the corresponding standard models and are hence omitted. A T , F T and LCA 10 values and confidence intervals are computed over 10 runs. Other baselines are given in Tab. 5, 6 and 7 in the Appendix, which are used to generate the plots.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 :Figure 4 :</head><label>34</label><figDesc>Top Row: Evolution of average accuracy (A k ) as new tasks are learned. Bottom Row: Evolution of LCA during the first ten mini-batches. Evolution of LCA during the first ten mini-batches.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 3 Figure 5 :</head><label>35</label><figDesc>shows a more fine-grained analysis and comparison with more methods on Permuted MNIST and Split CIFAR. The average accuracy plots show how A-GEM and GEM greatly outperform other approaches, with the exception of PROG-NN on MNIST as discussed above. On different datasets, Evolution of zero-shot performance as the learner sees new tasks on Split CUB and Split AWA datasets.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>procedure C A-GEM UPDATE RULE Here we provide the proof of the update rule of A-GEM (Eq. 11),g = g ? g g ref g ref g ref g ref , stated in Sec. 4 of the main paper.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 6 :</head><label>6</label><figDesc>Number of constraint violations in GEM and A-GEM on Permuted MNIST and Split CIFAR as new tasks are learned.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 7 :Figure 8 :</head><label>78</label><figDesc>on Split CIFAR which has fewer number of training examples per task. Permuted MNIST: Change in average accuracy and forgetting as the number of epochs are increased. Tokens '-S' and '-B' denote smaller and bigger networks, respectively. Split CIFAR: Change in average accuracy and forgetting as the number of epochs are increased. Tokens '-S' and '-B' denote smaller and bigger networks, respectively.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>1: for h in hyper-parameter list doCross-validation loop, executing multiple passes over D CV 2:for k = 1 to T CV do Learn over data stream D CV using h 3:for i = 1 to n k do Select best hyper-parameter setting, h * , based on average accuracy of test set of D CV , see Eq. 1. Report metrics on test set of D EV .</figDesc><table><row><cell>4:</cell><cell>Update f ? using (x k i , t k i , y k i ) and hyper-parameter h</cell><cell>Single pass over D k</cell></row><row><cell>5:</cell><cell>Update metrics on test set of D CV</cell><cell></cell></row><row><cell>6:</cell><cell>end for</cell><cell></cell></row><row><cell>7:</cell><cell>end for</cell><cell></cell></row><row><cell cols="2">8: end for</cell><cell></cell></row><row><cell cols="2">9: 10: Reset f ? .</cell><cell></cell></row><row><cell cols="2">11: Reset all metrics.</cell><cell></cell></row><row><cell cols="2">12: for k = T CV + 1 to T do</cell><cell>Actual learning over datastream D EV</cell></row><row><cell>13: 14:</cell><cell>for i = 1 to n k do Update f ? using (x k i , t k i , y k i ) and hyper-parameter h  *</cell><cell>Single pass over D k</cell></row><row><cell>15:</cell><cell>Update metrics on test set of D EV</cell><cell></cell></row><row><cell>16:</cell><cell>end for</cell><cell></cell></row><row><cell cols="2">17: end for</cell><cell></cell></row><row><cell>18:</cell><cell></cell><cell></cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 :</head><label>1</label><figDesc>Dataset statistics. Training and evaluation of A-GEM on sequential data D = {D 1 , ? ? ? , D T }</figDesc><table><row><cell></cell><cell cols="3">Perm. MNIST Split CIFAR</cell><cell>Split CUB</cell><cell>Split AWA</cell></row><row><cell></cell><cell>num. of tasks</cell><cell>20</cell><cell>20</cell><cell>20</cell><cell>20</cell></row><row><cell></cell><cell>input size</cell><cell>1?28?28</cell><cell>3?32?32</cell><cell cols="2">3?224?224 3?224?224</cell></row><row><cell></cell><cell>num. of classes per task</cell><cell>10</cell><cell>5</cell><cell>10</cell><cell>5</cell></row><row><cell></cell><cell>num. of training images per task</cell><cell>60000</cell><cell>2500</cell><cell>300</cell><cell>-</cell></row><row><cell></cell><cell>num. of test images per task</cell><cell>10000</cell><cell>500</cell><cell>290</cell><cell>560</cell></row><row><cell cols="2">B A-GEM ALGORITHM</cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="2">Algorithm 2 test )</cell><cell></cell><cell></cell><cell></cell></row><row><cell>2:</cell><cell>M ? {}</cell><cell></cell><cell></cell><cell></cell></row><row><cell>3:</cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table><note>1: procedure TRAIN(f ? , D train , D</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 2 :</head><label>2</label><figDesc>Comparison of average accuracy (A T ) and worst-case forgetting (F wst ) on the Episodic Memory (M) and Test Set (D EV ).</figDesc><table /><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 3 :</head><label>3</label><figDesc>Comparison of different variations of GEM on MNIST Permutations and Split CIFAR.</figDesc><table><row><cell cols="3">Methods Permuted MNIST</cell><cell cols="2">Split CIFAR</cell></row><row><cell></cell><cell>AT (%)</cell><cell>FT</cell><cell>AT (%)</cell><cell>FT</cell></row><row><cell>GEM</cell><cell>89.5</cell><cell>0.06</cell><cell>61.2</cell><cell>0.06</cell></row><row><cell>S-GEM</cell><cell>88.2</cell><cell>0.08</cell><cell>56.2</cell><cell>0.12</cell></row><row><cell>A-GEM</cell><cell>89.1</cell><cell>0.06</cell><cell>62.3</cell><cell>0.07</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 4 :</head><label>4</label><figDesc>Comparison with different baselines on Permuted MNIST and Split CIFAR. The value of ? is assigned to a metric when the model fails to train with the cross-validated values of hyperparameters found on the subset of the tasks as discussed in Sec. 2 of the main paper. The numbers are averaged across 5 runs using a different seed each time. The results from this table are used to generate Fig 1 in Sec. 6.1 of the main paper.</figDesc><table><row><cell>Methods</cell><cell></cell><cell>Permuted MNIST</cell><cell></cell><cell></cell><cell>Split CIFAR</cell><cell></cell></row><row><cell></cell><cell>AT (%)</cell><cell>FT</cell><cell>LCA10</cell><cell>AT (%)</cell><cell>FT</cell><cell>LCA10</cell></row><row><cell>VAN</cell><cell>47.9 (? 1.32)</cell><cell>0.51 (? 0.01)</cell><cell>0.26 (? 0.006)</cell><cell>42.9 (? 2.07)</cell><cell>0.25 (? 0.03)</cell><cell>0.30 (? 0.008)</cell></row><row><cell>ICARL</cell><cell>-</cell><cell>-</cell><cell>-</cell><cell>50.1</cell><cell>0.11</cell><cell>-</cell></row><row><cell>EWC</cell><cell>68.3 (? 0.69)</cell><cell>0.29 (? 0.01)</cell><cell cols="2">0.27 (? 0.003) 42.4 (? 3.02 )</cell><cell>0.26 (? 0.02)</cell><cell>0.33 (? 0.01)</cell></row><row><cell>PI</cell><cell>?</cell><cell>?</cell><cell>?</cell><cell>47.1 (? 4.41)</cell><cell>0.17 (? 0.04)</cell><cell>0.31 (? 0.008)</cell></row><row><cell>MAS</cell><cell>69.6 (? 0.93)</cell><cell>0.27 (? 0.01)</cell><cell>0.29 (? 0.003)</cell><cell>44.2 (? 2.39)</cell><cell>0.25 (? 0.02)</cell><cell>0.33 (? 0.009)</cell></row><row><cell>RWALK</cell><cell>85.7 (? 0.56)</cell><cell>0.08 (? 0.01)</cell><cell>0.31 (? 0.005)</cell><cell>40.9 (? 3.97)</cell><cell>0.29 (? 0.04)</cell><cell>0.32 (? 0.005)</cell></row><row><cell>PROG-NN</cell><cell>93.5 (? 0.07)</cell><cell>0</cell><cell>0.19 (? 0.006)</cell><cell>59.2 (? 0.85)</cell><cell>0</cell><cell>0.21 (? 0.001)</cell></row><row><cell>GEM</cell><cell cols="3">89.5 (? 0.48) 0.06 (? 0.004) 0.23 (? 0.005)</cell><cell cols="3">61.2 (? 0.78) 0.06 (? 0.007) 0.36 (? 0.007)</cell></row><row><cell cols="4">A-GEM (Ours) 89.1 (? 0.14) 0.06 (? 0.001) 0.29 (? 0.004)</cell><cell>62.3 (? 1.24)</cell><cell>0.07 (? 0.01)</cell><cell>0.35 (? 0.01)</cell></row><row><cell>MULTI-TASK</cell><cell>95.3</cell><cell>-</cell><cell>-</cell><cell>68.3</cell><cell>-</cell><cell>-</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>Table 5 :</head><label>5</label><figDesc>Average accuracy and forgetting of standard models (left) and joint embedding models (right) on Split CUB. The value of 'OoM' is assigned to a metric when the model fails to fit in the memory. The numbers are averaged across 10 runs using a different seed each time. The results from this table are used to generate Fig 2 in Sec. 6.1 of the main paper.</figDesc><table><row><cell>Methods</cell><cell></cell><cell>Split CUB</cell><cell></cell></row><row><cell></cell><cell>AT (%)</cell><cell>FT</cell><cell>LCA10</cell></row><row><cell>VAN</cell><cell cols="3">54.3 (? 2.03) / 67.1 (? 4.77) 0.13 (? 0.02)/ 0.10 (? 0.04) 0.29 (? 0.009) / 0.52 (? 0.01)</cell></row><row><cell>EWC</cell><cell>54 (? 1.08) / 68.4 (? 4.08)</cell><cell cols="2">0.13 (? 0.02) / 0.09 (? 0.03) 0.29 (? 0.007) / 0.52 (? 0.01)</cell></row><row><cell>PI</cell><cell cols="3">55.3 (? 2.28) / 66.6 (? 5.18) 0.12 (? 0.02)/ 0.10 (? 0.04) 0.29 (? 0.008) / 0.52 (? 0.01)</cell></row><row><cell>RWALK</cell><cell cols="3">54.4 (? 1.82) / 67.4 (? 3.50) 0.13 (? 0.01) / 0.10 (? 0.03) 0.29 (? 0.008) / 0.52 (? 0.01)</cell></row><row><cell>PROG-NN</cell><cell>OoM / OoM</cell><cell>OoM / OoM</cell><cell>OoM / OoM</cell></row><row><cell>A-GEM (Ours)</cell><cell>62 (? 3.5) / 71 (? 2.83)</cell><cell cols="2">0.07 (? 0.02) / 0.07 (? 0.01) 0.30 (? 0.008) / 0.54 (? 0.02)</cell></row><row><cell>MULTI-TASK</cell><cell>65.6 / 73.8</cell><cell>-/ -</cell><cell>-/ -</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head>Table 6 :</head><label>6</label><figDesc>Average accuracy and forgetting of standard models (left) and joint embedding models (right) on Split AWA. The value of 'OoM' is assigned to a metric when the model fails to fit in the memory. The numbers are averaged across 10 runs using a different seed each time. The results from this table are used to generateFig 2 inSec. 6.1 of the main paper.</figDesc><table><row><cell>Methods</cell><cell></cell><cell>Split AWA</cell><cell></cell></row><row><cell></cell><cell>AT (%)</cell><cell>FT</cell><cell>LCA10</cell></row><row><cell>VAN</cell><cell cols="3">30.3 (? 2.84) / 42.8 (? 2.86) 0.04 (? 0.01) / 0.07 (? 0.02) 0.21 (? 0.008) / 0.37 (? 0.02)</cell></row><row><cell>EWC</cell><cell cols="2">33.9 (? 2.87) / 43.3 (? 3.71) 0.08 (? 0.02) / 0.07 (? 0.03)</cell><cell>0.26 (? 0.01) / 0.37 (? 0.02)</cell></row><row><cell>PI</cell><cell cols="2">33.9 (? 3.25) / 43.4 (? 3.49) 0.08 (? 0.02) / 0.06 (? 0.02)</cell><cell>0.26 (? 0.01) / 0.37 (? 0.02)</cell></row><row><cell>RWALK</cell><cell cols="2">33.9 (? 2.91) / 42.9 (? 3.10) 0.08 (? 0.02) / 0.07 (? 0.02)</cell><cell>0.26 (? 0.01) / 0.37 (? 0.02)</cell></row><row><cell>PROG-NN</cell><cell>OoM / OoM</cell><cell>OoM / OoM</cell><cell>OoM / OoM</cell></row><row><cell>A-GEM (Ours)</cell><cell>44 (? 4.10) / 50 (? 3.25)</cell><cell>0.05 (? 0.02) / 0.03 (? 0.02)</cell><cell>0.29 (? 0.01) / 0.39 (? 0.02)</cell></row><row><cell>MULTI-TASK</cell><cell>64.8 / 66.8</cell><cell>-/ -</cell><cell>-/ -</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head>Table 7 :</head><label>7</label><figDesc>Computational cost and memory complexity of different LLL approaches. The timing refers to training time on a GPU device. Memory cost is provided in terms of the total number of parameters P, the size of the minibatch B, the total size of the network hidden state H (assuming all methods use the same architecture), the size of the episodic memory M per task. The results from this table are used to generateFig. 1 and 2in Sec. 6.1 of the main paper.</figDesc><table><row><cell>Methods</cell><cell></cell><cell cols="2">Training Time [s]</cell><cell></cell><cell>Memory</cell><cell></cell></row><row><cell></cell><cell cols="4">MNIST CIFAR CUB AWA</cell><cell>Training</cell><cell>Testing</cell></row><row><cell>VAN</cell><cell>186</cell><cell>105</cell><cell>54</cell><cell>4123</cell><cell>P + B*H</cell><cell>P + B*H</cell></row><row><cell>EWC</cell><cell>403</cell><cell>250</cell><cell>72</cell><cell>4136</cell><cell>4*P + B*H</cell><cell>P + B*H</cell></row><row><cell>PROGRESSIVE NETS</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9"><head></head><label></label><figDesc>? MULTI-TASK learning rate: [0.3, 0.1, 0.03 (MNIST perm, Split CIFAR, Split CUB, Split AWA), 0.01, 0.003, 0.001, 0.0003, 0.0001] ? MULTI-TASK-JE learning rate: [0.3, 0.1, 0.03 (Split CUB, Split AWA), 0.01, 0.003, 0.001, 0.0003, 0.0001] ? VAN learning rate: [0.3, 0.1, 0.03 (MNIST perm, Split CUB), 0.01 (Split CIFAR), 0.003, 0.001 (Split AWA), 0.0003, 0.0001] ? VAN-JE learning rate: [0.3, 0.1, 0.03 (Split CUB), 0.01, 0.003 (Split AWA), 0.001, 0.0003, 0.0001] ? PROG-NN learning rate: [0.3, 0.1 (MNIST perm, ), 0.03 (Split CIFAR, Split AWA), 0.01 (Split CUB), 0.003, 0.001, 0.0003, 0.0001] ? EWC learning rate: [0.3, 0.1, 0.03 (MNIST perm, Split CIFAR, Split CUB), 0.01, 0.003 (Split AWA), 0.001, 0.0003, 0.0001] (x k , t k , y k )</figDesc><table /><note></note></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Expert gate: Lifelong learning with a network of experts</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rahaf</forename><surname>Aljundi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Punarjay</forename><surname>Chakravarty</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tinne</forename><surname>Tuytelaars</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CVPR</title>
		<imprint>
			<date type="published" when="2017" />
			<biblScope unit="page" from="7120" to="7129" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Memory aware synapses: Learning what (not) to forget</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rahaf</forename><surname>Aljundi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Francesca</forename><surname>Babiloni</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mohamed</forename><surname>Elhoseiny</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marcus</forename><surname>Rohrbach</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tinne</forename><surname>Tuytelaars</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In ECCV</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marco</forename><surname>Baroni</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Armand</forename><surname>Joulin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Allan</forename><surname>Jabri</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Germ?n</forename><surname>Kruszewski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Angeliki</forename><surname>Lazaridou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Klemen</forename><surname>Simonic</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tomas</forename><surname>Mikolov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Commai</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1701.08954</idno>
		<title level="m">Evaluating the first steps towards a useful general ai</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Automatically composing representation transformations as a means for generalization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Abhishek</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sergey</forename><surname>Levine</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><forename type="middle">L</forename><surname>Griffiths</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICML workshop Neural Abstract Machines and Program Induction v2</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Riemannian walk for incremental learning: Understanding forgetting and intransigence</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Arslan</forename><surname>Chaudhry</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Puneet</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thalaiyasingam</forename><surname>Dokania</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Philip Hs</forename><surname>Ajanthan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Torr</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ECCV</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Write a classifier: Predicting visual classifiers from unstructured text</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mohamed</forename><surname>Elhoseiny</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ahmed</forename><surname>Elgammal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Babak</forename><surname>Saleh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE TPAMI</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="2539" to="2553" />
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chrisantha</forename><surname>Fernando</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dylan</forename><surname>Banarse</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Charles</forename><surname>Blundell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yori</forename><surname>Zwols</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Ha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrei</forename><forename type="middle">A</forename><surname>Rusu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alexander</forename><surname>Pritzel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daan</forename><surname>Wierstra</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Pathnet</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1701.08734</idno>
		<title level="m">Evolution channels gradient descent in super neural networks</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Leslie</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tomas</forename><surname>Kaelbling Ferran Alet</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Lozano-Perez</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1806.10166v1</idno>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
	<note type="report_type">Modular meta-learning. arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Deep residual learning for image recognition</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kaiming</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xiangyu</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shaoqing</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jian</forename><surname>Sun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CVPR</title>
		<imprint>
			<date type="published" when="2016" />
			<biblScope unit="page" from="770" to="778" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Using task features for zero-shot knowledge transfer in lifelong learning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Isele</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mohammad</forename><surname>Rostami</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eric</forename><surname>Eaton</surname></persName>
		</author>
		<idno>978-1-57735-770- 4</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-Fifth International Joint Conference on Artificial Intelligence, IJCAI&apos;16</title>
		<meeting>the Twenty-Fifth International Joint Conference on Artificial Intelligence, IJCAI&apos;16</meeting>
		<imprint>
			<publisher>AAAI Press</publisher>
			<date type="published" when="2016" />
			<biblScope unit="page" from="1620" to="1626" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Agnieszka Grabska-Barwinska, Demis Hassabis, Claudia Clopath, Dharshan Kumaran, and Raia Hadsell. Overcoming catastrophic forgetting in neural networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><surname>Kirkpatrick</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Razvan</forename><surname>Pascanu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Neil</forename><forename type="middle">C</forename><surname>Rabinowitz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joel</forename><surname>Veness</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Guillaume</forename><surname>Desjardins</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrei</forename><forename type="middle">A</forename><surname>Rusu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kieran</forename><surname>Milan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><surname>Quan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tiago</forename><surname>Ramalho</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2016" />
			<publisher>PNAS</publisher>
		</imprint>
		<respStmt>
			<orgName>Proceedings of the National Academy of Sciences of the United States of America</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Learning multiple layers of features from tiny images</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alex</forename><surname>Krizhevsky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Geoffrey</forename><surname>Hinton</surname></persName>
		</author>
		<ptr target="https://www.cs.toronto.edu/kriz/cifar.html" />
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Learning to detect unseen object classes by between-class attribute transfer</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Christoph</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hannes</forename><surname>Lampert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stefan</forename><surname>Nickisch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Harmeling</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Vision and Pattern Recognition</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2009" />
			<biblScope unit="page" from="951" to="958" />
		</imprint>
	</monogr>
	<note>CVPR 2009. IEEE Conference on</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Attribute-based classification for zero-shot visual object categorization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Christoph</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hannes</forename><surname>Lampert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stefan</forename><surname>Nickisch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Harmeling</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Pattern Analysis and Machine Intelligence</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="453" to="465" />
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">The mnist database of handwritten digits</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yann</forename><surname>Lecun</surname></persName>
		</author>
		<ptr target="http://yann.lecun.com/exdb/mnist/" />
		<imprint>
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Gradient episodic memory for continuum learning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Lopez</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">-</forename><surname>Paz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marc&amp;apos;aurelio</forename><surname>Ranzato</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NIPS</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yingzhen</forename><surname>Cuong V Nguyen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Thang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Richard</forename><forename type="middle">E</forename><surname>Bui</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Turner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Variational continual learning. ICLR</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">iCaRL: Incremental classifier and representation learning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S-V</forename><surname>Rebuffi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Kolesnikov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">H</forename><surname>Lampert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CVPR</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Child: A first step towards continual learning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Mark</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Ring</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Machine Learning</title>
		<imprint>
			<date type="published" when="1997" />
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="77" to="104" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Routing networks: Adaptive selection of non-linear functions for multi-task learning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Clemens</forename><surname>Rosenbaum</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tim</forename><surname>Klinger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Matthew</forename><surname>Riemer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Learning Representations</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Andrei</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Rusu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Neil</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Guillaume</forename><surname>Rabinowitz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hubert</forename><surname>Desjardins</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><surname>Soyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Koray</forename><surname>Kirkpatrick</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Kavukcuoglu</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1606.04671</idno>
		<title level="m">Razvan Pascanu, and Raia Hadsell. Progressive neural networks</title>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">Universal value function approximators</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Schaul</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Horgan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Gregor</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Silver</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Progress and compress: A scalable framework for continual learning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jonathan</forename><surname>Schwarz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jelena</forename><surname>Luketina</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wojciech</forename><forename type="middle">M</forename><surname>Czarnecki</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Agnieszka</forename><surname>Grabska-Barwinska</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yee</forename><forename type="middle">Whye</forename><surname>Teh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Razvan</forename><surname>Pascanu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Raia</forename><surname>Hadsell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference in Machine Learning</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Continual learning with deep generative replay</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hanul</forename><surname>Shin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jaehong</forename><surname>Jung Kwon Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jiwon</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Kim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NIPS</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Horde: A scalable real-time architecture for learning knowledge from unsupervised sensorimotor interaction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">S</forename><surname>Sutton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Modayil</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Delp</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Degris</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">M</forename><surname>Pilarski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>White</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Precup</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The 10th International Conference on Autonomous Agents and Multiagent Systems</title>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Lifelong learning algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sebastian</forename><surname>Thrun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Learning to learn</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1998" />
			<biblScope unit="page" from="181" to="209" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">The caltech-ucsd birds-200-2011 dataset</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Wah</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Branson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Welinder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Perona</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Belongie</surname></persName>
		</author>
		<idno>CNS-TR-2011-001</idno>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
		<respStmt>
			<orgName>California Institute of Technology</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Zero-shot learning-a comprehensive evaluation of the good, the bad and the ugly</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yongqin</forename><surname>Xian</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Christoph</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bernt</forename><surname>Lampert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zeynep</forename><surname>Schiele</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Akata</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE transactions</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">Reinforced continual learning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ju</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhanxing</forename><surname>Zhu</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1805.12369v1</idno>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
	<note type="report_type">In arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Continual learning through synaptic intelligence</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Zenke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Poole</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Ganguli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICML</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ji</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yannis</forename><surname>Kalantidis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marcus</forename><surname>Rohrbach</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Manohar</forename><surname>Paluri</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1804.10660</idno>
		<title level="m">Ahmed Elgammal, and Mohamed Elhoseiny. Large-scale visual relationship understanding</title>
		<meeting><address><addrLine>Split AWA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2018" />
			<biblScope unit="page">10000</biblScope>
		</imprint>
		<respStmt>
			<orgName>MNIST perm, Split CIFAR</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">arXiv preprint</note>
	<note>regularization: [1 (Split CUB</note>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">1000, 10000] ? PI -learning rate</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">? Ewc-Je -Learning</forename><surname>Rate</surname></persName>
		</author>
		<idno>0.01, 0.003</idno>
	</analytic>
	<monogr>
		<title level="j">Split CIFAR, Split CUB)</title>
		<imprint>
			<biblScope unit="page">10</biblScope>
		</imprint>
	</monogr>
	<note>0.3, 0.1, 0.03 (Split CUB. Split AWA), 0.001, 0.0003, 0.0001] -regularization: [1, 10 (Split CUB. 0.3, 0.1 (MNIST perm), 0.03 (Split CUB), 0.01 (Split CIFAR), 0.003 (Split AWA), 0.001, 0.0003, 0.0001] -regularization: [0.001, 0.01, 0.1 (MNIST perm</note>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">? Pi-Je -Learning</forename><surname>Rate</surname></persName>
		</author>
		<idno>0.01, 0.003</idno>
		<imprint>
			<biblScope unit="volume">1</biblScope>
		</imprint>
	</monogr>
	<note>0.3, 0.1, 0.03 (Split CUB. Split AWA), 0.001, 0.0003, 0.0001] -regularization: [0.001, 0.01, 0.1 (Split CUB. Split AWA)</note>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">?</forename><surname>Mas -Learning Rate</surname></persName>
			<affiliation>
				<orgName type="collaboration">Split CIFAR</orgName>
			</affiliation>
		</author>
		<idno>0.01, 0.003</idno>
	</analytic>
	<monogr>
		<title level="j">Split CIFAR, Split CUB)</title>
		<imprint>
			<biblScope unit="page">10</biblScope>
		</imprint>
	</monogr>
	<note>0.3, 0.1 (MNIST perm. Split CUB. Split AWA), 0.001, 0.0003, 0.0001] -regularization: [0.01, 0.1 (MNIST perm</note>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Split AWA), 1, 10] ? RWALK -learning rate</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">? Mas-Je -Learning</forename><surname>Rate</surname></persName>
		</author>
		<idno>0.01, 0.003, 0.001</idno>
	</analytic>
	<monogr>
		<title level="j">Split CIFAR, Split CUB)</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
		</imprint>
	</monogr>
	<note>0.3, 0.1, 0.03 (Split CUB. Split AWA), 0.0003, 0.0001] -regularization: [0.01, 0.1 (Split CUB. 0.3, 0.1 (MNIST perm), 0.03 (Split CIFAR, Split CUB), 0.01, 0.003 (Split AWA), 0.001, 0.0003, 0.0001] -regularization: [0.1, 1 (MNIST perm. Split AWA), 100, 1000</note>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">? Rwalk-Je -Learning</forename><surname>Rate</surname></persName>
		</author>
		<idno>0.01, 0.003</idno>
		<imprint>
			<biblScope unit="page">1000</biblScope>
			<pubPlace>Split AWA</pubPlace>
		</imprint>
	</monogr>
	<note>0.3, 0.1, 0.03 (SPLIT CUB. Split AWA), 0.001, 0.0003, 0.0001] -regularization: [0.1, 1 (Split CUB</note>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">? A-Gem -Learning</forename><surname>Rate</surname></persName>
			<affiliation>
				<orgName type="collaboration">Split CIFAR</orgName>
			</affiliation>
		</author>
		<idno>0.03</idno>
		<imprint/>
	</monogr>
	<note>0.3, 0.1 (MNIST perm. Split CUB), 0.01 (Split AWA), 0.003, 0.001, 0.0003, 0.0001</note>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">? A-Gem-Je -Learning</forename><surname>Rate</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>0.3, 0.1, 0.03 (SPLIT CUB), 0.01, 0.003 (Split AWA), 0.001, 0.0003, 0.0001</note>
</biblStruct>

<biblStruct xml:id="b38">
	<monogr>
		<title level="m" type="main">9 we provide a pictorial description of the joint embedding model discussed in the Sec. 5 of the main paper</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Pictorial</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Of</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Embedding Model In</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Fig</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
