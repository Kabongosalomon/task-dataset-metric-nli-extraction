<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /nfs/home/kabenamualus/Research/task-dataset-metric-extraction/../grobid-0.6.0/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">UnICORNN: A recurrent model for learning very long time dependencies</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">Konstantin</forename><surname>Rusch</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Siddhartha</forename><surname>Mishra</surname></persName>
						</author>
						<title level="a" type="main">UnICORNN: A recurrent model for learning very long time dependencies</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>

		<encodingDesc>
			<appInfo>
				<application version="0.6.0" ident="GROBID-SDO" when="2022-11-11T21:02+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid-sdo"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The design of recurrent neural networks (RNNs) to accurately process sequential inputs with longtime dependencies is very challenging on account of the exploding and vanishing gradient problem. To overcome this, we propose a novel RNN architecture which is based on a structure preserving discretization of a Hamiltonian system of secondorder ordinary differential equations that models networks of oscillators. The resulting RNN is fast, invertible (in time), memory efficient and we derive rigorous bounds on the hidden state gradients to prove the mitigation of the exploding and vanishing gradient problem. A suite of experiments are presented to demonstrate that the proposed RNN provides state of the art performance on a variety of learning tasks with (very) long-time dependencies.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Recurrent Neural Networks (RNNs) have been very successful in solving a diverse set of learning tasks involving sequential inputs <ref type="bibr">(LeCun et al., 2015)</ref>. These include text and speech recognition, time-series analysis and natural language processing. However, the well-known Exploding and Vanishing Gradient Problem (EVGP) <ref type="bibr">(Pascanu et al., 2013)</ref> and references therein, impedes the efficiency of RNNs on tasks that require processing (very) long sequential inputs. The EVGP arises from the fact that the backpropagation through time (BPTT) algorithm for training RNNs entails computing products of hidden state gradients over a large number of steps and this product can either be exponentially small or large as the number of recurrent interactions increases.</p><p>Different approaches to solve the EVGP has been suggested in recent years. These include the use of gating mechanisms, 1 Seminar for Applied Mathematics (SAM), D-MATH, ETH Z?rich, R?mistrasse 101, Z?rich-8092, Switzerland.</p><p>Correspondence to: T. Konstantin Rusch &lt;konstantin.rusch@sam.math.ethz.ch&gt;.</p><p>Proceedings of the 38 th International Conference on Machine Learning, PMLR 139, 2021. Copyright 2021 by the author(s). such as in LSTMs <ref type="bibr" target="#b19">(Hochreiter &amp; Schmidhuber, 1997)</ref> and GRUs <ref type="bibr" target="#b8">(Cho et al., 2014)</ref>, where the additive structure of the gates mitigates the vanishing gradient problem. However, gradients might still explode, impeding the efficiency of LSTMs and GRUs on problems with very long time dependencies (LTDs) <ref type="bibr">(Li et al., 2018)</ref>. The EVGP can also be mitigated by constraining the structure of the recurrent weight matrices, for instance requiring them to be orthogonal or unitary <ref type="bibr" target="#b18">(Henaff et al., 2016;</ref><ref type="bibr" target="#b1">Arjovsky et al., 2016;</ref><ref type="bibr">Wisdom et al., 2016;</ref><ref type="bibr" target="#b21">Kerg et al., 2019)</ref>. Constraining recurrent weight matrices may lead to a loss of expressivity of the resulting RNN, reducing its efficiency in handling realistic learning tasks <ref type="bibr" target="#b21">(Kerg et al., 2019)</ref>. Finally, restricting weights of the RNN to lie within some prespecified bounds might lead to control over the norms of the recurrent weight matrices and alleviate the EVGP. Such an approach has been suggested in the context of independent neurons in each layer in <ref type="bibr">(Li et al., 2018)</ref>, and using a coupled system of damped oscillators in <ref type="bibr">(Rusch &amp; Mishra, 2021)</ref>, among others. However, ensuring that weights remain within a pre-defined range during training might be difficult. Furthermore, weight clipping could also reduce expressivity of the resulting RNN.</p><p>In addition to EVGP, the learning of sequential tasks with very long time dependencies can require significant computational resources, for training and evaluating the RNN. Moreover, as the BPTT training algorithms entail storing all hidden states at every time step, the overall memory requirements can be prohibitive. Thus, the design of a fast and memory efficient RNN architecture that can mitigate the EVGP is highly desirable for the effective use of RNNs in realistic learning tasks with very long time dependencies. The main objective of this article is to propose, analyze and test such an architecture.</p><p>The basis of our proposed RNN is the observation that a large class of dynamical systems in physics and engineering, the so-called Hamiltonian systems <ref type="bibr" target="#b2">(Arnold, 1989)</ref>, allow for very precise control on the underlying states. Moreover, the fact that the phase space volume is preserved by the trajectories of a Hamiltonian system, makes such systems invertible and allows one to significantly reduce the storage requirements. Furthermore, if the resulting hidden state gradients also evolve according to a Hamiltonian dynamical system, one can obtain precise bounds on the hidden state arXiv:2103.05487v2 <ref type="bibr">[cs.</ref>LG] 10 Jun 2021 gradients and alleviate the EVGP. We combine and extend these ideas into an RNN architecture that will allow us to prove rigorous bounds on the hidden states and their gradients, mitigating the EVGP. Moreover, our RNN architecture results in a fast implementation that attains state of the art performance on a variety of learning tasks with very long time dependencies.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">The proposed RNN</head><p>Our proposed RNN is based on the time-discretization of the following system of second-order ordinary differential equations (ODEs),</p><formula xml:id="formula_0">y = ?[? (w y + Vu + b) + ?y].</formula><p>(1)</p><p>Here, t ? [0, 1] is the (continuous) time variable, u = u(t) ? R d is the time-dependent input signal, y = y(t) ? R m is the hidden state of the RNN with w ? R m is a weight vector, V ? R m?d a weight matrix, b ? R m is the bias vector and ? ? 0 is a control parameter. The operation is the Hadamard product and the function ? : R ? R is the activation function and is applied component wise. For the rest of this paper, we set ?(u) = tanh(u).</p><p>By introducing the auxiliary variable z = y , we can rewrite the second order ODE (1) as a first order ODE system:</p><formula xml:id="formula_1">y = z, z = ?[? (w y + Vu + b) + ?y].<label>(2)</label></formula><p>Assuming that w i = 0, for all 1 ? i ? m, it is easy to see that the ODE system (2) is a Hamiltonian system,</p><formula xml:id="formula_2">y = ?H ?z , z = ? ?H ?y ,<label>(3)</label></formula><p>with the time-dependent Hamiltonian,</p><formula xml:id="formula_3">H(y, z, t) = ? 2 y 2 + 1 2 z 2 + m i=1 1 w i log(cosh(w i y i + (Vu(t)) i + b i )),<label>(4)</label></formula><p>with x 2 = x, x denoting the Euclidean norm of the vector x ? R m and ?, ? the corresponding inner product. The next step is to find a discretization of the ODE system (2). Given that it is highly desirable to ensure that the discretization respects the Hamiltonian structure of the underlying continuous ODE, the simplest such structure preserving discretization is the symplectic Euler method <ref type="bibr">(Sanz Serna &amp; Calvo, 1994;</ref><ref type="bibr" target="#b15">Hairer et al., 2003)</ref>. Applying the symplectic Euler method to the ODE (2) results in the following discrete dynamical system, y n = y n?1 + ?tz n , z n = z n?1 ? ?t[? (w y n?1 + Vu n + b) + ?y n?1 ],</p><p>for 1 ? n ? N . Here, 0 &lt; ?t &lt; 1 is the time-step and u n ? u(t n ), with t n = n?t, is the input signal. It is common to initialize with y 0 = z 0 = 0.</p><p>We see from the structure of the discrete dynamical system (5) that there is no interaction between the neurons in the hidden layer of (5). Such an RNN will have very limited expressivity. Hence, we stack more hidden layers to propose the following deep or multi-layer RNN, y n = y n?1 + ?t?(c ) z n ,</p><formula xml:id="formula_5">z n = z n?1 ? ?t?(c ) [?(w y n?1 + V y ?1 n + b l ) + ?y n?1 ].<label>(6)</label></formula><p>Here y l n , z l n ? R m are hidden states and w , V , b are weights and biases, corresponding to layer = 1, . . . , L. We set y 0 n = u n in the multilayer RNN (6). In <ref type="figure">Fig. 1</ref>, we present a schematic diagram of the proposed multi-layer recurrent model UnICORNN.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Input</head><p>Layer l = 1</p><formula xml:id="formula_6">Layer l = 2 n = 1 n = 2 Time n [y 1 1 , z 1 1 ] [y 2 1 , z 2 1 ] [y 1 2 , z 1 2 ] [y 2 2 , z 2 2 ]</formula><p>u 1 u 2 <ref type="figure">Figure 1</ref>. Schematic diagram of the multi-layer UnICORNN architecture, where the layers (respectively the input) are densely connected and the hidden states evolve independently in time. The invertibility of UnICORNN is visualized with blue arrows, emphasizing that the hidden states can be reconstructed during the backward pass and do not need to be stored.</p><p>Observe that we use the same step-size ?t for every layer, while multiplying a trainable parameter vector c ? R m to the time step. The action of c is modulated with the sigmoidal activation function?(u) = 0.5 + 0.5 tanh(u/2), which ensures that the time-step ?t is multiplied by a value between 0 and 1. We remark that the presence of this trainable vector c allows us to incorporate multi-scale behavior in the proposed RNN, as the effective time-step is learned during training and can be significantly different from the nominal time-step ?t. It is essential to point out that including this multi-scale time stepping is only possible, as each neuron (within the same hidden layer) is independent of the others and can be integrated with a different effective time step. Finally, we also share the control hyperparameter ? across the different layers, which results in a memory unit of L layers with a total of only 2 hyperparameters.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.">Motivation and background</head><p>The ODE system (2) is a model for a nonlinear system of uncoupled driven oscillators <ref type="bibr" target="#b14">(Guckenheimer &amp; Holmes, 1990)</ref>. To see this, we denote y i (t) as the displacement and z i (t) as the velocity. Then, the dynamics of the i-th oscillator is determined by the frequency ? and also by the forcing or driving term in the second equation of (2), where the forcing acts through the input signal u and is modulated by the weight V and bias b. Finally, the weight w modulates the frequency ? and allows each neuron to oscillate with its own frequency, rather than the common frequency ? of the system. The structure of w implies that each neuron is independent of the others. A key element of the oscillator system <ref type="formula" target="#formula_1">(2)</ref> is the absence of any damping or friction term. This allows the system to possess a Hamiltonian structure, with desirable long time behavior. Thus, we term the resulting RNN (6), based on the ODE system (2) as Undamped Independent Controlled Oscillatory RNN or UnICORNN.</p><p>We remark that networks of oscillators are very common in science and engineering <ref type="bibr" target="#b14">(Guckenheimer &amp; Holmes, 1990;</ref><ref type="bibr">Strogatz, 2015)</ref> with prominent examples being pendulums in mechanics, electrical circuits in engineering, business cycles in economics and functional brain circuits such as cortical columns in neurobiology.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.">Comparison with related work.</head><p>UnICORNN lies firmly in the class of ODE-based or ODEinspired RNNs, which have received considerable amount of attention in the machine learning literature in recent years. Neural ODEs, first proposed in <ref type="bibr" target="#b6">(Chen et al., 2018)</ref>, are a prominent example of using ODEs to construct neural networks. In this architecture, the continuous ODE serves as the learning model and gradients are computed from a sensitivity equation, which allows one to trade accuracy with computing time. Moreover, it is argued that these neural ODEs are invertible and hence, memory efficient. However, it is unclear if a general neural ODE, without any additional structure, can be invertible. Other RNN architectures that are based on discretized ODEs include those proposed in <ref type="bibr">(E, 2017)</ref> and <ref type="bibr">(Chang et al., 2018)</ref>, where the authors proposed an anti-symmetric RNN, based on the discretization of a stable ODE resulting from a skew-symmetric hidden weight matrix, thus constraining the gradient dynamics.</p><p>Our proposed RNN (6) is inspired by two recent RNN architectures. The first one is coRNN, proposed recently in <ref type="bibr">(Rusch &amp; Mishra, 2021)</ref>, where the underlying RNN archi-tecture was also based on the use of a network of oscillators.</p><p>As long as a constraint on the underlying weights was satisfied, coRNN was shown to mitigate the EVGP. In contrast to coRNN, our proposed RNN does not use a damping term. Moreover, each neuron, for any hidden layer, in UnICORNN (6) is independent. This is very different from coRNN where all the neurons were coupled together. Finally, UnICORNN is a multi-layer architecture whereas coRNN used a single hidden layer. These innovations allow us to admit a Hamiltonian structure for UnICORNN and facilitate a fast and memory efficient implementation.</p><p>Our proposed architecture was also partly inspired by <ref type="bibr">In-dRNN, proposed in (Li et al., 2018;</ref>, where the neurons in each hidden layers were independent of each other and interactions between neurons were mediated by stacking multiple RNN layers, with output of each hidden layer passed on to the next hidden layer, leading to a deep RNN. We clearly use this construction of independent neurons in each layer and stacking multiple layers in UnICORNN (6). However in contrast to IndRNN, our proposed RNN is based on a discretized Hamiltonian system and we will not require any constraints on the weights to mitigate the EVGP.</p><p>Finally, we would like to point out that discrete Hamiltonian systems have already been used to design RNNs, for instance in <ref type="bibr" target="#b13">(Greydanus et al., 2019)</ref> and also in <ref type="bibr">(Chen et al.)</ref>, where a symplectic time-integrator for a Hamiltonian system was proposed as the RNN architecture. However, these approaches are based on underlying time-independent Hamiltonians and are only relevant for mechanical systems as they cannot process time-dependent inputs, which arise in most realistic learning tasks. Moreover, as these methods enforce exact conservation of the Hamiltonian in time, they are not suitable for learning long-time dependencies, see <ref type="bibr">(MacKay et al., 2018)</ref> for a discussion and experiment on that issue. Although we use a Hamiltonian system as the basis of our proposed RNN (6), our underlying Hamiltonian (4) is time-dependent and the resulting RNN can readily process any time-dependent input signal.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.">On the Memory Efficiency of UnICORNN</head><p>As mentioned in the introduction, the standard BPTT training algorithm for RNNs requires one to store all the hidden states at every time step. To see this, we observe that for a standard multi-layer RNN with L layers and a minibatch size of b (for any mini-batch stochastic gradient descent algorithm), the storage (in terms of floats) scales as O(N bd + LbmN ), with input and hidden sequences of length N . This memory requirement can be very high. Note that we have ignored the storage of trainable weights and biases for the RNN in the above calculation.</p><p>On the other hand, as argued before, our proposed RNN is a symplectic Euler discretization for a Hamiltonian system. Hence, it is invertible. In fact, one can explicitly write the inverse of UnICORNN (6) as,</p><formula xml:id="formula_7">y l n?1 = y l n ? ?t?(c l ) z l n , z l n?1 = z l n + ?t?(c l ) [?(w l y l n?1 + V y ?1 n + b l ) + ?y l n?1 ].<label>(7)</label></formula><p>Thus, one can recover all the hidden states in a given hidden layer, only from the stored hidden state at the final time step, for that layer. Moreover, only the input signal needs to be stored as the other hidden states can be reconstructed from the formula (7). Hence, a straightforward calculation shows that the storage for UnICORNN scales as O(N bd + Lbm).</p><p>As L &lt;&lt; N , we conclude that UnICORNN allows for a significant saving in terms of storage, when compared to a standard RNN.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Rigorous Analysis of UnICORNN</head><p>On the dynamics of the hidden state gradients for ODE (2). In order to investigate the EVGP for the proposed RNN (6), we will first explore the dynamics of the gradients of hidden states y, z (solutions of the ODE (2)) with respect to the trainable parameters w, V and b. Denote any scalar parameter as ? and f ? = ?f ?? , then differentiating the ODE (2) with respect to ? results in the ODE,</p><formula xml:id="formula_8">y ? = z ? , z ? = ?? (A) (w y ? ) ? ?y ? ? ? (A) C(t),<label>(8)</label></formula><p>where A = w y + Vu + b is the pre-activation and the coefficient C ? R m is given by</p><formula xml:id="formula_9">C i = y i if ? = w i , C i = u j if ? = V ij and C i = 1 if ? = b i ,</formula><p>with all other entries of the vector C being zero.</p><p>It is easy to check that the ODE system (8) is a Hamiltonian system of form (3), with the following time-dependent Hamiltonian;</p><formula xml:id="formula_10">H (y ? , z ? , t) := ? 2 y ? 2 + 1 2 z ? 2 + 1 2 m i=1 ? (A i )w i ((y ? ) i ) 2 + m i=1 ? (A i )C i (t)(y ? ) i .</formula><p>(9) Thus, by the well-known Liouville's theorem <ref type="bibr">(Sanz Serna &amp; Calvo, 1994)</ref>, we know that the phase space volume of (8) is preserved. Hence, this system cannot have any asymptotically stable fixed points. This implies that {0, 0} cannot be a stable fixed point for the hidden state gradients (y ? , z ? ). Thus, we can expect that the hidden state gradients with respect to the system of oscillators (2) do not remain near zero and suggest a possible mechanism for the mitigation of the vanishing gradient problem for UnICORNN (6), which is a structure preserving discretization of the ODE (2).</p><p>On the Exploding Gradient Problem for UnICORNN. We train the RNN (6) to minimize the loss function,</p><formula xml:id="formula_11">E := 1 N N n=1 E n , E n = 1 2 y L n ?? n 2 2 ,<label>(10)</label></formula><p>with? being the underlying ground truth (training data). Note that the loss function (10) only involves the output at the last hidden layer (we set the affine output layer to identity for the sake of simplicity). During training, we compute gradients of the loss function (10) with respect to the trainable weights and biases ? = [w , V , b , c ], for all 1 ? ? L, i.e.,</p><formula xml:id="formula_12">?E ?? = 1 N N n=1 ?E n ?? , ? ? ? ?.<label>(11)</label></formula><p>We have the following upper bound on the hidden state gradient, Proposition 3.1. Let the time step ?t &lt;&lt; 1 be sufficiently small in the RNN (6) and let y n , z n , for 1 ? ? L, and 1 ? n ? N be the hidden states generated by the RNN (6). Then, the gradient of the loss function E (10) with respect to any parameter ? ? ? is bounded as,</p><formula xml:id="formula_13">?E ?? ? 1 ? (?t) L 1 ? ?t T (1 + 2?T )V(Y + F)?,<label>(12)</label></formula><formula xml:id="formula_14">with? = max 1?n?N</formula><p>? n ? , be a bound on the underlying training data and other quantities in (12) defined as,</p><formula xml:id="formula_15">? = max 2, w L ? + ? + max 2, w L ? + ? 2 2 , V = L q=1 max{1, V q ? }, ? = max{1 + 2?, 4? 2 } F = 2 ? (1 + 2?T ), T = N ?t, ? = 2 + 2 (1 + 2?T ) + (2 + ?) 2 ? (1 + 2?T ).</formula><p>This proposition, proved in Appendix C.2, demonstrates that as long as the weights w L , V q are bounded, there is a uniform bound on the hidden state gradients. This bound grows at most as (N ?t) 3 , with N being the total number of time steps. Thus, there is no exponential growth of the gradient with respect to the number of time steps and the exploding gradient problem is mitigated for UnICORNN.</p><p>On the Vanishing Gradient Problem for UnICORNN. By applying the chain rule repeatedly to each term on the right-hand-side of (11), we obtain</p><formula xml:id="formula_16">?E n ?? = L =1 n k=1 ?E (n,L) k, ?? , ?E (n,L) k, ?? := ?E n ?X L n ?X L n ?X k ? + X k ?? ,</formula><p>X n = y ,1 n , z ,1 n , . . . , y ,j n , z ,j n , . . . , y ,m n , z ,m n .</p><p>(13) Here, the notation ? + X k ?? refers to taking the partial derivative of X k with respect to the parameter ?, while keeping the other arguments constant. The quantity ?E (n,L) k, ?? denotes the contribution from the k-recurrent step at the l-th hidden layer of the deep RNN (6) to the overall hidden state gradient at the step n. , defined in (13), ? 0 exponentially fast in k, for k &lt;&lt; n (long-term dependencies). In that case, the RNN does not have long-term memory, as the contribution of the k-th hidden state at the -th layer to error at time step t n is infinitesimally small.</p><p>We have established that the hidden state gradients for the underlying continuous ODE (2) do not vanish. As we use a symplectic Euler discretization, the phase space volume for the discrete dynamical system (5) is also conserved <ref type="bibr">(Sanz Serna &amp; Calvo, 1994;</ref><ref type="bibr" target="#b15">Hairer et al., 2003)</ref>. Hence, one can expect that the gradients of the multilayer RNN (6) do not vanish. However, these heuristic considerations need to be formalized. Observe that the vanishing gradient problem for RNNs focuses on the possible smallness of contributions of the gradient over a large number of recurrent steps. As this behavior of the gradient is independent of the number of layers, we focus on the vanishing gradient problem for a single hidden layer here, while presenting the multilayer results in Appendix C.4. Also, for the sake of definiteness, we set the scalar parameter ? = w 1,p for some 1 ? p ? m. Similar results also hold for any other ? ? ?.</p><p>We have the following representation formula (proved in Appendix C.3) for the hidden state gradients, Proposition 3.2. Let y n be the hidden states generated by the RNN (6). Then the gradient for long-term dependencies, i.e. k &lt;&lt; n, satisfies the representation formula,</p><formula xml:id="formula_17">?E (n,1) k,1 ?w 1,p = ??t?(c 1,p ) 2 t n ? (A 1,p k?1 )y 1,p k?1 y 1,p n ? y p n + O(?t 2 ).<label>(14)</label></formula><p>It is clear from the representation formula (14) that there is no k-dependence for the gradient. In particular, as long as all the weights are of O(1), the leading-order term in <ref type="formula" target="#formula_3">(14)</ref> is O(?t). Hence, the gradient can be small but is independent of the recurrent step k. Thus, we claim that the vanishing gradient problem, with respect to recurrent connections, is mitigated for UnICORNN (6).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Experiments</head><p>The details of the training procedure for each experiment can be found in Appendix A. Code to replicate the experiments can be found at https://github.com/tk-rusch/unicornn. Implementation The structure of UnICORNN (6) enables us to achieve a very fast implementation. First, the transformation of the input (i.e. V y ?1 n for all l = 1, . . . , L), which is the most computationally expensive part of UnICORNN, does not have a sequential structure and can thus be computed in parallel over time. Second, as the underlying ODEs of the UnICORNN are uncoupled for each neuron, the remaining recurrent part of UnICORNN is solved independently for each component. Hence, inspired by the implementation of Simple Recurrent Units (SRU) <ref type="bibr">(Lei et al., 2018)</ref> and IndRNN, we present in Appendix B, the details of an efficient CUDA implementation, where the input transformation is computed in parallel and the dynamical system corresponding to each component of <ref type="formula" target="#formula_5">(6)</ref> is an independent CUDA thread.</p><p>We benchmark the training speed of UnICORNN with L = 2 layers, against the fastest available RNN implementations, namely the cuDNN implementation <ref type="bibr" target="#b0">(Appleyard et al., 2016)</ref> of LSTM (with 1 hidden layer), SRU and IndRNN (both with L = 2 layers and with batch normalization). <ref type="figure" target="#fig_1">Fig. 2</ref> shows the computational time (measured on a GeForce RTX 2080 Ti GPU) of the combined forward and backward pass for each network, averaged over 100 batches with each of size 128, for two different sequence lengths, i.e. N = 1000, 2000. We can see that while the cuDNN LSTM is relatively slow, the SRU, IndRNN and the UnICORNN perform similarly fast. Moreover, we also observe that UnICORNN is about 30 ? 40 times faster per combined forward and backward pass, when compared to recently developed RNNs such as expRNN (Casado &amp; Mart?nez-Rubio, 2019) and coRNN <ref type="bibr">(Rusch &amp; Mishra, 2021)</ref>. We thus conclude that the UnICORNN is among the fastest available RNN architectures.</p><p>Permuted sequential MNIST A well-established benchmark for testing RNNs on input sequences with long-time dependencies is the permuted sequential MNIST (psM-NIST) task <ref type="bibr">(Le et al., 2015)</ref>. Based on the classical MNIST data set <ref type="bibr">(LeCun et al., 1998)</ref>, the flattened grey-scale matrices are randomly permuted (based on a fixed random permutation) and processed sequentially by the RNN. This makes the learning task more challenging than sequential MNIST, where one only flattens the MNIST matrices without permuting them. In order to make different methods comparable, we use the same fixed seed for the random permutation, as in <ref type="bibr">(Casado &amp; Mart?nez-Rubio, 2019;</ref><ref type="bibr">Casado, 2019;</ref><ref type="bibr" target="#b17">Helfrich et al., 2018)</ref>. <ref type="table">Table 1 shows</ref>  posed RNNs, which were explicitly designed to learn LTDs as well as two gated baselines. We see that UnICORNN clearly outperforms the other methods. <ref type="table">Table 1</ref>. Test accuracies on permuted sequential MNIST together with number of hidden units as well as total number of parameters M for each network. All other results are taken from the corresponding original publication, cited in the main text, except that we are using the results of <ref type="bibr" target="#b5">(Chang et al., 2017)</ref> for GRU and of <ref type="bibr" target="#b17">(Helfrich et al., 2018)</ref>  Noise padded CIFAR-10 A more challenging test for the ability of RNNs to learn LTDs is provided by the recently proposed noise padded CIFAR-10 experiment <ref type="bibr">(Chang et al., 2018)</ref>. In it, the CIFAR-10 data points <ref type="bibr" target="#b22">(Krizhevsky et al., 2009</ref>) are fed to the RNN row-wise and flattened along the channels resulting in sequences of length 32. To test long term memory, entries of uniform random numbers are added such that the resulting sequences have a length of 1000, i.e. the last 968 entries of each sequences are only noise to distract the RNNs.  <ref type="bibr">(Rusch &amp; Mishra, 2021)</ref>. We conclude that the proposed RNN readily outperforms all other methods on this experiment. EigenWorms The EigenWorms data set <ref type="bibr" target="#b3">(Bagnall et al., 2018</ref>) is a collecting of 259 very long sequences, i.e. length of 17984, describing the motion of a worm. The task is, based on the 6-dimensional motion sequences, to classify a worm as either wild-type or one of four mutant types. We use the same train/valid/test split as in (Morrill et al., 2020), i.e. 70%/15%/15%. As the length of the input sequences is extremely long for this test case, we benchmark UnICORNN against three sub-sampling based baselines. These include the results of (Morrill et al., 2020), which is based on signature sub-sampling routine for neural controlled differential equations. Additionally after a hyperparameter fine-tuning procedure, we perform a random sub-sampling as well as truncated back-propagation through time (BPTT) routine using LSTMs, where the random sub-sampling is based on 200 randomly selected time points of the sequences as well as the BPTT is truncated after the last 500 time points of the sequences. Furthermore, we compare UnICORNN with three leading RNN architectures for solving LTD tasks, namely expRNN, IndRNN and coRNN, which are all applied to the full-length sequences. The results, presented in  truly exhibit very long-time dependencies. To investigate this further, we train UnICORNN on a subset of the entries of the sequences. To this end, we consider using only the last entries as well as using a random subset of the entries. <ref type="figure" target="#fig_2">Fig. 3</ref> shows the distributional results (10 re-trainings of the best performing UnICORNN) for the number of entries used in each sub-sampling routine, ranging from only using 1000 entries to using the full sequences for training. We can see that in order to reach a test accuracy of 80% when training on the last entries of the sequences, at least the last 10k entries are needed. Moreover, for both sub-sampling methods the test accuracy increases monotonically as the number of entries for training is increased. On the other hand, using a random subset of the entries increases the test accuracy significantly when compared to using only the last entries of the sequences. This indicates that the important entries of the sequences, i.e. information needed in order to classify them correctly, are uniformly distributed throughout the full sequence. We thus conclude that the EigenWorms data set indeed exhibits very long-time dependencies.  testing set, using a 70%/15%/15% split. <ref type="table">Table 4</ref> shows the distributional results of all networks using 5 re-trainings of the best performing RNN. We observe that while the LSTM does not reach a low L 2 testing error in both experiments, the other RNNs approximate the vital signs reasonably well. However, UnICORNN clearly outperforms all other methods on both benchmarks. We emphasize that UnICORNN significantly outperforms all other state-of-the-art methods on estimating the RR, which is of major importance in modern healthcare applications for monitoring hospital inpatients as well as for mobile health applications, as special invasive equipment (for instance capnometry or measurement of gas flow) is normally needed to do so <ref type="bibr">(Pimentel et al., 2016)</ref>.  <ref type="formula" target="#formula_1">2011)</ref>, which consists of 50k online movie reviews with 25k reviews used for training and 25k reviews used for testing. This denotes a classical sentiment analysis task, where the model has to decide whether a movie review is positive or negative. We use 30% of the training set (i.e. 7.5k reviews) as the validation set and restrict the dictionary to 25k words. We choose an embedding size of 100 and initialize it with the pretrained 100d GloVe (Pennington et al., 2014) vectors. <ref type="table">Table 5</ref> shows the results for UnICORNN with 2 layers together with other recently proposed RNN architectures and gated baselines (which are known to perform very well on these tasks). The result of ReLU GRU is taken from <ref type="bibr" target="#b9">(Dey &amp; Salemt, 2017)</ref>, of coRNN from <ref type="bibr">(Rusch &amp; Mishra, 2021)</ref> and all other results are taken from <ref type="bibr">(Campos et al., 2018)</ref>. We can see that UnICORNN outperforms the other methods while requiring significantly less parameters. We thus conclude, that the UnICORNN can also be successfully applied to problems, which do not necessarily exhibit long-term dependencies.</p><p>Further experimental results As stated before, UnI-CORNN has two hyperparameters, i.e. the maximum allowed time-step ?t and the damping parameter ?. It is of interest to examine how sensitive the performance of UnICORNN is with respect to variations of these hyperparameters. To this end, we consider the noise padded CIFAR-10 experiment and perform an ablation study of the test accuracy with respect to variations of both ? and ?t. Both hyperparameters are varied by an order of magnitude and the results of this study are plotted in <ref type="figure" target="#fig_4">Fig. 4</ref>. We observe from this figure, that the results are indeed somewhat sensitive to the maximum allowed time-step ?t and show a variation of approximately 15% with respect to to this hyperparameter. On the other hand, there is very little noticeable variation with respect to the damping parameter ?. Thus, it can be set to a default value, for instance ? = 1, without impeding the performance of the underlying RNN.  Next, we recall that the design of UnICORNN (6) enables it to learn the effective time step (with a possible maximum of ?t) from data. It is instructive to investigate if this ability to express multi-scale behavior is realized in practice or not. To this end, we consider the trained UnICORNN of the psMNIST task with 3 layers and 256 neurons. Here, a maximum time step of ?t = 0.19 was identified by the hyperparameter tuning. In <ref type="figure" target="#fig_5">Fig. 5</ref>, we plot the effective time step ?t?(c l i ), for each hidden neuron i = 1, . . . , 256 and each layer l = 1, 2, 3. We observe from this figure that a significant variation of the effective time step is observed, both within the neurons in each layer, as well as between layers. In particular, the minimum effective time step is about 28 times smaller than the maximum allowed time step. Thus, we conclude from this figure, that UnICORNN exploits its design features to learn multi-scale behavior that is latent in the data. This perhaps explains the superior performance of UnICORNN on many learning tasks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Discussion</head><p>The design of RNNs that can accurately handle sequential inputs with long-time dependencies is very challenging. This is largely on account of the exploding and vanishing gradient problem (EVGP). Moreover, there is a significant increase in both computational time as well as memory requirements when LTD tasks have to be processed. Our main aim in this article was to present a novel RNN architecture which is fast, memory efficient, invertible and mitigates the EVGP. To this end, we proposed UnICORNN <ref type="formula" target="#formula_5">(6)</ref>, an RNN based on the symplectic Euler discretization of a Hamiltonian system of second-order ODEs (2) modeling a network of independent, undamped, controlled and driven oscillators. In order to gain expressivity, we stack layers of RNNs and also endow this construction with a multi-scale feature by training the effective time step in (6).</p><p>Given the Hamiltonian structure of our continuous and discrete dynamical system, invertibility and volume preservation in phase space are guaranteed. Invertibility enables the proposed RNN to be memory efficient. The independence of neurons within each hidden layer allows us to build a highly efficient CUDA implementation of UnICORNN that is as fast as the fastest available RNN architectures. Under suitable smallness constraints on the maximum allowed time step ?t, we prove rigorous upper bounds (12) on the gradients and show that the exploding gradient problem is mitigated for UnICORNN. Moreover, we derive an explicit representation formula (14) for the gradients of (6), which shows that the vanishing gradient problem is also mitigated. Finally, we have tested UnICORNN on a suite of benchmarks that includes both synthetic as well as realistic learning tasks, designed to test the ability of an RNN to deal with long-time dependencies. In all the experiments, UnICORNN was able to show state of the art performance.</p><p>It is instructive to compare UnICORNN with two recently proposed RNN architectures, with which it shares some essential features. First, the use of coupled oscillators to design RNNs was already explored in the case of coRNN <ref type="bibr">(Rusch &amp; Mishra, 2021)</ref>. In contrast to coRNN, neurons in UnICORNN are independent (uncoupled) and as there is no damping, UnICORNN possesses a Hamiltonian structure. This paves the way for invertibility as well as for mitigating the EVGP without any assumptions on the weights whereas the mitigation of EVGP with coRNN was conditional on restrictions on weights. Finally, UnICORNN provides even better performance on benchmarks than coRNN, while being significantly faster. While we also use independent neurons in each hidden layer and stack RNN layers together as in <ref type="bibr">IndRNN (Li et al., 2018)</ref>, our design principle is completely different as it is based on Hamiltonian ODEs. Consequently, we do not impose weight restrictions, which are necessary for IndRNN to mitigate the EVGP. Moreover, in contrast to IndRNNs, our architecture is invertible and hence, memory efficient.</p><p>This work can be extended in different directions. First, UnI-CORNN is a very flexible architecture in terms of stacking layers of RNNs together. We have used a fully connected stacking in (6) but other possibilities can be readily explored. See Appendix C.5 for a discussion on the use of residual connections in stacking layers of UnICORNN. Second, the invertibility of UnICORNN can be leveraged in the context of normalizing flows <ref type="bibr">(Papamakarios et al., 2019)</ref>, where the objective is to parametrize a flow such that the resulting Jacobian is readily computable. Finally, our focus in this article was on testing UnICORNN on learning tasks with long-time dependencies. Given that the underlying ODE (2) models oscillators, one can envisage that UnICORNN will be very competitive with respect to processing different time series data that arise in healthcare AI such as EEG and EMG data, as well as seismic time series from the geosciences. All experiments were run on GPU, namely NVIDIA GeForce GTX 1080 Ti and NVIDIA GeForce RTX 2080 Ti. The hidden weights w of the UnICORNN are initialized according to U(0, 1), while all biases are set to zero. The trained vector c is initialized according to U(?0.1, 0.1). The input weights V are initialized according to the Kaiming uniform initialization <ref type="bibr" target="#b16">(He et al., 2015)</ref> based on the input dimension mode and the negative slope of the rectifier set to a = 8.</p><p>The hyperparameters of the UnICORNN are selected using a random search algorithm based on a validation set. The hyperparameters of the best performing UnICORNN can be seen in <ref type="table">Table 6</ref>. The value for ?t and ? is shared across all layers, except for the IMDB task and EigenWorms task, where we use a different ?t value for the first layer and the corresponding ?t value in <ref type="table">Table 6</ref> for all subsequent layers, i.e. we use ?t = 6.6 ? 10 ?3 for IMDB and ?t = 2.81 ? 10 ?5 for EigenWorms in the first layer. Additionally, the dropout column corresponds to variational dropout <ref type="bibr" target="#b12">(Gal &amp; Ghahramani, 2016)</ref>, which is applied after each consecutive layer. Note that for the IMDB task also an embedding dropout with p = 0.65 is used.</p><p>We train the UnICORNN for a total of 50 epochs on the IMDB task and for a total of 250 epochs on the EigenWorms task. Moreover, we train UnICORNN for 650 epochs on psMNIST, after which we decrease the learning rate by a factor of 10 and proceed training for 3 times the amount of epochs used before reducing the learning rate. On all other tasks, UnICORNN is trained for 250 epochs, after which we decrease the learning rate by a factor of 10 and proceed training for additional 250 epochs. The resulting best performing networks are selected based on a validation set. <ref type="table">Table 6</ref>. Hyperparameters of the best performing UnICORNN architecture (based on a validation set) for each experiment.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Experiment</head><p>learning rate dropout batch size ?t ? noise padded CIFAR-10 3.14 ? 10 ?2 1.0 ? 10 ?1 30 1.26 ? 10 ?1 13.0 psMNIST (#units = 128) 1.14 ? 10 ?3 1.0 ? 10 ?1 64 4.82 ? 10 ?1 12.53 psMNIST (#units = 256) 2.51 ? 10 ?3 1.0 ? 10 ?1 32 1.9 ? 10 ?1 30.65 IMDB 1.67 ? 10 ?4 6.1 ? 10 ?1 32 2.05 ? 10 ?1 0.0 EigenWorms 8.59 ? 10 ?3 0.0 8 3.43 ? 10 ?2 0.0 Healthcare: RR 3.98 ? 10 ?3 1.0 ? 10 ?1 32 1.1 ? 10 ?2 9.0 Healthcare: HR 2.88 ? 10 ?3 1.0 ? 10 ?1 32 4.6 ? 10 ?2 10.0</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Implementation details</head><p>As already described in the implementation details of the main paper, we can speed up the computation of the forward and backward pass, by parallelizing the input transformation and computing the recurrent part for each independent dimension in an independent CUDA thread. While the forward/backward pass for the input transformation is simply that of an affine transformation, we discuss only the recurrent part. Since we compute the gradients of each dimension of the UnICORNN independently and add them up afterwards to get the full gradient, we will simplify to the following one-dimensional system: z n = z n?1 ? ?t?(c)[? (wy n?1 + x n ) + ?y n?1 ], y n = y n?1 + ?t?(c)z n , where x n = (Vu n ) j is the transformed input corresponding to the respective dimension j = 1, . . . , m.</p><p>Since we wish to train the UnICORNN on some given objective</p><formula xml:id="formula_18">E := N n=1? (y n ),<label>(1)</label></formula><p>where? is some loss function taking the hidden states y n as inputs, for instance mean-square distance of (possibly transformed) hidden states y n to some ground truth. During training, we compute gradients of the loss function (1) with respect to the following quantities ? = [w, ?t, x n ], i.e.</p><formula xml:id="formula_19">?E ?? = N n=1 ??(y n ) ?? , ? ? ? ?.<label>(2)</label></formula><p>We can work out a recursion formula to compute the gradients in (2). We will exemplarily provide the formula for the gradient with respect to the hidden weight w. The computation of the gradients with respect to the other quantities follow similarly. Thus</p><formula xml:id="formula_20">? z k = ? z k?1 + ? y k?1 ?t?(c),<label>(3)</label></formula><formula xml:id="formula_21">? y k = ? y k?1 ? ? z k ?t?(c)[? (wy N ?k + x N ?k+1 )w + ?] + ?? ?y N ?k ,<label>(4)</label></formula><p>with initial values ? y 0 = ?? ?y N and ? z 0 = 0. The gradient can then be computed as</p><formula xml:id="formula_22">?E ?w = N k=1 a k , with a k = ?? z k ?t?(c)? (wy N ?k + x N ?k+1 )y N ?k .<label>(5)</label></formula><p>Note that this recursive formula is a direct formulation of the back-propagation through time algorithm (Werbos, 1990) for the UnICORNN.</p><p>We can verify formula (3)-(5) by explicitly calculating the gradient in <ref type="formula" target="#formula_1">(2)</ref>:</p><formula xml:id="formula_23">?E ?w = N n=1 ??(y n ) ?w = N ?1 n=1 ??(y n ) ?w + ?? ?y N ?y N ?1 ?w + ?t?(c) ?z N ?1 ?w ? ?t?(c)(? (wy N ?1 + x N ) (y N ?1 + w ?y N ?1 ?w ) + ? ?y N ?1 ?w = N ?2 n=1 ??(y n ) ?w + a 1 + ? z 1 ?z N ?1 ?w + ? y 1 ?y N ?1 ?w = N ?2 n=1 ??(y n ) ?w + a 1 + ? y 1 ?y N ?2 ?w + (? y 1 ?t?(c) + ? z 1 ) ?z N ?2 ?w ? ?t?(c)(? (wy N ?2 + x N ?1 ) (y N ?2 + w ?y N ?2 ?w ) + ? ?y N ?2 ?w ) = N ?3 n=1 ??(y n ) ?w + 2 k=1 a k + ? z 2 ?z N ?2 ?w + ? y 2 ?y N ?2 ?w .</formula><p>Iterating the same reformulation yields the desired formula (3)-(5).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Rigorous bounds on UnICORNN</head><p>We rewrite <ref type="bibr">UnICORNN (Eqn. (6)</ref> in the main text) in the following form: for all 1 ? ? L and for all 1 ? i ? m</p><formula xml:id="formula_24">y ,i n = y ,i n?1 + ?t?(c ,i )z ,i n , z ,i n = z ,i n?1 ? ?t?(c ,i )?(A ,i n?1 ) ? ??t?(c ,i )y ,i n?1 , A ,i n?1 = w ,i y ,i n?1 + V y ?1 n i + b ,i .<label>(6)</label></formula><p>Here, we have denoted the i-th component of a vector x as x i .</p><p>We follow standard practice and set y 0 = z 0 ? 0, for all 1 ? ? L. Moreover for simplicity of exposition, we set ? &gt; 0 in the following.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C.1. Pointwise bounds on hidden states.</head><p>We have the following bounds on the discrete hidden states, Proposition C.1. Let y n , z n be the hidden states at the n-th time level t n for UnICORNN <ref type="formula" target="#formula_5">(6)</ref>, then under the assumption that the time step ?t &lt;&lt; 1 is sufficiently small, these hidden states are bounded as,</p><formula xml:id="formula_25">max 1?i?m |y ,i n | ? 2 ? (1 + 2?t n ), max 1?i?m |z ,i n | ? 2 (1 + 2?t n ) ?n, ? 1 ? ? L,<label>(7)</label></formula><p>with the constant ? = max{1 + 2?, 4? 2 }.</p><p>Proof. We fix , n and multiply the first equation in (6) with ?y ,i n?1 and use the elementary identity</p><formula xml:id="formula_26">b(a ? b) = a 2 2 ? b 2 2 ? 1 2 (a ? b) 2 , to obtain ?(y ,i n ) 2 2 = ?(y ,i n?1 ) 2 2 + ? 2 (y ,i n ? y ,i n?1 ) 2 + ??t?(c ,i )y ,i n?1 z ,i n , = ?(y ,i n?1 ) 2 2 + ??t 2 2 (?(c ,i )) 2 (z ,i n ) 2 + ??t?(c ,i )y ,i n?1 z ,i n .<label>(8)</label></formula><p>Next, we multiply the second equation in (6) with z ,i n and use the elementary identity</p><formula xml:id="formula_27">a(a ? b) = a 2 2 ? b 2 2 + 1 2 (a ? b) 2 , to obtain (z ,i n ) 2 2 = (z ,i n?1 ) 2 2 ? 1 2 (z ,i n ? z ,i n?1 ) 2 ? ?t?(c ,i )?(A ,i n?1 ) z ,i n ? z ,i n?1 ? ?t?(c ,i )?(A ,i n?1 )z ,i n?1 ? ??t?(c ,i )y ,i n?1 z ,i n .<label>(9)</label></formula><p>Adding <ref type="formula" target="#formula_8">(8)</ref> and <ref type="formula" target="#formula_27">(9)</ref> and using Cauchy's inequality yields,</p><formula xml:id="formula_28">?(y ,i n ) 2 2 + (z ,i n ) 2 2 ? ?(y ,i n?1 ) 2 2 + (1 + ?t)(z ,i n?1 ) 2 2 + ??t 2 2 (?(c ,i )) 2 (z ,i n ) 2 + (?(c ,i )) 2 (?(A ,i n?1 )) 2 ?t + ?t ? 1 2 (z ,i n ? z ,i n?1 ) 2 ? ?(y ,i n ) 2 + (z ,i n ) 2 ? ?(y ,i n?1 ) 2 + (1 + ?t)(z ,i n?1 ) 2 + 2?t + ??t 2 (z ,i n ) 2 ,</formula><p>where the last inequality follows from the fact that |?|, |?| ? 1 and ?t &lt; 1. Using the elementary inequality,</p><formula xml:id="formula_29">(a + b + c) 2 ? 4a 2 + 4b 2 + 2c 2 ,</formula><p>and substituting for z ,i n from the second equation of (6) in the last inequality leads to, ?(y ,i n ) 2 + (z ,i n ) 2 ? (1 + 4? 2 ?t 4 )?(y ,i n?1 ) 2 + (1 + ?t + 2??t 2 )(z ,i n?1 ) 2 + 2?t + 4??t 4 .</p><p>Denoting H n = ?(y ,i n ) 2 + (z ,i n ) 2 and G := 1 + ??t, ? = max{1 + 2?, 4? 2 } yields the following inequality, H n ? GH n?1 + 2?t(1 + 2??t 3 ).</p><p>Iterating the above n-times and using the fact that the initial data is such that H 0 ? 0 we obtain,</p><formula xml:id="formula_31">H n ? 2?t + 4??t 4 n?1 k=0 (1 + ??t) k ? (1 + ??t) n ??t 2?t + 4??t 4 ? 1 ? (1 + 2?n?t) 2 + 4??t 3 as ?t &lt;&lt; 1, ? 2(1 + 2?t n ) (from definition of ?).<label>(11)</label></formula><p>The definition of H clearly implies the desired bound <ref type="formula" target="#formula_7">(7)</ref>.</p><p>C.2. On the exploding gradient problem for UnICORNN and Proof of proposition 3.1 of the main text.</p><p>We train the RNN (6) to minimize the loss function,</p><formula xml:id="formula_32">E := 1 N N n=1 E n , E n = 1 2 y L n ?? n 2 2 ,<label>(12)</label></formula><p>with? being the underlying ground truth (training data). Note that the loss function <ref type="formula" target="#formula_1">(12)</ref> only involves the output at the last hidden layer (we set the affine output layer to identity for the sake of simplicity). During training, we compute gradients of the loss function (12) with respect to the trainable weights and biases</p><formula xml:id="formula_33">? = [w , V , b , c ], for all 1 ? ? L i.e. ?E ?? = 1 N N n=1 ?E n ?? , ? ? ? ?.<label>(13)</label></formula><p>We have the following bound on the gradient (13), Proposition C.2. Let the time step ?t &lt;&lt; 1 be sufficiently small in the RNN (6) and let y n , z n , for 1 ? ? L, be the hidden states generated by the RNN <ref type="figure">(6)</ref>. Then, the gradient of the loss function E (12) with respect to any parameter ? ? ? is bounded as,</p><formula xml:id="formula_34">?E ?? ? 1 ? (?t) L 1 ? ?t T (1 + 2?T )V(Y + F)?,<label>(14)</label></formula><p>with? = max 1?n?N ? n ? , be a bound on the underlying training data and other quantities in (14) defined as,</p><formula xml:id="formula_35">? = max 2, w L ? + ? + max 2, w L ? + ? 2 2 , V = L q=1 max{1, V q ? }, F = 2 ? (1 + 2?T ), ? = 2 + (1 + 2?T ) + (2 + ?) 2 ? (1 + 2?T ) .<label>(15)</label></formula><p>Proof. For any 1 ? n ? N and 1 ? ? L, let X n ? R 2m be the augmented hidden state vector defined by, X n = y ,1 n , z ,1 n , . . . , y ,i n , z ,i n , . . . , y ,m n , z ,m n .</p><p>For any ? ? ?, we can apply the chain rule repeatedly to obtain the following extension of the formula of (Pascanu et al., 2013) to a deep RNN,</p><formula xml:id="formula_37">?E n ?? = L =1 n k=1 ?E n ?X L n ?X L n ?X k ? + X k ?? ?E (n,L) k, ?? .<label>(17)</label></formula><p>Supplementary Material for "UnICORNN: A recurrent model for learning very long time dependencies"</p><p>Here, the notation ? + X k ?? refers to taking the partial derivative of X k with respect to the parameter ?, while keeping the other arguments constant.</p><p>We remark that the quantity ?E (n,L) k, ?? denotes the contribution from the k-recurrent step at the l-th hidden layer of the deep RNN (6) to the overall hidden state gradient at the step n.</p><p>It is straightforward to calculate that, ?E n ?X L n = y L,1 n ? y 1 n , 0, . . . , y L,i n ? y i n , 0, . . . , y L,m n ? y m n , 0 .</p><p>Repeated application of the chain and product rules yields,</p><formula xml:id="formula_39">?X L n ?X k = n j=k+1 ?X L j ?X L j?1 L q= +1 ?X q k ?X q?1 k .<label>(19)</label></formula><p>For any j, a straightforward calculation using the form of the RNN (6) leads to the following representation formula for the</p><formula xml:id="formula_40">matrix ?X L j ?X L j?1 ? R 2m ? R 2m : ?X L j ?X L j?1 = ? ? ? ? ? ? ? B L,1 j 0 . . . 0 0 B L,2 j . . . 0 . . . . . . . . . . . . . . . . . . . . . . . . 0 . . . 0 B L,m j ? ? ? ? ? ? ? ,<label>(20)</label></formula><p>with the block matrices B L,i j ? R 2?2 given by,</p><formula xml:id="formula_41">B L,i j = ? ? 1 ? (?(c L,i )) 2 ?t 2 w L,i ? (A L,i j?1 ) + ? ?(c L,i )?t ??(c L,i )?t w L,i ? (A L,i j?1 ) + ? 1 ? ? .<label>(21)</label></formula><p>Similarly for any q, the matrix </p><formula xml:id="formula_42">? ? ? ? ? ? ? ? ? ,<label>(22)</label></formula><p>with entries given by,</p><formula xml:id="formula_43">D q,k i,? = ??t 2 (?(c q,i )) 2 ? A q,i k?1 V q i? , E q,k i,? = ??t?(c q,i )? A q,i k?1 V q i? .<label>(23)</label></formula><p>A direct calculation with (21) leads to,</p><formula xml:id="formula_44">B L,i j ? ? max 1 + ?t + (|w L,i | + ?)?t 2 , 1 + (|w L,i | + ?)?t ? 1 + max 2, |w L,i | + ? ?t + max 2, |w L,i | + ? 2 ?t 2 2 .<label>(24)</label></formula><p>Using the definition of the L ? norm of a matrix, we use (24) to the derive the following bound from <ref type="formula" target="#formula_1">(20)</ref>,</p><formula xml:id="formula_45">?X L j ?X L j?1 ? ? 1 + max 2, w L ? + ? ?t + max 2, w L ? + ? 2 ?t 2 2 ? 1 + ??t,<label>(25)</label></formula><p>with ? defined in (15).</p><p>As ?t &lt; 1, it is easy to see that,</p><formula xml:id="formula_46">?X q k ?X q?1 k ? ? V q ? ?t.<label>(26)</label></formula><p>Combining <ref type="formula" target="#formula_1">(25)</ref> and <ref type="formula" target="#formula_1">(26)</ref> , we obtain from (19)</p><formula xml:id="formula_47">?X L n ?X k ? ? n j=k+1 ?X L j ?X L j?1 ? L q= +1 ?X q k ?X q?1 k ? ? ?t L? L q= +1 V q ? (1 + 2?(n ? k)?t), (as ?t &lt;&lt; 1) ? V?t L? (1 + 2?t n ),<label>(27)</label></formula><p>where the last inequality follows from the fact that t n = n?t ? T and the definition of V in (15).</p><p>Next, we observe that for any ? ? ?</p><formula xml:id="formula_48">? + X k ?? = ? + y ,1 k ?? , ? + z ,1 k ?? . . . , . . . , ? + y ,i k ?? , ? + z ,i k ?? , . . . , . . . , ? + y ,m k ?? , ? + z ,m k ?? .<label>(28)</label></formula><p>For any 1 ? i ? m, a direct calculation with the RNN (6) yields,</p><formula xml:id="formula_49">? + y ,i k ?? = ?t? (c ,i ) ?c ,i ?? z ,i k + ?t?(c ,i ) ? + z ,i k ?? , ? + z ,i k ?? = ??t? (c ,i ) ?c ,i ?? ?(A ,i k?1 ) ? ?t?(c ,i )? (A ,i k?1 ) ?A ,i k?1 ?? ? ??t? (c ,i ) ?c ,i ?? y ,i k?1 .<label>(29)</label></formula><p>Next, we have to compute explicitly ?c ,i ?? and ?A ,i k?1 ?? in order to complete the expressions (29). To this end, we need to consider explicit forms of the parameter ? and obtain, If ? = w q,p , for some 1 ? q ? L and 1 ? p ? m, then,</p><formula xml:id="formula_50">?A ,i k?1 ?? = y ,i k?1 , if q = , p = i, 0, if otherwise.<label>(30)</label></formula><p>If ? = b q,p , for some 1 ? q ? L and 1 ? p ? m, then,</p><formula xml:id="formula_51">?A ,i k?1 ?? = 1, if q = , p = i, 0, if otherwise.<label>(31)</label></formula><p>If ? = V q p,p , for some 1 ? q ? L and 1 ? p,p ? m, then,</p><formula xml:id="formula_52">?A ,i k?1 ?? = y ?1,p k , if q = , p = i, 0, if otherwise.<label>(32)</label></formula><p>If ? = c q,p for any 1 ? q ? L and 1 ? p ? m, then,</p><formula xml:id="formula_53">?A ,i k?1 ?? ? 0.<label>(33)</label></formula><p>Similarly, if ? = w q,p or ? = b q,p , for some 1 ? q ? L and 1 ? p ? m, or If ? = V q p,p , for some 1 ? q ? L and 1 ? p,p ? m, then ?c ,i ?? ? 0.</p><p>On the other hand, if ? = c q,p for any 1 ? q ? L and 1 ? p ? m, then</p><formula xml:id="formula_55">?c ,i ?? = 1, if q = , p = i, 0, if otherwise.<label>(35)</label></formula><p>For any ? ? ?, by substituting (30) to (35) into (29) and doing some simple algebra with norms, leads to the following inequalities,</p><formula xml:id="formula_56">? + z ,i k ?? ? ?t 1 + ?|y ,i k?1 | + max |y ,i k?1 |, |y ?1,p k |, 1 ,<label>(36)</label></formula><p>and,</p><formula xml:id="formula_57">? + y ,i k ?? ? ?t|z ,i k | + ?t 2 1 + ?|y ,i k?1 | + max |y ,i k?1 |, |y ?1,p k |, 1 ,<label>(37)</label></formula><p>for any 1 ?p ? m.</p><p>By the definition of L ? norm of a vector and some straightforward calculations with (37) yields,</p><formula xml:id="formula_58">? + X k ?? ? ? ?t 2 + z k ? + (1 + ?) y k?1 ? + y ?1 k ? .<label>(38)</label></formula><p>From the pointwise bounds <ref type="formula" target="#formula_7">(7)</ref>, we can directly bound the above inequality further as,</p><formula xml:id="formula_59">? + X k ?? ? ? ?t 2 + 2 (1 + 2?T ) + (2 + ?) 2 ? (1 + 2?T ) .<label>(39)</label></formula><p>By (18) and the definition of Y as well as the bound <ref type="formula" target="#formula_7">(7)</ref> on the hidden states, it is straightforward to obtain that,</p><formula xml:id="formula_60">?E n ?X L n ? ? Y + 2 ? (1 + 2?T )<label>(40)</label></formula><p>From the definition in (17), we have</p><formula xml:id="formula_61">?E (n,L) k, ?? ? ?E n ?X L n ? ?X L n ?X k ? ? + X k ?? ? .<label>(41)</label></formula><p>Substituting <ref type="formula" target="#formula_3">(40)</ref>, <ref type="formula" target="#formula_2">(39)</ref> and <ref type="formula" target="#formula_1">(25)</ref> into <ref type="formula" target="#formula_3">(41)</ref> yields,</p><formula xml:id="formula_62">?E (n,L) k, ?? ? ?t L? +1 (1 + 2?T ) V(Y + F)?,<label>(42)</label></formula><p>with F and ? defined in (15).</p><p>Therefore, from the fact that ?t &lt; 1, t n = n?t ? T and <ref type="formula" target="#formula_7">(17)</ref>, we obtain</p><formula xml:id="formula_63">?E n ?? ? 1 ? (?t) L 1 ? ?t T (1 + 2?T )V(Y + F)?.<label>(43)</label></formula><p>By the definition of the loss function (12) and the fact that the right-hand-side of (43) is independent of n leads to the desired bound (14).</p><p>C.3. On the Vanishing gradient problem for UnICORNN and Proof of Proposition 3.2 of the main text.</p><p>By applying the chain rule repeatedly to the each term on the right-hand-side of (13), we obtain</p><formula xml:id="formula_64">?E n ?? = L =1 n k=1 ?E (n,L) k, ?? , ?E (n,L) k, ?? := ?E n ?X L n ?X L n ?X k ? + X k ?? .<label>(44)</label></formula><p>Here, the notation ? + X k ?? refers to taking the partial derivative of X k with respect to the parameter ?, while keeping the other arguments constant. The quantity ?E (n,L) k, ?? denotes the contribution from the k-recurrent step at the l-th hidden layer of the deep RNN (6) to the overall hidden state gradient at the step n. The vanishing gradient problem <ref type="bibr">(Pascanu et al., 2013)</ref> arises if ?E (n,L) k, ?? , defined in (44), ? 0 exponentially fast in k, for k &lt;&lt; n (long-term dependencies). In that case, the RNN does not have long-term memory, as the contribution of the k-th hidden state at the -th layer to error at time step t n is infinitesimally small.</p><p>As argued in the main text, the vanishing gradient problem for RNNs focuses on the possible smallness of contributions of the gradient over a large number of recurrent steps. As this behavior of the gradient is independent of the number of layers, we start with a result on the vanishing gradient problem for a single hidden layer here. Also, for the sake of definiteness, we set the scalar parameter ? = w 1,p for some 1 ? p ? m. Similar results also hold for any other ? ? ?. Moreover, we introduce the following order-notation,</p><formula xml:id="formula_65">? = O(?), for ?, ? ? R + if there exists constants C, C such that C? ? ? ? C?. M = O(?), for M ? R d1?d2 , ? ? R + if there exists constant C such that M ? C?.<label>(45)</label></formula><p>We restate Proposition 3.2 of the main text, Proposition C.3. Let y n be the hidden states generated by the RNN (6). Then the gradient for long-term dependencies, i.e. k &lt;&lt; n, satisfies the representation formula, ?E (n,1) k,1 ?w 1,p = ??t?(c 1,p ) 2 t n ? (A 1,p k?1 )y 1,p k?1 y 1,p n ? y p n + O(?t 2 ).</p><p>Proof. Following the definition (44) and as L = 1 and ? = w 1,p , we have,</p><formula xml:id="formula_67">?E (n,1) k,1 ?w 1,p := ?E n ?X 1 n ?X 1 n ?X 1 k ? + X 1 k ?w 1,p .<label>(47)</label></formula><p>We will explicitly compute all three expressions on the right-hand-side of (47). To start with, using <ref type="formula" target="#formula_1">(28)</ref>, <ref type="formula" target="#formula_1">(29)</ref> and <ref type="formula" target="#formula_2">(30)</ref>, we obtain, ? + X 1 k ?w 1,p = 0, 0, . . . , . . . ,</p><formula xml:id="formula_68">? + y 1,p k ?w 1,p , ? + z 1,p k ?w 1,p , . . . , . . . , 0, 0 , ? + X 1 k ?w 1,p 2p?1 = ? + y 1,p k ?w 1,p = ??t 2 (?(c 1,p )) 2 ? (A 1,p k?1 )y 1,p k?1 , ? + X 1 k ?w 1,p 2p = ? + z 1,p k ?w 1,p = ??t?(c 1,p )? (A 1,p k?1 )y 1,p k?1 .<label>(48)</label></formula><p>Using the product rule (19) we have,</p><formula xml:id="formula_69">?X 1 n ?X 1 k = n j=k+1 ?X 1 j ?X 1 j?1 .<label>(49)</label></formula><p>Observing from the expressions <ref type="formula" target="#formula_1">(20)</ref> and <ref type="formula" target="#formula_1">(21)</ref> and using the order-notation (45), we obtain that,</p><formula xml:id="formula_70">?X 1 j ?X 1 j?1 = I 2m?2m + ?tC 1 j + O(?t 2 ),<label>(50)</label></formula><p>with I k?k is the k ? k Identity matrix and the matrix C 1 j defined by,</p><formula xml:id="formula_71">?X L j ?X L j?1 = ? ? ? ? ? ? C 1,1 j 0 . . . 0 0 C 1,2 j . . . 0 . . . . . . . . . . . . . . . . . . . . . . . . 0 . . . 0 C 1,m j ? ? ? ? ? ? ,<label>(51)</label></formula><p>with the block matrices C 1,i j ? R 2?2 given by,</p><formula xml:id="formula_72">C 1,i j = 0?(c 1,i ) ??(c 1,i ) w 1,i ? (A 1,i j?1 ) + ? 0 .<label>(52)</label></formula><p>By a straightforward calculation and the use of induction, we claim that</p><formula xml:id="formula_73">n j=k+1 ?X 1 j ?X 1 j?1 = I 2m?2m + ?tC 1 + O(?t 2 ),<label>(53)</label></formula><p>with</p><formula xml:id="formula_74">C 1 = ? ? ? ? ? ? C 1,1 0 . . . 0 0 C 1,2 . . . 0 . . . . . . . . . . . . . . . . . . . . . . . . 0 . . . 0 C 1,m ? ? ? ? ? ? ,<label>(54)</label></formula><p>with the block matrices C 1,i ? R 2?2 given by,</p><formula xml:id="formula_75">C 1,i = ? ? 0 (n ? k)?(c 1,i ) ?(n ? k)??(c 1,i ) ??(c 1,i )w 1,i n j=k+1 ? (A 1,i j?1 ) 0 ? ? .<label>(55)</label></formula><p>By the assumption that k &lt;&lt; n and using the fact that t n = n?t, we have that,</p><formula xml:id="formula_76">?tC 1,i = ? ? 0 t n? (c 1,i ) ?t n ??(c 1,i ) ??(c 1,i )w 1,i ?t n j=k+1 ? (A 1,i j?1 ) 0 ? ? .<label>(56)</label></formula><p>Hence, the non-zero entries in the block matrices can be O(1). Therefore, the product formula (53) is modified to, n j=k+1 ?X 1 j ?X 1</p><formula xml:id="formula_77">j?1 = C + O(?t),<label>(57)</label></formula><p>with the 2m ? 2m matrix C defined as,</p><formula xml:id="formula_78">C = ? ? ? ? ? ? C 1 0 . . . 0 0 C 2 . . . 0 . . . . . . . . . . . . . . . . . . . . . . . . 0 . . . 0 C m ? ? ? ? ? ? ,<label>(58)</label></formula><p>and,</p><formula xml:id="formula_79">C i = ? ? 1 t n? (c 1,i ) ?t n ??(c 1,i ) ??(c 1,i )w 1,i ?t n j=k+1 ? (A 1,i j?1 ) 1 ? ? .<label>(59)</label></formula><p>Thus by taking the product of (57) with <ref type="formula" target="#formula_3">(48)</ref>, we obtain that, </p><p>with C p 12 , C p 21 are the off-diagonal entries of the corresponding block matrix, defined in (59). Note that the O(?t 2 ) remainder term arises from the ?t-dependence in (48).</p><p>From <ref type="formula" target="#formula_8">(18)</ref>, we have that, ?E n ?X 1 n = y 1,1 n ? y 1 n , 0, . . . , y 1,i n ? y i n , 0, . . . , y 1,m n ? y m n , 0 .</p><p>Therefore, taking the products of (61) and (60) and substituting the explicit expressions in <ref type="formula" target="#formula_3">(48)</ref>, we obtain the desired identity (46).</p><p>C.4. On the vanishing gradient problem for the multilayer version of UnICORNN.</p><p>The explicit representation formula (46) holds for 1 hidden layer in <ref type="formula" target="#formula_5">(6)</ref>. What happens when additional hidden layers are stacked together as in UnICORNN <ref type="formula" target="#formula_5">(6)</ref>? To answer this question, we consider the concrete case of L = 3 layers as this is the largest number of layers that we have used in the context of UnICORNN with fully connected stacked layers. As before, we set the scalar parameter ? = w 1,p for some 1 ? p ? m. Similar results also hold for any other ? ? ?. We have the following representation formula for the gradient in this case, Proposition C.4. Let y n be the hidden states generated by the RNN (6). The gradient for long-term dependencies satisfies the representation formula,</p><formula xml:id="formula_82">?E (n,3) k,1 ?w 1,p = ?t 4? (c 1,p )t n ? + z 1,p k ?w 1,p m i=1? 2i?1,2p?1 y 3,i ? y i + O(?t 6 ),<label>(62)</label></formula><p>with the coefficients given by,</p><formula xml:id="formula_83">? + z 1,p k ?w 1,p = ??t?(c 1,p )? (A 1,p k?1 )y 1,p k?1 , G 2i?1,2p?1 = m j=1 G 3 ij G 2 jp , ? 1 ? i ? m, G q r,s = ?(?(c q,r )) 2 ? A q,r n?1 V q rs , q = 2, 3.<label>(63)</label></formula><p>Proof. Following the definition (44) and as L = 3 and ? = w 1,p , we have,</p><formula xml:id="formula_84">?E (n,3) k,1 ?w 1,p := ?E n ?X 3 n ?X 3 n ?X 1 k ? + X 1 k ?w 1,p .<label>(64)</label></formula><p>We will explicitly compute all three expressions on the right-hand-side of (64).</p><p>In <ref type="formula" target="#formula_3">(48)</ref>, we have already explicitly computed the right most expression in the RHS of (64). Using the product rule <ref type="formula" target="#formula_18">(19)</ref>  </p><p>with,  </p><formula xml:id="formula_86">G q,n = ? ? ? ? ? ? ? ? G q,</formula><formula xml:id="formula_87">? ? ? ? ? ? ? ? , G q,k i,? = ?(?(c q,i )) 2 ? A q,i n?1 V q i? ,<label>(67)</label></formula><formula xml:id="formula_88">0 ? ? ? ? ? ? ? ? , H q,k i,? = ??(c q,i )? A q,i n?1 V q i? .<label>(68)</label></formula><p>It is straightforward to see from <ref type="formula" target="#formula_5">(68)</ref> and <ref type="formula" target="#formula_5">(67)</ref> that,</p><formula xml:id="formula_89">H 3,n H 2,n ? 0 2m?2m , G 3,n H 2,n ? 0 2m?2m ,<label>(69)</label></formula><p>and the entries of the 2m ? 2m matrix? = G 3,n G 2,n are given by,</p><formula xml:id="formula_90">G 2r?1,2s?1 = m j=1 G 3,n r,j G 2,n j,s ,? 2r?1,2s =? 2r,2s?1 =? 2r,2s = 0, ? 1 ? r, s ? m,<label>(70)</label></formula><p>while the entries of the 2m ? 2m matrixH = H 3,n G 2,n are given b?</p><formula xml:id="formula_91">H 2r,2s?1 = m j=1 H 3,n r,j G 2,n j,s ,H 2r?1,2s?1 =H 2r?1,2s =H 2r,2s = 0, ? 1 ? r, s ? m.<label>(71)</label></formula><p>Hence we have,</p><formula xml:id="formula_92">?X 3 n ?X 2 n ?X 2 n ?X 1 n = ?t 4 (? + ?t ?1H ).<label>(72)</label></formula><p>Taking the matrix-vector product of (72) with <ref type="formula" target="#formula_5">(60)</ref> </p><formula xml:id="formula_93">+ O(?t 6 ),<label>(73)</label></formula><p>where the last identify follows from the fact that ? + y 1,p k ?w 1,p = O(?t 2 ). Therefore, taking the products of (61) and <ref type="formula" target="#formula_2">(73)</ref>, we obtain the desired identity (62).</p><p>An inspection of the representation formula (62) shows that as long as the weights are O(1) and from the bounds <ref type="formula" target="#formula_7">(7)</ref>, we know that y ? O(1), the gradient ?E (n,3) k,1 ?w 1,p ? O(?t 5 ), where the additional ?t stems from the ?t-term in (48). Thus the gradient does not depend on the recurrent step k. Hence, there is no vanishing gradient problem with respect to the number of recurrent connections, even in the multi-layer case.</p><p>However, it is clear from the representation formulas (46) and (62), as well as the proof of proposition C.4 that for L-hidden layers in UnICORNN (6), we have, ?E (n,L) k,1</p><formula xml:id="formula_94">?w 1,p ? O ?t 2L?1 .<label>(74)</label></formula><p>Thus, the gradient can become very small if too many layers are stacked together. This is not at all surprising as such a behavior occurs even if there are no recurrent connections in UnICORNN (6). In that case, we simply have a fully connected deep neural network and it is well-known that the gradient can vanish as the number of layers increases, making it harder to train deep networks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C.5. Residual stacking of layers in UnICORNN.</head><p>Given the above considerations, it makes imminent sense to modify the fully-connected stacking of layers in UnICORNN (6) if a moderately large number of layers (L ? 4) are used. It is natural to modify the fully-connected stacking with a residual stacking, see <ref type="bibr">(Li et al., 2019)</ref>. We use the following form of residual stacking,</p><formula xml:id="formula_95">y n = y n?1 + ?t?(c ) z n ,<label>(75)</label></formula><formula xml:id="formula_96">z n = z n?1 ? ?t?(c ) [? w y n?1 + x n + b l + ?y n?1 ],<label>(76)</label></formula><p>where the input x n corresponds to a residual connection skipping S layers, i.e.</p><formula xml:id="formula_97">x n = ? y ?S?1 n + V y ?1 n , for l &gt; S V y ?1 n , for l ? S .</formula><p>The number of skipped layers is 2 ? S and ? ? R m?m is a trainable matrix.</p><p>The main advantages of using a residual staking such as <ref type="formula" target="#formula_4">(75)</ref> is to alleviate the vanishing gradient problem that arises from stacking multiple layers together and obtain a better scaling of the gradient than (74). To see this, we can readily follow the proof of proposition C.4, in particular the product,</p><formula xml:id="formula_98">?X L n ?X 1 n = ? s=1 ?X L?(s?1)S n ?X L?sS k L??S =2 ?X n ?X ?1 n + L?1 =1 ?X +1 n ?X k ,<label>(77)</label></formula><p>with,</p><formula xml:id="formula_99">? = L S , if L mod S = 0, L S ? 1, if L mod S = 0.<label>(78)</label></formula><p>Here [x] ? N is the largest natural number less than or equal to x ? R.</p><p>Given the additive structure in the product of gradients and using induction over matrix products as in <ref type="formula" target="#formula_5">(69)</ref> and <ref type="formula" target="#formula_7">(70)</ref>, we can compute that, ?X L n ?X 1 n = O ?t 2(?+L??S?1 ) + O ?t 2(L?1) .</p><p>By choosing S large enough, we clearly obtain that ? + L ? ?S ? 1 &lt; L ? 1. Hence by repeating the arguments of the proof of proposition C.4, we obtain that to leading order, the gradient of the residual stacked version of UnICORNN scales like,</p><formula xml:id="formula_101">?E (n,L) k,1 ?w 1,p ? O ?t 2?+2L?2?S?1 .<label>(80)</label></formula><p>Note that <ref type="formula" target="#formula_8">(80)</ref> is far more favorable scaling for the gradient than the scaling (74) for a fully connected stacking. As a concrete example, let us consider L = 7 i.e., a network of 7 stacked layers of UniCORNN. From <ref type="formula" target="#formula_3">(74)</ref>, we see that the gradient scales like O(?t 13 ) in this case. Even for a very moderate values of ?t &lt; 1, this gradient will be very small and will ensure that the first layer will have very little, if any, influence on the loss function gradients. On the other hand, for the same number of layers L = 7, let us consider the residual stacking (75) with S = 3 skipped connections. In this case ? = 2 and one directly concludes from (80) that the gradient scales like O(?t 5 ), which is significantly larger than the gradient for the fully connected version of UnICORNN. In fact, it is exactly the same as the gradient scaling for fully connected UnICORNN (6) with 3 hidden layers (62). Thus, introducing skipped connections enabled the gradient to behave like a shallower fully-connected network, while possibly showing the expressivity of a deeper network.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Chaotic time-series prediction: Lorenz 96 system</head><p>It is instructive to explore limitations of the proposed UnICORNN. It is straightforward to prove, along the lines of the proof of proposition C.1, that the UnICORNN architecture does not exhibit chaotic behavior with respect to changes in the input. While this property is highly desirable for many applications where a slight change in the input should not lead to a major (possibly unbounded) change in the output, it impairs the performance on tasks where an actual chaotic system has to be learned.</p><p>Following the experiment in <ref type="bibr">(Rusch &amp; Mishra, 2021)</ref>, we aim to predict future states of a dynamical system, following the Lorenz 96 system <ref type="bibr">(Lorenz, 1996)</ref>:</p><formula xml:id="formula_102">x j = (x i+1 ? x i?2 )x i?1 ? x i + F,<label>(81)</label></formula><p>where x j ? R for all j = 1, . . . , 5 and F is an external force controlling the level of chaos in the system.</p><p>We consider two different choices for the external force, namely F = 0.9 and F = 8. While the first one produces non-chaotic trajectories, the latter leads to a highly chaotic system. We discretize the system exactly along the lines of (Rusch &amp; Mishra, 2021), resulting in 128 sequences of length 2000 for each the training, validation and testing set. shows the normalized root mean square error (NRMSE) for UnICORNN as well as for coRNN and an LSTM, where all models have 9k parameters. We can see that UnICORNN performs comparably to coRNN and LSTM in the chaos-free regime (i.e. F = 0.9), while performing poorly compared to an LSTM when the system exhibits chaotic behavior (i.e. F = 8). This is not surprising, as LSTMs are shown to be able to exhibit chaotic behavior <ref type="bibr">(Laurent &amp; von Brecht, 2017)</ref>, while coRNN and UnICORNN are not chaotic by design. This shows also numerically that UnICORNN should not be used for chaotic time-series prediction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E. Further experimental results</head><p>As we compare the results of the UnICORNN to the results of other recent RNN architecture, where only the best results of each RNN were published for the psMNIST, noise padded CIFAR-10 and IMDB task, we as well show the best (based on a validation set) obtained results for the UnICORNN in the main paper. However, distributional results, i.e. statistics of several re-trainings of the best performing UnICORNN based on different random initialization of the trainable parameters, provide additional insights into the performance. <ref type="table" target="#tab_12">Table 8</ref> shows the mean and standard deviation of 10 re-trainings of the best performing UnICORNN for the psMNIST, noise padded CIFAR-10 and IMDB task. We can see that in all experiments the standard deviation of the re-trainings are relatively low, which underlines the robustness of our presented results. As emphasized in the main paper and in the last section, naively stacking of many layers for the UnICORNN might result in a vanishing gradient for the deep multi-layer model, due to the vanishing gradient problem of stacking many (not necessarily recurrent) layers. Following section C.5, one can use skipped residual connections and we see that the estimate on the gradients scale preferably when using residual connections compared to a naively stacking, when using many layers. To test this also numerically, we train a standard UnICORNN (6) as well as a residual UnICORNN (res-UnICORNN) (75), with S = 2 skipping layers, on the noise padded CIFAR-10 task. <ref type="figure">Fig. 6</ref> shows the test accuracy (mean and standard deviation) of the best resulting model for different number of network layers L = 3, . . . , 6, for the standard UnICORNN and res-UnICORNN. We can see that while both models seem to perform comparably for using only few layers, i.e. L = 3, 4, the res-UnICORNN with S = 2 skipping connections outperforms the standard UnICORNN when using more layers, i.e. L = 5, 6. In particular, we can see that the standard UnICORNN is not able to significantly improve the test accuracy when using more layers, while the res-UnICORNN seems to obtain higher test accuracies when using more layers.</p><p>Moreover, <ref type="figure">Fig. 6</ref> also shows the test accuracy for a UnICORNN with an untrained time-step vector c, resulting in a UnICORNN without the multi-scale property generated by the time-step. We can see that the UnICORNN without the multi-scale feature is inferior in performance, to the standard UnICORNN as well as its residual counterpart. Finally, we recall that the estimate (14) on the gradients for UnICORNN (6) needs the weights to be bounded, see (15). One always initializes the training with bounded weights. However, it might happen that the weights explode during training. To check this issue, in <ref type="figure">Fig. 7</ref>, we plot the mean and standard deviation of the norms of the hidden weights w l for l = 1, 2, 3 during training based on 10 re-trainings of the best performing UnICORNN on the noise padded CIFAR-10 experiment. We can see that none of the norms of the weights explode during training. In fact the weight norms seem to saturate, mostly on account of reducing the learning rate after 250 epochs. Thus, the upper bound (14) can be explicitly computed and it is finite, even after training has concluded.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 .</head><label>2</label><figDesc>the results for UnICORNN with 3 layers, together with other recently pro-Measured computing time for the combined forward and backward pass for the UnICORNN as well as for three of the fastest available RNN implementations.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 .</head><label>3</label><figDesc>Test accuracy (mean and standard deviation) for the UnICORNN on EigenWorms for two types of sub-sampling approaches, i.e. using the last entries of the sequences as well as using a random subset of the entries. Both are shown for increasing number of entries used in each corresponding sub-sampling routine.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 4 .</head><label>4</label><figDesc>Ablation study on the hyperparameters ?t and ? of UnI-CORNN (6) using the noise padded CIFAR-10 experiment.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 5 .</head><label>5</label><figDesc>Effective time-step ?t?(c l i ) for each hidden neuron i = 1, . . . , m and each layer l = 1, . . . , L of UnICORNN, after training on the psMNIST task using m = 256 hidden units and L = 3 layers.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>. . . . E q,k 1m 0 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>?</head><label></label><figDesc>+ X 1 k ?w 1,p = 0, 0, . . . , . . . , ? + y 1,p k ?w 1,p + C p 12 ? + z 1,p k ?w 1,p , C p 21 ? + y 1,p k ?w 1,p + ? + z 1,p k ?w 1,p . . . , . . . , 0, 0 + O(?t 2 ),</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . G q,n m1 0 G q,n m2 0 . . . . . . G q,n mm</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 6 .Figure 7 .</head><label>67</label><figDesc>Test accuracies (mean and standard deviation of 10 retrainings of the best performing model) of the standard UnI-CORNN, res-UnICORNN and UnICORNN without multi-scale behavior on the noise padded CIFAR-10 experiment for different number of layers L. Norms (mean and standard deviation of 10 re-trainings) of the hidden weights w l ?, for l = 1, 2, 3, of the UnICORNN during training.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 2</head><label>2</label><figDesc>, anti.sym. RNN and gated anti.sym. RNN(Chang et al.,  2018), Lipschitz RNN<ref type="bibr" target="#b11">(Erichson et al., 2021)</ref>, Incremental RNN(Kag et al.),FastRNN (Kusupati et al., 2018)  and coRNN</figDesc><table /><note>shows the result of the UnICORNN with 3 layers together with the results of other recently proposed RNNs, namely for the LSTM</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 2 .</head><label>2</label><figDesc>Test accuracies on noise padded CIFAR-10 together with number of hidden units as well as total number of parameters M for each network. All other results are taken from literature, specified in the main text.</figDesc><table><row><cell>MODEL</cell><cell>TEST ACC.</cell><cell cols="2">#UNITS M</cell></row><row><cell>LSTM</cell><cell>11.6%</cell><cell>128</cell><cell>64K</cell></row><row><cell>INCREMENTAL RNN</cell><cell>54.5%</cell><cell>128</cell><cell>12K</cell></row><row><cell>LIPSCHITZ RNN</cell><cell>55.8%</cell><cell>256</cell><cell>158K</cell></row><row><cell>FASTRNN</cell><cell>45.8%</cell><cell>128</cell><cell>16K</cell></row><row><cell>ANTI.SYM. RNN</cell><cell>48.3%</cell><cell>256</cell><cell>36K</cell></row><row><cell cols="2">GATED ANTI.SYM. RNN 54.7%</cell><cell>256</cell><cell>37K</cell></row><row><cell>CORNN</cell><cell>59.0%</cell><cell>128</cell><cell>46K</cell></row><row><cell>UNICORNN (L=3)</cell><cell>62.4%</cell><cell>128</cell><cell>47K</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 3</head><label>3</label><figDesc>, show that while sub-sampling approaches yield moderate test accuracies, expRNN as well as the IndRNN yield very poor accuracies. In contrast, coRNN performs very well. However, the best results are obtained for UnI-CORNN as it reaches a test accuracy of more than 90%, while at the same time yielding a relatively low standard deviation, further underlining the robustness of the proposed RNN.</figDesc><table /><note>As this data set has only recently been proposed as a test for RNNs in learning LTDs, it is unclear if the input sequences</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 3 .</head><label>3</label><figDesc>Test accuracies on EigenWorms using 5 re-trainings of each best performing network (based on the validation set) together with number of hidden units as well as total number of parameters M for each network.</figDesc><table><row><cell>MODEL</cell><cell>TEST ACC.</cell><cell cols="2">#UNITS M</cell></row><row><cell>T-BPTT LSTM</cell><cell>57.9% ? 7.0%</cell><cell>32</cell><cell>5.3K</cell></row><row><cell>SUB-SAMP. LSTM</cell><cell>69.2% ? 8.3%</cell><cell>32</cell><cell>5.3K</cell></row><row><cell>SIGN.-NCDE</cell><cell>77.8% ? 5.9%</cell><cell>32</cell><cell>35K</cell></row><row><cell>EXPRNN</cell><cell cols="2">40.0% ? 10.1% 64</cell><cell>2.8K</cell></row><row><cell>INDRNN (L=2)</cell><cell>49.7% ? 4.8%</cell><cell>32</cell><cell>1.6K</cell></row><row><cell>CORNN</cell><cell>86.7% ? 3.0%</cell><cell>32</cell><cell>2.4K</cell></row><row><cell cols="2">UNICORNN (L=2) 90.3% ? 3.0%</cell><cell>32</cell><cell>1.5K</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>Healthcare application: Vital signs prediction We apply UnICORNN on two real-world data sets in health care, aiming to predict the vital signs of a patient, based on PPG and ECG signals. The data sets are part of the TSR archive(Tan et al., 2020)  and are based on clinical data from the Beth Israel Deaconess Medical Center. The PPG and ECG signals are sampled with a frequency of 125Hz for 8 minutes each. The resulting two-dimensional sequences have a length of 4000. The goal is to predict a patient's respiratory rate (RR) and heart rate (HR) based on these signals. We compare UnICORNN to 3 leading RNN architectures for solving LTDs, i.e. expRNN, IndRNN and coRNN. Additionally, we present two baselines using the LSTM as well as the recently proposed sub-sampling method of computing signatures for neural controlled differential equations (NCDE)(Morrill et al., 2020). Following (Morrill et al., 2020), we split the 7949 sequences in a training set, validation set and</figDesc><table><row><cell></cell><cell>90</cell><cell></cell></row><row><cell>Test accuracy in %</cell><cell>60 70 80</cell><cell>Last entries of sequences</cell></row><row><cell></cell><cell></cell><cell>Randomly selected entries</cell></row><row><cell></cell><cell></cell><cell>5000 Number of sequence entries used for training 10000 15000</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>Table 4 .Table 5 .</head><label>45</label><figDesc>L 2 test error on vital sign prediction using 5 re-trainings of each best performing network (based on the validation set), where the respiratory rate (RR) and heart rate (HR) is estimated based on PPG and ECG data. UNICORNN (L=3) 1.06 ? 0.03 1.39 ? 0.09 Test accuracies on IMDB together with number of hidden units as well as total number of parameters M (without embedding) for each network. All other results are taken from literature, specified in the main text.</figDesc><table><row><cell>MODEL</cell><cell>RR</cell><cell>HR</cell></row><row><cell>SIGN.-NCDE</cell><cell cols="2">1.51 ? 0.08 2.97 ? 0.45</cell></row><row><cell>LSTM</cell><cell cols="2">2.28 ? 0.25 10.7 ? 2.0</cell></row><row><cell>EXPRNN</cell><cell cols="2">1.57 ? 0.16 1.87 ? 0.19</cell></row><row><cell>INDRNN (L=3)</cell><cell cols="2">1.47 ? 0.09 2.10 ? 0.2</cell></row></table><note>CORNN 1.45 ? 0.23 1.71 ? 0.1</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head></head><label></label><figDesc>rent neural networks. In 6th International Conference on Learning Representations, ICLR 2018, Vancouver, BC, Canada, April 30 -May 3, 2018, Conference Track Proceedings, 2018. Casado, M. L. Trivializations for gradient-based optimization on manifolds. In Advances in Neural Information Processing Systems, pp. 9154-9164, 2019. April 24-26, 2017, Conference Track Proceedings. OpenReview.net, 2017. Le, Q. V., Jaitly, N., and Hinton, G. E. A simple way to initialize recurrent networks of rectified linear units. arXiv preprint arXiv:1504.00941, 2015. Pennington, J., Socher, R., and Manning, C. D. Glove: Global vectors for word representation. In Proceedings of the 2014 Conference on Empirical Methods in Natural Language Processing (EMNLP), pp. 1532-1543, 2014. Pimentel, M. A., Johnson, A. E., Charlton, P. H.</figDesc><table><row><cell cols="2">Supplementary Material for</cell></row><row><cell cols="2">, Birrenkott, "UnICORNN: A recurrent model for learning very long time dependencies"</cell></row><row><cell></cell><cell>D., Watkinson, P. J., Tarassenko, L., and Clifton, D. A.</cell></row><row><cell>LeCun, Y., Bottou, L., Bengio, Y., and Haffner, P. Gradient-</cell><cell>Toward a robust estimation of respiratory rate from pulse</cell></row><row><cell>based learning applied to document recognition. Proceed-Casado, M. L. and Mart?nez-Rubio, D. Cheap orthogonal constraints in neural networks: A simple parametrization ings of the IEEE, 86(11):2278-2324, 1998. A. Training details</cell><cell>oximeters. IEEE Transactions on Biomedical Engineer-ing, 64(8):1914-1923, 2016.</cell></row><row><cell>of the orthogonal and unitary group. In Proceedings of LeCun, Y., Bengio, Y., and Hinton, G. Deep learning. Na-</cell><cell>Rusch, T. K. and Mishra, S. Coupled oscillatory recurrent</cell></row><row><cell>the 36th International Conference on Machine Learn-ture, 521:436-444, 2015.</cell><cell>neural network (cornn): An accurate and (gradient) sta-</cell></row><row><cell>ing, ICML 2019, volume 97 of Proceedings of Machine</cell><cell>ble architecture for learning long time dependencies. In</cell></row><row><cell>Learning Research, pp. 3794-3803, 2019. Lei, T., Zhang, Y., Wang, S. I., Dai, H., and Artzi, Y. Sim-</cell><cell>International Conference on Learning Representations,</cell></row><row><cell>ple recurrent units for highly parallelizable recurrence. Chang, B., Chen, M., Haber, E., and Chi, E. H. Antisym-In Empirical Methods in Natural Language Processing metricrnn: A dynamical system view on recurrent neural (EMNLP), 2018. networks. In International Conference on Learning Rep-Li, S., Li, W., Cook, C., Zhu, C., and Gao, Y. Independently resentations, 2018.</cell><cell>2021. Sanz Serna, J. and Calvo, M. Numerical Hamiltonian prob-lems. Chapman and Hall, London, 1994.</cell></row><row><cell>recurrent neural network (indrnn): Building a longer and</cell><cell>Strogatz, S. Nonlinear Dynamics and Chaos. Westview,</cell></row><row><cell>deeper rnn. In Proceedings of the IEEE conference on</cell><cell>Boulder CO, 2015.</cell></row><row><cell>computer vision and pattern recognition, pp. 5457-5466,</cell><cell></cell></row><row><cell>2018.</cell><cell></cell></row><row><cell>arXiv preprint</cell><cell></cell></row><row><cell>arXiv:1910.06251, 2019.</cell><cell>):1550-</cell></row><row><cell>Lorenz, E. N. Predictability: A problem partly solved. In</cell><cell>1560, 1990.</cell></row><row><cell>Proc. Seminar on Predictability, volume 1, 1996.</cell><cell>Wisdom, S., Powers, T., Hershey, J., Le Roux, J., and Atlas,</cell></row><row><cell>Maas, A. L., Daly, R. E., Pham, P. T., Huang, D., Ng, A. Y., and Potts, C. Learning word vectors for sentiment anal-ysis. In Proceedings of the 49th Annual Meeting of the</cell><cell>L. Full-capacity unitary recurrent neural networks. In Advances in Neural Information Processing Systems, pp. 4880-4888, 2016.</cell></row><row><cell>Association for Computational Linguistics: Human Lan-</cell><cell></cell></row><row><cell>guage Technologies, volume 1, pp. 142-150. Association</cell><cell></cell></row><row><cell>for Computational Linguistics, 2011.</cell><cell></cell></row><row><cell>MacKay, M., Vicol, P., Ba, J., and Grosse, R. B. Reversible</cell><cell></cell></row><row><cell>recurrent neural networks. In Advances in Neural Infor-</cell><cell></cell></row><row><cell>mation Processing Systems, pp. 9029-9040, 2018.</cell><cell></cell></row><row><cell>Morrill, J., Kidger, P., Salvi, C., Foster, J., and Lyons, T.</cell><cell></cell></row><row><cell>Neural cdes for long time series via the log-ode method.</cell><cell></cell></row><row><cell>arXiv preprint arXiv:2009.08295, 2020.</cell><cell></cell></row><row><cell>Papamakarios, G., Nalisnick, E., Rezende, D. J., Mohamed,</cell><cell></cell></row><row><cell>S., and Lakshminarayanan, B. Normalizing flows for</cell><cell>Kusupati, A., Singh, M., Bhatia, K., Kumar, A., Jain, P.,</cell></row><row><cell>probabilistic modeling and inference. arXiv preprint</cell><cell>and Varma, M. Fastgrnn: A fast, accurate, stable and</cell></row><row><cell>arXiv:1912.02762v1, 2019.</cell><cell>tiny kilobyte sized gated recurrent neural network. In</cell></row><row><cell></cell><cell>Advances in Neural Information Processing Systems, pp.</cell></row><row><cell></cell><cell>9017-9028, 2018.</cell></row></table><note>Laurent, T. and von Brecht, J. A recurrent neural network without chaos. In 5th International Conference on Learn- ing Representations, ICLR 2017, Toulon, France,Li, S., Li, W., Cook, C., Gao, Y., and Zhu, C. Deep indepen- dently recurrent neural network (indrnn).Pascanu, R., Mikolov, T., and Bengio, Y. On the difficulty of training recurrent neural networks. In Proceedings of the 30th International Conference on Machine Learning, vol- ume 28 of ICML'13, pp. III-1310-III-1318. JMLR.org, 2013.Tan, C. W., Bergmeir, C., Petitjean, F., and Webb, G. I. Monash university, uea, ucr time series regression archive. arXiv preprint arXiv:2006.10996, 2020. Werbos, P. J. Backpropagation through time: what it does and how to do it. Proceedings of the IEEE, 78(10</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9"><head></head><label></label><figDesc>12 0 . . . . . . H q,n 1m 0 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</figDesc><table><row><cell>and</cell><cell>?</cell><cell>0</cell><cell>0</cell><cell>0</cell><cell>0 . . . . . .</cell><cell>0</cell><cell>0</cell></row><row><cell>H q,n =</cell><cell cols="2">? H q,n 11 ? ? ? ? ? 0 ? H q,n m1</cell><cell cols="2">0 H q,n 0 0 0 H q,n m2</cell><cell cols="2">. . . 0 0 . . . . . . H q,n 0 . . . . . . mm</cell><cell>. . . 0</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_11"><head>Table 7 Table 7 .</head><label>77</label><figDesc>Test NRMSE on the Lorenz 96 system (81) for UnICORNN, coRNN and LSTM.</figDesc><table><row><cell>Model</cell><cell>F = 0.9</cell><cell>F = 8</cell><cell cols="2"># units # params</cell></row><row><cell cols="4">LSTM (Rusch &amp; Mishra, 2021) coRNN (Rusch &amp; Mishra, 2021) 2.0 ? 10 ?2 9.8 ? 10 ?2 64 2.0 ? 10 ?2 6.8 ? 10 ?2 44 UnICORNN (L=2) 2.2 ? 10 ?2 3.1 ? 10 ?1 90</cell><cell>9k 9k 9k</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_12"><head>Table 8 .</head><label>8</label><figDesc>Distributional information (mean and standard deviation) on the results for the classification experiment presented in the paper, where only the best results is shown, based on 10 re-trainings of the best performing UnICORNN using different random seeds.</figDesc><table><row><cell>Experiment</cell><cell>Mean</cell><cell>Standard deviation</cell></row><row><cell>psMNIST (128 units)</cell><cell cols="2">97.7% 0.09%</cell></row><row><cell>psMNIST (256 units)</cell><cell cols="2">98.2% 0.22%</cell></row><row><cell cols="3">Noise padded CIFAR-10 61.5% 0.52%</cell></row><row><cell>IMDB</cell><cell cols="2">88.1% 0.19%</cell></row></table><note></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>The research of TKR and SM was performed under a project that has received funding from the European Research Council (ERC) under the European Union's Horizon 2020 research and innovation programme (grant agreement No. 770880).</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Optimizing performance of recurrent neural networks on gpus</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Appleyard</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Kocisky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Blunsom</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1604.01946</idno>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Unitary evolution recurrent neural networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Arjovsky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Shah</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Bengio</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Machine Learning</title>
		<imprint>
			<date type="published" when="2016" />
			<biblScope unit="page" from="1120" to="1128" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Mathematical methods of classical mechanics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><forename type="middle">I</forename><surname>Arnold</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1989" />
			<publisher>Springer Verlag</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">The uea multivariate time series classification archive</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Bagnall</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">A</forename><surname>Dau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Lines</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Flynn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Large</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Bostrom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Southam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Keogh</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1811.00075</idno>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Campos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Jou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Gir?-I-Nieto</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Torres</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chang</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename></persName>
		</author>
		<title level="m">Skip RNN: learning to skip state updates in recur</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Dilated recurrent neural networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Guo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Tan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Cui</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Witbrock</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">A</forename><surname>Hasegawa-Johnson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">S</forename><surname>Huang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems</title>
		<imprint>
			<date type="published" when="2017" />
			<biblScope unit="page" from="77" to="87" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Neural ordinary differential equations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">T</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Rubanova</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Bettencourt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">K</forename><surname>Duvenaud</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems</title>
		<imprint>
			<date type="published" when="2018" />
			<biblScope unit="page" from="6571" to="6583" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Symplectic recurrent neural networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Arjovsky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Bottou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">8th International Conference on Learning Representations</title>
		<meeting><address><addrLine>Addis Ababa, Ethiopia</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2020" />
			<biblScope unit="volume">2020</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Learning phrase representations using rnn encoder-decoder for statistical machine translation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Cho</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Van Merrienboer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Gulcehre</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Bougares</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Schwenk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Bengio</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Conference on Empirical Methods in Natural Language Processing</title>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Gate-variants of gated recurrent unit (gru) neural networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Dey</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><forename type="middle">M</forename><surname>Salemt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2017 IEEE 60th International Midwest Symposium on Circuits and Systems (MWSCAS)</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2017" />
			<biblScope unit="page" from="1597" to="1600" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">A proposal on machine learning via dynamical systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. Math. Stat</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="1" to="11" />
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Lipschitz recurrent neural networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><forename type="middle">B</forename><surname>Erichson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Azencot</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Queiruga</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">W</forename><surname>Mahoney</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Learning Representations</title>
		<imprint>
			<date type="published" when="2021" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A theoretically grounded application of dropout in recurrent neural networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Gal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Ghahramani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in neural information processing systems</title>
		<imprint>
			<date type="published" when="2016" />
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="page" from="1019" to="1027" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Hamiltonian neural networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Greydanus</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Dzamba</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yosinski</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems</title>
		<imprint>
			<date type="published" when="2019" />
			<biblScope unit="page" from="15379" to="15389" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Nonlinear oscillations, dynamical systems, and bifurcations of vector fields</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Guckenheimer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Holmes</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1990" />
			<publisher>Springer Verlag</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Geometric numerical integration illustrated by the st?rmer-verlet method</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Hairer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Lubich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Wanner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Acta Numerica</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="399" to="450" />
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Delving deep into rectifiers: Surpassing human-level performance on imagenet classification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Sun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE international conference on computer vision</title>
		<meeting>the IEEE international conference on computer vision</meeting>
		<imprint>
			<date type="published" when="2015" />
			<biblScope unit="page" from="1026" to="1034" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Orthogonal recurrent neural networks with scaled cayley transform</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Helfrich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Willmott</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ye</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Q</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Machine Learning</title>
		<imprint>
			<publisher>PMLR</publisher>
			<date type="published" when="2018" />
			<biblScope unit="page" from="1969" to="1978" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Recurrent orthogonal networks and long-memory tasks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Henaff</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Szlam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Lecun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of The 33rd International Conference on Machine Learning</title>
		<editor>Balcan, M. F. and Weinberger, K. Q.</editor>
		<meeting>The 33rd International Conference on Machine Learning</meeting>
		<imprint>
			<date type="published" when="2016" />
			<biblScope unit="volume">48</biblScope>
			<biblScope unit="page" from="2034" to="2042" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Long short-term memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Hochreiter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Schmidhuber</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Neural computation</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="1735" to="1780" />
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Rnns incrementally evolving on an equilibrium manifold: A panacea for vanishing and exploding gradients?</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Kag</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Saligrama</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">8th International Conference on Learning Representations</title>
		<meeting><address><addrLine>Addis Ababa, Ethiopia</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2020" />
			<biblScope unit="volume">2020</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Non-normal recurrent neural network (nnrnn): learning long time dependencies while improving expressivity with transient dynamics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Kerg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Goyette</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">P</forename><surname>Touzel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Gidel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Vorontsov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Bengio</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Lajoie</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems</title>
		<imprint>
			<date type="published" when="2019" />
			<biblScope unit="page" from="13591" to="13601" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Learning multiple layers of features from tiny images</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Krizhevsky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Hinton</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
