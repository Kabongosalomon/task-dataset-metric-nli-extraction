<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /nfs/home/kabenamualus/Research/task-dataset-metric-extraction/../grobid-0.6.0/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Published as a conference paper at ICLR 2020 QUERY2BOX: REASONING OVER KNOWLEDGE GRAPHS IN VECTOR SPACE USING BOX EMBEDDINGS</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hongyu</forename><surname>Ren</surname></persName>
							<email>hyren@cs.stanford.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Stanford University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Weihua</forename><surname>Hu</surname></persName>
							<email>weihuahu@cs.stanford.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Stanford University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jure</forename><surname>Leskovec</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Stanford University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Published as a conference paper at ICLR 2020 QUERY2BOX: REASONING OVER KNOWLEDGE GRAPHS IN VECTOR SPACE USING BOX EMBEDDINGS</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>

		<encodingDesc>
			<appInfo>
				<application version="0.6.0" ident="GROBID-SDO" when="2022-11-12T09:21+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid-sdo"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Answering complex logical queries on large-scale incomplete knowledge graphs (KGs) is a fundamental yet challenging task. Recently, a promising approach to this problem has been to embed KG entities as well as the query into a vector space such that entities that answer the query are embedded close to the query. However, prior work models queries as single points in the vector space, which is problematic because a complex query represents a potentially large set of its answer entities, but it is unclear how such a set can be represented as a single point. Furthermore, prior work can only handle queries that use conjunctions (?) and existential quantifiers (?). Handling queries with logical disjunctions (?) remains an open problem. Here we propose QUERY2BOX, an embedding-based framework for reasoning over arbitrary queries with ?, ?, and ? operators in massive and incomplete KGs. Our main insight is that queries can be embedded as boxes (i.e., hyper-rectangles), where a set of points inside the box corresponds to a set of answer entities of the query. We show that conjunctions can be naturally represented as intersections of boxes and also prove a negative result that handling disjunctions would require embedding with dimension proportional to the number of KG entities. However, we show that by transforming queries into a Disjunctive Normal Form, QUERY2BOX is capable of handling arbitrary logical queries with ?, ?, ? in a scalable manner. We demonstrate the effectiveness of QUERY2BOX on three large KGs and show that QUERY2BOX achieves up to 25% relative improvement over the state of the art. * Equal contributions. Project website with data and code: http://snap.stanford.edu/ query2box</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Knowledge graphs (KGs) capture different types of relationships between entities, e.g., Canada citizen ????? Hinton. Answering arbitrary logical queries, such as "where did Canadian citizens with Turing Award graduate?", over such KGs is a fundamental task in question answering, knowledge base reasoning, as well as AI more broadly.</p><p>First-order logical queries can be represented as Directed Acyclic Graphs (DAGs) ( <ref type="figure">Fig. 1(A)</ref>) and be reasoned according to the DAGs to obtain a set of answers ( <ref type="figure">Fig. 1(C)</ref>). While simple and intuitive, such approach has many drawbacks: (1) Computational complexity of subgraph matching is exponential in the query size, and thus cannot scale to modern KGs; (2) Subgraph matching is very sensitive as it cannot correctly answer queries with missing relations. To remedy (2) one could impute missing relations <ref type="bibr" target="#b18">(Koller et al., 2007;</ref><ref type="bibr" target="#b11">D?eroski, 2009;</ref><ref type="bibr" target="#b10">De Raedt, 2008;</ref><ref type="bibr" target="#b24">Nickel et al., 2016)</ref> but that would only make the KG denser, which would further exacerbate issue (1) <ref type="bibr" target="#b6">(Dalvi &amp; Suciu, 2007;</ref><ref type="bibr" target="#b19">Krompa? et al., 2014)</ref>.</p><p>Recently, a promising alternative approach has emerged, where logical queries as well as KG entities are embedded into a low-dimensional vector space such that entities that answer the query are embedded close to the query <ref type="bibr" target="#b13">(Guu et al., 2015;</ref><ref type="bibr" target="#b14">Hamilton et al., 2018;</ref><ref type="bibr" target="#b8">Das et al., 2017)</ref>. Such approach robustly handles missing relations <ref type="bibr" target="#b14">(Hamilton et al., 2018)</ref> and is also orders of magnitude faster, as answering an arbitrary logical query is reduced to simply identifying entities nearest to the embedding of the query in the vector space. <ref type="figure">Figure 1</ref>: Query2Box reasoning framework. (A) A given conjunctive query "Where did Canadian citizens with Turing Award graduate?" can be represented with a dependency graph. (B) Computation graph specifies the reasoning procedure to obtain a set of answers for the query in (A). (C) Example knowledge graph, where green nodes/entities denote answers to the query. Bold arrows indicate subgraphs that match the query graph in (A). (D) In QUERY2BOX, nodes of the KG are embedded as points in the vector space. We then obtain query embedding according to the computation graph (B) as a sequence of box operations: start with two nodes TuringAward and Canada and apply Win and Citizen projection operators, followed by an intersection operator (denoted as a shaded intersection of yellow and orange boxes) and another projection operator. The final embedding of the query is a green box and query's answers are the entities inside the box.</p><p>However, prior work embeds a query into a single point in the vector space. This is problematic because answering a logical query requires modeling a set of active entities while traversing the KG <ref type="figure">(Fig. 1(C)</ref>), and how to effectively model a set with a single point is unclear. Furthermore, it is also unnatural to define logical operators (e.g., set intersection) of two points in the vector space. Another fundamental limitation of prior work is that it can only handle conjunctive queries, a subset of first-order logic that only involves conjunction (?) and existential quantifier (?), but not disjunction (?). It remains an open question how to handle disjunction effectively in the vector space.</p><p>Here we present QUERY2BOX, an embedding-based framework for reasoning over KGs that is capable of handling arbitrary Existential Positive First-order (EPFO) logical queries (i.e., queries that include any set of ?, ?, and ?) in a scalable manner. First, to accurately model a set of entities, our key idea is to use a closed region rather than a single point in the vector space. Specifically, we use a box (axis-aligned hyper-rectangle) to represent a query ( <ref type="figure">Fig. 1(D)</ref>). This provides three important benefits:</p><p>(1) Boxes naturally model sets of entities they enclose; (2) Logical operators (e.g., set intersection) can naturally be defined over boxes similarly as in Venn diagrams (Venn, 1880); (3) Executing logical operators over boxes results in new boxes, which means that the operations are closed; thus, logical reasoning can be efficiently performed in QUERY2BOX by iteratively updating boxes according to the query computation graph ( <ref type="figure">Fig. 1(B)</ref></p><formula xml:id="formula_0">(D)).</formula><p>We show that QUERY2BOX can naturally handle conjunctive queries. We first prove a negative result that embedding EPFO queries to only single points or boxes is intractable as it would require embedding dimension proportional to the number of KG entities. However, we provide an elegant solution, where we transform a given EPFO logical query into a Disjunctive Normal Form (DNF) <ref type="bibr" target="#b9">(Davey &amp; Priestley, 2002)</ref>, i.e., disjunction of conjunctive queries. Given any EPFO query, QUERY2BOX represents it as a set of individual boxes, where each box is obtained for each conjunctive query in the DNF. We then return nearest neighbor entities to any of the boxes as the answers to the query. This means that to answer any EPFO query we first answer individual conjunctive queries and then take the union of the answer entities.</p><p>We evaluate QUERY2BOX on three standard KG benchmarks and show: (1) QUERY2BOX provides strong generalization as it can answer complex queries; (2) QUERY2BOX can generalize to new logical query structures that it has never seen during training; (3) QUERY2BOX is able to implicitly impute missing relations as it can answer any EPFO query with high accuracy even when relations involving answering the query are missing in the KG; (4) QUERY2BOX provides up to 25% relative improvement in accuracy of answering EPFO queries over state-of-the-art baselines.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">FURTHER RELATED WORK</head><p>Most related to our work are embedding approaches for multi-hop reasoning over KGs <ref type="bibr" target="#b5">(Bordes et al., 2013;</ref><ref type="bibr" target="#b8">Das et al., 2017;</ref><ref type="bibr" target="#b13">Guu et al., 2015;</ref><ref type="bibr" target="#b14">Hamilton et al., 2018)</ref>. Crucial difference is that we provide a way to tractably handle a larger subset of the first-order logic (EPFO queries vs. conjunctive queries) and that we embed queries as boxes, which provides better accuracy and generalization.</p><p>Second line of related work is on structured embeddings, which associate images, words, sentences, or knowledge base concepts with geometric objects such as regions <ref type="bibr" target="#b12">(Erk, 2009;</ref><ref type="bibr" target="#b31">Vilnis et al., 2018;</ref><ref type="bibr" target="#b22">Li et al., 2019)</ref>, densities <ref type="bibr" target="#b30">(Vilnis &amp; McCallum, 2014;</ref><ref type="bibr" target="#b15">He et al., 2015;</ref><ref type="bibr" target="#b1">Athiwaratkun &amp; Wilson, 2018)</ref>, and orderings <ref type="bibr" target="#b28">(Vendrov et al., 2016;</ref><ref type="bibr" target="#b20">Lai &amp; Hockenmaier, 2017;</ref><ref type="bibr" target="#b21">Li et al., 2017)</ref>. While the above work uses geometric objects to model individual entities and their pairwise relations, we use the geometric objects to model sets of entities and reason over those sets. In this sense our work is also related to classical Venn Diagrams <ref type="bibr" target="#b29">(Venn, 1880)</ref>, where boxes are essentially the Venn Diagrams in vector space, but our boxes and entity embeddings are jointly learned, which allows us to reason over incomplete KGs.</p><p>Box embeddings have also been used to model hierarchical nature of concepts in an ontology with uncertainty <ref type="bibr" target="#b31">(Vilnis et al., 2018;</ref><ref type="bibr" target="#b22">Li et al., 2019)</ref>. While our work is also based on box embeddings we employ them for logical reasoning in massive heterogeneous knowledge graphs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">QUERY2BOX: LOGICAL REASONING OVER KGS IN VECTOR SPACE</head><p>Here we present the QUERY2BOX, where we will define an objective function that allows us to learn embeddings of entities in the KG, and at the same time also learn parameterized geometric logical operators over boxes. Then given an arbitrary EPFO query q ( <ref type="figure">Fig. 1(A)</ref>), we will identify its computation graph ( <ref type="figure">Fig. 1(B)</ref>), and embed the query by executing a set of geometric operators over boxes ( <ref type="figure">Fig. 1(D)</ref>). Entities that are enclosed in the final box embedding are returned as answers to the query ( <ref type="figure">Fig. 1(D)</ref>).</p><p>In order to train our system, we generate a set of queries together with their answers at training time and then learn entity embeddings and geometric operators such that queries can be accurately answered. We show in the following sections that our approach is able to generalize to queries and logical structures never seen during training. Furthermore, as we show in experiments, our approach is able to implicitly impute missing relations and answer queries that would be impossible to answer with traditional graph traversal methods.</p><p>In the following we first only consider conjunctive queries (conjunction and existential operator) and then we extend our method to also include disjunction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">KNOWLEDGE GRAPHS AND CONJUNCTIVE QUERIES</head><p>We denote a KG as G = (V, R), where v ? V represents an entity, and r ? R is a binary function r : V ? V ? {True, False}, indicating whether the relation r holds between a pair of entities or not. In the KG, such binary output indicates the existence of the directed edge between a pair of entities,</p><formula xml:id="formula_1">i.e., v r ? ? v iff r(v, v ) = True.</formula><p>Conjunctive queries are a subclass of the first-order logical queries that use existential (?) and conjunction (?) operations. They are formally defined as follows.</p><formula xml:id="formula_2">q[V ? ] = V ? . ?V 1 , . . . , V k : e 1 ? e 2 ? ... ? e n ,<label>(1)</label></formula><formula xml:id="formula_3">where e i = r(v a , V ), V ? {V ? , V 1 , . . . , V k }, v a ? V, r ? R, or e i = r(V, V ), V, V ? {V ? , V 1 , . . . , V k }, V = V , r ? R,</formula><p>where v a represents non-variable anchor entity, V 1 , . . . , V k are existentially quantified bound variables, V ? is the target variable. The goal of answering the logical query q is to find a set of entities q ? V such that v ? q iff q[v] = True. We call q the denotation set (i.e., answer set) of query q.</p><p>As shown in <ref type="figure">Fig. 1(A)</ref>, the dependency graph is a graphical representation of conjunctive query q, where nodes correspond to variable or non-variable entities in q and edges correspond to relations in q. In order for the query to be valid, the corresponding dependency graph needs to be a Directed Acyclic Graph (DAG), with the anchor entities as the source nodes of the DAG and the query target V ? as the unique sink node <ref type="bibr" target="#b14">(Hamilton et al., 2018)</ref>.</p><p>From the dependency graph of query q, one can also derive the computation graph, which consists of two types of directed edges that represent operators over sets of entities:</p><p>? Projection: Given a set of entities S ? V, and relation r ? R, this operator obtains</p><formula xml:id="formula_4">? v?S A r (v), where A r (v) ? {v ? V : r(v, v ) = True}.</formula><p>? Intersection: Given a set of entity sets {S 1 , S 2 , . . . , S n }, this operator obtains ? n i=1 S i . For a given query q, the computation graph specifies the procedure of reasoning to obtain a set of answer entities, i.e., starting from a set of anchor nodes, the above two operators are applied iteratively until the unique sink target node is reached. The entire procedure is analogous to traversing KGs following the computation graph <ref type="bibr" target="#b13">(Guu et al., 2015)</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">REASONING OVER SETS OF ENTITIES USING BOX EMBEDDINGS</head><p>So far we have defined conjunctive queries as computation graphs that can be executed directly over the nodes and edges in the KG. Now, we define logical reasoning in the vector space. Our intuition follows <ref type="figure">Fig. 1</ref>: Given a complex query, we shall decompose it into a sequence of logical operations, and then execute these operations in the vector space. This way we will obtain the embedding of the query, and answers to the query will be entities that are enclosed in the final query embedding box.</p><p>In the following, we detail our two methodological advances: (1) the use of box embeddings to efficiently model and reason over sets of entities in the vector space, and (2) how to tractably handle disjunction operator (?), expanding the class of first-order logic that can be modeled in the vector space (Section 3.3).</p><p>Box embeddings. To efficiently model a set of entities in the vector space, we use boxes (i.e., axis-aligned hyper-rectangles). The benefit is that unlike a single point, the box has the interior; thus, if an entity is in a set, it is natural to model the entity embedding to be a point inside the box. Formally, we operate on R d , and define a box in R d by p = (Cen(p), Off(p)) ? R 2d as:</p><formula xml:id="formula_5">Box p ? {v ? R d : Cen(p) ? Off(p) v Cen(p) + Off(p)},<label>(2)</label></formula><p>where is element-wise inequality, Cen(p) ? R d is the center of the box, and Off(p) ? R d ?0 is the positive offset of the box, modeling the size of the box. Each entity v ? V in KG is assigned a single vector v ? R d (i.e., a zero-size box), and the box embedding p models {v ? V : v ? Box p }, i.e., a set of entities whose vectors are inside the box. For the rest of the paper, we use the bold face to denote the embedding, e.g., embedding of v is denoted by v.</p><p>Our framework reasons over KGs in the vector space following the computation graph of the query, as shown in <ref type="figure">Fig. 1(D)</ref>: we start from the initial box embeddings of the source nodes (anchor entities) and sequentially update the embeddings according to the logical operators. Below, we describe how we set initial box embeddings for the source nodes, as well as how we model projection and intersection operators (defined in Sec. 3.1) as geometric operators that operate over boxes. After that, we describe our entity-to-box distance function and the overall objective that learns embeddings as well as the geometric operators.</p><p>Initial boxes for source nodes. Each source node represents an anchor entity v ? V, which we can regard as a set that only contains the single entity. Such a single-element set can be naturally modeled by a box of size/offset zero centered at v. Formally, we set the initial box embedding as (v, 0), where v ? R d is the anchor entity vector and 0 is a d-dimensional all-zero vector.</p><p>Geometric projection operator. We associate each relation r ? R with relation embedding r = (Cen(r), Off(r)) ? R 2d with Off(r) 0. Given an input box embedding p, we model the projection by p + r, where we sum the centers and sum the offsets. This gives us a new box with the translated center and larger offset because Off(r) 0, as illustrated in <ref type="figure" target="#fig_0">Fig. 2(A)</ref>. The adaptive box size effectively models a different number of entities/vectors in the set.</p><p>Geometric intersection operator. We model the intersection of a set of box embeddings {p 1 , . . . , p n } as p inter = (Cen(p inter ), Off(p inter )), which is calculated by performing attention over the box centers <ref type="bibr" target="#b2">(Bahdanau et al., 2015)</ref> and shrinking the box offset using the sigmoid function:</p><formula xml:id="formula_6">Cen(p inter ) = i a i Cen(p i ), a i = exp(MLP(p i )) j exp(MLP(p j )) , Off(p inter ) = Min({Off(p 1 ), . . . , Off(p n )}) ?(DeepSets({p 1 , . . . , p n })), where is the dimension-wise product, MLP(?) : R 2d ? R d is the Multi-Layer Perceptron, ?(?)</formula><p>is the sigmoid function, DeepSets(?) is the permutation-invariant deep architecture <ref type="bibr" target="#b33">(Zaheer et al., 2017)</ref>, and both Min(?) and exp(?) are applied in a dimension-wise manner. Following <ref type="bibr" target="#b14">Hamilton et al. (2018)</ref>, we model all the deep sets by</p><formula xml:id="formula_7">DeepSets({x 1 , . . . , x N }) = MLP((1/N ) ? N i=1 MLP(x i ))</formula><p>, where all the hidden dimensionalities of the two MLPs are the same as the input dimensionality. The intuition behind our geometric intersection is to generate a smaller box that lies inside a set of boxes, as illustrated in <ref type="figure" target="#fig_0">Fig. 2(B)</ref>. 1 Different from the generic deep sets to model the intersection <ref type="bibr" target="#b14">(Hamilton et al., 2018)</ref>, our geometric intersection operator effectively constrains the center position and models the shrinking set size.</p><p>Entity-to-box distance. Given a query box q ? R 2d and an entity vector v ? R d , we define their distance as</p><formula xml:id="formula_8">dist box (v; q) = dist outside (v; q) + ? ? dist inside (v; q),<label>(3)</label></formula><p>where</p><formula xml:id="formula_9">q max = Cen(q) + Off(q) ? R d , q min = Cen(q) ? Off(q) ? R d and 0 &lt; ? &lt; 1 is a fixed scalar, and dist outside (v; q) = Max(v ? q max , 0) + Max(q min ? v, 0) 1 , dist inside (v; q) = Cen(q) ? Min(q max , Max(q min , v)) 1 .</formula><p>As illustrated in <ref type="figure" target="#fig_0">Fig. 2(C)</ref>, dist outside corresponds to the distance between the entity and closest corner/side of the box. Analogously, dist inside corresponds to the distance between the center of the box and its side/corner (or the entity itself if the entity is inside the box).</p><p>The key here is to downweight the distance inside the box by using 0 &lt; ? &lt; 1. This means that as long as entity vectors are inside the box, we regard them as "close enough" to the query center (i.e., dist outside is 0, and dist inside is scaled by ?). When ? = 1, dist box reduces to the ordinary L 1 distance, i.e., Cen(q) ? v 1 , which is used by the conventional TransE <ref type="bibr" target="#b5">(Bordes et al., 2013)</ref> as well as prior query embedding methods <ref type="bibr" target="#b13">(Guu et al., 2015;</ref><ref type="bibr" target="#b14">Hamilton et al., 2018)</ref>.</p><p>Training objective. Our next goal is to learn entity embeddings as well as geometric projection and intersection operators.</p><p>Given a training set of queries and their answers, we optimize a negative sampling loss <ref type="bibr" target="#b23">(Mikolov et al., 2013)</ref> to effectively optimize our distance-based model <ref type="bibr" target="#b25">(Sun et al., 2019)</ref>:</p><formula xml:id="formula_10">L = ? log ? (? ? dist box (v; q)) ? k i=1 1 k log ? (dist box (v i ; q) ? ?) ,<label>(4)</label></formula><p>where ? represents a fixed scalar margin, v ? q is a positive entity (i.e., answer to the query q), and v i / ? q is the i-th negative entity (non-answer to the query q) and k is the number of negative entities.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">TRACTABLE HANDLING OF DISJUNCTION USING DISJUNCTIVE NORMAL FORM</head><p>So far we have focused on conjunctive queries, and our aim here is to tractably handle in the vector space a wider class of logical queries, called Existential Positive First-order (EPFO) queries <ref type="bibr" target="#b7">(Dalvi &amp; Suciu, 2012)</ref> that involve ? in addition to ? and ?. We specifically focus on EPFO queries whose computation graphs are a DAG, same as that of conjunctive queries (Section 3.1), except that we now have an additional type of directed edge, called union defined as follows:</p><p>? Union: Given a set of entity sets {S 1 , S 2 , . . . , S n }, this operator obtains ? n i=1 S i .</p><p>A straightforward approach here would be to define another geometric operator for union and embed the query as we did in the previous sections. An immediate challenge for our box embeddings is that boxes can be located anywhere in the vector space, so their union would no longer be a simple box. In other words, union operation over boxes is not closed.</p><p>Theoretically, we prove a general negative result that holds for any embedding-based method that embeds query q into q and uses some distance function to retrieve entities, i.e., dist(</p><formula xml:id="formula_11">v; q) ? ? iff v ? q . Here, dist(v; q)</formula><p>is the distance between entity and query embeddings, e.g., dist box (v; q) or v ? q 1 , and ? is a fixed threshold. Theorem 1. Consider any M conjunctive queries q 1 , . . . , q M whose denotation sets q 1 , . . . , q M are disjoint with each other,</p><formula xml:id="formula_12">? i = j, q i ? q j = ?. Let D be the VC dimension of the function class {sign(? ? dist(?; q)) : q ? ?},</formula><p>where ? represents the query embedding space and sign(?) is the sign function. Then, we need D ? M to model any EPFO query, i.e., dist</p><formula xml:id="formula_13">(v; q) ? ? ? v ? q is satisfied for every EPFO query q.</formula><p>The proof is provided in Appendix A, where the key is that with the introduction of the union operation any subset of denotation sets can be the answer, which forces us to model the powerset</p><formula xml:id="formula_14">{? q i ?S q i : S ? {q 1 , . . . , q M }} in a vector space.</formula><p>For a real-world KG, there are M ? |V| conjunctive queries with non-overlapping answers. For example, in the commonly-used FB15k dataset <ref type="bibr" target="#b5">(Bordes et al., 2013)</ref>, derived from the Freebase <ref type="bibr" target="#b4">(Bollacker et al., 2008)</ref>, we find M = 13,365, while |V| is 14,951 (see Appendix B for the details).</p><p>Theorem 1 shows that in order to accurately model any EPFO query with the existing framework, the complexity of the distance function measured by the VC dimension needs to be as large as the number of KG entities. This implies that if we use common distance functions based on hyper-plane, Euclidean sphere, or axis-aligned rectangle, 2 their parameter dimensionality needs to be ?(M ), which is ?(|V|) for real KGs we are interested in. In other words, the dimensionality of the logical query embeddings needs to be ?(|V|), which is not low-dimensional; thus not scalable to large KGs and not generalizable in the presence of unobserved KG edges.</p><p>To rectify this issue, our key idea is to transform a given EPFO query into a Disjunctive Normal Form (DNF) <ref type="bibr" target="#b9">(Davey &amp; Priestley, 2002)</ref>, i.e., disjunction of conjunctive queries, so that union operation only appears in the last step. Each of the conjunctive queries can then be reasoned in the low-dimensional space, after which we can aggregate the results by a simple and intuitive procedure. In the following, we describe the transformation to DNF and the aggregation procedure.</p><p>Transformation to DNF. Any first-order logic can be transformed into the equivalent DNF <ref type="bibr" target="#b9">(Davey &amp; Priestley, 2002)</ref>. We perform such transformation directly in the space of computation graph, i.e., moving all the edges of type "union" to the last step of the computation graph. Let G q = (V q , E q ) be the computation graph for a given EPFO query q, and let V union ? V q be a set of nodes whose in-coming edges are of type "union". For each v ? V union , define P v ? V q as a set of its parent nodes. We first generate N = v?Vunion |P v | different computation graphs G q (1) , . . . , G q (N ) as follows, each with different choices of v parent in the first step. 1. For every v ? V union , select one parent node v parent ? P v . 2. Remove all the edges of type 'union.' 3. Merge v and v parent , while retaining all other edge connections. We then combine the obtained computation graphs G q (1) , . . . , G q (N ) as follows to give the final equivalent computation graph.</p><p>1. Convert the target sink nodes of all the obtained computation graphs into the existentially quantified bound variables nodes. 2. Create a new target sink node V ? , and draw directed edges of type "union" from all the above variable nodes to the new target node. An example of the entire transformation procedure is illustrated in <ref type="figure" target="#fig_1">Fig. 3</ref>. By the definition of the union operation, our procedure gives the equivalent computation graph as the original one. Furthermore, as all the union operators are removed from G q (1) , . . . , G q (N ) , all of these computation graphs represent conjunctive queries, which we denote as q (1) , . . . , q <ref type="bibr">(N )</ref> . We can then apply existing framework to obtain a set of embeddings for these conjunctive queries as q (1) , . . . , q (N) .</p><p>Aggregation. Next we define the distance function between the given EPFO query q and an entity v ? V. Since q is logically equivalent to q (1) ? ? ? ? ? q (N ) , we can naturally define the aggregated distance function using the box distance dist box :</p><formula xml:id="formula_15">dist agg (v; q) = Min({dist box (v; q (1) ), . . . , dist box (v; q (N) )}),<label>(5)</label></formula><p>where dist agg is parameterized by the EPFO query q. When q is a conjunctive query, i.e., N = 1, dist agg (v; q) = dist box (v; q). For N &gt; 1, dist agg takes the minimum distance to the closest box as the distance to an entity. This modeling aligns well with the union operation; an entity is inside the union of sets as long as the entity is in one of the sets. Note that our DNF-query rewriting scheme is general and is able to extend any method that works for conjunctive queries (e.g., <ref type="bibr" target="#b14">(Hamilton et al., 2018)</ref>) to handle more general class of EPFO queries.</p><p>Computational complexity. The computational complexity of answering an EPFO query with our framework is equal to that of answering the N conjunctive queries. In practice, N might not be so large, and all the N computations can be parallelized. Furthermore, answering each conjunctive query is very fast as it requires us to execute a sequence of simple box operations (each of which takes constant time) and then perform a range search <ref type="bibr" target="#b3">(Bentley &amp; Friedman, 1979)</ref> in the embedding space, which can also be done in constant time using techniques based on Locality Sensitive Hashing <ref type="bibr" target="#b16">(Indyk &amp; Motwani, 1998)</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">EXPERIMENTS</head><p>Our goal in the experiment section is to evaluate the performance of QUERY2BOX on discovering answers to complex logical queries that cannot be obtained by traversing the incomplete KG. This means, we will focus on answering queries where one or more missing edges in the KG have to be successfully predicted in order to obtain the additional answers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">KNOWLEDGE GRAPHS AND QUERY GENERATION</head><p>We perform experiments on three standard KG benchmarks, FB15k <ref type="bibr" target="#b5">(Bordes et al., 2013)</ref>, FB15k-237 <ref type="bibr" target="#b26">(Toutanova &amp; Chen, 2015)</ref>, and NELL995 <ref type="bibr" target="#b32">(Xiong et al., 2017</ref>) (see Appendix E for NELL995 pre-processing details). Dataset statistics are summarized in <ref type="table" target="#tab_4">Table 5</ref> in Appendix F. to be specified to instantiate logical queries. Naming for each query structure is provided under each subfigure, where 'p', 'i', and 'u' stand for 'projection', 'intersection', and 'union', respectively. Models are trained on the first 5 query structures, and evaluated on all 9 query structures. For example, "3p" is a path query of length three, and "2i" is an intersection of cardinality two. We follow the standard evaluation protocol in KG literture: Given the standard split of edges into training, test, and validation sets, we first augment the KG to also include inverse relations and effectively double the number of edges in the graph. We then create three graphs: G train , which only contains training edges and we use this graph to train node embeddings as well as box operators. We then also generate two bigger graphs: G valid , which contains G train plus the validation edges, and G test , which includes G valid as well as the test edges.</p><p>We consider 9 kinds of diverse query structures shown and named in <ref type="figure" target="#fig_2">Fig. 4</ref>. We use 5 query structures for training and then evaluate on all the 9 query structures. We refer the reader to Appendix D for full details on query generation and <ref type="table" target="#tab_5">Table 6</ref> in Appendix F for statistics of the generated logical queries. Given a query q, let q train , q val , and q test denote a set of answer entities obtained by running subgraph matching of q on G train , G valid , and G test , respectively. At the training time, we use q train as positive examples for the query and other random entities as negative examples. However, at the test/validation time we proceed differently. Note that we focus on answering queries where generalization performance is crucial and at least one edge needs to be imputed in order to answer the queries. Thus, rather than evaluating a given query on the full validation (or test) set q val ( q test ) of answers, we validate the method only on answers that include missing relations. Given how we constructed G train ? G valid ? G test , we have q train ? q val ? q test and thus we evaluate the method on q val \ q train to tune hyper-parameters and then report results identifying answer entities in q test \ q val . This means we always evaluate on queries/entities that were not part of the training set and the method has not seen them before. Furthermore, for these queries, traditional graph traversal techniques would not be able to find the answers (due to missing relations). <ref type="table" target="#tab_0">Table 1</ref> shows the average number of answer entities for different query structures. We observe that complex logical queries (especially 2p, 3p, ip, pi, up) indeed require modeling a much larger number of answer entities (often more than 10 times) than the simple 1p queries do. Therefore, we expect our box embeddings to work particularly well in handling complex queries with many answer entities. 3</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">EVALUATION PROTOCOL</head><p>Given a test query q, for each of its non-trivial answers v ? q test \ q val , we use dist box in Eq. 3 to rank v among V\ q test . Denoting the rank of v by Rank(v), we then calculate evaluation metrics for answering query q, such as Mean Reciprocal Rank (MRR) and Hits at K (H@K):  where f metrics (x) = 1 x for MRR, and f metrics (x) = 1[x ? K] for H@K. We then average Eq. 6 over all the queries within the same query structure, 4 and report the results separately for different query structures. The same evaluation protocol is applied to the validation stage except that we evaluate on q val \ q train rather than q test \ q val .</p><formula xml:id="formula_16">Metrics(q) = 1 | q test \ q val | v? q test\ q val f metrics (Rank(v)),<label>(6)</label></formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">BASELINE AND MODEL VARIANTS</head><p>We compare our framework QUERY2BOX against the state-of-the-art GQE <ref type="bibr" target="#b14">(Hamilton et al., 2018)</ref>. GQE embeds a query to a single vector, and models projection and intersection operators as translation and deep sets <ref type="bibr" target="#b33">(Zaheer et al., 2017)</ref>, respectively. The L 1 distance is used as the distance between query and entity vectors. For a fair comparison, we also compare with GQE-DOUBLE (GQE with doubled embedding dimensionality) so that QUERY2BOX and GQE-DOUBLE have the same amount of parameters. Refer to Appendix G for the model hyper-parameters used in our experiments. Although the original GQE cannot handle EPFO queries, we apply our DNF-query rewriting strategy and in our evaluation extend GQE to handle general EPFO queries as well. Furthermore, we perform extensive ablation study by considering several variants of QUERY2BOX (abbreviated as Q2B). We list our method as well as its variants below.</p><p>? Q2B (our method): The box embeddings are used to model queries, and the attention mechanism is used for the intersection operator. ? Q2B-AVG: The attention mechanism for intersection is replaced with averaging.</p><p>? Q2B-DEEPSETS: The attention mechanism for intersection is replaced with the deep sets.</p><p>? Q2B-AVG-1P: The variant of Q2B-AVG that is trained with only 1p queries (see <ref type="figure" target="#fig_2">Fig. 4</ref>); thus, logical operators are not explicitly trained. ? Q2B-SHAREDOFFSET; The box offset is shared across all queries (every query is represented by a box with the same trainable size).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">MAIN RESULTS</head><p>We start by comparing our Q2B with state-of-the-art query embedding method GQE <ref type="bibr" target="#b14">(Hamilton et al., 2018)</ref> on FB15k, FB15k-237, and NELL995. As listed in Tables 2, our method significantly and consistently outperforms the state-of-the-art baseline across all the query structures, including those not seen during training as well as those with union operations. On average, we obtain 9.8% (25% relative), 3.8% (15% relative), and 5.9% (24% relative) higher H@3 than the best baselines on FB15k, FB15k-237, and NELL995, respectively. Notice that na?vely increasing embedding dimensionality in GQE yields limited performance improvement. Our Q2B is able to effectively model a large set of entities by using the box embedding, and achieves a significant performance gain compared with GQE-DOUBLE (with same number of parameters) that represents queries as point vectors. Also notice  that Q2B performs well on new queries with the same structure as the training queries as well as on new query structures never seen during training, which demonstrates that Q2B generalizes well within and beyond query structures.</p><p>We also conduct extensive ablation studies <ref type="table" target="#tab_2">(Tables 3)</ref>. We summarize the results as follows:</p><p>Importance of attention mechanism. First, we show that our modeling of intersection using the attention mechanism is important. Given a set of box embeddings {p 1 , . . . , p n }, Q2B-AVG is the most na?ve way to calculate the center of the resulting box embedding p inter while Q2B-DEEPSETS is too flexible and neglects the fact that the center should be a weighted average of Cen(p 1 ), . . . , Cen(p n ).</p><p>Compared with the two methods, Q2B achieves better performance in answering queries that involve intersection operation, e.g., 2i, 3i, pi, ip. Specifically, on FB15k-237, Q2B obtains more than 4% and 2% absolute gain in H@3 compared to Q2B-AVG and Q2B-DEEPSETS, respectively.</p><p>Necessity of training on complex queries. Second, we observe that explicitly training on complex logical queries beyond one-hop path queries (1p in <ref type="figure" target="#fig_2">Fig. 4)</ref> improves the reasoning performance. Although Q2B-AVG-1P is able to achieve strong performance on 1p and 2u, where answering 2u is essentially answering two 1p queries with an additional minimum operation (see Eq. 5 in Section 3.3), Q2B-AVG-1P fails miserably in answering other types of queries involving logical operators. On the other hand, other methods (Q2B, Q2B-AVG, and Q2B-DEEPSETS) that are explicitly trained on the logical queries achieve much higher accuracy, with up to 10% absolute average improvement of H@3 on FB15k.</p><p>Adaptive box size for different queries. Third, we investigate the importance of learning adaptive offsets (box size) for different queries. Q2B-SHAREDOFFSET is a variant of our Q2B where all the box embeddings share the same learnable offset. Q2B-SHAREDOFFSET does not work well on all types of queries. This is most likely because different queries have different numbers of answer entities, and the adaptive box size enables us to better model it. In fact, we find that box offset varies significantly across different relations, and one-to-many relations tend to have larger offset embeddings (see Appendix H for the details).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">CONCLUSION</head><p>In this paper we proposed a reasoning framework called QUERY2BOX that can effectively model and reason over sets of entities as well as handle EPFO queries in a vector space. Given a logical query, we first transform it into DNF, embed each conjunctive query into a box, and output entities closest to their nearest boxes. Our approach is capable of handling all types of EPFO queries scalably and accurately. Experimental results on standard KGs demonstrate that QUERY2BOX significantly outperforms the existing work in answering diverse logical queries.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A PROOF OF THEOREM 1</head><p>Proof. To model any EPFO query, we need to at least model a subset of EPFO queries Q = {? q i ?S q i : S ? {q 1 , . . . , q M }}, where the corresponding denotation sets are {? q i ?S q i : S ? {q 1 , . . . , q M }}.</p><p>For the sake of modeling Q, without loss of generality, we consider assigning a single entity embedding v q i to all v ? q i , so there are M kinds of entity vectors, v q1 , . . . , v q M . To model all queries in Q, it is necessary to satisfy the following.</p><formula xml:id="formula_17">?v q1 , . . . , ?v q M , ?S ? {q 1 , . . . , q M }, ?q S ? ?, such that dist(v q i ; q S ) ? ? if q i ? S, &gt; ? if q i / ? S.<label>(7)</label></formula><p>where q S is the embedding of query ? q i ?S q i . Eq. 7 means that we can learn the M kinds of entity vectors such that for every query in Q, we can obtain its embedding to model the corresponding set using the distance function. Notice that this is agnostic to the specific algorithm to embed query ? q?S q into q S ; thus, our result is generally applicable to any method that embeds the query into a single vector.</p><p>Crucially, satisfying Eq. 7 is equivalent to {sign(? ? dist(?; q)) : q ? ?} being able to shutter {v q1 , . . . , v q M }, i.e., any binary labeling of the points can be perfectly fit by some classifier in the function class. To sum up, in order to model any EPFO query, we need to at least model any query in Q, which requires the VC dimension of the distance function to be larger than or equal to M .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B DETAILS ABOUT COMPUTING M IN THEOREM 1</head><p>Given the full KG G test for the FB15k dataset, our goal is to find conjunctive queries q 1 , . . . , q M such that q 1 , . . . , q M are disjoint with each other. For conjunctive queries, we use two types of queries: '1p' and '2i' whose query structures are shown in <ref type="figure" target="#fig_2">Figure 4</ref>. On the FB15k, we instantiate 308,006 queries of type '1p', which we denote by S 1p . Out of all the queries in S 1p , 129,717 queries have more than one answer entities, and we denote such a set of the queries by S 1p . We then generate a set of queries of type '2i' by first randomly sampling two queries from S 1p and then taking conjunction; we denote the resulting set of queries by S 2i . Now, we use S 1p and S 2i to generate a set of conjunctive queries whose denotation sets are disjoint with each other. First, we prepare two empty sets V seen = ?, and Q = ?. Then, for every q ? S 1p , if V seen ? q = ? holds, we let Q ? Q ? {q} and V seen ? V seen ? q . This procedure already gives us Q, where we have 10, 812 conjunctive queries whose denotation sets are disjoint with each other. We can further apply the analogous procedure for S 2i , which gives us a further increased Q, where we have 13, 365 conjunctive queries whose denotation sets are disjoint with each other. Therefore, we get M = 13, 365.  <ref type="table">Table 4</ref>: Performance comparison on the simple link prediction task on the three datasets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C EXPERIMENTS ON LINK PREDICTION</head><p>In <ref type="table">Table 4</ref>, we report the link prediction performance (no multi-hop logical reasoning required) following the conventional metrics (taking average over the triples of head, relation, and tail). Here query2box is trained on all five query structures as shown in <ref type="figure" target="#fig_2">Figure 4</ref>, and query2box-1p is only trained on simple 1p queries. We found that our query2box is comparable or slightly better than TransE on simple link prediction. Note that in the case of simple link prediction, we do not expect a huge performance gain by using box embeddings as link prediction does not involve logical reasoning nor handling a large set of answer entities. Also, we see that even if we train query2box over diverse queries, its performance on link prediction is still comparable to TransE and query2box-1p, which are trained solely on the link prediction task. ? ? ? <ref type="figure">Figure 5</ref>: Example of the degenerated queries, including (1) r and r ?1 appear along one path and (2) same anchor node and relation in intersections.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D DETAILS ON QUERY GENERATION</head><p>Given G train , G valid , and G test as defined in Section 4.1, we generate training, validation and test queries of different query structures. During training, we consider the first 5 kinds of query structures. For evaluation, we consider all the 9 query structures in <ref type="figure" target="#fig_2">Fig. 4</ref>, containing query structures that are both seen and unseen during training time. We instantiate queries in the following way.</p><p>Given a KG and a query structure (which is a DAG), we use pre-order traversal to assign an entity and a relation to each node and edge in the DAG of query structure to instantiate a query. Namely, we start from the root of the DAG (which is the target node), we sample an entity e uniformly from the KG to be the root, then for every node connected to the root in the DAG, we choose a relation r uniformly from the in-coming relations of e in the KG, and a new entity e from the set of entities that reaches e by r in the KG. Then we assign the relation r to the edge and e to the node, and move on the process based on the pre-order traversal. This iterative process stops after we assign an entity and relation to every node and edge in DAG. The leaf nodes in the DAG serve as the anchor nodes. Note that during the entity and relation assignment, we specifically filter out all the degenerated queries, as shown in <ref type="figure">Fig. D</ref>. Then we perform a post-order traversal of the DAG on the KG, starting from the anchor nodes, to obtain a set of answer entities to this query.</p><p>When generating validation/test queries, we explicitly filter out trivial queries that can be fully answered by subgraph matching on G train /G valid .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E DETAILS OF NELL995 DATASET</head><p>Here we detail our pre-processing of the NELL995 dataset, which is originally presented by <ref type="bibr" target="#b32">Xiong et al. (2017</ref>   F DATASET STATISTICS <ref type="table" target="#tab_4">Table 5</ref> summarizes the basic statistics of the three datasets used in our experiments. <ref type="table" target="#tab_5">Table 6</ref> summarizes the basic statistics of the generated logical queries.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>G HYPER-PARAMETERS</head><p>We use embedding dimensionality of d = 400 and set ? = 24, ? = 0.2 for the loss in Eq. 4. We train all types of training queries jointly. In every iteration, we sample a minibatch size of 512 queries for each query structure (details in Appendix D), and we sample 1 answer entity and 128 negative entities for each query. We optimize the loss in Eq. 4 using Adam Optimizer <ref type="bibr" target="#b17">(Kingma &amp; Ba, 2015)</ref> with learning rate = 0.0001. We train all models for 250 epochs, monitor the performance on the validation set, and report the test performance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>H ANALYSIS OF LEARNED BOX OFFSET SIZE</head><p>Here we study the correlation between the box size (measured by the L1 norm of the box offset) and the average number of entities that are contained in 1p queries using the corresponding relation. <ref type="table" target="#tab_7">Table 7</ref> shows the top 10 relations with smallest/largest box sizes. We observe a clear trend that the size of the box has a strong correlation with the number of entities the box encloses. Specifically, we see that one-to-many relations tend to have larger offset embeddings, which demonstrates that larger boxes are indeed used to model sets of more points (entities).      </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I MRR RESULTS</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Method</head></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 2 :</head><label>2</label><figDesc>The geometric intuition of the two operations and distance function in QUERY2BOX. (A) Projection generates a larger box with a translated center. (B) Intersection generates a smaller box lying inside the given set of boxes. (C) Distance dist box is the weighted sum of dist outside and dist inside , where the latter is weighted less.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 :</head><label>3</label><figDesc>Illustration of converting a computation graph of an EPFO query into an equivalent computation graph of the Disjunctive Normal Form.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 :</head><label>4</label><figDesc>Query structures considered in the experiments, where anchor entities and relations are</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>FB15k</head><label></label><figDesc></figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Q2B 0 .</head><label>0</label><figDesc>41 0.654 0.373 0.274 0.488 0.602 0.194 0.339 0.468 0.301 Q2B-AVG 0.396 0.648 0.368 0.27 0.476 0.564 0.182 0.295 0</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1</head><label>1</label><figDesc></figDesc><table><row><cell>Dataset</cell><cell>1p</cell><cell>2p</cell><cell>3p</cell><cell>2i</cell><cell>3i</cell><cell>ip</cell><cell>pi</cell><cell>2u</cell><cell>up</cell></row><row><cell>FB15k</cell><cell cols="9">10.8 255.6 250.0 90.3 64.1 593.8 190.1 27.8 227.0</cell></row><row><cell cols="10">FB15k-237 13.3 131.4 215.3 69.0 48.9 593.8 257.7 35.6 127.7</cell></row><row><cell>NELL995</cell><cell>8.5</cell><cell>56.6</cell><cell cols="7">65.3 30.3 15.9 310.0 144.9 14.4 62.5</cell></row></table><note>: Average number of answer entities of test queries with missing edges grouped by different query structures (for a KG with 10% edges missing).</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 2 :</head><label>2</label><figDesc>H@3 results of QUERY2BOX vs. GQE on FB15k, FB15k-237 and NELL995.</figDesc><table /><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 3 :</head><label>3</label><figDesc>H@3 results of QUERY2BOX vs. several variants on FB15k, FB15k-237 and NELL995.</figDesc><table /><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>). Following<ref type="bibr" target="#b0">Allen et al. (2019)</ref>, we first combine the validation and test sets with the training set to create the whole knowledge graph for NELL995. Then we create new validation and test set splits by randomly selecting 20,000 triples each from the whole knowledge graph. Note that we filter out all the entities that only appear in the validation and test sets but not in the training set.</figDesc><table><row><cell>Dataset</cell><cell cols="6">Entities Relations Training Edges Validation Edges Test Edges Total Edges</cell></row><row><cell>FB15k</cell><cell>14,951</cell><cell>1,345</cell><cell>483,142</cell><cell>50,000</cell><cell>59,071</cell><cell>592,213</cell></row><row><cell>FB15k-237</cell><cell>14,505</cell><cell>237</cell><cell>272,115</cell><cell>17,526</cell><cell>20,438</cell><cell>310,079</cell></row><row><cell>NELL995</cell><cell>63,361</cell><cell>200</cell><cell>114,213</cell><cell>14,324</cell><cell>14,267</cell><cell>142,804</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 5 :</head><label>5</label><figDesc>Knowledge graph dataset statistics as well as the split into training, validation, and test sets.</figDesc><table><row><cell>Queries</cell><cell cols="2">Training</cell><cell cols="2">Validation</cell><cell></cell><cell>Test</cell></row><row><cell>Dataset</cell><cell>1p</cell><cell>others</cell><cell>1p</cell><cell>others</cell><cell>1p</cell><cell>others</cell></row><row><cell>FB15k</cell><cell cols="6">273,710 273,710 59,097 8,000 67,016 8,000</cell></row><row><cell cols="7">FB15k-237 149,689 149,689 20,101 5,000 22,812 5,000</cell></row><row><cell>NELL995</cell><cell cols="6">107,982 107,982 16,927 4,000 17,034 4,000</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 6 :</head><label>6</label><figDesc>Number of training, validation, and test queries generated for different query structures.</figDesc><table /><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head>Table 7 :</head><label>7</label><figDesc>Top 10 relations with smallest/largest box size in FB15k.</figDesc><table /><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head>Table 8 :</head><label>8</label><figDesc>MRR results of QUERY2BOX vs. GQE on FB15k, FB15k-237 and NELL995.</figDesc><table><row><cell>Method</cell><cell>Avg</cell><cell>1p</cell><cell>2p</cell><cell>3p</cell><cell>2i</cell><cell>3i</cell><cell>ip</cell><cell>pi</cell><cell>2u</cell><cell>up</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>FB15k</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9"><head>Table 9 :</head><label>9</label><figDesc>MRR results of QUERY2BOX vs. several variants on FB15k, FB15k-237 and NELL995.</figDesc><table /><note></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1">One possible choice here would be to directly use raw box intersection, however, we find that our richer learnable parameterization is more expressive and robust</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2">For the detailed VC dimensions of these function classes, see<ref type="bibr" target="#b27">Vapnik (2013)</ref>. Crucially, their VC dimensions are all linear with respect to the number of parameters d.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3">On the simple link prediction (1p query) task, box embeddings provide minor empirical performance improvement over TransE, possibly because simple link prediction does not require modeling large sets of entities, as shown inTable 1. See Appendix C for full experimental results on link prediction.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4">Note that our evaluation metric is slightly different from conventional metric<ref type="bibr" target="#b24">(Nickel et al., 2016;</ref><ref type="bibr" target="#b14">Hamilton et al., 2018;</ref><ref type="bibr" target="#b13">Guu et al., 2015)</ref>, where average is taken over query-answer pairs. The conventional metric is problematic as it can be significantly biased toward correctly answering generic queries with huge number of answers, while dismissing fine-grained queries with a few answers. Here, to treat queries equally regardless of the number of answers they have, we take average over queries.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENTS</head><p>We thank William Hamilton, Rex Ying, and Jiaxuan You for their helpful discussion. W.H is supported by Funai Overseas Scholarship and Masason Foundation Fellowship. J.L is a Chan Zuckerberg Biohub investigator. We gratefully acknowledge the support of DARPA under Nos. FA865018C7880 (ASED), N660011924033 (MCS); ARO under Nos. W911NF-16-1-0342 (MURI), W911NF-16-1-0171 (DURIP); NSF under Nos. OAC-1835598 (CINES), OAC-1934578 (HDR); Stanford Data Science Initiative, Wu Tsai Neurosciences Institute, Chan Zuckerberg Biohub, JD.com, Amazon, Boeing, Docomo, Huawei, Hitachi, Observe, Siemens, UST Global.</p><p>The U.S. Government is authorized to reproduce and distribute reprints for Governmental purposes notwithstanding any copyright notation thereon. Any opinions, findings, and conclusions or recommendations expressed in this material are those of the authors and do not necessarily reflect the views, policies, or endorsements, either expressed or implied, of DARPA, NIH, ARO, or the U.S. Government.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Carl</forename><surname>Allen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ivana</forename><surname>Balazevic</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Timothy</forename><forename type="middle">M</forename><surname>Hospedales</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1909.11611</idno>
		<title level="m">On understanding knowledge graph representation</title>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Hierarchical density order embeddings</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ben</forename><surname>Athiwaratkun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrew</forename><forename type="middle">Gordon</forename><surname>Wilson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Learning Representations (ICLR)</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Neural machine translation by jointly learning to align and translate</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dzmitry</forename><surname>Bahdanau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kyunghyun</forename><surname>Cho</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yoshua</forename><surname>Bengio</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Learning Representations (ICLR)</title>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Data structures for range searching</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jon</forename><forename type="middle">Louis</forename><surname>Bentley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jerome H</forename><surname>Friedman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Computing Surveys (CSUR)</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="397" to="409" />
			<date type="published" when="1979" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Freebase: a collaboratively created graph database for structuring human knowledge</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kurt</forename><surname>Bollacker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Colin</forename><surname>Evans</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Praveen</forename><surname>Paritosh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tim</forename><surname>Sturge</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jamie</forename><surname>Taylor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGMOD international conference on Management of data (SIGMOD)</title>
		<imprint>
			<publisher>AcM</publisher>
			<date type="published" when="2008" />
			<biblScope unit="page" from="1247" to="1250" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Translating embeddings for modeling multi-relational data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Antoine</forename><surname>Bordes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nicolas</forename><surname>Usunier</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alberto</forename><surname>Garcia-Duran</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jason</forename><surname>Weston</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Oksana</forename><surname>Yakhnenko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems (NeurIPS)</title>
		<imprint>
			<date type="published" when="2013" />
			<biblScope unit="page" from="2787" to="2795" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Efficient query evaluation on probabilistic databases</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nilesh</forename><surname>Dalvi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dan</forename><surname>Suciu</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007" />
			<publisher>VLDB</publisher>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="page" from="523" to="544" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">The dichotomy of probabilistic inference for unions of conjunctive queries</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nilesh</forename><surname>Dalvi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dan</forename><surname>Suciu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM (JACM)</title>
		<imprint>
			<biblScope unit="volume">59</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page">30</biblScope>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Chains of reasoning over entities, relations, and text using recurrent neural networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rajarshi</forename><surname>Das</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Arvind</forename><surname>Neelakantan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Belanger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrew</forename><surname>Mccallum</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2017" />
			<biblScope unit="page" from="132" to="141" />
		</imprint>
	</monogr>
	<note>In European Chapter of the Association for Computational Linguistics (EACL)</note>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Introduction to lattices and order</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Brian</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hilary</forename><forename type="middle">A</forename><surname>Davey</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Priestley</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002" />
			<publisher>Cambridge university press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Logical and relational learning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Raedt</forename><surname>Luc De</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008" />
			<publisher>Springer Science &amp; Business Media</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Relational data mining</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sa?o</forename><surname>D?eroski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Data Mining and Knowledge Discovery Handbook</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009" />
			<biblScope unit="page" from="887" to="911" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Representing words as regions in vector space</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Katrin</forename><surname>Erk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Thirteenth Conference on Computational Natural Language Learning</title>
		<meeting>the Thirteenth Conference on Computational Natural Language Learning</meeting>
		<imprint>
			<date type="published" when="2009" />
			<biblScope unit="page" from="57" to="65" />
		</imprint>
	</monogr>
	<note>Annual Meeting of the Association for Computational Linguistics</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Traversing knowledge graphs in vector space</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kelvin</forename><surname>Guu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Percy</forename><surname>Liang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Empirical Methods in Natural Language Processing (EMNLP)</title>
		<imprint>
			<date type="published" when="2015" />
			<biblScope unit="page" from="318" to="327" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Embedding logical queries on knowledge graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Will</forename><surname>Hamilton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Payal</forename><surname>Bajaj</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marinka</forename><surname>Zitnik</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dan</forename><surname>Jurafsky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jure</forename><surname>Leskovec</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems (NeurIPS)</title>
		<imprint>
			<date type="published" when="2018" />
			<biblScope unit="page" from="2027" to="2038" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Learning to represent knowledge graphs with gaussian embedding</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shizhu</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kang</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Guoliang</forename><surname>Ji</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jun</forename><surname>Zhao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 24th ACM International on Conference on Information and Knowledge Management</title>
		<meeting>the 24th ACM International on Conference on Information and Knowledge Management</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2015" />
			<biblScope unit="page" from="623" to="632" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Approximate nearest neighbors: towards removing the curse of dimensionality</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Piotr</forename><surname>Indyk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rajeev</forename><surname>Motwani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the thirtieth annual ACM symposium on Theory of computing</title>
		<meeting>the thirtieth annual ACM symposium on Theory of computing</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1998" />
			<biblScope unit="page" from="604" to="613" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Adam: A method for stochastic optimization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Diederik</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jimmy</forename><surname>Kingma</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Ba</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Learning Representations (ICLR)</title>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Chris Meek, et al. Introduction to statistical relational learning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daphne</forename><surname>Koller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nir</forename><surname>Friedman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sa?o</forename><surname>D?eroski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Charles</forename><surname>Sutton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrew</forename><surname>Mccallum</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Avi</forename><surname>Pfeffer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pieter</forename><surname>Abbeel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ming-Fai</forename><surname>Wong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Heckerman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007" />
			<publisher>MIT press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Querying factorized probabilistic triple databases</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Denis</forename><surname>Krompa?</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Maximilian</forename><surname>Nickel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Volker</forename><surname>Tresp</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Semantic Web Conference</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2014" />
			<biblScope unit="page" from="114" to="129" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Learning to predict denotational probabilities for modeling entailment</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alice</forename><surname>Lai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Julia</forename><surname>Hockenmaier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Annual Meeting of the Association for Computational Linguistics (ACL)</title>
		<imprint>
			<date type="published" when="2017" />
			<biblScope unit="page" from="721" to="730" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">Improved representation learning for predicting commonsense ontologies</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xiang</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Luke</forename><surname>Vilnis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrew</forename><surname>Mccallum</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1708.00549</idno>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Smoothing the geometry of probabilistic box embeddings</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xiang</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Luke</forename><surname>Vilnis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dongxu</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Boratko</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrew</forename><surname>Mccallum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Learning Representations (ICLR)</title>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Efficient estimation of word representations in vector space</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tomas</forename><surname>Mikolov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kai</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Greg</forename><surname>Corrado</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jeffrey</forename><surname>Dean</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Learning Representations (ICLR)</title>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">A review of relational machine learning for knowledge graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Maximilian</forename><surname>Nickel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kevin</forename><surname>Murphy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Volker</forename><surname>Tresp</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Evgeniy</forename><surname>Gabrilovich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proceedings of the IEEE</title>
		<imprint>
			<biblScope unit="volume">104</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="11" to="33" />
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Rotate: Knowledge graph embedding by relational rotation in complex space</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhiqing</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhi-Hong</forename><surname>Deng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jian-Yun</forename><surname>Nie</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jian</forename><surname>Tang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Learning Representations (ICLR)</title>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Observed versus latent features for knowledge base and text inference</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kristina</forename><surname>Toutanova</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Danqi</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 3rd Workshop on Continuous Vector Space Models and their Compositionality</title>
		<meeting>the 3rd Workshop on Continuous Vector Space Models and their Compositionality</meeting>
		<imprint>
			<date type="published" when="2015" />
			<biblScope unit="page" from="57" to="66" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">The nature of statistical learning theory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vladimir</forename><surname>Vapnik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Springer science &amp; business media</title>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Order-embeddings of images and language</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ivan</forename><surname>Vendrov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ryan</forename><surname>Kiros</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sanja</forename><surname>Fidler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Raquel</forename><surname>Urtasun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Learning Representations (ICLR)</title>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title level="m" type="main">on the diagrammatic and mechanical representation of propositions and reasonings. The London, Edinburgh, and Dublin philosophical magazine and journal of science</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">.</forename><forename type="middle">I</forename><surname>John Venn</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1880" />
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="1" to="18" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Word representations via gaussian embedding</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Luke</forename><surname>Vilnis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrew</forename><surname>Mccallum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Learning Representations (ICLR)</title>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Probabilistic embedding of knowledge graphs with box lattice measures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Luke</forename><surname>Vilnis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xiang</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shikhar</forename><surname>Murty</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrew</forename><surname>Mccallum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Annual Meeting of the Association for Computational Linguistics (ACL)</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Deeppath: A reinforcement learning method for knowledge graph reasoning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wenhan</forename><surname>Xiong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thien</forename><surname>Hoang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">William</forename><forename type="middle">Yang</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Empirical Methods in Natural Language Processing</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Deep sets</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Manzil</forename><surname>Zaheer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Satwik</forename><surname>Kottur</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Siamak</forename><surname>Ravanbakhsh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Barnabas</forename><surname>Poczos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Ruslan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alexander</forename><forename type="middle">J</forename><surname>Salakhutdinov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Smola</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems (NeurIPS)</title>
		<imprint>
			<date type="published" when="2017" />
			<biblScope unit="page" from="3391" to="3401" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
