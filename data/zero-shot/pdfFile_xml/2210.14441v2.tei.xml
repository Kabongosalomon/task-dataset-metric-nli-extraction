<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /nfs/home/kabenamualus/Research/task-dataset-metric-extraction/../grobid-0.6.0/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Towards Automatically Extracting UML Class Diagrams from Natural Language Specifications</title>
			</titleStmt>
			<publicationStmt>
				<publisher>ACM</publisher>
				<availability status="unknown"><p>Copyright ACM</p>
				</availability>
				<date>October 23-28, 2022</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Song</forename><surname>Yang</surname></persName>
							<email>song.yang.1@umontreal.ca</email>
							<affiliation key="aff0">
								<orgName type="institution">Universit? de Montr?al Montreal</orgName>
								<address>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Houari</forename><surname>Sahraoui</surname></persName>
							<email>houari.sahraoui@umontreal.ca</email>
							<affiliation key="aff1">
								<orgName type="institution">Universit? de Montr?al Montreal</orgName>
								<address>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Towards Automatically Extracting UML Class Diagrams from Natural Language Specifications</title>
					</analytic>
					<monogr>
						<title level="m">ACM/IEEE 25th International Conference on Model Driven Engineering Languages and Systems (MODELS &apos;22 Companion)</title>
						<meeting> <address><addrLine>Montreal, QC, Canada; New York, NY, USA</addrLine></address>
						</meeting>
						<imprint>
							<publisher>ACM</publisher>
							<biblScope unit="volume">8</biblScope>
							<date type="published">October 23-28, 2022</date>
						</imprint>
					</monogr>
					<idno type="DOI">10.1145/3550356.3561592</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>

		<encodingDesc>
			<appInfo>
				<application version="0.6.0" ident="GROBID-SDO" when="2022-11-11T21:39+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid-sdo"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>CCS CONCEPTS ? Software and its engineering ? Software design engineer- ing</term>
					<term>? Computing methodologies ? Information extraction</term>
					<term>Classification and regression trees KEYWORDS Model-driven engineering, Machine learning, Natural language processing, Domain modeling</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>In model-driven engineering (MDE), UML class diagrams serve as a way to plan and communicate between developers. However, it is complex and resource-consuming. We propose an automated approach for the extraction of UML class diagrams from natural language software specifications. To develop our approach, we create a dataset of UML class diagrams and their English specifications with the help of volunteers. Our approach is a pipeline of steps consisting of the segmentation of the input into sentences, the classification of the sentences, the generation of UML class diagram fragments from sentences, and the composition of these fragments into one UML class diagram. We develop a quantitative testing framework specific to UML class diagram extraction. Our approach yields low precision and recall but serves as a benchmark for future research.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Software development is a complex and error-prone process. Part of this complexity comes from the gap between domain experts who are familiar with the domain knowledge but have limited expertise with development tools, and software specialists who master the development environments but are unfamiliar with the target application domain. To fill that gap, the model-driven engineering paradigm aims at raising the level of abstraction in Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. Copyrights for components of this work owned by others than ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. Request permissions from permissions@acm.org. MODELS '22 Companion, October 23-28, 2022, Montreal, QC, Canada ? 2022 Association for Computing Machinery. ACM ISBN 978-1-4503-9467-3/22/10. . . $15.00 https://doi.org <ref type="bibr">/10.1145/3550356.3561592</ref> development activities by considering domain models, such as UML class diagrams, as first-class development artifacts.</p><p>Though smaller, a gap still exists between the domain concepts and the tools and languages that are produced to model them <ref type="bibr" target="#b7">[8]</ref>. For a domain specialist, creating UML models from scratch is a timeconsuming and error-prone process that requires various technical skills. To address that problem, various approaches target the generation of models from different structured information such as user stories <ref type="bibr" target="#b3">[4]</ref>. However, little work has been done on the extraction of natural language specifications. In the specific case of UML class diagrams, existing work rely either on techniques that use machine learning in a semi-automated process <ref type="bibr" target="#b11">[12]</ref> or rule-based techniques that are fully automated but require a restricted input <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b6">7]</ref>. In this paper, we propose an approach that combines both machine learning and rules while accepting free-flowing text.</p><p>Our approach uses natural language patterns and machine learning to fully automate the generation process. We first decompose a specification into sentences. Then, using a trained classifier, we tag each sentence as describing either a class or a relationship. Next, using grammar patterns, we map each sentence into a UML fragment. Finally, we assemble the fragments into a complete UML diagram using a composition algorithm. In addition to our approach, we build a dataset thanks to the effort of the modeling community. This dataset is used to train the classifier et to evaluate the approach.</p><p>We evaluate our approach on a dataset of 62 diagrams containing 624 fragments. Although the accuracy of our approach does not reach an accuracy level needed for practical use, our work explores the benefits of mixing machine learning with natural language patterns for a fully automated process. Our approach can serve as a baseline for future research on generating UML diagrams from English specifications, and the dataset created together with the defined quantitative metrics can serve as a benchmark for this problem.</p><p>The rest of the paper is structured as follows. Section 2 gives an overview of the proposed generation pipeline and the details of each step. The setup and the results of evaluating the approach are provided in Section 3.1. Section 5 discusses the related work and positions our contribution to it. Section 4 lists some threats to validity. Finally, we conclude this paper in Section 6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">APPROACH 2.1 Overview</head><p>The goal is to design a method to translate English specifications to UML diagrams. To do this, we implement a tool pipeline that generates UML class diagrams from natural language specifications. First, we create a dataset. Secondly, we implement an NLP arXiv:2210.14441v2 [cs.SE] 27 Oct 2022 pipeline that performs the extraction of UML class diagrams. <ref type="figure">Figure  2</ref> summarizes the process. <ref type="figure">Figure 1</ref> summarizes the process.</p><p>Our approach combines machine learning with pattern-based diagram generation. To perform machine learning, we start by creating a dataset of UML class diagrams and their corresponding specifications in natural language (top part of <ref type="figure">Figure 1</ref>). We select pre-existing UML class diagrams from the AtlanMod Zoo repository <ref type="bibr" target="#b0">1</ref> . The selected diagrams are decomposed into fragments and manually labeled by volunteer participants. After postprocessing, the labeled diagrams are stored in a repository.</p><p>The bottom part of <ref type="figure">Figure 1</ref> consists of the actual diagram generation process, which takes place right after a user submits a software specification. The submitted natural language specification is then preprocessed and decomposed into sentences. Using a classifier built from the above-mentioned dataset, the sentences are labeled according to the nature of the UML construct they refer to, i.e. a class or a relation. According to this label, specific procedures of parsing and extraction are performed on the sentence to generate a UML fragment. In the end, all UML fragments are composed back together into one UML class diagram.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Dataset Creation</head><p>We create a new dataset for both the operation and the evaluation of our approach. In particular, we use this dataset to learn a classifier for the Classification step in <ref type="figure">Figure 1</ref>.</p><p>To build the dataset, we start from an existing set of UML class diagrams from the AtlanMod Zoo. The AtlanMod Zoo has a repository of 305 high-quality UML class diagrams that model various domains. The size of the diagrams varies from a few to hundreds of classes. We fragment each diagram into simple classes ( <ref type="figure">Figure 2</ref>) and relationships ( <ref type="figure">Figure 3</ref>). <ref type="table">Table 1</ref> shows the size of the initial set of diagrams and the fragments, as well as the portion that we labeled.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Dataset</head><p>UML models UML fragments AtlanMod Zoo 305 8706 Labeled 62 649 <ref type="table">Table 1</ref>: UML datasets and their sizes by version</p><p>Since we are interested in the translation of specifications into diagrams, each UML class diagram needs to be paired with an English specification. To achieve that goal, we set up a website where we crowdsource the labeling of fragments. The website proposes the labeling of 305 diagrams containing 8706 fragments. We present the diagrams in ascending order of complexity. The website first shows a complete diagram, then iterates on its fragments for labeling while keeping the whole diagram in view. The volunteer participants write an English specification for each fragment. We give examples of labels to help the participants write at the right level of abstraction.</p><p>We send the labeling invitation to different MDE mailing lists and specific large research groups active in the MDE field. Volunteer participants are mostly university students and faculty members across the world. To ensure that the labeling is done in good faith, 1 https://web.imt-atlantique.fr/x-info/atlanmod/index.php?title=Zoos we do not offer monetary compensation for participation. However, since participation was low, we did not impose a contribution limit.</p><p>After about two months of crowdsourcing, we receive labels for 649 fragments across 62 UML class diagrams. The produced dataset is available on a public repository 2 . To ensure quality, labels are reviewed and some are rejected. We replace the rejected labels by labeling them again ourselves. <ref type="figure" target="#fig_2">Figure 4</ref> shows example labels.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Preprocessing and Fragmentation</head><p>Preprocessing is the first step after receiving an input specification from the user as shown in <ref type="figure">Figure 1</ref>. We substitute pronouns throughout the text, such as it and him, by their reference nouns. This is done using coreferee <ref type="bibr" target="#b4">[5]</ref>, which is a tool written in Python that performs coreference resolution, including pronoun substitution.</p><p>A course is taught by a teacher. A classroom is assigned to it. =? A course is taught by a teacher. A classroom is assigned to a course.</p><p>Pronoun substitution allows sentences in the English specification to be less dependent on each other for semantic purposes. The accuracy of coreferee for general English text is 81%.</p><p>Sentence fragmentation is the second step in the runtime operations in <ref type="figure">Figure 1</ref>. We split the preprocessed text into individual sentences, using spaCy <ref type="bibr" target="#b2">[3]</ref>. spaCy is an NLP library in Python that can be used for various NLP tasks, such as sentence splitting. spaCy splits text into sentences by looking at punctuation and special cases like abbreviations. Its decisions are powered by pre-trained statistical models. We use the small English model, which has a good speed and respectable performance. For instance, in the following example, the first two dots are not considered for splitting the sentences but the third dot is.</p><p>An employee has a level of studies, i.e., a degree. An employee is affiliated to a department. =? 1 : An employee has a level of studies, i.e., a degree. <ref type="bibr" target="#b1">2</ref> : An employee is affiliated to a department.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Sentence Classification</head><p>Sentence classification is the third step in the runtime operations of <ref type="figure">Figure 1</ref>. Classification provides additional information on the English specification that can be used later to better generate the related UML diagram fragment. Each sentence is classified as describing either a "class" or a "relationship".</p><p>The training data for the classifier comes from the dataset described in Section 2.2. Each data point is structured as a pair &lt;English specification, UML fragment&gt; and is assigned a label of a "class" or "relationship" from the moment the dataset was processed from AtlanMod Zoo. The pairing means that the English specification belongs to that specific UML fragment. Our classifier is trained to predict the "class/relationship" label from an English specification. To evaluate the accuracy of the classifier, we use 80% of the data for the training, and the remaining 20% for testing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Data collection</head><p>AtlanMod Zoo</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>UML Model Fragmentation</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Crowdsourced</head><p>Labeling Postprocessing Data</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>English specs</head><p>Specification Preprocessing</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Sentence Fragmentation</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Runtime operations</head><p>Sentence Classification UML Fragment Generation When training classifiers on natural language text, we have to select a method to map those sentences into numerical representations. To this end, we experiment with two vectorization methods, count and tf-idf, which are designed to turn words into vectors. tfidf 's key difference from count is the penalization of very common words in a document. This allows giving less importance to words like "the".</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>UML Composition</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>UML Class Diagram</head><p>As for the classification algorithms, we experiment with various algorithms from the scikit-learn library <ref type="bibr" target="#b8">[9]</ref>. We use the default hyperparameter settings for each algorithm. <ref type="table">Table 2</ref> shows the performance of the algorithms on the test data. It is worth noting that the training takes less than one minute.</p><p>Although some classifiers have better accuracy, we pick the Bernoulli Naive Bayes classifier with a tf-idf vectorizer. Bernoulli Naive Bayes is simple, has a good accuracy that is more stable across training experiments and is generally faster to execute.</p><p>Interestingly, Bernoulli Naive Bayes performs better on a tf-idf vectorizer than the count vectorizer, when it should perform equally   well on both in theory. We attribute the difference in performance to the randomized splitting of the dataset when training and testing. Moreover, if a Bernoulli distribution captures enough information to classify well, it seems frequency-based vectorization is not needed. Should a given sentence may describe both a UML class and a UML relationship, we let the classifier make the decision.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5">UML Fragment Generation</head><p>After classifying each sentence as describing either a "class" or a "relationship", we generate the corresponding UML fragment according to this classification, which is the fourth step in the runtime operations of <ref type="figure">Figure 1</ref>.</p><p>Using spaCy's small English model <ref type="bibr" target="#b2">[3]</ref>, we define several grammar patterns to match the English sentences. We design the patterns Key is a class in SimpleRDBMS package CP2: "there is"</p><p>There is a place.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>CP3: Compound noun</head><p>Drawing Interchange Format CP4: Compound explicit Workflow State class CP5: "to have" a Mesh has a name of type String CP6: "class named"</p><p>A class named "Actor".</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>CP7: "of package"</head><p>TextualPathExp is part of the package TextualPathExp CP8: "and" clauses News have titles and links Relationship fragments RP1: "to have"</p><p>A MSProject has at least one task.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>RP2: Passive voice</head><p>A news is published on a specific date RP3: "composed"</p><p>A node is composed of a label RP4: Active voice Eclipse plugins may require other plugins RP5: Noun "with"</p><p>A table with a caption</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>RP6: Copula</head><p>In a Petri Net a Place may be the destination of a Transition <ref type="table">Table 3</ref>: Summary of patterns based on the data we collected through crowdsourcing. We broadly group the patterns in <ref type="table">Table 3</ref>. For sentences labeled as class descriptions, we define eight patterns 1 to 8, and for those describing relationships, we define six patterns 1 to 6. The patterns make use of part-of-speech tagging and dependency analysis.</p><p>Multiple patterns can overlap and as such, the spaCy parser produces several parse trees for the same sentence. For example, in the category of class fragments, the patterns CP3: compound noun and CP4: compound explicit are likely to be both applied at the same time. In this case, we set the CP4: compound explicit pattern at a higher priority and discard the parse tree from CP3: compound noun.</p><p>In general, the priority of patterns in the event of multiple parse trees is based on how specific the pattern is and how much information can be acquired in the parse tree. Hence, for relationship fragments, the patterns for passive voice and active voice are so general that they always yield priority to the other patterns.</p><p>After a pattern and its parse tree have been chosen, we generate a UML fragment using a specific template.</p><p>If the classification of the sentence resulted in "class", we generate a UML class fragment consisting of only one class with some potential attributes. For example, the CP8: and clause pattern creates a class whose name is the subject noun and whose attributes are the objects among the "and" clauses, as shown in <ref type="figure" target="#fig_3">Figure 5</ref>. If the classification of the sentence resulted in a "relationship", we generate a UML fragment with two classes and one unidirectional association between them. In the case of a "relationship", we can also extract the multiplicity, if present in the sentence. Here is an example with the pattern RP1: to have in <ref type="figure" target="#fig_4">Figure 6</ref>.</p><p>A MSProject has at least one task. During the creation of UML class fragments, we perform additional processing on the parse tree results, such as lemmatization, noun phrase discovery, and variable naming. In <ref type="figure" target="#fig_3">Figure 5</ref>, the attributes are in the singular form of the original word. If <ref type="figure" target="#fig_3">Figure 5</ref>'s input text was "News have bold titles and url links", the noun phrase discovery combines the attributes into "boldTitle" and "urlLink" to follow the variable naming convention.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.6">Composition of UML Fragments</head><p>The last step in the runtime operations of <ref type="figure">Figure 1</ref> is the composition of UML fragments into one UML class diagram. After each sentence is turned into a UML fragment, we produce the final UML diagram by combining the fragments. Since the merging of general UML class diagrams is NP-hard <ref type="bibr" target="#b10">[11]</ref>, we design an algorithm tailored to our use case. The time complexity of our algorithm is polynomial, more specifically (( + ) 2 ) where is the number of classes, is the number of relationships between classes and is the number of class attributes.</p><p>The composition algorithm takes a greedy approach. Algorithm 1 merges one UML fragment at a time into a larger, work-in-progress UML diagram. When all fragments are used, the work-in-process diagram is the completed UML diagram.</p><p>During composition, fragments may present contradicting information to the model in progress. We identify two situations for this. The first is an Attribute-Class conflict and the second is an Attribute-Relationship conflict <ref type="figure" target="#fig_8">(Figure 8</ref>). In both situations, the resolution involves removing attributes to create a new class  if has a type and has no type then <ref type="bibr">5:</ref> replace by inside class 6: else <ref type="bibr">7:</ref> insert into class.attributes 8: return class or a new relationship. We favor having many smaller classes and relationships, instead of a few very big classes.</p><p>An Attribute-Class conflict arises when the UML class diagram in progress contains an attribute with a name identical to the name of a class from a class fragment. We resolve this conflict by removing the attribute from the diagram in progress, inserting the class fragment into the larger UML diagram, and creating a new relationship from the class that previously contained the attribute to the inserted class. This relationship has the name of the attribute as its name and a multiplicity of zero-to-many. See an example in <ref type="figure" target="#fig_7">Figure 7</ref>.</p><p>An Attribute-Relationship conflict arises when the UML class diagram in progress contains an attribute whose name is identical to the name of the relationship inside the incoming relationship fragment. Let be the class of this attribute in the diagram in progress. Let be the class that is the source of the unidirectional   Lines 16 and 18 in the composition algorithm (Algorithm 1) make use of "relationship" equality. We define two relationships to be equal if the classes they are related to have the same name and if the name of the relationship is the same after processing. This implies that multiplicity is ignored when assessing equality.</p><p>Finally, this entire pipeline produces one UML class diagram from the received input. We compile the result into an image using a compiler called plantuml [10].</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">EVALUATION 3.1 Setup</head><p>To test the performance of our approach, we use the dataset we created through crowdsourcing in Section 2.2. We first group all the English specifications for fragments by the UML model they originated from. This creates 62 testing samples. For example, the following grouped specification corresponds to the UML class diagram shown in <ref type="figure" target="#fig_10">Figure 9</ref>.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Evaluation Metrics</head><p>To evaluate the accuracy of our approach, we use comparative metrics. We design three levels of strictness for comparing the diagrams generated by our tool and the ground truth of the dataset. We assume there is only one good UML class diagram per input specification.</p><p>First, we have exact matching, which is the most strict comparison. Under exact matching, we look at how many classes and relationships from the ground truth are present in the generated diagrams. A ground truth class is considered present in the prediction if there is a class in the generated diagram that has an identical name and identical attributes. A ground truth relationship is considered "present" in the prediction if both of the classes attached to it are present and if there is a relationship between these two classes with the same name and multiplicity in the predicted output. Each UML diagram under evaluation outputs precision, recall, and f-1 score.</p><p>Second, we have relaxed matching, which is a weaker form of exact matching. In relaxed matching, we still look at how many ground truth classes and relationships are present in the generated diagram. However, a ground truth class is considered "present" if there is a predicted class with the same name. We don't look at attributes anymore. Similarly, ground truth relationships are considered "present" in the prediction in the same way as exact matching, except that multiplicities are ignored.</p><p>Third, we have general matching. This is the most lenient matching criterion. In general matching, classes are still evaluated like in relaxed matching. Relationships, on the other hand, are evaluated collectively instead of individually. We look at a diagram's graph connectivity and compare this connectivity to the ground truth diagram's connectivity. This comparative metric ignores class names, the orientation of relationships, and the name of relationships. As such, general matching ignores semantics.</p><p>To compare two diagrams' connectivity, we use the technique of eigenvector similarity <ref type="bibr" target="#b5">[6]</ref>. In short, this technique looks at the eigenvalues of the Laplacian matrices of the two undirected graphs. If the distance between the most prominent eigenvalues is small, the two graphs are similarly connected. Distances are in the range [0, ?). We apply a mapping to normalize the distance into a score in the interval (0,1], where 0 means no similarity at all and 1 means the two diagrams are identically connected. The mapping is ( ) = 2(1 ? ( )), where ? [0, ?) is the distance and ( ) is the sigmoid function. A perfect connectivity score does not mean the two diagrams are identical.</p><p>To complement connectivity, we add a size difference score to the general matching metric. The size difference is evaluated by computing || 1 ? 2 ||, where = ([number of nodes, number of edges]) of graph . The norm is the Pythagorean distance, and the graphs are the two undirected graphs used in the eigenvector similarity calculation. The norm ranges from 0 to ? 2, with 0 being the best score. We apply the mapping ( ) = 1 ? / ? 2 to make the score fall in the interval [0,1] with 0 being the worst score and 1 being the best score. This means 0 is attributed to graphs with vastly different sizes, and 1 is attributed to graphs with similar sizes. A score of 1 means the size vectors are oriented closely, not that the graphs have the same sizes. To get a better grasp, we look at the precision and recall results for class generation and the connectivity similarity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Results and Discussion</head><p>After generating 62 candidate UML class diagrams from English specifications, we use an automated script to compare the predictions with the ground truth. Each predicted diagram is compared with its ground truth counterpart in the dataset. We take the average of the 62 results for all metrics and present it in <ref type="table">Tables 4 and  5</ref>.</p><p>The evaluation results are not great. The performances are below 50%, which makes our approach not suited for practical use. We explore several reasons for this and the meaning of low results in the challenge of extracting UML class diagrams from natural language specifications.</p><p>Since the precision for class generation is low at 17% for exact matching and 35% for relaxed matching, it might be caused by too  <ref type="table">Table 5</ref>: Performance of generating relationships from English specification many classes in the prediction that can be traced to synonyms in the specification. English specifications can contain synonyms and different wordings for the same idea. If the user decides to use two different terms for the same concept in a specification, they might have wanted two different classes, or the user might have wanted a specification that is more interesting for humans to read. This ambiguity cannot be resolved without user feedback. However, given our approach generates too many classes on average, a more aggressive merging during the composition step (Section 2.6) would be beneficial.</p><p>While our approach generates too many classes, recall for class generation is still too low at 25% for exact matching and 50% for relaxed matching. This means there are elements in the ground truth UML class diagram that are not extracted from English specifications. This can be improved by adding more patterns to the rule set in Section 2.5. Moreover, a better noun phrase extraction mechanism can extract more class names and attributes from the text. Currently, our method works well with noun phrases that are one word or two words long. Noun phrases longer than two words require a more sophisticated extraction process. We used spaCy's default noun phrase detector, but exploring the dependency parse tree ourselves directly might be a better idea.</p><p>A low performance signals that our approach has limits. Since we incorporate several statistical components with their own imperfect accuracy in our pipeline, there is an upper ceiling of performance we cannot exceed. Our performance cannot be better than the performances of these components. If we assume all components have an equal influence on the output, we have an expected upper limit of accuracy of 0.63 as seen in <ref type="table">Table 6</ref>. One way of reducing the effect of compounding errors is to introduce a retroactive step. In our case, that step is the composition algorithm's attempt to resolve conflicts in Algorithm 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Statistical component</head><p>Accuracy Pronoun resolution (coreferee) 0.81 Grammar analysis (spaCy) 0.90 Binary classification 0.87</p><p>Combined product 0.63 <ref type="table">Table 6</ref>: Accuracies of each statistical component in our approach</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">THREATS TO VALIDITY</head><p>Although we rejected bad labels during the creation of the dataset, some volunteers provided specifications with questionable semantics and spelling errors. We kept those labels because we want our approach to operate under imperfect conditions. Our approach cannot deal with spelling errors and confusing specifications. Each spelling mistake creates an extra UML class or relationship that should not exist. And if the specification is unclear, then the generated diagram is also unclear.</p><p>Due to a lack of sufficient data, we did not set aside unseen data for the evaluation. The evaluation uses the entire dataset for testing. Despite the classifier of Section 2.4 splitting the data into 80-20, 80% of the evaluation data has been seen during the training of the classifier. We believe this bias to be minimal because the classification is an intermediate step.</p><p>In the composition algorithm (Algorithm 1), the merging of the UML class diagram with fragments is treated in a non-commutative fashion. In other words, the pseudo-code only addresses the conflicts when it is an Attribute-Class ( <ref type="figure" target="#fig_7">Figure 7)</ref> and not Class-Attribute. A similar situation is happening for the Attribute-Relationship conflict. If the conflicting relationship is already inside the model in progress, the algorithm will not flag that as an Attribute-Relationship conflict and it will therefore not resolve it. An improved version of the algorithm should treat the merging of the UML class diagram and the fragment in two directions, i.e. in a commutative way. This would increase the performance of our approach.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">RELATED WORK 5.1 Survey of Relevant Literature</head><p>In 2021, 24 published tools and methods for the extraction of UML class diagrams from natural language specifications have been surveyed. In the survey, most tools and methods require consistent user intervention. Most tools also required the specification to be given in a specific format, such as a more restricted vocabulary of English or a more rigid structure rather than free-flowing text. The authors concluded that no fully automated tool to generate complex UML class diagrams exists <ref type="bibr" target="#b1">[2]</ref>. The survey uses qualitative methods to evaluate the outputs of UML extractors. Though valuable, qualitative evaluation is not enough to assess the correctness of the proposed approach and to compare them. We provide quantitative metrics and a testing dataset that can be used for all future UML class diagram extractors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Degree of automation # of papers</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Automatic Approaches</head><p>Automatic approaches do not require extensive user intervention. Once input is given, the user only needs to wait for the recommended result. The automatic approaches make use of more traditional NLP techniques, such as hand-written rules and grammar parsing. For example, the authors of <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b6">7]</ref> use several heuristics to analyze the natural language specification.</p><p>The automated approaches presented in <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b6">7]</ref> have normalization rules, which require users to write specifications in a restricted English sentence structure. Our approach accepts free-flowing text. We don't have any normalization rules that users must keep in mind.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Semi-automatic Approaches</head><p>Semi-automatic approaches make use of an AI assistant to guide the user in general UML class diagrams. DoMoBOT is an example of such a tool. Overall, DoMoBOT makes use of machine learning via knowledge bases inside pre-trained models and word embeddings. The UML class diagram is generated progressively as the user provides feedback to DoMoBOT <ref type="bibr" target="#b11">[12]</ref>.</p><p>Although human intervention during the generation of UML models improves quality, the additional effort spent by users makes the tools difficult to use, especially by domain experts. Our approach is meant to improve the automation of the generation process as much as possible. An automated approach is also better for consistent testing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">CONCLUSION</head><p>In this paper, we propose an automated approach to extract UML class diagrams from English specifications. The approach uses machine learning and pattern-based techniques. Machine learning is used in the form of a binary classifier that labels sentences as either describing a class or a relationship. The pattern-based techniques are handwritten grammar rules to parse English sentences. In this approach, we fragment the English input into sentences, generate UML class diagram fragments from them, and combine all the fragments together into a final result.</p><p>To develop our tool, we first create a dataset of UML diagrams paired with English specifications. The specifications are produced by a crowdsourcing initiative. The resulting dataset, although small, is enough to train the classifier and evaluate our approach.</p><p>We define three evaluation metrics of varying strictness to test our approach's accuracy in generating classes and relationships from an English specification. The results for classes are 17% precision and 25% recall for exact matching, the strictest metric. The results for relationships are a connectivity similarity of 63% and a size difference of 67%.</p><p>The correctness of the produced diagrams is limited. However, these results are in part explained by the imprecision of the NLP tools we used. Using more sophisticated NLP tools will help to improve these results. In addition, more grammar patterns can be added in Section 2.5 and an improved version of the composition algorithm will reduce irrelevant classes.</p><p>From a broader perspective, our research lays the work for a consistent quantitative evaluation framework with our approach being the baseline and with the dataset and metrics being the testing framework. From the novelty perspective, we explore intermediate machine learning steps to simplify a mostly rule-based approach. Furthermore, our approach uses a divide-and-conquer strategy when fragmenting diagrams and text and when composing them back together.</p><p>In the future, a more complex pattern system can improve the performance of our approach. Currently, we only use a single rule to generate a UML fragment, but if several rules contribute together, the performance can increase. The composition algorithm can also be improved, such as by considering a confidence score in each fragment. Furthermore, inheritance can be generated as a new type of relationship by adding more grammar patterns. Finally, we can generalize our approach to handle other types of UML diagrams, in particular behavioral ones.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :Figure 2 Figure 3 :</head><label>123</label><figDesc>Overview of the extraction process of UML class diagrams from natural language specification ClassName attributeName attributeName Relationship fragment</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>Key is a class in SimpleRDBMS packageSimpleRDBS Key</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 :</head><label>4</label><figDesc>Example labels received by crowdsourcing</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 5 :</head><label>5</label><figDesc>Example of class generation</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 6 :</head><label>6</label><figDesc>Example of relationship generation</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Algorithm 1 algorithm 1 :</head><label>11</label><figDesc>Composition ? previous composition result or any fragment if the composition is just starting 2:? incoming fragment3:  if kind( ) = class then4:    if ? ? .classes where .name = .name then</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 7 :</head><label>7</label><figDesc>Attribute-Class conflict and its resolution association inside the relationship fragment. Let be the class that is the destination of the unidirectional association inside the relationship fragment. If the names of and are not the same, this is not a conflict and we proceed with a standard insertion. Otherwise, the resolution starts by removing the attribute from . Then we merge the attributes of and . The relationship from to is now from the attribute merge result to .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 8 :</head><label>8</label><figDesc>Attribute-Relationship conflict and its resolution</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Drawing</head><label></label><figDesc>Interchange Format. a Drawing Interchange model may have multiple meshes. a Mesh has a name of type String. a Mesh may have any number of points. a point maps to only one Mesh. a point has a name of type String and coordinates X and Z of type Double.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 9 :</head><label>9</label><figDesc>An original UML class diagram from the AtlanMod Zoo</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table owner</head><label>owner</label><figDesc></figDesc><table><row><cell>1..1</cell></row></table><note>(b) A Key is owned by one and only one Table in an RDBMS</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>if ? ? class.attributes where .name = .name then</figDesc><table><row><cell></cell><cell cols="3">left ? class from which points</cell></row><row><cell>15:</cell><cell cols="3">right ? class to which points</cell></row><row><cell>16:</cell><cell>if left ?</cell><cell cols="2">.classes then</cell></row><row><cell>17:</cell><cell cols="2">insert left into</cell></row><row><cell>18:</cell><cell>if right ?</cell><cell cols="2">.classes then</cell></row><row><cell>19:</cell><cell cols="2">insert right into</cell></row><row><cell>20:</cell><cell cols="2">if 's relationship ?</cell><cell>.relationships then</cell></row><row><cell>21:</cell><cell cols="2">do nothing</cell></row><row><cell>22:</cell><cell>else</cell><cell></cell></row><row><cell>23:</cell><cell cols="2">insert into</cell></row><row><cell cols="2">24: return</cell><cell></cell></row><row><cell cols="3">Algorithm 2 Merge attributes</cell></row><row><cell cols="3">1: class ? recipient UML class</cell></row><row><cell>2:</cell><cell cols="2">? incoming attribute</cell></row><row><cell>3: 4:</cell><cell></cell><cell></cell></row></table><note></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2">https://github.com/XsongyangX/uml-classes-and-specs</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Generating UML class diagram using NLP techniques and heuristic rules</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Esra A Abdelnabi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Abdelsalam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Maatuk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Tawfig</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Abdelaziz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Salwa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Elakeili</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2020 20th International Conference on Sciences and Techniques of Automatic Control and</title>
		<imprint>
			<date type="published" when="2020" />
			<biblScope unit="page" from="277" to="282" />
		</imprint>
		<respStmt>
			<orgName>Computer Engineering (STA). IEEE</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Generating UML Class Diagram from Natural Language Requirements: A Survey of Approaches and Techniques</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Esra</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Abdelsalam</forename><forename type="middle">M</forename><surname>Abdelnabi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mohammed</forename><surname>Maatuk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Hagal</surname></persName>
		</author>
		<idno type="DOI">10.1109/MI-STA52233.2021.9464433</idno>
		<ptr target="https://doi.org/10.1109/MI-STA52233.2021.9464433" />
	</analytic>
	<monogr>
		<title level="m">2021 IEEE 1st International Maghreb Meeting of the Conference on Sciences and Techniques of Automatic Control and Computer Engineering MI-STA. 288-293</title>
		<imprint>
			<date type="published" when="2021" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">spaCy: Industrial-Strength Natural Language Processing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">I</forename><surname>Explosion</surname></persName>
		</author>
		<ptr target="https://spacy.io/" />
	</analytic>
	<monogr>
		<title level="j">Explosion AI</title>
		<imprint>
			<date type="published" when="2016-07-13" />
		</imprint>
	</monogr>
	<note>Retrieved</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Automatic generation of UML sequence diagrams from user stories in Scrum process</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Meryem</forename><surname>Elallaoui</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Khalid</forename><surname>Nafil</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Raja</forename><surname>Touahni</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2015 10th international conference on intelligent systems: theories and applications (SITA)</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2015" />
			<biblScope unit="page" from="1" to="6" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Coreferee: Coreference resolution for multiple languages</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Richard</forename><surname>Paul</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hudson</forename></persName>
		</author>
		<ptr target="https://spacy.io/universe/project/coreferee" />
	</analytic>
	<monogr>
		<title level="j">Explosion AI</title>
		<imprint>
			<date type="published" when="2021-07-13" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Algorithms for Graph Similarity and Subgraph Matching</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Danai</forename><surname>Koutra</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ankur</forename><surname>Parikh</surname></persName>
		</author>
		<ptr target="https://www.cs.cmu.edu/~jingx/docs/DBreport.pdf" />
	</analytic>
	<monogr>
		<title level="m">Aaditya Ramdas, and Jing Xiang</title>
		<imprint>
			<date type="published" when="2011-07-18" />
			<biblScope unit="page" from="15" to="16" />
		</imprint>
	</monogr>
	<note>Retrieved</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Generating UML diagrams from natural language specifications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Priyanka</forename><surname>More</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rashmi</forename><surname>Phalnikar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Applied Information Systems</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="19" to="23" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gunter</forename><surname>Mussbacher</surname></persName>
		</author>
		<title level="m">Opportunities in intelligent modeling assistance. Software and Systems Modeling</title>
		<imprint>
			<date type="published" when="2020" />
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="1045" to="1053" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Scikit-learn: Machine Learning in Python</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Pedregosa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Varoquaux</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Gramfort</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Michel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Thirion</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Grisel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Blondel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Prettenhofer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Weiss</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Dubourg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Vanderplas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Passos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Cournapeau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Brucher</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Perrot</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Duchesnay</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Machine Learning Research</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="2825" to="2830" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Open-source tool that uses simple textual descriptions to draw beautiful UML diagrams</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Plantuml</surname></persName>
		</author>
		<ptr target="https://plantuml.com" />
	</analytic>
	<monogr>
		<title level="j">PlantUML</title>
		<imprint>
			<date type="published" when="2021-07-14" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">N-Way Model Merging</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Julia</forename><surname>Rubin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marsha</forename><surname>Chechik</surname></persName>
		</author>
		<idno type="DOI">10.1145/2491411.2491446</idno>
		<ptr target="https://doi.org/10.1145/2491411.2491446" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2013 9th Joint Meeting on Foundations of Software Engineering</title>
		<meeting>the 2013 9th Joint Meeting on Foundations of Software Engineering<address><addrLine>Saint Petersburg, Russia; New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2013" />
			<biblScope unit="page" from="301" to="311" />
		</imprint>
	</monogr>
	<note>ESEC/FSE 2013)</note>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Automated, interactive, and traceable domain modelling empowered by artificial intelligence. Software and Systems Modeling</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rijul</forename><surname>Saini</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gunter</forename><surname>Mussbacher</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">C</forename><surname>Jin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J?rg</forename><surname>Guo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Kienzle</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2022" />
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="1015" to="1045" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
