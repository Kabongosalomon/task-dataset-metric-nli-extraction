<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /nfs/home/kabenamualus/Research/task-dataset-metric-extraction/../grobid-0.6.0/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Submanifold Sparse Convolutional Networks</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2017-06-06">June 6, 2017</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Benjamin</forename><surname>Graham</surname></persName>
							<email>benjamingraham@fb.com</email>
							<affiliation key="aff0">
								<orgName type="department">Facebook AI Research</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Laurens</forename><surname>Van Der Maaten</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Facebook AI Research</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Submanifold Sparse Convolutional Networks</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2017-06-06">June 6, 2017</date>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>

		<encodingDesc>
			<appInfo>
				<application version="0.6.0" ident="GROBID-SDO" when="2022-11-12T19:26+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid-sdo"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Convolutional network are the de-facto standard for analysing spatio-temporal data such as images, videos, 3D shapes, etc. Whilst some of this data is naturally dense (for instance, photos), many other data sources are inherently sparse. Examples include penstrokes forming on a piece of paper, or (colored) 3D point clouds that were obtained using a LiDAR scanner or RGB-D camera. Standard "dense" implementations of convolutional networks are very inefficient when applied on such sparse data. We introduce a sparse convolutional operation tailored to processing sparse data that differs from prior work on sparse convolutional networks in that it operates strictly on submanifolds, rather than "dilating" the observation with every layer in the network. Our empirical analysis of the resulting submanifold sparse convolutional networks shows that they perform on par with state-of-the-art methods whilst requiring substantially less computation.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Convolutional networks constitute the state-of-the art method for a wide range of tasks that involve the analysis of data with spatial and/or temporal structure, such as photographs, videos, or three-dimensional surface models. While such data frequently comprises a densely filled (2D or 3D) grid, other spatio-temporal datasets are naturally sparse. For instance, handwriting is made up of one-dimensional lines in two-dimensional space, pictures made by RGB-D cameras are three-dimensional point clouds, and OFF models form two-dimensional surfaces in 3D space. The curse of dimensionality applies, in particular, on data that lives on grids that have three or more dimensions: the number of points on the grid grows exponentially with its dimensionality. In such scenarios, it becomes increasingly important to exploit data sparsity whenever possible in order to reduce the computational resources needed for data processing. Indeed, exploiting sparsity is paramount when analyzing, for instance, RGB-D videos which are sparsely populated 4D structures.</p><p>Traditional convolutional network implementations are optimized for data that lives on densely populated grids, and cannot process sparse data efficiently. More recently, a number of convolutional network implementations have been presented that are tailored to work efficiently on sparse data <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b1">2,</ref><ref type="bibr" target="#b8">9]</ref>. Mathematically, some of these implementations are identical to a regular convolutional network, but they require fewer computational resources in terms of FLOPs <ref type="bibr" target="#b0">[1]</ref> and/or in terms of memory <ref type="bibr" target="#b1">[2]</ref>. OctNets <ref type="bibr" target="#b8">[9]</ref> slightly modify the convolution operator to produce "averaged" hidden states in parts of the grid that are away from regions of interest.</p><p>One of the downsides of prior sparse implementations of convolutional networks is that they "dilate" the sparse data in every layer, because they implement a "full" convolution. In this work, we show that it is possible to successfully train convolutional networks that keep the same sparsity pattern throughout the layers of the network, without dilating the feature maps. To this end, we explore two novel convolution operators: sparse convolution (SC) and valid sparse convolution (VSC). In our experiments with recognizing handwritten digits and 3D shapes, networks using SC and VSC achieve state-of-the-art performance whilst reducing the computation and memory requirements by ? 50%.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Motivation</head><p>We define a d-dimensional convolutional network as a network that takes as input that is a (d + 1)-dimensional tensor: the input tensor contains d spatiotemporal dimensions (such as length, width, height, time, etc.) and one additional feature space dimension (for instance, RGB color channels, surface normal vectors, etc.). A sparse input corresponds to a d-dimensional grid of sites that is associated with a feature vector. We define a site in the input to be active if any element in the feature vector is not in its ground state, for instance, if it is non-zero 1 . In many practical problems, thresholding may be used to eliminate sites at which the feature vector is within a very small distance from the ground state. Note that even though the input tensor is (d + 1)-dimensional, activity is a d-dimensional phenomenon: entire planes along the feature dimension are either active or not.</p><p>The hidden layers of a convolutional network are also represented by d-dimensional grids of feature-space vectors. When propagating the input data through the network, a site in a hidden layer is active if any of the sites in the layer that it takes as input is active. (Note that when using 3 ? 3 convolutions, each site is connected to 3 ? 3 = 9 sites in the hidden layer below.) Activity in a hidden layer thus follows an inductive definition in which each layer determines the set of active states in the next. In each hidden layer, inactive sites all have the same feature vector: the one corresponding to the ground state. Note that the ground state in a hidden layer is often not equal to zero, in particular, when convolutions with a bias term are used. However, irrespective of the value of the ground state, the ground-state value only needs to be calculated once per forward pass during training (and only once for all forward passes at test time). This allows for substantial savings in computational and memory requirements; the exact savings depend on the data sparsity and the network depth.</p><p>In this paper, we argue that the framework described above is unduly restrictive, in particular, because the convolution operation has not been modified to accommodate the sparsity of the input data. If the input data contains a single active site, then after applying a 3 d convolution, there will be 3 d active sites. Applying a second convolution of the same size will yield 5 d active sites, and so on. This rapid growth of the number of active sites is a poor prospect when implementing modern convolutional network architectures that comprise tens or even hundreds of convolutions, such as VGG networks, ResNets, and DenseNets <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b9">10]</ref>. Of course, convolutional networks are not often applied to inputs that only have a single active site, but the aforementioned "dilation" problems are equally problematic when the input data comprises one-dimensional curves in spaces with two or more dimensions, or two-dimensional surfaces in three or more dimensions.</p><p>To address the problems with dilation of active sites, we propose two slightly different convolution operations for use in convolutional networks. What the two operations have in common is that they both ignore the ground state: they replace the ground state with a zero vector to simplify the convolution operations. The difference between both operations is in how they handle active sites: instead of automatically making a site active if any of the inputs to its receptive field is active (thereby dilating the set of active sites), our most efficient convolutional operation only considers the central input. As a result, the output set of active sites exactly mirrors that of the input set. We empirically demonstrate that use of our adapted convolutional operators allows us to build much deeper networks that achieve state-of-the-art results whilst requiring much fewer resources by preserving sparsity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Submanifold Dilation</head><p>In <ref type="figure" target="#fig_0">Figure 1</ref>, we show an example of a one-dimensional curve that is embedded on a two-dimensional grid. The figure shows that even when we apply small 3 ? 3 convolutions on this grid, the sparsity on the grid rapidly disappears. At the same time, if we restrict the output of the convolution only to the set of active input points, hidden layers in the network cannot capture a lot of information that may relevant to the classification of the curve. In particular, two neighboring connected components will be treated completely independently. Luckily, nearly all convolutional networks incorporate some form of pooling, or use strided convolutions. These operations are essential in the sparse convolutional networks 2 we investigate, as they allow neighboring components to merge. In particular, the closer the components are, the smaller the number of poolings / strided convolutions is that is necessary for the components to merge in the hidden-layer representations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Very Deep Convolutional Networks</head><p>In image classification, very deep convolutional networks with small filters, often of size 3 ? 3 pixels and a padding of 1 pixel (to preserve the size of the feature maps), have proven to be very effective. Such small filters were used successfully in VGG networks, which have relatively wide layers. The introduction of residual networks (ResNets) showed that deeper but narrow networks with small filters are more efficient. The success of very deep ResNets, ResNeXt models, and DenseNets with bottleneck connections <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b11">12]</ref> shows that it can be useful to calculate a relatively small number of features at a time and amalgamate these features into a larger state variable, either by vector-addition or feature-vector concatenation.</p><p>Unfortunately, these techniques are impractical using existing sparse convolutional network implementations. One problem is that networks with multiple paths will tend to generate different sets of active paths, which would have to be merged to reconnect the outputs. It seems that this would be difficult to perform this merging efficiently. More importantly, ResNets and DenseNets generate such large receptive fields that sparsity would almost immediately be destroyed by the explosion in the number of active sites.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">(Valid) Sparse Convolutions: SC and VSC</head><p>We define a sparse convolution SC(m, n, f, s) with m input feature planes, n output feature planes, a filter size of f , and stride s. We assume f and s to be odd integers, but we can allow generalization to non-square filters, e.g., f = 1 ? 7 or f = 7 ? 1, if we want to implement Inception-style factorised convolutions <ref type="bibr" target="#b10">[11]</ref>. An SC convolution computes the set of active sites in the same way as a regular convolution: it looks for the presence of any active sites in its receptive field of size f d . If the input has size then the output will have size ( ? f + s)/s. An SC convolution differs from a regular convolution in that it discards the ground state for non-active sites by assuming that the input from those sites is exactly zero. Whereas this is a seemingly small change to the convolution operation, it may bring computational benefits in practice.</p><p>Next, we define a second type of sparse convolution, which forms the main contribution of this paper. Again, let f denote an odd number, or collection of odd numbers, e.g., f = 3 or f = 1 ? 7.</p><p>We define a valid sparse convolution VSC(m, n, f, 1) as a modified SC(m, n, f, 1) convolution. First, we pad the input with (f ? 1)/2 on each side, so that the output will have the same size as the input. Next, we restrict an output site to be active if and only if the site at the corresponding site in the input is active (i.e., if the central site in the receptive field is active). Whenever an <ref type="table">Table 1</ref>: Computational and memory costs of three different convolutional operations at active and non-active sites: regular convolution (C), sparse convolution (SC), and valid sparse convolution (VSC). We consider convolutions of size 3 at a single location in d dimensions. Notation: a is the number of active inputs to the spatial location, m the number of input feature planes, and n the number of output feature planes. output site is determined to be active, its output feature vector is calculated by the SC operation. <ref type="table">Table 1</ref> presents the computational and memory requirements of a regular convolution (C) and of our SC and VSC convolutions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Active</head><p>To construct convolutional networks using SC and VSC, we also need activation functions, batch normalization, and pooling. Activation functions are defined as usual, but are restricted to the set of active sites. Similarly, we define batch normalization in terms of regular batchnormalization applied over the set of active sites. Max-pooling MP(f, s) and average-pooling AP(f, s) operations are defined as a variant of SC(?, ?, f, s). MP takes the maximum of the zero vector and the input feature vectors in the receptive field. AP calculates f ?d times the sum of the active input vectors.</p><p>We also define a deconvolution operation DC(?, ?, f, s) as an inverse of the SC(?, ?, f, s) convolution <ref type="bibr" target="#b12">[13]</ref>. The set of active output sites from a DC convolution is exactly the set of input active sites to the matching SC convolution. The set of connections between input-output sites is simply inverted.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Submanifold Convolutional Networks</head><p>We use a combination of VSC convolutions, strided SC convolutions, and sparse pooling operations to build sparse versions of the popular VGG, ResNet, and DenseNet convolutional networks. The blocks we use in our networks are presented in <ref type="figure">Figure 2</ref>. We refer to our networks as submanifold convolutional networks, because they are optimised to process low-dimensional data living in a space of higher dimensionality. <ref type="bibr" target="#b2">3</ref> We use the name VGG to refer to networks that contain a number of VSC(?,?,3,1) convolutions, separated by max-pooling <ref type="bibr" target="#b9">[10]</ref>. Each convolution is followed by batch normalization and a ReLU non-linearity.</p><p>Similarly, we define "pre-activated ResNets" <ref type="bibr" target="#b2">[3]</ref> in which most data processing is performed by pairs of VSC(?,?,3,1) convolutions, and in which the residual connections are identity functions. Whenever the number of input / output features is different, we use a VSC(?,?,1,1) instead. Whenever there is change of scale, we replace the first convolution and the residual connection by a SC(?, ?,3,2) convolution. This ensures that two branches can use the same hash table of active sites, and reduces additions to a simple sum of two equally sized matrices. The increased size of the residual connection's receptive field also prevents excessive information loss.</p><p>We also experiment with submanifold DenseNets <ref type="bibr" target="#b3">[4]</ref>. Herein, the word dense does not refer to a lack of spatial sparsity but rather to the pattern of connections between convolution operations. A simple DenseNet module is a sequence of convolutions in which each convolution takes as input the concatenated output of all the previous convolution operations. The bottleneck layers in our submanifold DenseNets are implemented in the same way as for ResNets.  <ref type="figure">Figure 2</ref>: Modules used for building sub-manifold sparse convolutional networks: (a) VGG blocks comprise two VSC convolutions and a max-pooling operation; (b) ResNet blocks that maintain spatial resolution add the output of two VSC convolutions to the input; (c) ResNet blocks that reduce spatial resolution replace the first VSC convolution and the (implicit) identity function by a strided SC convolution; (d) DenseNet blocks that maintain spatial resolution concatenate the output of two VSC convolutions with the input; and (e) DenseNet blocks that reduce spatial resolution perform a single VSC convolution and an average-pooling. The four arguments of a convolution operator (SC or VSC) are the number of input planes n i , the number of output planes n o , the kernel size, and the stride, respectively. The two arguments of a pooling operator are the kernel size and the stride, respectively. The "growth rate" of a DenseNet <ref type="bibr" target="#b3">[4]</ref> is denoted by g.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Implementation</head><p>To implement (V)SC convolutions efficiently, we store the state of a input/hidden layer in two parts: a hash table <ref type="bibr" target="#b3">4</ref> and a matrix. The matrix has size a ? m and contains one row for each of the a active sites. The hash table contains (location, row) pairs for all active sites: the location is a tuple of integer coordinates, and the row number indicates the corresponding row in the feature matrix. Given a convolution with filter size f , we define a rule book to be a collection R = (R i : i ? {0, 1, ..., f ?1} d ) of f d integer matrices of size k i ?2. To implement an SC(m, n, f, s) convolution, we:</p><p>? Iterate once through the the input hash-table. We build the output hash table and rule book on-the-fly by iterating over points in the output layer that receive input from a given point in the input layer. When an output site is visited for the first time, a new entry is created in the output hash table. Based on the spatial offset between the input and output points, a (input index, output index) pair is added to the rule book.</p><p>? Initialize the output matrix to all zeros. For each i ? f , there is a parameter matrix W i with size m ? n. For each j ? {1, . . . , k i }, multiply the R i (j, 1)-th row of the input feature matrix by W i and add it to the R i (j, 2)-th row of the the output feature matrix. This can be implemented very efficiently on GPUs because it is a matrix-matrix multiply-add operation.</p><p>To implement a VSC convolution, we re-use the input hash table for the output, and construct an appropriate rule book. Note that because the sparsity pattern does not change, the same rule book can be re-used in VGG/ResNet/DenseNet networks until a pooling or subsampling layer is encountered.</p><p>If there are a active points in the input layer, the cost of building the input hash-table is O(a). For VGG/ResNet/DenseNet networks, assuming the number of active sites reduces by a multiplicative factor with each pooling operation, the cost of building all the hash-tables and rule-books is also O(a), regardless of the depth of the network.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Experiments</head><p>We perform experiments on a 2D and a 3D dataset with sparse images. The CASIA dataset [7] 5 contains samples of 3755 GBK level-1 characters with approximately 240 train and 60 test images per class. CJVK characters are good test cases for our models because they are a worst-case scenario for sparse convolutional networks: when drawn at scale 64 ? 64, about 8% of the pixels are active, but this percentage rapidly decreases after pooling due to the small density of the pen strokes. This makes them a good test case for our models. The ModelNet-40 dataset 6 contain 2468 CAD models that contain shapes corresponding to 40 classes. We follow the preprocessing of <ref type="bibr" target="#b7">[8]</ref> before feeding the models into our convolutional networks. All CAD models were rendered as surfaces at size 30 3 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Results on CASIA</head><p>We first experiment with two VGG architectures on the CASIA dataset. We trained all models for 100 epochs using batches of size 100, SGD with momentum 0.9, a weight decay of 10 ?4 , and a learning rate decay of 5% per epoch. For simplicity, we do not employ any data augmentation.</p><p>The architectures of our VGG networks and their performances are presented in <ref type="table" target="#tab_1">Table  2</ref>. We observe that "regular" C convolutions and "sparse" SC convolutions achieve the same error: this result suggests that discarding the ground state has essentially no negative impact on performance. This is an argument for always discarding ground states, as it makes things easier computationally and algorithmically. Comparing SC with VSC convolutions, we observe a minimal loss in performance by considering only the valid part of the convolution. This minimal  loss in accuracy does facilitate great computational improvements: networks using VSC use 2 to 3? less computation and memory. Next, we performed experiments on CASIA with submanifold ResNets. The key difference between our implementation of ResNets and regular ResNets is that stride-2 ResNet modules use SC(?,?,3,2) convolutions for the strided convolution, rather than SC(?,?,1,2). This change is necessary to ensure the two branches produce the same set of active sites, which simplifies bookkeeping and turns the addition operation into a simple matrix-matrix addition. Unlike the VSC convolutions that are used in most layers, the SC(?,?,3,2) we use after downsampling leads sites to be active if any of its inputs are active, which avoids information loss in the transition. The architectures of our ResNet networks and their performances are presented in <ref type="table" target="#tab_2">Table 3</ref>. The results with ResNets are in line with those obtained using VGG networks: we obtain reductions in computational and memory requirements by at least a factor of 2 at a minimal loss in accuracy.</p><p>We also performed experiments with DenseNets; please see <ref type="table" target="#tab_3">Table 4</ref>.</p><p>Next we experimented with adding extra connections to VGG networks to increase the effective receptive fields of the hidden states; see <ref type="table" target="#tab_4">Table 5</ref> for results. In the table, {a, b} denotes a VSC(?, a, 3, 1) convolution performed in parallel with a chain of SC(?, b, 3, 2)-VSC(b, b, 3, 1)-DC(b, b, 3, 2) operations; outputs are concatenated to produce a + b output feature planes.   To simplify the network design, we switched to size-3 stride-2 max-pooling, matching the SC convolutions in the SC-VSC-DC branches, and reduce the input size from 64?64 to 63?63. <ref type="figure" target="#fig_2">Figure  3</ref> presents an overview of all our results on the CASIA dataset.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Feature size</head><formula xml:id="formula_0">VGG-C VGG + -C VGG-D VGG + -D 63?63 {16, 0} ? 2 {16, 8} ? 2 {16, 0} ? 2 {16, 8} ? 2 31? 31 {32, 0} ? 2 {32, 8} ? 2 {32, 0} ? 2 {32, 8} ? 2 15 ?15 {48, 0} ? 2 {48, 16} ? 2 {64, 0} ? 2 {64, 16} ? 2 7?7 {64, 0} ? 2 {64, 16} ? 2 {128, 0} ? 2 {96, 16} ? 2 3?3 {96, 0} ? 2 {96, 16} ? 2 {256, 0} ? 2 {256, 32} ? 2 3?3 128C3 128C3 512C3 512C3</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Results on ModelNet</head><p>In a second set of experiments, we compare two submanifold VGG networks with a state-of-the-art dense convolutional network on the ModelNet-40 dataset <ref type="bibr" target="#b7">[8]</ref>. The results of these experiments are shown in <ref type="table" target="#tab_6">Table 6</ref>: the left part of the table shows the architecture and performance of our submanifold VGG networks, whereas the right part of the table shows that of the dense 3DNiN network <ref type="bibr" target="#b7">[8]</ref>. The results clearly demonstrate that submanifold have the potential for designing convolutional networks for sparse data that obtain state-of-the-art performance with limited computational requirements: in particular, our VGG-A network makes 2% more errors at 13? fewer computations, and our VGG-B performs roughly on par with the dense 3DNiN whilst performing ? 5? fewer computations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Related Work</head><p>This paper is not the first to study sparse convolutional networks <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b1">2,</ref><ref type="bibr" target="#b8">9]</ref>. Most prior networks for sparse data implements a standard convolutional operator that increases the number of active sites with each layer <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b1">2]</ref>. By contrast, our submanifold convolutional networks allows sparse data to be processed whilst retraining a much greater degree of sparsity. We have shown that this makes it practical to train deep and efficient VGG and ResNet models.  Submanifold convolutional networks are also much sparser than OctNets <ref type="bibr" target="#b8">[9]</ref>. OctNet stores data in oct-trees: a data structure in which the grid cube is progressively subdivided into 2 3 smaller sub-cubes until the sub-cubes are either empty or contain a single active site. To compare the efficiency of OctNets with that of submanifold convolutional networks, we picked a random sample from the ModelNet-40 dataset and rendered it in a cube with 32 3 grid points. The resulting grid had 423 active sites, which corresponds to 1.3% of the total number of sites. Each active site had on average 12.4 active neighbors (the maximum possible number of neighbors is 27). VSC convolutions, therefore, require only 0.6% of the work of a dense (C) convolution. However, in the OctTree, 80%, 13%, 4%, and 3% of the volume of the cube is covered by sub-cubes of size 8 3 , 4 3 , 2 3 and 1 3 , respectively. As a result, an OctNet convolution, which operates over the surfaces of the smaller cubes, requires about 35% of the computations that a dense (C) convolution requires. In this particular example, an OctNet convolution thus has a computational cost that is 60 times higher than that of a VSC convolution.</p><p>Submanifold convolutional networks also have advantages in terms of memory requirements. In particular, a submanifold network stores a single feature vector for each of the active sites. By contrast, OctTrees have about twice as many empty child nodes as active nodes, which implies they have to store roughly three times as many features as a submanifold convolutional network.</p><p>Having said that, some of the ideas of <ref type="bibr" target="#b8">[9]</ref> may be combined with VSC convolutions. In particular, it is possible to use oct-trees as a specialized hash function in VSC convolutions. Such an oct-tree-based hash function has the potential to be faster than a standard universal hash function that operates on integer tuple keys, like in our implementation of VSC.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusion</head><p>We introduced a new sparse convolutional operator, called valid sparse convolution (VSC), that facilitates the design of efficient, deep convolutional networks for sparse data. We have shown that VSC convolutions lead to substantial computational savings whilst maintain state-of-theart accuracies on two datasets: a dataset comprising one-dimensional manifolds embedded in two-dimensional space, and a dataset comprising two-dimensional surfaces embedded in threedimensional space.</p><p>As part of this paper, we are releasing easy-to-use implementations of VSC and the other sparse operations we used in the networks described in this paper. We will also release code to reproduce the results of our experiments.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Example of "submanifold" dilation. Left: Original curve. Middle: Result of applying a regular 3 ? 3 convolution with weights 1/9. Right: Result of applying the same convolution again. The example shows that regular convolutions substantially reduce the sparsity of the feature maps.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>VGG (b) ResNet (block) (c) ResNet (transition) (e) DenseNet (transition) (d) DenseNet (block)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Overview of all experiments on the CASIA dataset. We denote submanifold convolutional networks by V, submanifold networks with SC-VSC-DC connections by D, regular sparse networks by S, and regular dense networks by C. Locations closer to the bottom-left corner are better.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 2 :</head><label>2</label><figDesc>Classification error, computational requirements (in FLOPs), and memory load (measured by the number of hidden states) of two VGG networks with three different convolutional operations (C, SC, and VSC) on the CASIA dataset. The network architecture is specified in the top part of the table; the bottom part presents the performance characteristics of the networks. Lower is better.</figDesc><table><row><cell>Feature size</cell><cell></cell><cell>VGG-A</cell><cell></cell><cell></cell><cell>VGG-B</cell><cell></cell></row><row><cell>64?64</cell><cell cols="3">2?16C3, MP2</cell><cell cols="3">2?16C3, MP2</cell></row><row><cell>32?32</cell><cell cols="3">2?32C3, MP2</cell><cell cols="3">2?32C3, MP2</cell></row><row><cell>16 ?16</cell><cell cols="3">2?48C3, MP2</cell><cell cols="3">2?64C3, MP2</cell></row><row><cell>8?8</cell><cell cols="3">2?64C3, MP2</cell><cell cols="3">2?128C3, MP2</cell></row><row><cell>4?4</cell><cell></cell><cell>2?96C43</cell><cell></cell><cell></cell><cell>2?256C3</cell><cell></cell></row><row><cell>4?4</cell><cell></cell><cell>128C4</cell><cell></cell><cell></cell><cell>512C4</cell><cell></cell></row><row><cell>Convolution</cell><cell>C</cell><cell cols="2">SC VSC</cell><cell>C</cell><cell cols="2">SC VSC</cell></row><row><cell>Class. error (in %)</cell><cell cols="3">4.15 4.11 4.67</cell><cell cols="3">3.45 3.47 3.82</cell></row><row><cell>FLOPs (?10 6 )</cell><cell>41</cell><cell>25</cell><cell>7.4</cell><cell>72</cell><cell>50</cell><cell>23</cell></row><row><cell cols="3">Hidden states (?10 3 ) 233 133</cell><cell>41</cell><cell cols="2">254 155</cell><cell>55</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 3 :</head><label>3</label><figDesc>Classification error, computational requirements (in FLOPs), and memory load (measured by the number of hidden states) of four ResNet networks with two different convolutional operations (C and VSC) on the CASIA dataset. The network architecture is specified in the top part of the table; the bottom part presents the performance characteristics of the networks. Lower is better.</figDesc><table><row><cell>Feature size</cell><cell cols="2">ResNet-A</cell><cell cols="2">ResNet-B</cell><cell cols="2">ResNet-C</cell><cell></cell><cell>ResNet-D</cell></row><row><cell>64?64</cell><cell cols="2">16C3, MP2</cell><cell cols="2">16C3, MP2</cell><cell cols="2">16C3, MP2</cell><cell cols="2">16C3, 2?ResNet(16)</cell></row><row><cell>32?32</cell><cell cols="4">2?ResNet(16) 2?ResNet(16)</cell><cell cols="2">2?ResNet(16)</cell><cell cols="2">2?ResNet(32)</cell></row><row><cell>16?16</cell><cell cols="4">2?ResNet(32) 2?ResNet(32)</cell><cell cols="2">2?ResNet(32)</cell><cell cols="2">2?ResNet(48)</cell></row><row><cell>8?8</cell><cell cols="4">2?ResNet(48) 2?ResNet(64)</cell><cell cols="2">2?ResNet(64)</cell><cell cols="2">2?ResNet(64)</cell></row><row><cell>4?4</cell><cell cols="6">2?ResNet(96) 2?ResNet(128) 2?ResNet(128)</cell><cell cols="2">2?ResNet(128)</cell></row><row><cell>4?4</cell><cell cols="2">128C4</cell><cell cols="2">256C4</cell><cell cols="2">2?ResNet(256)</cell><cell cols="2">2?ResNet(256)</cell></row><row><cell>2?2</cell><cell>-</cell><cell></cell><cell>-</cell><cell></cell><cell></cell><cell>512C2</cell><cell></cell><cell>512C2</cell></row><row><cell>Convolution</cell><cell>C</cell><cell>VSC</cell><cell>C</cell><cell>VSC</cell><cell>C</cell><cell>VSC</cell><cell>C</cell><cell>VSC</cell></row><row><cell>Class. error (in %)</cell><cell>3.97</cell><cell>4.09</cell><cell>3.78</cell><cell>3.87</cell><cell>3.70</cell><cell>3.78</cell><cell>3.51</cell><cell>3.57</cell></row><row><cell>FLOPs (?10 6 )</cell><cell>32</cell><cell>14.5</cell><cell>40</cell><cell>21</cell><cell>51</cell><cell>31</cell><cell>88</cell><cell>49</cell></row><row><cell cols="2">Hidden states (?10 3 ) 193</cell><cell>63</cell><cell>200</cell><cell>71</cell><cell>209</cell><cell>81</cell><cell>471</cell><cell>153</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 4 :</head><label>4</label><figDesc>Classification error, computational requirements (in FLOPs), and memory load (measured by the number of hidden states) of two DenseNet networks with SVC convolutions on the CASIA dataset. The network architecture is specified in the top part of the table; the bottom part presents the performance characteristics of the networks. Lower is better.</figDesc><table><row><cell>Feature size</cell><cell>DenseNet-A</cell><cell>DenseNet-B</cell></row><row><cell>64?64</cell><cell>VSC(3,16,3,1), MP</cell><cell>VSC(3,16,3,1), MP</cell></row><row><cell>32?32</cell><cell cols="2">2 ? 16 BC layers, Transition 4 ? 16 BC layers, Transition(Compress=0.5)</cell></row><row><cell>16?16</cell><cell cols="2">2 ? 16 BC layers, Transition 4 ? 16 BC layers, Transition(Compress=0.5)</cell></row><row><cell>8?8</cell><cell cols="2">2 ? 16 BC layers, Transition 4?16 BC layers, Transition(Compress=0.5)</cell></row><row><cell>4?4</cell><cell>2?16 BC layers</cell><cell>4 ? 16 BC layers</cell></row><row><cell>4?4</cell><cell>SC(144,256,4,1)</cell><cell>SC(128,256,4,1)</cell></row><row><cell>Class. error (in %)</cell><cell>4.49</cell><cell>4.09</cell></row><row><cell>FLOPs (?10 6 )</cell><cell>8.7</cell><cell>15</cell></row><row><cell>Hidden states (?10 3 )</cell><cell>84</cell><cell>136</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 5 :</head><label>5</label><figDesc>Evaluation of the effect of adding SC-VSC-DC branches to a VGG network on the CASIA dataset. Lower values are better.</figDesc><table /><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>Table 6 :</head><label>6</label><figDesc>Comparison of two submanifold VGG networks (left) with the dense 3DNiN network (right) on the ModelNet-40 dataset. Lower values are better.</figDesc><table><row><cell>Feature size</cell><cell>VGG-A</cell><cell>VGG-B</cell><cell>Feature size</cell><cell>3DNiN</cell></row><row><cell>32? 32</cell><cell cols="2">3?8C3, MP2 2?16C3, MP2</cell><cell>30?30</cell><cell>48C6/2</cell></row><row><cell>16 ?16</cell><cell cols="2">3?16C3, MP2 2?32C3, MP2</cell><cell>13?13</cell><cell>2?48C1,96C5/4</cell></row><row><cell>8 ?8</cell><cell cols="2">3?24C3, MP2 2?64C3, MP2</cell><cell>5?5</cell><cell>2?96C1, 512C3/2</cell></row><row><cell>4?4</cell><cell>3?32C3</cell><cell>2?128C3</cell><cell>2?2</cell><cell>MP2</cell></row><row><cell>4?4</cell><cell>32C4</cell><cell>128C4</cell><cell>-</cell><cell>-</cell></row><row><cell>Convolution</cell><cell>VSC</cell><cell>VSC</cell><cell></cell><cell>C</cell></row><row><cell>Class. error (in %)</cell><cell>13.6</cell><cell>11.8</cell><cell></cell><cell>11.2</cell></row><row><cell>FLOPs (?10 6 )</cell><cell>9.2</cell><cell>28</cell><cell></cell><cell>124</cell></row><row><cell>Hidden states (?10 3 )</cell><cell>55</cell><cell>78</cell><cell></cell><cell>368</cell></row></table><note></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1">Note that the ground state does not necessarily have to be zero.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2">By "sparse convolutional networks", we mean networks designed to operate on sparse input data. We do not mean networks that have sparse parameter matrices<ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b5">6]</ref>.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3">We note that this is a slight abuse of the term "submanifold". Our input data may contain multiple connected components, and even a mixture of 1D and 2D objects embedded in 3D space.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4">https://github.com/sparsehash/sparsehash 5 http://www.nlpr.ia.ac.cn/databases/handwriting/Online_database.html 6 http://3dshapenets.cs.princeton.edu/</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Vote3deep: Fast object detection in 3d point clouds using efficient convolutional neural networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Engelcke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Rao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">Z</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">H</forename><surname>Tong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Posner</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Graham</surname></persName>
		</author>
		<title level="m">Sparse 3D convolutional neural networks. In BMVC</title>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Sun</surname></persName>
		</author>
		<title level="m">Identity mappings in deep residual networks. ECCV</title>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">Q</forename><surname>Weinberger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Van Der Maaten</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Optimal brain damage</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Lecun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Denker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Solla</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NIPS</title>
		<imprint>
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Foroosh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Tappen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Penksy</surname></persName>
		</author>
		<title level="m">Sparse convolutional neural networks. In CVPR</title>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">CASIA online and offline chinese handwriting databases</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C.-L</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Yin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D.-H</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Q.-F</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDAR</title>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2011" />
			<biblScope unit="page" from="37" to="41" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Volumetric and multi-view CNNs for object classification on 3D data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">R</forename><surname>Qi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Su</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Niessner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Dai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Yan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">J</forename><surname>Guibas</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Octnet: Learning deep 3D representations at high resolutions. CoRR</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Riegler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">O</forename><surname>Ulusoy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Geiger</surname></persName>
		</author>
		<idno>abs/1611.05009</idno>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Very deep convolutional networks for large-scale image recognition</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Simonyan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Zisserman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Going deeper with convolutions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Szegedy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Jia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Sermanet</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">E</forename><surname>Reed</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Anguelov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Erhan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Vanhoucke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Rabinovich</surname></persName>
		</author>
		<idno>abs/1409.4842</idno>
		<imprint>
			<date type="published" when="2014" />
			<publisher>CoRR</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Xie</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Girshick</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Doll?r</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Tu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>He</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1611.05431</idno>
		<title level="m">Aggregated residual transformations for deep neural networks</title>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Deconvolutional networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">D</forename><surname>Zeiler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Krishnan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">W</forename><surname>Taylor</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Fergus</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CVPR</title>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
