<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /nfs/home/kabenamualus/Research/task-dataset-metric-extraction/../grobid-0.6.0/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Learning to Generalize: Meta-Learning for Domain Generalization</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Da</forename><surname>Li</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Queen Mary University of London University of Edinburgh</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yongxin</forename><surname>Yang</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Queen Mary University of London University of Edinburgh</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yi-Zhe</forename><surname>Song</surname></persName>
							<email>yizhe.song@qmul.ac.uk</email>
							<affiliation key="aff0">
								<orgName type="institution">Queen Mary University of London University of Edinburgh</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Timothy</forename><forename type="middle">M</forename><surname>Hospedales</surname></persName>
							<email>t.hospedales@ed.ac.uk</email>
							<affiliation key="aff0">
								<orgName type="institution">Queen Mary University of London University of Edinburgh</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Learning to Generalize: Meta-Learning for Domain Generalization</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>

		<encodingDesc>
			<appInfo>
				<application version="0.6.0" ident="GROBID-SDO" when="2022-11-11T21:38+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid-sdo"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Domain shift refers to the well known problem that a model trained in one source domain performs poorly when applied to a target domain with different statistics. Domain Generalization (DG) techniques attempt to alleviate this issue by producing models which by design generalize well to novel testing domains. We propose a novel meta-learning method for domain generalization. Rather than designing a specific model that is robust to domain shift as in most previous DG work, we propose a model agnostic training procedure for DG. Our algorithm simulates train/test domain shift during training by synthesizing virtual testing domains within each mini-batch. The meta-optimization objective requires that steps to improve training domain performance should also improve testing domain performance. This meta-learning procedure trains models with good generalization ability to novel domains. We evaluate our method and achieve state of the art results on a recent cross-domain image classification benchmark, as well demonstrating its potential on two classic reinforcement learning tasks.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Introduction</head><p>Humans are adept at solving tasks under many different conditions. This is partly due to fast adaptation, but also to a lifetime of encountering new task conditions providing the opportunity to develop of strategies that are robust to different task contexts. If a human discovers that their existing strategy fails in a new context they do not just adapt, but further try to update their strategy to be more context independent, so that next time they arrive in a new context they are more likely to succeed immediately. We would like artificial learning agents to solve many tasks under different conditions (domains) and similarly solve the second order task of constructing models that are robust to change of domain and perform well 'out of the box' in new domains. For example we might like computer vision systems to recognise objects immediately and without retraining, when the camera type is changed <ref type="bibr" target="#b4">(Patel et al. 2015)</ref>, or reinforcement learning trained agents to perform well immediately when placed in a new environment or subjected to changed morphology (Taylor and Stone 2009) -without waiting for adaptation.</p><p>Copyright c 2018, Association for the Advancement of Artificial Intelligence (www.aaai.org). All rights reserved.</p><p>Standard learning approaches tend to break down when applied in different conditions (ie to data with different statistics) than used for training. This is known as domain or covariate shift <ref type="bibr" target="#b5">(Storkey and Sugiyama 2007)</ref>, and seriously affects the usefulness of machine learning models as we do not always have access to training data that is exactly representative of the intended testing scenario. Approaches to addressing this issue can be categorized into domain adaptation (DA) and domain generalization (DG). DA is relatively well studied, and addresses using unlabeled or sparsely labeled data in the target domain to quickly adapt a model trained in a different source domain <ref type="bibr" target="#b4">(Patel et al. 2015;</ref><ref type="bibr">Csurka 2017)</ref>. The less well studied DG addresses building models that by design function well even in new target/testing domains. In contrast to DA, a DG model is not updated after training, and the issue is how well it works out of the box in a new domain. The few existing DG methods typically train on multiple source domains and propose mechanisms to extract some domain agnostic representation or model that describes common aspects of known domains <ref type="bibr" target="#b3">(Khosla et al. 2012;</ref><ref type="bibr" target="#b4">Muandet, Balduzzi, and Sch?lkopf 2013;</ref><ref type="bibr" target="#b2">Ghifary et al. 2015;</ref><ref type="bibr">Li et al. 2017)</ref>. They assume that such a common factor among existing source domains will persist to new testing domains, and thus provide a basis for generalization. DG is a harder problem than DA in that it makes fewer assumptions (target data not required) but for the same reasons, it may be more valuable if solved.</p><p>We take a meta learning approach to DG. Rather than proposing a specific model suited for DG <ref type="bibr" target="#b3">(Khosla et al. 2012;</ref><ref type="bibr" target="#b2">Ghifary et al. 2015;</ref><ref type="bibr">Li et al. 2017)</ref>, we propose a model-agnostic training algorithm that trains any given model to be more robust to domain shift. This is related to the long standing idea of learning to learn <ref type="bibr" target="#b6">(Thrun and Pratt 1998;</ref><ref type="bibr" target="#b5">Schmidhuber, Zhao, and Wiering 1997)</ref>, which has recently seen a resurgence of popularity with applications to few-shot learning <ref type="bibr" target="#b5">Ravi and Larochelle 2017)</ref> and learning optimizers <ref type="bibr" target="#b0">(Andrychowicz et al. 2016)</ref>. The most related of these studies to ours is the MAML approach of . MAML takes a meta-learning approach to few-shot learning by training a single model on a set of source tasks that is only a few gradient descent steps away from a good task-specific model. This meta-optimization objective trains models suited for few-shot fine-tuning to new target tasks.</p><p>The DG problem is different because we to transfer across domains rather than tasks, and because DG assumes zero, rather than few training examples of the target problem.</p><p>Our meta-learning domain generalization approach (MLDG provides a model agnostic training procedure that improves the domain generality of a base learner. Specifically, MLDG trains a base learner on a set of source domains by synthesising virtual training and virtual testing domains within each minibatch. The meta-optimization objective is then: to minimise the loss on the training domains, while also ensuring that the direction taken to achieve this also leads to an improvement in the (virtual) testing loss. We present analyses that give various perspectives on this strategy, including as following an optimization trajectory where the virtual training and virtual testing gradients are aligned. Overall our MLDG approach has several key benefits: As a meta-learning procedure, it does not introduce any new parameters, unlike other model-based DG approaches that grow parameters linearly in the number of source domains <ref type="bibr" target="#b3">(Khosla et al. 2012;</ref><ref type="bibr" target="#b2">Ghifary et al. 2015;</ref><ref type="bibr">Li et al. 2017;</ref><ref type="bibr" target="#b0">Bousmalis et al. 2016)</ref> resulting in large numbers of total parameters. Similarly MLDG does not place any constraint on the architecture of the base learner and moreover can be applied to both supervised and reinforcement learning; where prior DG alternatives <ref type="bibr" target="#b3">(Khosla et al. 2012;</ref><ref type="bibr" target="#b2">Ghifary et al. 2015;</ref><ref type="bibr">Li et al. 2017</ref>) both constrain the model architecture and address supervised learning.</p><p>To summarise our contributions: We develop a gradientbased meta-learning algorithm that trains models for improved domain generalisation ability. Our algorithm can train any type of base network and applies to both supervised and reinforcement learning settings. We evaluate our approach on a very recent cross domain image recognition benchmark and achieve state of the art results, as well as demonstrating its promising applicability to two classic reinforcement learning tasks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Related Work</head><p>Multi-Domain Learning (MDL) MDL addresses training a single model that is effective for multiple known domains <ref type="bibr">(Daum? 2007;</ref><ref type="bibr" target="#b5">Rebuff, Bilen, and Vedaldi 2017;</ref>. Domain generalization often starts with MDL on some source domains but addresses training a model that generalizes well to held out unknown domains. Domain Generalization Despite the variety of the different methodological tools, most existing DG methods are built on three main strategies. The simplest approach is to train a model for each source domain. When a testing domain comes, estimate the most relevant source domain and use that classifier <ref type="bibr" target="#b7">(Xu et al. 2014)</ref>. A second approach is to presume that any domain is composed of an underlying globally shared factor and a domain specific component. By factoring out the domain specific and domain-agnostic component during training on source domains, the domainagnostic component can be extracted and transferred as a model that is likely to work on a new source domain <ref type="bibr" target="#b3">(Khosla et al. 2012;</ref><ref type="bibr">Li et al. 2017)</ref>. Finally, there is learning a domain-invariant feature representation. If a feature repre-sentation can be learned that minimises the gap between multiple source domains, it should provide a domain independent representation that performs well on a new target domain. This has been achieved with multi-view autoencoders <ref type="bibr" target="#b2">(Ghifary et al. 2015)</ref> and mean map embeddingbased techniques <ref type="bibr" target="#b4">(Muandet, Balduzzi, and Sch?lkopf 2013)</ref>. It has also been achieved based on gradient reversal domain confusion losses in deep networks <ref type="bibr" target="#b2">(Ganin and Lempitsky 2015;</ref><ref type="bibr" target="#b0">Bousmalis et al. 2016)</ref>. Here multiple source domains are trained with an additional multi-task loss that prefers a shared representation for which domains are indistinguishable. Although initially proposed for DA rather than DG, these approaches can be adapted to the DG setting <ref type="bibr">(Li et al. 2017)</ref>. In contrast to these studies, ours is the first to addresses domain generalization via meta-learning. Neural Network Meta-Learning Meta-learning methods for neural networks have a long history <ref type="bibr" target="#b6">(Thrun and Pratt 1998;</ref><ref type="bibr" target="#b5">Schmidhuber, Zhao, and Wiering 1997)</ref>, but have resurged in popularity recently. Recent meta-learning studies have focused on learning good weight initializations for few-shot learning <ref type="bibr" target="#b4">Parisotto, Ba, and Salakhutdinov 2016)</ref>, meta-models that generate the parameters of other models <ref type="bibr" target="#b6">(Vinyals et al. 2016;</ref><ref type="bibr">Li et al. 2017)</ref>, or learning transferable optimizers <ref type="bibr" target="#b5">(Ravi and Larochelle 2017;</ref><ref type="bibr" target="#b0">Andrychowicz et al. 2016</ref>). Our approach is most related to those that learn transferable weight initializations, notably MAML . In MAML a single shared source model shared is trained using multiple source tasks. The meta-learning process simulates transfer learning by fine-tuning, so the global model is updated to solve each source task in turn based on a few examples and a few gradient descent steps. By training the source model such that all simulated testing tasks fine-tune well, meta-learning produces a source model that is easy to adapt. Both MAML and our MLDG are model agnostic in that they apply to any base architecture and both supervised and to reinforcement learning settings. However, MAML addresses few-shot transfer to new tasks, rather than zeroshot transfer to new domains. In our case a different metalearning objective is necessary because in DG we will not have access to target examples for fine-tuning during the actual testing. Therefore we propose a new meta-learning objective based around simulating domain shift and training such that steps to improve the source domain also improve the simulated testing domains.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Methodology</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Meta-Learning Domain Generalization</head><p>In the DG setting, we assume there are S source domains S and T target domains T . All of them contain the same task (same label space, and input feature space) but have different statistics. We define a single model parametrized as ? to solve the specified task. DG aims for training ? on the source domains, such that it generalizes to the target domains. To achieve this, at each learning iteration we split the original S source domains S into S ?V meta-train domains S and V meta-test domainsS (virtual-test domain). This is to mimic real train-test domain-shifts so that over many iter- Init: Model parameters ?. Hyperparameters ?, ?, ?.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>4:</head><p>for ite in iterations do 5: Init: Policy params ?, Hyperparameters ?, ?, ?.</p><formula xml:id="formula_0">Split:S andS ? S 6: Meta-train: Gradients ? ? = F ? (S; ?) 7: Updated parameters ? = ? ? ?? ? 8: Meta-test: Loss is G(S; ? ). 9: Meta-optimization: Update ? ? = ? ? ? ?(F(S; ?) + ?G(S; ? ? ?? ? ))<label>?? 10</label></formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>4:</head><p>for ite in iterations do</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>5:</head><p>Split:S andS ? S</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>6:</head><p>Meta-train:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>7:</head><p>Collect trajectories? applying policy ? inS.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>8:</head><p>Loss: F(? , ?).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>9:</head><p>Gradient: ? ? = F ? (? , ?).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>10:</head><p>Updated parameters: ? = ? ? ?? ? .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>11:</head><p>Meta-test:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>12:</head><p>Collect trajectories? applying policy ? inS.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>13:</head><p>Loss G(? , ? ? ?? ? ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>14:</head><p>Meta-optimization:</p><formula xml:id="formula_1">? = ? ? ? ?(F(? , ?) + ?G(? , ? ? ?F (? , ?))) ?? 15:</formula><p>end for 16: end procedure ations we can train a model to achieve good generalization in the final-test evaluated on target domains T . The overall methodological flow is illustrated schematically in <ref type="figure">Fig. 1</ref> and summarised in Algorithm 1. This model-agnostic approach can be flexibly applied to both supervised and reinforcement learning as elaborated in the following sections.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Supervised Learning</head><p>We first describe how to apply our method to supervised learning. We assume a loss function l(?, y) between the predicted and true labels? and y. For example in multi-class classification the cross-entropy loss: l(?, y) = ?? log(y). The process is outlined in the steps below.</p><p>Meta-Train The model is updated on all the S ? V metatrain domainsS in aggregate, and the loss function is, where y (i) j indicates the jth point among N i in the ith domain. The model is parameterized by ?, so the gradient of ? calculated respect to this loss function is ? ? , and optimization will update the model as ? = ? ? ?? ? . Meta-Test In each mini-batch the model is also virtually evaluated on the V meta-test domainsS. This meta-test evaluation simulates testing on new domains with different statistics, in order to allow learning to generalize across domains. The loss for the adapted parameters calculated on the meta-test domains is as below,</p><formula xml:id="formula_2">F(.) = 1 S ? V S?V i=1 1 N i Ni j=1 ? (? (i) j , y (i) j )<label>(1)</label></formula><formula xml:id="formula_3">G(?) = 1 V V i=1 1 N i Ni j=1 ? (? (i) j , y (i) j )<label>(2)</label></formula><p>where, N i is the number samples of the ith meta-test domain, and the loss on the meta-test domain is calculated using the updated parameters ? from meta-train. This means that for optimisation with respect to G we will need the second derivative with respect to ?. Summary The meta-train and meta-test are optimised simultaneously, so the final objective is:</p><formula xml:id="formula_4">argmin ? F(?) + ?G(? ? ?F (?))<label>(3)</label></formula><p>where ? is the meta-train step size and ? weights meta-train and meta-test. Objective (Eq. 3) is itself trained by gradient descent (Alg. 1).</p><p>Final-Test After Eq. 3 is optimised to convergence on the source domains, we deploy the final model ? on the truly held-out target domain(s).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Reinforcement Learning</head><p>In application to the reinforcement learning (RL) setting, we now assume an agent with a policy ? that inputs states x and produces actions a in a sequential decision making task: a t = ? ? (x t ). The agent operates in an environment defined by a Markov decision process (MDP) q(x t+1 |x t , a t ) and its goal is to maximize its return, the (potentially discounted) sum of rewards R = t ? t R t (x t , a t ).</p><p>While tasks in a supervised learning setting map to reward functions in an RL setting , domains map to solving the same task (reward function) with differences in the environment (MDP or observation function). Thus DG is to achieve an agent with improved generalization ability in the sense of maintaining ability to maximize reward when subject to changes in its operating environment (MDP) -without being allowed any rewarded (? supervised domain adaptation <ref type="bibr" target="#b0">Ammar et al. 2014)</ref>), or un-rewarded (? unsupervised domain adaptation <ref type="bibr" target="#b0">Ammar et al. 2015b</ref>)) trials in the target environment for adaptation. The key idea is still to achieve DG by simulating traintest domain shift during training. Meta-optimisation then trains for generalization across environmental conditions. The overall process is summarised in Algorithm 2 and elucidated in the steps below. Note that the MLDG strategy can be straightforwardly applied on-policy with policy-gradient (PG) <ref type="bibr" target="#b7">(Williams 1992)</ref>, or off-policy with Q-learning <ref type="bibr" target="#b4">(Mnih et al. 2015)</ref>. For simplicity we describe the PG variant. Meta-train: In meta-training, the loss function F(?) now corresponds to the negative return R of policy ? ? , averaged over all the meta-training environments inS. Update of the policy parameters ? is performed by REINFORCE <ref type="bibr" target="#b7">(Williams 1992</ref>) (or Q-learning <ref type="bibr" target="#b4">(Mnih et al. 2015)</ref>), leading to updated parameters ? . Meta-test: Similarly to the SL approach, we now evaluate the model on V meta-test domainsS. The meta-test loss G is again the average negative return on meta-test environments. For RL calculating this loss requires rolling out the metatrain updated policy ? in the meta-test domains to collect new trajectories and rewards.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Analysis of MLDG</head><p>In this section we provide some analysis to help better understand the proposed method. The objective of MLDG is:</p><formula xml:id="formula_5">argmin ? F(?) + ?G(? ? ?F (?))<label>(4)</label></formula><p>where F(.) is the loss from the aggregated meta-train domains (Eq. 1), G(.) is the loss from the aggregated meta-test domains (Eq. 2), and F (?) is the gradient of the training loss F(?) w.r.t '?'. This can be understood as: "tune such that after updating the meta-train domains, performance is also good on the meta-test domains". For another perspective on the MLDG objective, we can do the first order Taylor expansion for the second term, i.e.</p><formula xml:id="formula_6">G(x) = G(?) + G (?) ? (x ??)<label>(5)</label></formula><p>where? is an arbitrary point that is close to x. The multivariable form x is a vector and G(x) is a scalar. Assume we have x = ? ? ?F (?), and we choose the? to be ?. Then, we have</p><formula xml:id="formula_7">G(? ? ?F (?)) = G(?) + G (?) ? (??F (?))<label>(6)</label></formula><p>and the objective function becomes</p><formula xml:id="formula_8">argmin ? F(?) + ?G(?) ? ??(G (?) ? F (?)).<label>(7)</label></formula><p>This reveals that we want to: (i) minimize the loss on both meta-train and meta-test domains, and (ii) maximize the dot product of G (?) and F (?). Minimizing the loss on both domains (i) is intuitive. To understand (ii), recall the dot operation computes the similarity of two vectors: a ? b = ||a|| 2 ||b|| 2 cos(?), where ? is the angle between vectors a and b. If a and b are unit normalized, this computes cosine similarity exactly. Though G (?) and F (?) are not normalized, the dot product is still larger if these vectors are in a similar direction.</p><p>Since G (?) and F (?) are loss gradients in two sets of domains, then 'similar direction' means the direction of improvement in each set of domains is similar. Thus the overall objective can be seen as: "tune such that both domains' losses are minimised, and also such that they descend in a coordinated way". In a conventional optimisation of arg min ? F(?) + G(?), there is no such constraint on coordination. The optimiser will happily tune asymmetrically, e.g., focusing on which ever domain is easier to minimise. The regularisation provided by the third term in Eq. 7 prefers updates to weights where the two optimisation surfaces agree on the gradient. It reduces overfitting to a single domain by finding a route to minimisation where both subproblems agree on the direction at all points along the route.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Alternative Variants of MLDG</head><p>Based on the discussion above, we propose some variants inspired by the vanilla MLDG method. Variant MLDG-GC in Eq. 8 is based on the Taylor expansion and gradient alignment intution discussed earlier -with the regularizer updated to normalize the gradients so that it indeed computes cosine similarity.</p><formula xml:id="formula_9">argmin ? F(?) + ?G(?) ? ?? F (?) ? G (?) F (?) 2 G (?) 2<label>(8)</label></formula><p>Another perspective on 'similar direction' gradients is that once meta-train has converged, you also no longer need to update the parameters on the meta-test domains. I.e., at a good solution, meta-test gradients are close to zero. With this intuition variant MLDG-GN is proposed in Eq. 9.</p><formula xml:id="formula_10">argmin ? F(?) + ? G (? ? ?F (?)) 2 2<label>(9)</label></formula><p>Clearly MLDG-GN needs a good initialisation to be reasonable, so we initialise MLDG-GN with the domain aggregation baseline. In the experiments section we will compare these alternative variants to the initially proposed MLDG.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Experiments</head><p>To evaluate our method, we compare it with various alternatives on four different problems, including an illustrative synthetic experiment, a challenging recent computer vision benchmark for multi-class classification across different domains, and two classic reinforcement learning problems, Cart-Pole and Mountain Car. In each case we compare to the baseline of aggregating the data from all source domains to train a single model that ignores domains entirely, as well as various alternative DG methods. As shown in <ref type="bibr">(Li et al. 2017)</ref>, the former simple baseline can be very effective and outperform many purpose designed DG models.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Experiment I: Illustrative Synthetic Experiment</head><p>To illustrate our approach, we construct a synthetic binary classification experiment. We synthesize nine domains by sampling curved deviations from a diagonal line classifier. We treat eight of these as sources for meta-learning and hold out the last for final-test. <ref type="figure" target="#fig_0">Fig. 2a</ref> shows the nine synthetic domains which are related in form but differ in the details of their decision boundary. A one-hidden layer MLP (50 hidden neurons, RELU activation) is used as the base classifier. Baselines: MLP-All: Simple baseline of aggregating all source domains for training. MLDG: Our main proposed MLDG method (Eq. 4). MLDG-GC and MLDG-GN: variants of our method in Eq. 8 and Eq. 9 respectively. Results: From the results <ref type="figure" target="#fig_1">Fig. 2</ref> we can see that the baseline MLP-ALL over-fits on the training domains. Despite aggregating eight sources, it fits a curve in the bottom left corner rather than the underlying diagonal line. Our methods all draw nearly straight lines. These results illustrate that the MLDG approach helps to avoid overfitting to specific source domains and learn a more generalizable model.  <ref type="bibr">Li et al. 2017)</ref>. We note that this good performance is achieved without any special architecture design and without growing the size of the model in proportion to the number of domains (both of which are required in each of D-MTAE, DSN, and AlexNet+TF). This illustrates the flexibility of MLDG, and also highlights that its scalability compared to alternatives. AlexNet+TF for example requires approximately 2GB of memory per domain with batch size 64, meaning that it cannot be applied to more than 5 source domains on a contemporary GPU. Analysis of MLDG learning: We next perform some ablation experiments to understand: (i) whether it is important to use MLDG end-to-end way within a CNN, and (ii) verify the impact of the meta-optimisation strategy specifically.</p><p>To answer the first question of where it is important to employ MLDG learning, we compare the variant MLDG (FC): Only apply MLDG learning on the FC layers of AlexNet. This is in contrast to our full model MLDG (CNN) , which applies learning to all layers of AlexNet. Comparing MLDG (FC) to vanilla Deep-All AlexNet in <ref type="table" target="#tab_5">Table 2</ref>, we see a benefit of ? 1.6% is obtained by MLDG learning on the FC layers. Comparing full MLDG we see that a further ? 1.1% benefit is obtained by applying MLDG learning to the convolutional layers, for a total of ? 2.7% margin over Deep-All.</p><p>To verify the impact of the meta-optimisation strategy, we apply MLDG with setting ? = 0, in which case the objective is merely the sum of the training and validation (meta-test) domains' losses. From the results in <ref type="table" target="#tab_5">Table 2</ref>, we see that it performs comparably with Deep-All. Thus the key benefit of   MLDG is indeed in the meta-optimisation step. Analysis of MLDG variants: In the <ref type="table" target="#tab_6">Table 3</ref>, the original MLDG method is compared to the two variants also proposed in the methodology. In this experiment we found that while the MLDG-GC (cosine) and MLDG-GN (gradient norm) variants provide some benefit compared to Deep-All, the vanilla MLDG performs best.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Experiment III: Cart-Pole</head><p>We next demonstrate that MLDG also applies to RL problems. First we study the classic Cart Pole problem <ref type="bibr" target="#b0">(Brockman et al. 2016</ref>). The objective is to balance a pole upright by moving a cart. The action space is discrete -left or right.</p><p>The state it has four elements: the position and velocity of cart and angular position and velocity of the pole. Settings: We perform two sub-experiments by modifying the OpenAI Gym simulator to provide environments with different properties. In the first we vary one domain factor by changing the pole length. We simulate 9 domains with pole lengths [0.5, 1.0, . . . , 4.5]. In the second we vary multiple domain factors -pole length [0.5, 2.5, 4.5] and cart mass <ref type="bibr">[1,</ref><ref type="bibr">2,</ref><ref type="bibr">3]</ref>. In both experiments we randomly choose 6 source domains for training and hold out 3 domains for (true) testing. Since the game can last forever if the pole does not fall, we cap the maximum steps to 200. We train on the observed domains for 500 games per domain. Then, for each held-out domain, we play 500 games, and report the average reward. For fair comparison, the policy architecture for all models is a 1-hidden layer neural network with 50 hidden units. The reward structure is +1 for each time-step the pole is successfully balanced, so the maximum reward is 200. All methods are trained with vanilla REINFORCE policy gradient <ref type="bibr" target="#b7">(Williams 1992)</ref>.  Baselines:</p><p>We compare the following alternative approaches: RL-All: The reinforcement-learning analogy to 'Deep-ALL' in the recognition experiment. Trains a single policy by aggregating the reward from all six source domains. RL-Random-Source: Different from RL-All, it trains on a single randomly selected source domain. Total training trials are controlled so it gets the same number of trials in one domain as RL-All gets in multiple domains. RL-Undobias: Adaptation of the (linear) undo-bias model of <ref type="bibr" target="#b3">(Khosla et al. 2012</ref>) updated to non-linear multi-layer network as per <ref type="bibr">(Li et al. 2017)</ref>. The neural network is trained to factor domain-specific and a single domain-agnostic components on six source domains. The domain agnostic component is then transferred for testing on held out final-testing domains. RL-MLDG: Our MLDG. RL-MLDG-GC: Our MLDG variant. RL-MLDG-GN: Our MLDG variant. In each mini-batch, we split the S = 6 source domains into V = 2 meta-test and S ? V = 4 meta-train domains. Results: All experiments are repeated 10 times to reduce the impact of specific observed/held-out domain sampling. From the results in Tables 4 and 5, we see the impact of domain shift. No methods reach 200 (upper bound given the length cap) for unseen domains reliably. However, the proposed MLDG provides the best domain generalization and significantly outperform the baselines. It is interesting to note that RL-Random-Source outperforms RL-All in <ref type="table" target="#tab_7">Table 4</ref>, which is different than in vision problems where simply aggregating more domains is usually a reasonable strategy. Although RL-All is exposed to more diverse data, learning a single policy by naively 'averaging' over rewards for multiple distinct problems can sometimes be detrimental <ref type="bibr" target="#b5">(Sung et al. 2017</ref>), </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Experiment IV: Mountain Car</head><p>Our second RL experiment is the classic mountain car problem <ref type="bibr" target="#b0">(Brockman et al. 2016</ref>). The car is positioned between two mountains, and the agent needs to drive the car (back or forth) so that it can hit the peak of the right mountain. The difficulty of this problem is that the car engine is not strong enough to drive up the right mountain directly. The agent has to figure out a solution of driving up the left mountain to first generate momentum before driving up the right mountain. The state observation in this game consists two elements: the position and velocity of the car. There are three available actions: drive left, do nothing, and drive right. Settings: We simulate domain bias by randomly drawing the height of the mountains in each domain. Similar to cartpole, we simulate 9 domains in total, and 3 domains are held-out. In contrast to cartpole, it is very difficult for a random policy to finish a full game, as it is likely to be stuck forever. Thus instead of policy gradient, we use Q learning (Watkins and Dayan 1992) for this problem as the base RL algorithm, more specially DQNs <ref type="bibr" target="#b4">(Mnih et al. 2015)</ref>. For held out domains we play 100 games each without updating. The reward structure is -1 each time step before reaching the target. The Q-network is again a 1 hidden layer MLP. Baselines: We evaluate the following alternatives RL-Random-Source: Trains a single policy on one random source domain. RL-All: Trains a single policy on 6 source domains in aggregation. RL-Undobias: DG parametrised Q-network adaptation of <ref type="bibr" target="#b3">(Khosla et al. 2012;</ref><ref type="bibr">Li et al. 2017)</ref> as per cart-pole. RL-MLDG: Our MLDG. And its variants RL-MLDG-GC and RL-MLDG-GN. In each mini-batch, we split the S = 6 source domains into V = 2 meta-test domains, and S ? V = 4 meta-train domains.</p><p>Results: All experiments are repeated 10 times to reduce the impact of random observed/held-out domain splits. From the results in <ref type="table" target="#tab_9">Table 6</ref>, we again observe the performance drops from observed domains and held-out domains. In this benchmark, succeeding within 110 steps is a good outcome. So a reward of -110 is a good score for within domain evaluation. I.e., in the absence of domain shift. Since it is possible for an agent to never succeed on this benchmark, particularly when testing in a distinct domain from training, we apply a limit of 20, 000 steps maximum. For DG testing, most methods have some failed trials (&gt; 20, 000 steps) in final-test. The average reward is calculated by ignoring those failed cases. Therefore we report both failure rate and the average reward (negative time to success) in the successful cases. The results show that our vanilla MLDG method outperforms the alternatives: (i) Its average reward is better than RL-All and similar to RL-UndoBias. However (ii) its fail rate is lower than RL-UndoBias. Unlike Cartpole here RL-All is more effective than Random-Source. Analysis of MLDG variants: Only vanilla MLDG performed well here. MLDG-GC had low failure rate but low return, while MLDG-GN had very high failure rate.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Discussion</head><p>The experiments show that MLDG-based meta-learning can effectively alleviate domain-shift in diverse problems including supervised and re-reinforcement learning scenarios. Whether training on the aggregate of multiple source domains was a good strategy turned out to be problem dependent (yes for PACS vision benchmark and mountain car, but not for cart pole). The extended variants of the MLDG model MLDG-GC (explicit gradient direction alignment) and MLDG-GN (gradient norm) also had mixed results with MLDG-GC performing second best on PACS, but MLDG-GN performing best on cartpole. Nevertheless the core MLDG strategy was highly effective across all problems and always outperformed prior alternatives. We note that studies have used the terms 'domain' and 'task' in different ways <ref type="bibr" target="#b0">(Ammar et al. 2015a;</ref><ref type="bibr">Csurka 2017)</ref>. Some problems we solved here (e.g., poles of different length) have been termed 'tasks' in other studies <ref type="bibr" target="#b0">(Ammar et al. 2014;</ref><ref type="bibr" target="#b0">Ammar et al. 2015a)</ref>, which would use 'domain' to refer to cartpole versus mountaincar. We use the term domain in the sense of the pattern recognition community (Csurka 2017), where one can learn a model with better 'cross domain generalisation'. E.g. a recognition model that is robust to recognising photos vs sketches; or a policy that is more robust being deployed with poles of a different length than it was trained on. Note that if parameters like pole-length were observed, this would be a 'paramaterised' or 'contextual' policy situation -for which methods already exist <ref type="bibr" target="#b3">(Kupcsik et al. 2013)</ref>. But in our case what meta-learning has achieved is to learn a policy that is robust to (i.e., obtains high reward despite of) hidden changes in the underlying MDP. For example balancing poles of diverse but unknown lengths.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Conclusion</head><p>We proposed a meta-learning algorithm for domain generalisation. Our method trains for domain generalisation by meta-optimisation on simulated train/test splits with domain-shift. Unlike prior model-based domain generalisation approaches, it scales well with number of domains. It is model agnostic so can be applied to different base network types, and both to supervised and reinforcement learning problems. Experimental evaluation shows state of the art results on a recent challenging visual recognition benchmark and promising results on multiple classic RL problems.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>( a )</head><label>a</label><figDesc>Synthetic training domains for binary classification (b) Learned decision boundaries. From left to right: MLP-All; MLDG; MLDG-GC; MLDG-GN.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Synthetic experiment illustrating MLDG.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>Sketch'). The diverse depiction styles provide a significant domain gap. The goal is to train in set of domains and recognise objects in a disjoint domain. E.g., recognise photos given only various artistic depictions for training.</figDesc><table><row><cell>'guitar', 'house', 'horse' and 'person') and 4 domains of dif-</cell></row><row><cell>ferent stylistic depictions ('Photo', 'Art painting', 'Cartoon'</cell></row><row><cell>and 'Baselines: We use the ImageNet pre-trained AlexNet</cell></row><row><cell>CNN (Krizhevsky, Sutskever, and Hinton 2012) as the base</cell></row><row><cell>network in each competitor for fair comparison, and com-</cell></row><row><cell>pare the following models: D-MTAE: a multi-task auto en-</cell></row><row><cell>coder designed for the DG problems (Ghifary et al. 2015).</cell></row><row><cell>Deep-All: Vanilla AlexNet trained on the aggregation of</cell></row><row><cell>data from all source domains. This baseline that outper-</cell></row><row><cell>forms many prior DG methods as presented in (Li et al.</cell></row><row><cell>2017). DSN: The domain separation network learns specific</cell></row><row><cell>and shared representation components for the source and</cell></row><row><cell>target domains (Bousmalis et al. 2016). We re-purpose the</cell></row><row><cell>original DSN from the domain adaptation to the DG task.</cell></row><row><cell>AlexNet+TF: the low-rank paramaterized network provides</cell></row><row><cell>prior state of the art on this benchmark (Li et al. 2017).</cell></row><row><cell>Settings: We implement MLDG in tensorflow. We use</cell></row><row><cell>SGD optimiser with learning rate 5e ? 4 (exponential decay</cell></row><row><cell>is used with decay step 15k and decay rate 0.96) and mini-</cell></row><row><cell>batch 64. Meanwhile, parameters ?, ?, ? are set to 5e?4, 1.0</cell></row><row><cell>and 5e ? 4. For final-test, we use the best performing model</cell></row><row><cell>on the validation set after 45k iterations.</cell></row><row><cell>Experiment II: Object Recognition</cell></row><row><cell>We next evaluate the efficacy of MLDG on a recent challeng-</cell></row><row><cell>ing object recognition DG task in computer vision. Specif-</cell></row><row><cell>ically, we used the PACS multi-domain recognition bench-</cell></row><row><cell>mark, a new dataset designed for the cross-domain recogni-</cell></row><row><cell>tion problems (Li et al. 2017) 1 . This dataset has 9991 im-</cell></row><row><cell>ages in total across 7 categories ('dog', 'elephant', 'giraffe',</cell></row></table><note>1 http://sketchx.eecs.qmul.ac.ukResults: The comparison with state of the art on the PACS benchmark is shown in Table 1. From the results, we can see that MLDG surpasses the other baselines including the best prior method AlexNet+TF (</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 1 :</head><label>1</label><figDesc>Cross-domain recognition accuracy (Multi-class accuracy) on the PACS dataset. Best performance in bold. D-MTAE (Ghifary et al. 2015) Deep-all DSN (Bousmalis et al. 2016) AlexNet+TF (Li et al. 2017) MLDG (CNN)</figDesc><table><row><cell>art painting</cell><cell>60.27</cell><cell>64.91</cell><cell>61.13</cell><cell>62.86</cell><cell>66.23</cell></row><row><cell>cartoon</cell><cell>58.65</cell><cell>64.28</cell><cell>66.54</cell><cell>66.97</cell><cell>66.88</cell></row><row><cell>photo</cell><cell>91.12</cell><cell>86.67</cell><cell>83.25</cell><cell>89.50</cell><cell>88.00</cell></row><row><cell>sketch</cell><cell>47.86</cell><cell>53.08</cell><cell>58.58</cell><cell>57.51</cell><cell>58.96</cell></row><row><cell>Ave.</cell><cell>64.48</cell><cell>67.24</cell><cell>67.37</cell><cell>69.21</cell><cell>70.01</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 2 :</head><label>2</label><figDesc>PACS benchmark: Ablation study of MLDG.</figDesc><table><row><cell></cell><cell cols="4">Deep-All MLDG (? = 0) MLDG (FC) MLDG (CNN)</cell></row><row><cell>art painting</cell><cell>64.91</cell><cell>64.37</cell><cell>65.54</cell><cell>66.23</cell></row><row><cell>cartoon</cell><cell>64.28</cell><cell>65.39</cell><cell>66.37</cell><cell>66.88</cell></row><row><cell>photo</cell><cell>86.67</cell><cell>86.67</cell><cell>88.30</cell><cell>88.00</cell></row><row><cell>sketch</cell><cell>53.08</cell><cell>55.29</cell><cell>55.34</cell><cell>58.96</cell></row><row><cell>Ave.</cell><cell>67.24</cell><cell>67.93</cell><cell>68.89</cell><cell>70.01</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>Table 3 :</head><label>3</label><figDesc>PACS benchmark: Evaluation of MLDG variants.</figDesc><table><row><cell></cell><cell cols="3">Deep-All MLDG-GC (Eq. 8) MLDG-GN (Eq. 9)</cell></row><row><cell>art painting</cell><cell>64.91</cell><cell>64.71</cell><cell>63.64</cell></row><row><cell>cartoon</cell><cell>64.28</cell><cell>65.30</cell><cell>63.47</cell></row><row><cell>photo</cell><cell>86.67</cell><cell>86.79</cell><cell>87.88</cell></row><row><cell>sketch</cell><cell>53.08</cell><cell>56.92</cell><cell>54.94</cell></row><row><cell>Ave.</cell><cell>67.24</cell><cell>68.43</cell><cell>67.48</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head>Table 4</head><label>4</label><figDesc></figDesc><table><row><cell cols="4">: Cart-Pole RL. Domain generalisation performance</cell></row><row><cell cols="4">across pole length. Average reward testing on 3 held out do-</cell></row><row><cell cols="4">mains with random lengths. Upper bound: 200.</cell></row><row><cell cols="2">Method RL-Random-Source</cell><cell>RL-All</cell><cell>RL-Undobias</cell></row><row><cell>Return</cell><cell>133.74 ? 6.79</cell><cell cols="2">97.39 ? 73.49 113.52 ? 11.65</cell></row><row><cell>Method</cell><cell>RL-MLDG</cell><cell cols="2">RL-MLDG-GC RL-MLDG-GN</cell></row><row><cell>Return</cell><cell>165.34 ? 3.38</cell><cell>129.56 ? 2.51</cell><cell>175.25 ? 3.16</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head>Table 5</head><label>5</label><figDesc></figDesc><table><row><cell cols="4">: Cart-Pole RL. Generalisation performance across</cell></row><row><cell cols="4">both pole length and cart mass. Return testing on 3 held out</cell></row><row><cell cols="4">domains with random length and mass. Upper bound: 200.</cell></row><row><cell cols="2">Method RL-Random-Source</cell><cell>RL-All</cell><cell>RL-Undobias</cell></row><row><cell>Return</cell><cell>98.22 ? 20.35</cell><cell cols="2">144.21 ? 9.23 150.46 ? 17.59</cell></row><row><cell>Method</cell><cell>RL-MLDG</cell><cell cols="2">RL-MLDG-GC RL-MLDG-GN</cell></row><row><cell>Return</cell><cell>170.81 ? 9.90</cell><cell>147.76 ? 4.41</cell><cell>164.97 ? 8.45</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9"><head>Table 6 :</head><label>6</label><figDesc>Domain generalisation performance for mountain car. Failure rate (?) and reward (?) on held out testing domains with random mountain heights.</figDesc><table><row><cell cols="2">Mountain Car RL-Random-Source</cell><cell>RL-All</cell><cell>RL-Undobias</cell></row><row><cell>Avg. F Rate</cell><cell>0.55 ? 0.07</cell><cell>0.05 ? 0.02</cell><cell>0.08 ? 0.04</cell></row><row><cell>Avg. Return</cell><cell>?191.07 ? 3.01</cell><cell cols="2">?141.35 ? 2.64 ?124.48 ? 3.22</cell></row><row><cell>Mountain Car</cell><cell>RL-MLDG</cell><cell cols="2">RL-MLDG-GC RL-MLDG-GN</cell></row><row><cell>Avg. F Rate</cell><cell>0.05 ? 0.02</cell><cell>0.0 ? 0.0</cell><cell>1.0 ? 0.0</cell></row><row><cell>Avg. Return</cell><cell>?125.73 ? 2.76</cell><cell>?311.80 ? 3.92</cell><cell>-</cell></row><row><cell cols="4">Analysis of MLDG variants: Comparing MLDG with its</cell></row><row><cell cols="4">variants MLDG-GC and MLDG-GN we found that MLDG-</cell></row><row><cell cols="4">GN is comparable to vanilla MLDG on this problem, while</cell></row><row><cell cols="2">MLDG-GC is slightly worse.</cell><cell></cell><cell></cell></row></table><note></note></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Unsupervised cross-domain transfer in policy gradient reinforcement learning via manifold alignment</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">[</forename><surname>References</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Ammar</surname></persName>
		</author>
		<idno>arXiv 1701.07275</idno>
	</analytic>
	<monogr>
		<title level="m">IJCAI</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
	<note>ACL</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Model-agnostic meta-learning for fast adaptation of deep networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Abbeel</forename><surname>Finn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Levine ; Finn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Abbeel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Levine</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICML</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Domain generalization for object recognition with multi-task autoencoders</title>
	</analytic>
	<monogr>
		<title level="m">ICLR</title>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
	<note>ICCV</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Data-efficient generalization of robot skills with contextual policy search</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Khosla</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ECCV</title>
		<meeting><address><addrLine>Song, Y</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
	<note>ICCV</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Actor-mimic: Deep multitask and transfer reinforcement learning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">[</forename><surname>Mnih</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICML</title>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
	<note>ICLR. Patel et al. 2015. Visual domain adaptation: A survey of recent advances. Signal Processing Magazine</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Shifting inductive bias with success-story algorithm, adaptive levin search, and incremental self-improvement. Machine Learning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Ravi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Larochelle</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S.-A</forename><surname>Rebuff</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Bilen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Vedaldi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Schmidhuber</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Wiering</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">J</forename><surname>Storkey</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Sugiyama</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Sung</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Xiang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Hospedales</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">E</forename><surname>Taylor</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Stone</surname></persName>
		</author>
		<idno>1706.09529</idno>
	</analytic>
	<monogr>
		<title level="m">ICLR</title>
		<imprint>
			<date type="published" when="1997" />
		</imprint>
	</monogr>
	<note>Learning to learn: Meta-critic networks for sample efficient learning. Transfer learning for reinforcement learning domains: A survey. JMLR</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Matching networks for one shot learning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Thrun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Pratt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Vinyals</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Blundell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Lillicrap</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Kavukcuoglu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Wierstra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Machine Learning</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1998" />
		</imprint>
	</monogr>
	<note>NIPS</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Simple statistical gradient-following algorithms for connectionist reinforcement learning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">J</forename><surname>Williams</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Niu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Xu</surname></persName>
		</author>
		<idno>Xu et al. 2014</idno>
	</analytic>
	<monogr>
		<title level="m">Machine Learning</title>
		<imprint>
			<date type="published" when="1992" />
		</imprint>
	</monogr>
	<note>ECCV</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
