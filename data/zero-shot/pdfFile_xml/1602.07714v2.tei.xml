<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /nfs/home/kabenamualus/Research/task-dataset-metric-extraction/../grobid-0.6.0/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Learning values across many orders of magnitude</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hado</forename><surname>Van Hasselt</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Arthur</forename><surname>Guez</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Matteo</forename><surname>Hessel</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Google</forename><surname>Deepmind</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Volodymyr</forename><surname>Mnih</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Silver</surname></persName>
						</author>
						<title level="a" type="main">Learning values across many orders of magnitude</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>

		<encodingDesc>
			<appInfo>
				<application version="0.6.0" ident="GROBID-SDO" when="2022-11-12T03:43+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid-sdo"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Most learning algorithms are not invariant to the scale of the function that is being approximated. We propose to adaptively normalize the targets used in learning. This is useful in value-based reinforcement learning, where the magnitude of appropriate value approximations can change over time when we update the policy of behavior. Our main motivation is prior work on learning to play Atari games, where the rewards were all clipped to a predetermined range. This clipping facilitates learning across many different games with a single learning algorithm, but a clipped reward function can result in qualitatively different behavior. Using the adaptive normalization we can remove this domain-specific heuristic without diminishing overall performance.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Our main motivation is the work by <ref type="bibr" target="#b18">Mnih et al. [2015]</ref>, in which Q-learning <ref type="bibr" target="#b34">[Watkins, 1989]</ref> is combined with a deep convolutional neural network <ref type="bibr">[cf. LeCun et al., 2015]</ref>. The resulting deep Q network (DQN) algorithm learned to play a varied set of Atari 2600 games from the Arcade Learning Environment (ALE) <ref type="bibr" target="#b1">[Bellemare et al., 2013]</ref>, which was proposed as an evaluation framework to test general learning algorithms on solving many different interesting tasks. DQN was proposed as a singular solution, using a single set of hyperparameters, but the magnitudes and frequencies of rewards vary wildly between different games. To overcome this hurdle, the rewards and temporaldifference errors were clipped to <ref type="bibr">[?1, 1]</ref>. For instance, in Pong the rewards are bounded by ?1 and +1 while in Ms. Pac-Man eating a single ghost can yield a reward of up to +1600, but DQN clips the latter to +1 as well. This is not a satisfying solution for two reasons. First, such clipping introduces domain knowledge. Most games have sparse non-zero rewards outside of <ref type="bibr">[?1, 1]</ref>. Clipping then results in optimizing the frequency of rewards, rather than their sum. This is a good heuristic in Atari, but it does not generalize to other domains. More importantly, the clipping changes the objective, sometimes resulting in qualitatively different policies of behavior.</p><p>We propose a method to adaptively normalize the targets used in the learning updates. If these targets are guaranteed to be normalized it is much easier to find suitable hyperparameters. The proposed technique is not specific to DQN and is more generally applicable in supervised learning and reinforcement learning. There are several reasons such normalization can be desirable. First, sometimes we desire a single system that is able to solve multiple different problems with varying natural magnitudes, as in the Atari domain. Second, for multi-variate functions the normalization can be used to disentangle the natural magnitude of each component from its relative importance in the loss function. This is particularly useful when the components have different units, such as when we predict signals from sensors with different modalities. Finally, adaptive normalization can help deal with non-stationary. For instance, in reinforcement learning the policy of behavior can change repeatedly during learning, thereby changing the distribution and magnitude of the values.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Related work</head><p>Many machine-learning algorithms rely on a-priori access to data to properly tune relevant hyperparameters <ref type="bibr" target="#b4">[Bergstra et al., 2011</ref><ref type="bibr" target="#b3">, Bergstra and Bengio, 2012</ref><ref type="bibr" target="#b28">, Snoek et al., 2012</ref>. However, it is much harder to learn efficiently from a stream of data when we do not know the magnitude of the function we seek to approximate beforehand, or if these magnitudes can change over time, as is for instance typically the case in reinforcement learning when the policy of behavior improves over time.</p><p>Input normalization has long been recognized as important to efficiently learn non-linear approximations such as neural networks <ref type="bibr" target="#b13">[LeCun et al., 1998</ref>], leading to research on how to achieve scale-invariance on the inputs [e.g., <ref type="bibr" target="#b24">Ross et al., 2013</ref><ref type="bibr" target="#b9">, Ioffe and Szegedy, 2015</ref><ref type="bibr" target="#b5">, Desjardins et al., 2015</ref>. Output or target normalization has not received as much attention, probably because in supervised learning data is commonly available before learning commences, making it straightforward to determine appropriate normalizations or to tune hyper-parameters. However, this assumes the data is available a priori, which is not true in online (potentially non-stationary) settings.</p><p>Natural gradients <ref type="bibr" target="#b0">[Amari, 1998]</ref> are invariant to reparameterizations of the function approximation, thereby avoiding many scaling issues, but these are computationally expensive for functions with many parameters such as deep neural networks. This is why approximations are regularly proposed, typically trading off accuracy to computation <ref type="bibr" target="#b16">[Martens and Grosse, 2015]</ref>, and sometimes focusing on a certain aspect such as input normalization <ref type="bibr">[Desjardins et al., 2015, Ioffe and</ref><ref type="bibr" target="#b9">Szegedy, 2015]</ref>. Most such algorithms are not fully invariant to rescaling the targets.</p><p>In the Atari domain several algorithmic variants and improvements for DQN have been proposed <ref type="bibr" target="#b2">, Bellemare et al., 2016</ref><ref type="bibr" target="#b33">, Wang et al., 2016</ref>, as well as alternative solutions <ref type="bibr" target="#b15">[Liang et al., 2016</ref><ref type="bibr" target="#b19">, Mnih et al., 2016</ref>. However, none of these address the clipping of the rewards or explicitly discuss the impacts of clipping on performance or behavior.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Preliminaries</head><p>Concretely, we consider learning from a stream of data</p><formula xml:id="formula_0">{(X t , Y t )} ? t=1</formula><p>where the inputs X t ? R n and targets Y t ? R k are real-valued tensors. The aim is to update parameters ? of a function f ? : R n ? R k such that the output f ? (X t ) is (in expectation) close to the target Y t according to some loss l t (f ? ), for instance defined as a squared difference:</p><formula xml:id="formula_1">l t (f ? ) = 1 2 (f ? (X t ) ? Y t ) (f ? (X t ) ? Y t ).</formula><p>A canonical update is stochastic gradient descent (SGD). For a sample (X t , Y t ), the update is then ? t+1 = ? t ? ?? ? l t (f ? ), where ? ? [0, 1] is a step size. The magnitude of this update depends on both the step size and the loss, and it is hard to pick suitable step sizes when nothing is known about the magnitude of the loss.</p><p>An important special case is when f ? is a neural network <ref type="bibr" target="#b17">[McCulloch and</ref><ref type="bibr">Pitts, 1943, Rosenblatt, 1962]</ref>, which are often trained with a form of SGD <ref type="bibr" target="#b25">[Rumelhart et al., 1986]</ref>, with hyperparameters that interact with the scale of the loss. Especially for deep neural networks <ref type="bibr" target="#b14">[LeCun et al., 2015</ref><ref type="bibr" target="#b27">, Schmidhuber, 2015</ref> large updates may harm learning, because these networks are highly non-linear and such updates may 'bump' the parameters to regions with high error.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Adaptive normalization with Pop-Art</head><p>We propose to normalize the targets Y t , where the normalization is learned separately from the approximating function. We consider an affine transformation of the targets</p><formula xml:id="formula_2">Y t = ? ?1 t (Y t ? ? t ) ,<label>(1)</label></formula><p>where ? t and ? t are scale and shift parameters that are learned from data. The scale matrix ? t can be dense, diagonal, or defined by a scalar ? t as ? t = ? t I. Similarly, the shift vector ? t can contain separate components, or be defined by a scalar ? t as ? t = ? t 1. We can then define a loss on a normalized function g(X t ) and the normalized target? t . The unnormalized approximation for any input x is then given by f (x) = ?g(x) + ?, where g is the normalized function and f is the unnormalized function.</p><p>At first glance it may seem we have made little progress. If we learn ? and ? using the same algorithm as used for the parameters of the function g, then the problem has not become fundamentally different or easier; we would have merely changed the structure of the parameterized function slightly.</p><p>Conversely, if we consider tuning the scale and shift as hyperparameters then tuning them is not fundamentally easier than tuning other hyperparameters, such as the step size, directly.</p><p>Fortunately, there is an alternative. We propose to update ? and ? according to a separate objective with the aim of normalizing the updates for g. Thereby, we decompose the problem of learning an appropriate normalization from learning the specific shape of the function. The two properties that we want to simultaneously achieve are (ART) to update scale ? and shift ? such that ? ?1 (Y ? ?) is appropriately normalized, and (POP) to preserve the outputs of the unnormalized function when we change the scale and shift.</p><p>We discuss these properties separately below. We refer to algorithms that combine output-preserving updates and adaptive rescaling, as Pop-Art algorithms, an acronym for "Preserving Outputs Precisely, while Adaptively Rescaling Targets".</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Preserving outputs precisely</head><p>Unless care is taken, repeated updates to the normalization might make learning harder rather than easier because the normalized targets become non-stationary. More importantly, whenever we adapt the normalization based on a certain target, this would simultaneously change the output of the unnormalized function of all inputs. If there is little reason to believe that other unnormalized outputs were incorrect, this is undesirable and may hurt performance in practice, as illustrated in Section 3. We now first discuss how to prevent these issues, before we discuss how to update the scale and shift.</p><p>The only way to avoid changing all outputs of the unnormalized function whenever we update the scale and shift is by changing the normalized function g itself simultaneously. The goal is to preserve the outputs from before the change of normalization, for all inputs. This prevents the normalization from affecting the approximation, which is appropriate because its objective is solely to make learning easier, and to leave solving the approximation itself to the optimization algorithm.</p><p>Without loss of generality the unnormalized function can be written as</p><formula xml:id="formula_3">f ?,?,?,W,b (x) ? ?g ?,W,b (x) + ? ? ?(Wh ? (x) + b) + ? ,<label>(2)</label></formula><p>where h ? is a parametrized (non-linear) function, and g ?,W,b = Wh ? (x) + b is the normalized function. It is not uncommon for deep neural networks to end in a linear layer, and then h ? can be the output of the last (hidden) layer of non-linearities. Alternatively, we can always add a square linear layer to any non-linear function h ? to ensure this constraint, for instance initialized as W 0 = I and b 0 = 0.</p><p>The following proposition shows that we can update the parameters W and b to fulfill the second desideratum of preserving outputs precisely for any change in normalization.</p><p>Proposition 1. Consider a function f : R n ? R k defined as in (2) as </p><formula xml:id="formula_4">f ?,?,?,W,b (x) ? ? (Wh ? (x) + b) + ? , where h ? : R n ? R m is any non-linear function of x ? R n , ? is a k ? k matrix,</formula><formula xml:id="formula_5">W ? ? ?1 new ?W , b ? ? ?1 new (?b + ? ? ? new ) (rescale W and b) ? ? ? new , ? ? ? new (update scale and shift) h ? h ? (X) (store output of h ? ) J ? (? ? h ?,1 (X), . . . , ? ? h ?,m (X)) (compute Jacobian of h ? ) ? ? Wh + b ? ? ?1 (Y ? ?) (compute normalized error) ? ? ? ? ?J W ? (compute SGD update for ?) W ? W ? ??h (compute SGD update for W) b ? b ? ?? (compute SGD update for b) end while</formula><p>Algorithm 1 is an example implementation of SGD with Pop-Art for a squared loss. It can be generalized easily to any other loss by changing the definition of ?. Notice that W and b are updated twice: first to adapt to the new scale and shift to preserve the outputs of the function, and then by SGD. The order of these updates is important because it allows us to use the new normalization immediately in the subsequent SGD update.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Adaptively rescaling targets</head><p>A natural choice is to normalize the targets to approximately have zero mean and unit variance. For clarity and conciseness, we consider scalar normalizations. It is straightforward to extend to diagonal or dense matrices. If we have data</p><formula xml:id="formula_6">{(X i , Y i )} t i=1 up to some time t, we then may desire t i=1 (Y i ? ? t )/? t = 0 and 1 t t i=1 (Y i ? ? t ) 2 /? 2 t = 1 , such that ? t = 1 t t i=1 Y i and ? t = 1 t t i=1 Y 2 i ? ? 2 t .<label>(3)</label></formula><p>This can be generalized to incremental updates</p><formula xml:id="formula_7">? t = (1 ? ? t )? t?1 + ? t Y t and ? 2 t = ? t ? ? 2 t , where ? t = (1 ? ? t )? t?1 + ? t Y 2 t .</formula><p>(4) Here ? t estimates the second moment of the targets and ? t ? [0, 1] is a step size. If ? t ? ? 2 t is positive initially then it will always remain so, although to avoid issues with numerical precision it can be useful to enforce a lower bound explicitly by requiring ? t ? ? 2 t ? with &gt; 0. For full equivalence to (3) we can use ? t = 1/t. If ? t = ? is constant we get exponential moving averages, placing more weight on recent data points which is appropriate in non-stationary settings.</p><p>A constant ? has the additional benefit of never becoming negligibly small. Consider the first time a target is observed that is much larger than all previously observed targets. If ? t is small, our statistics would adapt only slightly, and the resulting update may be large enough to harm the learning. If ? t is not too small, the normalization can adapt to the large target before updating, potentially making learning more robust. In particular, the following proposition holds.</p><p>Proposition 2. When using updates (4) to adapt the normalization parameters ? and ?, the normalized targets are bounded for all t by</p><formula xml:id="formula_8">? (1 ? ? t )/? t ? (Y t ? ? t )/? t ? (1 ? ? t )/? t .</formula><p>For instance, if ? t = ? = 10 ?4 for all t, then the normalized target is guaranteed to be in (?100, 100). Note that Proposition 2 does not rely on any assumptions about the distribution of the targets. This is an important result, because it implies we can bound the potential normalized errors before learning, without any prior knowledge about the actual targets we may observe.</p><formula xml:id="formula_9">Algorithm 2 Normalized SGD For a given differentiable function h ? , initialize ?. while learning do Observe input X and target Y Use Y to compute new scale ? h ? h ? (X) (store output of h ? ) J ? (?h ?,1 (X), . . . , ?h ?,m (X)) (compute Jacobian of h ? ) ? ? Wh + b ? Y (compute unnormalized error) ? ? ? ? ?J (? ?1 W) ? ?1 ? (update ? with scaled SGD) W ? W ? ??g (update W with SGD) b ? b ? ?? (update b with SGD) end while</formula><p>It is an open question whether it is uniformly best to normalize by mean and variance. In the appendix we discuss other normalization updates, based on percentiles and mini-batches, and derive correspondences between all of these.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">An equivalence for stochastic gradient descent</head><p>We now step back and analyze the effect of the magnitude of the errors on the gradients when using regular SGD. This analysis suggests a different normalization algorithm, which has an interesting correspondence to Pop-Art SGD.</p><p>We consider SGD updates for an unnormalized multi-layer function of form</p><formula xml:id="formula_10">f ?,W,b (X) = Wh ? (X) + b. The update for the weight matrix W is W t = W t?1 + ? t ? t h ?t (X t ) , where ? t = f ?,W,b (X)?Y t</formula><p>is gradient of the squared loss, which we here call the unnormalized error. The magnitude of this update depends linearly on the magnitude of the error, which is appropriate when the inputs are normalized, because then the ideal scale of the weights depends linearly on the magnitude of the targets. 1 Now consider the SGD update to the parameters of h ? , ? t = ? t?1 ? ?J t W t?1 ? t where J t = (?g ?,1 (X), . . . , ?g ?,m (X)) is the Jacobian for h ? . The magnitudes of both the weights W and the errors ? depend linearly on the magnitude of the targets. This means that the magnitude of the update for ? depends quadratically on the magnitude of the targets. There is no compelling reason for these updates to depend at all on these magnitudes because the weights in the top layer already ensure appropriate scaling. In other words, for each doubling of the magnitudes of the targets, the updates to the lower layers quadruple for no clear reason.</p><p>This analysis suggests an algorithmic solution, which seems to be novel in and of itself, in which we track the magnitudes of the targets in a separate parameter ? t , and then multiply the updates for all lower layers with a factor ? ?2 t . A more general version of this for matrix scalings is given in Algorithm 2. We prove an interesting, and perhaps surprising, connection to the Pop-Art algorithm.</p><p>Proposition 3. Consider two functions defined by</p><formula xml:id="formula_11">f ?,?,?,W,b (x) = ?(Wh ? (x) + b) + ? and f ?,W,b (x) = Wh ? (x) + b ,</formula><p>where h ? is the same differentiable function in both cases, and the functions are initialized identically, using ? 0 = I and ? = 0, and the same initial ? 0 , W 0 and b 0 . Consider updating the first function using Algorithm 1 (Pop-Art SGD) and the second using Algorithm 2 (Normalized SGD). Then, for any sequence of non-singular scales {? t } ? t=1 and shifts {? t } ? t=1 , the algorithms are equivalent in the sense that 1) the sequences {? t } ? t=0 are identical, 2) the outputs of the functions are identical, for any input.</p><p>The proposition shows a duality between normalizing the targets, as in Algorithm 1, and changing the updates, as in Algorithm 2. This allows us to gain more intuition about the algorithm. In particular,  in Algorithm 2 the updates in top layer are not normalized, thereby allowing the last linear layer to adapt to the scale of the targets. This is in contrast to other algorithms that have some flavor of adaptive normalization, such as RMSprop <ref type="bibr" target="#b29">[Tieleman and Hinton, 2012]</ref>, AdaGrad <ref type="bibr" target="#b6">[Duchi et al., 2011]</ref>, and Adam <ref type="bibr" target="#b10">[Kingma and Adam, 2015]</ref> that each component in the gradient by a square root of an empirical second moment of that component. That said, these methods are complementary, and it is straightforward to combine Pop-Art with other optimization algorithms than SGD.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Binary regression experiments</head><p>We first analyze the effect of rare events in online learning, when infrequently a much larger target is observed. Such events can for instance occur when learning from noisy sensors that sometimes captures an actual signal, or when learning from sparse non-zero reinforcements. We empirically compare three variants of SGD: without normalization, with normalization but without preserving outputs precisely (i.e., with 'Art', but without 'Pop'), and with Pop-Art.</p><p>The inputs are binary representations of integers drawn uniformly randomly between 0 and n = 2 10 ?1. The desired outputs are the corresponding integer values. Every 1000 samples, we present the binary representation of 2 16 ? 1 as input (i.e., all 16 inputs are 1) and as target 2 16 ? 1 = 65, 535. The approximating function is a fully connected neural network with 16 inputs, 3 hidden layers with 10 nodes per layer, and tanh internal activation functions. This simple setup allows extensive sweeps over hyper-parameters, to avoid bias towards any algorithm by the way we tune these. The step sizes ? for SGD and ? for the normalization are tuned by a grid search over {10 ?5 , 10 ?4.5 , . . . , 10 ?1 , 10 ?0.5 , 1}. <ref type="figure" target="#fig_2">Figure 1a</ref> shows the root mean squared error (RMSE, log scale) for each of 5000 samples, before updating the function (so this is a test error, not a train error). The solid line is the median of 50 repetitions, and shaded region covers the 10th to 90th percentiles. The plotted results correspond to the best hyper-parameters according to the overall RMSE (i.e., area under the curve). The lines are slightly smoothed by averaging over each 10 consecutive samples.</p><p>SGD favors a relatively small step size (? = 10 ?3.5 ) to avoid harmful large updates, but this slows learning on the smaller updates; the error curve is almost flat in between spikes. SGD with adaptive normalization (labeled 'Art') can use a larger step size (? = 10 ?2.5 ) and therefore learns faster, but has high error after the spikes because the changing normalization also changes the outputs of the smaller inputs, increasing the errors on these. In comparison, Pop-Art performs much better. It prefers the same step size as Art (? = 10 ?2.5 ), but Pop-Art can exploit a much faster rate for the statistics (best performance with ? = 10 ?0.5 for Pop-Art and ? = 10 ?4 for Art). The faster tracking of statistics protects Pop-Art from the large spikes, while the output preservation avoids invalidating the outputs for smaller targets. We ran experiments with RMSprop but left these out of the figure as the results were very similar to SGD.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Atari 2600 experiments</head><p>An important motivation for this work is reinforcement learning with non-linear function approximators such as neural networks (sometimes called deep reinforcement learning). The goal is to predict and optimize action values defined as the expected sum of future rewards. These rewards can differ arbitrarily from one domain to the next, and non-zero rewards can be sparse. As a result, the action values can span a varied and wide range which is often unknown before learning commences. <ref type="bibr" target="#b18">Mnih et al. [2015]</ref> combined Q-learning with a deep neural network in an algorithm called DQN, which impressively learned to play many games using a single set of hyper-parameters. However, as discussed above, to handle the different reward magnitudes with a single system all rewards were clipped to the interval [?1, 1]. This is harmless in some games, such as Pong where no reward is ever higher than 1 or lower than ?1, but it is not satisfactory as this heuristic introduces specific domain knowledge that optimizing reward frequencies is approximately is useful as optimizing the total score. However, the clipping makes the DQN algorithm blind to differences between certain actions, such as the difference in reward between eating a ghost (reward &gt;= 100) and eating a pellet (reward = 25) in Ms. Pac-Man. We hypothesize that 1) overall performance decreases when we turn off clipping, because it is not possible to tune a step size that works on many games, 2) that we can regain much of the lost performance by with Pop-Art. The goal is not to improve state-of-the-art performance, but to remove the domain-dependent heuristic that is induced by the clipping of the rewards, thereby uncovering the true rewards.</p><p>We ran the Double DQN algorithm  in three versions: without changes, without clipping both rewards and temporal difference errors, and without clipping but additionally using Pop-Art. The targets are the cumulation of a reward and the discounted value at the next state:</p><formula xml:id="formula_12">Y t = R t+1 + ?Q(S t , argmax a Q(S t , a; ?); ? ? ) ,<label>(5)</label></formula><p>where Q(s, a; ?) is the estimated action value of action a in state s according to current parameters ?, and where ? ? is a more stable periodic copy of these parameters [cf. <ref type="bibr" target="#b18">Mnih et al., 2015</ref>, for more details]. This is a form of Double Q-learning <ref type="bibr" target="#b30">[van Hasselt, 2010</ref><ref type="bibr" target="#b31">[van Hasselt, , 2011</ref>. We roughly tuned the main step size and the step size for the normalization to 10 ?4 . It is not straightforward to tune the unclipped version, for reasons that will become clear soon. Without clipping the rewards, Pop-Art produces a much narrower band within which the gradients fall. Across games, 95% of median norms range over less than two orders of magnitude (roughly between 1 and 20), compared to almost four orders of magnitude for clipped Double DQN, and more than six orders of magnitude for unclipped Double DQN without Pop-Art. The wide range for the latter shows why it is impossible to find a suitable step size with neither clipping nor Pop-Art: the updates are either far too small on some games or far too large on others.</p><p>After 200M frames, we evaluated the actual scores of the best performing agent in each game on 100 episodes of up to 30 minutes of play, and then normalized by human and random scores as described by <ref type="bibr" target="#b18">Mnih et al. [2015]</ref>. <ref type="figure" target="#fig_2">Figure 1 shows</ref>   Some games fare worse with unclipped rewards because it changes the nature of the problem. For instance, in Time Pilot the Pop-Art agent learns to quickly shoot a mothership to advance to a next level of the game, obtaining many points in the process. The clipped agent instead shoots at anything that moves, ignoring the mothership. 2 However, in the long run in this game more points are scored with the safer and more homogeneous strategy of the clipped agent. One reason for the disconnect between the seemingly qualitatively good behavior combined with lower scores is that the agents are fairly myopic: both use a discount factor of ? = 0.99, and therefore only optimize rewards that happen within a dozen or so seconds into the future.</p><p>On the whole, the results show that with Pop-Art we can successfully remove the clipping heuristic that has been present in all prior DQN variants, while retaining overall performance levels. Double DQN with Pop-Art performs slightly better than Double DQN with clipped rewards: on 32 out of 57 games performance is at least as good as clipped Double DQN and the median (+0.4%) and mean (+34%) differences are positive.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Discussion</head><p>We have demonstrated that Pop-Art can be used to adapt to different and non-stationary target magnitudes. This problem was perhaps not previously commonly appreciated, potentially because in deep learning it is common to tune or normalize a priori, using an existing data set. This is not as straightforward in reinforcement learning when the policy and the corresponding values may repeatedly change over time. This makes Pop-Art a promising tool for deep reinforcement learning, although it is not specific to this setting.</p><p>We saw that Pop-Art can successfully replace the clipping of rewards as done in DQN to handle the various magnitudes of the targets used in the Q-learning update. Now that the true problem is exposed to the learning algorithm we can hope to make further progress, for instance by improving the exploration <ref type="bibr" target="#b21">[Osband et al., 2016]</ref>, which can now be informed about the true unclipped rewards.</p><p>In this appendix, we introduce and analyze several extensions and variations, including normalizing based on percentiles or minibatches. Additionally, we prove all propositions in the main text and the appendix.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Experiment setup</head><p>For the experiments described in Section 4 in the main paper, we closely followed the setup described in <ref type="bibr" target="#b18">Mnih et al. [2015]</ref> and . In particular, the Double DQN algorithm is identical to that described by van Hasselt et al. The shown results were obtained by running the trained agent for 30 minutes of simulated play (or 108,000 frames). This was repeated 100 times, where diversity over different runs was ensured by a small probability of exploration on each step ( -greedy exploration with = 0.01), as well as by performing up to 30 'no-op' actions, as also used and described by Mnih et al. In summary, the evaluation setup was the same as used by Mnih et al., except that we allowed more evaluation time per game (30 minutes instead of 5 minutes), as also used by <ref type="bibr" target="#b33">Wang et al. [2016]</ref>.</p><p>The results in <ref type="figure" target="#fig_1">Figure 2</ref> were obtained by normalizing the raw scores by first subtracting the score by a random agent, and then dividing by the absolute difference between human and random agents, such that score normalized ? score agent ? score random |score human ? score random | .</p><p>The raw scores are given below, in <ref type="table" target="#tab_3">Table 1</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Generalizing normalization by variance</head><p>We can change the variance of the normalized targets to influence the magnitudes of the updates. For a desired standard deviation of s &gt; 0, we can use</p><formula xml:id="formula_13">? t = ? t ? ? 2 t s ,</formula><p>with the updates for ? t and ? t as normal. It is straightforward to show that then a generalization of Proposition 2 holds with a bound of</p><formula xml:id="formula_14">?s 1 ? ? t ? t ? Y t ? ? t ? t ? s 1 ? ? t ? t .</formula><p>This additional parameter is for instance useful when we desire fast tracking in non-stationary problems. We then want a large step size ?, but without risking overly large updates.  <ref type="figure" target="#fig_1">Figure 2</ref>: The left plot shows histograms for 10,000 normally distributed targets with mean 1 and standard deviation 2 (blue) and for normalized targets for ? = 0.1 (green) and ? = 0.5 (red). The middle plot shows the same histograms, except that the histogram for ? = 0.5 and s = 1 is replaced by a histogram for ? = 0.1 and s = 1/3 (red). The right plot shows the variance of the normalized targets as a function of the upper bound s (1 ? ?)/? when we either change ? while keeping s = 1 fixed (magenta curve) or we change s while keeping ? = 0.01 fixed (black straight line).</p><p>The new parameter s may seem superfluous because increasing the normalization step size ? also reduces the hard bounds on the normalized targets. However, ? additionally influences the distribution of the normalized targets. The histograms in the left-most plot in <ref type="figure" target="#fig_1">Figure 2</ref> show what happens when we try to limit the magnitudes using only ?. The red histogram shows normalized targets where the unnormalized targets come from a normal distribution, shown in blue. The normalized targets are contained in [?1, 1], but the distribution is very non-normal even though the actual targets are normal. Conversely, the red histogram in the middle plot shows that the distribution remains approximately normal if we instead use s to reduce the magnitudes. The right plot shows the effect on the variance of normalized targets for either approach. When we change ? while keeping s = 1 fixed, the variance of the normalized targets can drop far below the desired variance of one (magenta curve). When we use change s while keeping ? = 0.01 fixed, the variance remains predictably at approximately s (black line). The difference in behavior of the resulting normalization demonstrates that s gives us a potentially useful additional degree of freedom.</p><p>Sometimes, we can simply roll the additional scaling s into the step size, such that without loss of generality we can use s = 1 and decrease the step size to avoid overly large updates. However, sometimes it is easier to separate the magnitude of the targets, as influenced by s, from the magnitude of the updates, for instance when using an adaptive step-size algorithm. In addition, the introduction of an explicit scaling s allows us to make some interesting connections to normalization by percentiles, in the next section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Adaptive normalization by percentiles</head><p>Instead of normalizing by mean and variance, we can normalize such that a given ratio p of normalized targets is inside the predetermined interval. The per-output objective is then</p><formula xml:id="formula_15">P Y ? ? ? ? [?1, 1] = p .</formula><p>For normally distributed targets, there is a direct correspondence to normalizing by means and variance.</p><p>Proposition 4. If scalar targets {Y t } ? t=1 are distributed according to a normal distribution with arbitrary finite mean and variance, then the objective P((Y ? ?)/? ? [?1, 1]) = p is equivalent to the joint objective E [Y ? ?] = 0 and E ? ?2 (Y ? ?) 2 = s 2 with p = erf 1 ? 2s .</p><p>For example, percentiles of p = 0.99 and p = 0.95 correspond to s ? 0.4 and s ? 0.5, respecticely. Conversely, s = 1 corresponds to p ? 0.68. The fact only applies when the targets are normal. For other distributions the two forms of normalization differ even in terms of their objectives.</p><p>We now discuss a concrete algorithm to obtain normalization by percentiles. Let Y (n) t denote order statistics of the targets up to time t, 3 such that Y</p><formula xml:id="formula_16">(1) t = min i {Y i } t i=1 , Y (t) t = max i {Y i } t i=1 , and Y ((t+1)/2) t = median i {Y i } t i=1 .</formula><p>For notational simplicity, define n + ? t+1 2 + p t?1 2 and n ? ? t+1 2 ? p t?1 2 . Then, for data up to time t, the goal is Y</p><formula xml:id="formula_17">(n + ) t ? ? t ? t = ?1 , and Y (n ? ) t ? ? t ? t = 1 .</formula><p>Solving for ? t and ? t gives</p><formula xml:id="formula_18">? t = 1 2 Y (n + ) t + Y (n ? ) t , and ? t = 1 2 Y (n + ) t ? Y (n ? ) t .</formula><p>In the special case where p = 1 we get</p><formula xml:id="formula_19">? t = 1 2 (max i Y i + min i Y i ) and ? t = 1 2 (max i Y i ? min i Y i ).</formula><p>We are then guaranteed that all normalized targets fall in [?1, 1], but this could result in an overly conservative normalization that is sensitive to outliers and may reduce the overall magnitude of the updates too far. In other words, learning will then be safe in the sense that no updates will be too big, but it may be slow because many updates may be very small. In general it is probably typically better to use a ratio p &lt; 1.</p><p>Exact order statistics are hard to compute online, because we would need to store all previous targets. To obtain more memory-efficient online updates for percentiles we can store two values y min t and y max t , which should eventually have the property that a proportion of (1 ? p)/2 values is larger than y max t and a proportion of (1 ? p)/2 values is smaller than y min t , such that</p><formula xml:id="formula_20">P (Y &gt; y max t ) = P Y &lt; y min t = (1 ? p)/2 .<label>(6)</label></formula><p>This can be achieved asymptotically by updating y min t and y max t according to</p><formula xml:id="formula_21">y max t = y max t?1 + ? t I(Y t &gt; y max t?1 ) ? 1 ? p 2 and<label>(7)</label></formula><formula xml:id="formula_22">y min t = y min t?1 ? ? t I(Y t &lt; y min t?1 ) ? 1 ? p 2 ,<label>(8)</label></formula><p>where the indicator function I(?) is equal to one when its argument is true and equal to zero otherwise.</p><p>Proposition 5. If ? t=1 ? t and ? t=1 ? 2 t , and the distribution of targets is stationary, then the updates in <ref type="formula" target="#formula_21">(7)</ref> converge to values such that (6) holds.</p><p>If the step size ? t is too small it will take long for the updates to converge to appropriate values. In practice, it might be better to let the magnitude of the steps depend on the actual errors, such that the update takes the form of an asymmetrical least-squares update <ref type="bibr" target="#b20">[Newey and</ref><ref type="bibr">Powell, 1987, Efron, 1991]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Online learning with minibatches</head><p>Online normalization by mean and variance with minibatches {Y t,1 , . . . , Y t,B } of size B can be achieved by using the updates</p><formula xml:id="formula_23">? t = (1 ? ? t )? t?1 + ? t 1 B B b=1 Y t,b , and ? t = ? t ? ? 2 t s , where ? t = (1 ? ? t )? t?1 + ? t 1 B B b=1 Y 2 t,b .</formula><p>Another interesting possibility is to update y min t and y max t towards the extremes of the minibatch such that</p><formula xml:id="formula_24">y min t = (1 ? ? t )y min t?1 + ? t min b Y t,b , and<label>(9)</label></formula><formula xml:id="formula_25">y max t = (1 ? ? t )y max t?1 + ? t max b Y t,b</formula><p>, and then use</p><formula xml:id="formula_26">? t = 1 2 (y max t + y min t ) , and ? t = 1 2 (y max t ? y min t )</formula><p>. The statistics of this normalization depend on the size of the minibatches, and there is an interesting correspondence to normalization by percentiles. Proposition 6. Consider minibatches {{Y t,1 , . . . , Y t,B }} ? t=1 of size B ? 2 whose elements are drawn i.i.d. from a uniform distribution with support on <ref type="bibr">[a, b]</ref>. If t ? t = ? and t ? 2 t &lt; ?, then in the limit the updates (9) converge to values such that (6) holds, with p = (B ? 1)/(B + 1).</p><p>This fact connects the online minibatch updates (9) to normalization by percentiles. For instance, a minibatch size of B = 20 would correspond roughly to online percentile updates with p = 19/21 ? 0.9 and, by Proposition 4, to a normalization by mean and variance with a s ? 0.6. These different normalizations are not strictly equivalent, but may behave similarly in practice.</p><p>Proposition 6 quantifies an interesting correspondence between minibatch updates and normalizing by percentiles. Although the fact as stated holds only for uniform targets, the proportion of normalized targets in the interval [?1, 1] more generally becomes larger when we increase the minibatch size, just as when we increase p or decrease s, potentially resulting in better robustness to outliers at the possible expense of slower learning.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A note on initialization</head><p>When using constant step sizes it is useful to be aware of the start of learning, to trust the data rather than arbitrary initial values. This can be done by using a step size as defined in the following fact.</p><p>Proposition 7. Consider a recency-weighted running averagez t updated from a stream of data</p><formula xml:id="formula_27">{Z t } ? t=1 usingz t = (1 ? ? t )z t?1 + ? t Z t , with ? t defined by ? t = ?(1 ? (1 ? ?) t ) ?1 .<label>(10)</label></formula><p>Then 1) the relative weights of the data in Z t are the same as when using a constant step size ?, and 2) the estimatez t does not depend on the initial valuez 0 .</p><p>A similar result was derived to remove the effect of the initialization of certain parameters by <ref type="bibr" target="#b11">Kingma and Ba [2014]</ref> for a stochastic optimization algorithm called Adam. In that work, the initial values are assumed to be zero and a standard exponentially weighted average is explicitly computed and stored, and then divided by a term analogous to 1 ? (1 ? ?) t . The step size (10) corrects for any initialization in place, without storing auxiliary variables, but for the rest the method and its motivation are very similar.</p><p>Alternatively, it is possible to initialize the normalization safely, by choosing a scale that is relatively high initially. This can be beneficial when at first the targets are relatively small and noisy. If we would then use the step size in (10), the updates would treat these initial observations as important, and would try to fit our approximating function to the noise. A high initialization (e.g., ? 0 = 10 4 or ? 0 = 10 6 ) would instead reduce the effect of the first targets on the learning updates, and would instead use these only to find an appropriate normalization. Only after finding this normalization the actual learning would then commence.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Deep Pop-Art</head><p>Sometimes it makes sense to apply the normalization not to the output of the network, but at a lower level. For instance, the i th output of a neural network with a soft-max on top can be written</p><formula xml:id="formula_28">g ?,i (X) = e [Wh ? (X)+b]i j e [Wh ? (X)+b]j ,</formula><p>where W is the weight matrix of the last linear layer before the soft-max. The actual outputs are already normalized by using the soft-max, but the outputs Wh ? (X) + b of the layer below the soft-max may still benefit from normalization. To determine the targets to be normalized, we can either back-propagate the gradient of our loss through the soft-max or invert the function.</p><p>More generally, we can consider applying normalization at any level of a hierarchical non-linear function. This seems a promising way to counteract undesirable characteristics of back-propagating gradients, such as vanishing or exploding gradients <ref type="bibr" target="#b8">[Hochreiter, 1998</ref>].</p><p>In addition, normalizing gradients further down in a network can provide a straightforward way to combine gradients from different sources in more complex network graphs than a standard feedforward multi-layer network. First, the normalization allows us to normalize the gradient from each source separately before merging gradients, thereby avoiding one source to fully drown out any others and allowing us to weight the gradients by actual relative importance, rather than implicitly relying on the current magnitude of each as a proxy for this. Second, the normalization can prevent undesirably large gradients when many gradients come together at one point of the graph, by normalizing again after merging gradients.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proofs</head><p>Proposition 1. Consider a function f :</p><formula xml:id="formula_29">R n ? R k defined by f ?,?,?,W,b (x) ? ? (Wh ? (x) + b) + ? ,</formula><p>where h ? : R n ? R m is any non-linear function of x ? R n , ? is a k ? k matrix, ? and b are k-element vectors, and W is a k ? m matrix. Consider any change of the scale and shift parameters from ? to ? 2 and from ? to ? 2 , where ? 2 is non-singular. If we then additionally change the parameters W and b to W 2 and b 2 , defined by</p><formula xml:id="formula_30">W 2 = ? ?1 2 ?W and b 2 = ? ?1 2 (?b + ? ? ? 2 ) ,</formula><p>then the outputs of the unnormalized function f are preserved precisely in the sense that f ?,?,?,W,b (x) = f ?,?2,?2,W2,b2 (x) , ?x .</p><p>Proof. The stated result follows from</p><formula xml:id="formula_31">f ?,?2,?2,W2,b2 (x) = ? 2 g ?,W2,b2 (x) + ? 2 = ? 2 (W 2 h ? (x) + b 2 ) + ? 2 = ? 2 ? ?1 2 ?Wh ? (x) + ? ?1 2 (?b + ? ? ? 2 ) + ? 2 = (?Wh ? (x) + ?b + ? ? ? 2 ) + ? 2 = ?Wh ? (x) + ?b + ? = ?g ?,W,b (x) + ? = f ?,?,?,W,b (x) .</formula><p>Proposition 2. When using updates (4) to adapt the normalization parameters ? and ?, the normal-</p><formula xml:id="formula_32">ized target ? ?1 t (Y t ? ? t ) is bounded for all t by ? 1 ? ? t ? t ? Y t ? ? t ? t ? 1 ? ? t ? t .</formula><p>We use the shorthands f 1 t and f 2 t for the first and second function, respectively. First, we show that W 1 t = ? ?1 t W 2 t , for all t. For t = 0, this holds trivially because W 1 0 = W 2 0 = W 0 , and ? 0 = I. Now assume that W 1</p><formula xml:id="formula_33">t?1 = ? ?1 t?1 W 2 t?1 . Let ? t = Y t ? f 1 t (X t ) be the unnormalized error at time t.</formula><p>Then, Algorithm 1 results in p = erf 1 ? 2s</p><p>Proof. For any ? and ?, the normalized targets are distributed according to a normal distribution because the targets themselves are normally distributed and the normalization is an affine transformation. For a normal distribution with mean zero and variance v, the values 1 and ?1 are both exactly 1/ ? v standard deviations from the mean, implying that the ratio of data between these points is</p><formula xml:id="formula_34">?(1/ ? v) ? ?(?1/ ? v), where ?(x) = 1 2 1 + erf x ? 2</formula><p>is the standard normal cumulative distribution. The normalization by mean and variance is then equivalent to a normalization by percentiles with a ratio p defined by</p><formula xml:id="formula_35">p = ?(1/ ? v) ? ?(?1/ ? n) = 1 2 1 + erf 1 ? 2v ? 1 2 1 + erf ? 1 ? 2v = erf 1 ? 2v ,</formula><p>where we used the fact that erf is odd, such that erf(x) = ? erf(?x).</p><p>Proposition 5. If ? t=1 ? t and ? t=1 ? 2 t , and the distribution of targets is stationary, then the updates</p><formula xml:id="formula_36">y max t = y max t?1 + ? t I(Y t &gt; y max t?1 ) ? 1 ? p 2 and y min t = y min t?1 ? ? t I(Y t &lt; y min t?1 ) ? 1 ? p 2 ,</formula><p>converge to values such that</p><formula xml:id="formula_37">P (Y &gt; y max t ) = P Y &lt; y min t = 1 ? p 2 .</formula><p>Proof. Note that</p><formula xml:id="formula_38">E y max t = y max t?1 ?? E [I(Y &gt; y max t )] = (1 ? p)/2 ?? P (Y &gt; y max t ) =</formula><p>(1 ? p)/2 , so this is a fixed point of the update. Note further that the variance of the stochastic update is finite, and that the expected direction of the updates is towards the fixed point, so that this fixed point is an attractor. The conditions on the step sizes ensure that the fixed point is reachable ( ? t=1 ? t = ?) and that we converge upon it in the limit ( ? t=1 ? 2 t &lt; ?). For more detail and weaker conditions, we refer to reader to the extensive literature on stochastic approximation <ref type="bibr" target="#b22">[Robbins and</ref><ref type="bibr">Monro, 1951, Kushner and</ref><ref type="bibr" target="#b12">Yin, 2003]</ref>. The proof for the update for y min t is exactly analogous. Proposition 6. Consider minibatches {{Y t,1 , . . . , Y t,B }} ? t=1 of size B ? 2 whose elements are drawn i.i.d. from a uniform distribution with support on <ref type="bibr">[a, b]</ref>. If t ? t = ? and t ? 2 t &lt; ?, then in the limit the updates</p><formula xml:id="formula_39">y min t = (1 ? ? t )y min t?1 + ? t min b Y t,b , and y max t = (1 ? ? t )y max t?1 + ? t max b Y t,b</formula><p>converge to values such that P (Y &gt; y max t ) = P Y &lt; y min t = (1 ? p)/2 , with p = (B ? 1)/(B + 1).</p><p>Proof. Because of the conditions on the step size, the quantities y min t and y max t will converge to the expected value for the minimum and maximum of a set of B i.i.d. random variables. The cumulative distribution function (CDF) for the maximum of B i.i.d. random variables with CDF F (x) is F (x) B , since</p><formula xml:id="formula_40">P (x &lt; max 1?b?B Y b ) = B b=1 P (x &lt; Y b ) = F (x) B</formula><p>The CDF for a uniform random variables with support on [a, b] is</p><formula xml:id="formula_41">F (x) = ? ? ? 0 if x &lt; a, x?a b?a if a ? x ? b, 1 if x &gt; b.</formula><p>Therefore,</p><formula xml:id="formula_42">P (x ? max 1?b?B Y b ) = ? ? ? ? ? 0 if x &lt; a, x?a b?a B if a ? x ? b, 1 if x &gt; b.</formula><p>The associated expected value can then be calculated to be</p><formula xml:id="formula_43">E [max 1?b?B Y b ] = a + B B + 1 (b ? a) ,</formula><p>so that a fraction of 1 B+1 of samples will be larger than this value. Through a similar reasoning, an additional fraction of 1 B+1 will be smaller than the minimum, and a ratio of p = B?1 B+1 will on average fall between these values. </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>. Median RMSE on binary regression for SGD without normalization (red), with normalization but without preserving outputs (blue, labeled 'Art'), and with Pop-Art (green). Shaded 10-90 percentiles.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1b shows 2</head><label>2</label><figDesc>norm of the gradient of Double DQN during learning as a function of number of training steps. The left plot corresponds to no reward clipping, middle to clipping (as per original DQN and Double DQN), and right to using Pop-Art instead of clipping. Each faint dashed lines corresponds to the median norms (where the median is taken over time) on one game. The shaded areas correspond to 50%, 90%, and 95% of games.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 1 :</head><label>1</label><figDesc>Differences between normalized scores for Double DQN with and without Pop-Art on 57 Atari games.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>? and b are k-element vectors, and W is a k ? m matrix. Consider any change of the scale and shift parameters from ? to ? new and from ? to ? new , where ? new is non-singular. If we then additionally change the parameters W and b to W new and b new , defined by This and later propositions are proven in the appendix. For the special case of scalar scale and shift, with ? ? ?I and ? ? ?1, the updates to W and b become W new = (?/? new )W and b new = (?b + ? ? ? new )/? new . After updating the scale and shift we can update the output of the normalized function g ?,W,b (X t ) toward the normalized output? t , using any learning algorithm. SGD on squared loss with Pop-Art For a given differentiable function h ? , initialize ?. Initialize W = I, b = 0, ? = I, and ? = 0. while learning do Observe input X and target Y Use Y to compute new scale ? new and new shift ? new</figDesc><table><row><cell>Algorithm 1</cell><cell></cell></row><row><cell cols="2">W new = ? ?1 new ?W then the outputs of the unnormalized function f are preserved precisely in the sense that and b new = ? ?1 new (?b + ? ? ? new ) ,</cell></row><row><cell>f ?,?,?,W,b (x) = f ?,?new,?new,Wnew,bnew (x) ,</cell><cell>?x .</cell></row><row><cell cols="2">Importantly, the normalization can be updated first, thereby avoiding harmful large updates just before they would otherwise occur. This observation will be made more precise in Proposition 2 in Section 2.2.</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>Pop-ArtFig. 1b. 2 gradient norms for DQN during learning on 57 Atari games with actual unclipped rewards (left, red), clipped rewards (middle, blue), and using Pop-Art (right, green) instead of clipping. Shaded areas correspond to 95%, 90% and 50% of games.</figDesc><table /><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 1 :</head><label>1</label><figDesc>Raw scores for a random agent, a human tested, Double DQN as described by, and Double DQN with Pop-Art and no reward clipping on 30 minutes of simulated play (108,000 frames). The random, human, and Double DQN scores are all taken from Wang et al.</figDesc><table><row><cell>Game Alien Amidar Assault Asterix Asteroids Atlantis Bank Heist Battle Zone Beam Rider Berzerk Bowling Boxing Breakout Centipede Chopper Command Crazy Climber Defender Demon Attack Double Dunk Enduro Fishing Derby Freeway Frostbite Gopher Gravitar H.E.R.O. Ice Hockey James Bond Kangaroo Krull Kung-Fu Master Montezuma's Revenge Ms. Pacman Name This Game Phoenix Pitfall Pong Private Eye Q*Bert River Raid Road Runner Robotank Seaquest Skiing Solaris Space Invaders Star Gunner Surround Tennis Time Pilot Tutankham Up and Down Venture Video Pinball Wizard of Wor Yars Revenge Zaxxon</cell><cell>Random 227.80 5.80 222.40 210.00 719.10 12850.00 14.20 2360.00 363.90 123.70 23.10 0.10 1.70 2090.90 811.00 10780.50 2874.50 152.10 ?18.60 0.00 ?91.70 0.00 65.20 257.60 173.00 1027.00 ?11.20 29.00 52.00 1598.00 258.50 0.00 307.30 2292.30 761.40 ?229.40 ?20.70 24.90 163.90 1338.50 11.50 2.20 68.40 ?17098.10 ?4336.90 Human Double DQN Double DQN with Pop-Art 7127.70 3747.70 3213.50 1719.50 1793.30 782.50 742.00 5393.20 9011.60 8503.30 17356.50 18919.50 47388.70 734.70 2869.30 29028.10 106056.00 340076.00 753.10 1030.60 1103.30 37187.50 31700.00 8220.00 16926.50 13772.80 8299.40 2630.40 1225.40 1199.60 160.70 68.10 102.10 12.10 91.60 99.30 30.50 418.50 344.10 12017.00 5409.40 49065.80 7387.80 5809.00 775.00 35829.40 117282.00 119679.00 18688.90 35338.50 11099.00 1971.00 58044.20 63644.90 ?16.40 ?5.50 ?11.50 860.50 1211.80 2002.10 ?38.70 15.50 45.10 29.60 33.30 33.40 4334.70 1683.30 3469.60 2412.50 14840.80 56218.20 3351.40 412.00 483.50 30826.40 20130.20 14225.20 0.90 ?2.70 ?4.10 302.80 1358.00 507.50 3035.00 12992.00 13150.00 2665.50 7920.50 9745.10 22736.30 29710.00 34393.00 4753.30 0.00 0.00 6951.60 2711.40 4963.80 8049.00 10616.00 15851.20 7242.60 12252.50 6202.50 6463.70 ?29.90 ?2.60 14.60 20.90 20.60 69571.30 129.70 286.70 13455.00 15088.50 5236.80 17118.00 14884.50 12530.80 7845.00 44127.00 47770.00 11.90 65.10 64.30 42054.70 16452.70 10932.30 ?9021.80 ?13585.10 1236.30 12326.70 3067.80 4544.80 148.00 1668.70 2525.50 2589.70 664.00 10250.00 60142.00 589.00 ?10.00 6.50 ?2.90 ?2.50 ?23.80 ?8.30 ?22.80 12.10 3568.00 5229.20 8339.00 4870.00 11.40 167.60 218.40 183.90 533.40 11693.20 22972.20 22474.40 0.00 1187.50 98.00 1172.00 16256.90 17667.90 309941.90 56287.00 563.50 4756.50 7492.00 483.00 3092.90 54576.90 11712.60 21409.50 32.50 9173.30 10163.00 14402.00</cell></row></table><note>[2016].</note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1">In general care should be taken that the inputs are well-behaved; this is exactly the point of recent work on input normalization<ref type="bibr" target="#b9">[Ioffe and</ref> Szegedy, 2015, Desjardins et al., 2015].</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2">A video is included in the supplementary material.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3">For non-integer x we can define Y (x) by either rounding x to an integer or, perhaps more appropriately, by linear interpolation between the values for the nearest integers.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot">t ,W 2 t ,b 2 t (x) = f ? 1 t ,?t,?t,W 1 t ,b 1 t (x), where the quantities ? 2 , W 2 , and b 2 are updated with Algorithm 2 and quantities ? 1 , W 1 , and b 1 are updated with Algorithm 1. We do not require W 2 t = W 1 t or b 2 t = b 1 t , and indeed these quantities will generally differ.</note>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix</head><p>Proof.</p><p>The inequality follows from the fact that ? t?1 ? ? 2 t?1 .</p><p>Proposition 3. Consider two functions defined by</p><p>where h ? is the same differentiable function in both cases, and the functions are initialized identically, using ? 0 = I and ? = 0, and the same initial ? 0 , W 0 and b 0 . Consider updating the first function using Algorithm 1 and the second using Algorithm 2. Then, for any sequence of non-singular scales {? t } ? t=1 and shifts {? t } ? t=1 , the algorithms are equivalent in the sense that 1) the sequences {? t } ? t=0 are identical, 2) the outputs of the functions are identical, for any input.</p><p>Proof. Let ? 1 t and ? 2 t denote the parameters of h ? for Algorithms 1 and 2, respectively. Similarly, let W 1 and b 1 be parameters of the first function, while W 2 and b 2 are parameters of the second function. It is enough to show that single updates of both Algorithms 1 and 2 from the same starting points have equivalent results. That is, if</p><p>As ? 1 0 = ? 2 0 by assumption, ? 1 t = ? 2 t for all t. Finally, we put everything together and note that f 1 0 = f 2 0 and that (</p><p>where ? is a constant. Then 1) the relative weights of the data in x t are the same as when only the constant step size ? is used, and 2) the average does not depend on the initial value x 0 .</p><p>Proof. The point of the fact is to show that</p><p>where</p><p>?t , and where ? 0 = ? ? 0 . Note that ? t as defined by <ref type="formula">(11)</ref> exactly removes the contribution of the initial value ? 0 , which at time t have weight (1 ? ?) t in the exponential moving average ? ? t , and then renormalizes the remaining value by dividing by 1 ? (1 ? ?) t , such that the relative weights of the observed samples {Z t } ? t=1 is conserved. If (11) holds for ? t?1 , then</p><p>so that then (11) holds for ? t . Finally, verify that ? 1 = Y 1 . Therefore, (11) holds for all t by induction.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Natural gradient works efficiently in learning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">I</forename><surname>Amari</surname></persName>
		</author>
		<idno>0899-7667</idno>
	</analytic>
	<monogr>
		<title level="j">Neural computation</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="251" to="276" />
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">The arcade learning environment: An evaluation platform for general agents</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">G</forename><surname>Bellemare</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Naddaf</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Veness</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Bowling</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Artif. Intell. Res. (JAIR)</title>
		<imprint>
			<biblScope unit="volume">47</biblScope>
			<biblScope unit="page" from="253" to="279" />
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Increasing the action gap: New operators for reinforcement learning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">G</forename><surname>Bellemare</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Ostrovski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Guez</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">S</forename><surname>Thomas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Munos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">AAAI</title>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Random search for hyper-parameter optimization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Bergstra</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Bengio</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The Journal of Machine Learning Research</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="281" to="305" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Algorithms for hyper-parameter optimization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">S</forename><surname>Bergstra</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Bardenet</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Bengio</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>K?gl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems</title>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="page" from="2546" to="2554" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Natural neural networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Desjardins</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Simonyan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Pascanu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Kavukcuoglu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems</title>
		<imprint>
			<date type="published" when="2015" />
			<biblScope unit="page" from="2062" to="2070" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Adaptive subgradient methods for online learning and stochastic optimization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Duchi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Hazan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Singer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The Journal of Machine Learning Research</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="2121" to="2159" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Regression percentiles using asymmetric squared error loss</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Efron</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Statistica Sinica</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="93" to="125" />
			<date type="published" when="1991" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">The vanishing gradient problem during learning recurrent neural nets and problem solutions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Hochreiter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Uncertainty, Fuzziness and Knowledge-Based Systems</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="107" to="116" />
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Batch normalization: Accelerating deep network training by reducing internal covariate shift</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Ioffe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Szegedy</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1502.03167</idno>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">A method for stochastic optimization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">P</forename><surname>Kingma</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">B</forename><surname>Adam</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Learning Representation</title>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Adam: A method for stochastic optimization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">P</forename><surname>Kingma</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Ba</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1412.6980</idno>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Stochastic approximation and recursive algorithms and applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">J</forename><surname>Kushner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Yin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003" />
			<publisher>Springer Science &amp; Business Media</publisher>
			<biblScope unit="volume">35</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Gradient-based learning applied to document recognition</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Lecun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Bottou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Bengio</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Haffner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proceedings of the IEEE</title>
		<imprint>
			<biblScope unit="volume">86</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="2278" to="2324" />
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Deep learning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Lecun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Bengio</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Hinton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nature</title>
		<imprint>
			<biblScope unit="volume">521</biblScope>
			<biblScope unit="issue">7553</biblScope>
			<biblScope unit="page" from="436" to="444" />
			<date type="published" when="2015-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">State of the art control of atari games using shallow reinforcement learning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Liang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">C</forename><surname>Machado</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Talvitie</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">H</forename><surname>Bowling</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Autonomous Agents and Multiagent Systems</title>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Optimizing neural networks with kronecker-factored approximate curvature</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Martens</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">B</forename><surname>Grosse</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 32nd International Conference on Machine Learning</title>
		<meeting>the 32nd International Conference on Machine Learning</meeting>
		<imprint>
			<date type="published" when="2015" />
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="page" from="2408" to="2417" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">A logical calculus of the ideas immanent in nervous activity</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">S</forename><surname>Mcculloch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Pitts</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The bulletin of mathematical biophysics</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="115" to="133" />
			<date type="published" when="1943" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Human-level control through deep reinforcement learning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Mnih</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Kavukcuoglu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Silver</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">A</forename><surname>Rusu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Veness</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">G</forename><surname>Bellemare</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Graves</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Riedmiller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">K</forename><surname>Fidjeland</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Ostrovski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Petersen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Beattie</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Sadik</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Antonoglou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>King</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Kumaran</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Wierstra</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Legg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Hassabis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nature</title>
		<imprint>
			<biblScope unit="volume">518</biblScope>
			<biblScope unit="issue">7540</biblScope>
			<biblScope unit="page" from="529" to="533" />
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Asynchronous methods for deep reinforcement learning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Mnih</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">P</forename><surname>Badia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Mirza</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Graves</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Lillicrap</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Harley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Silver</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Kavukcuoglu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Machine Learning</title>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Asymmetric least squares estimation and testing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">K</forename><surname>Newey</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">L</forename><surname>Powell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Econometrica: Journal of the Econometric Society</title>
		<imprint>
			<biblScope unit="page" from="819" to="847" />
			<date type="published" when="1987" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">Deep exploration via bootstrapped DQN. CoRR</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Osband</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Blundell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Pritzel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Van Roy</surname></persName>
		</author>
		<idno>abs/1602.04621</idno>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">A stochastic approximation method. The Annals of Mathematical Statistics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Robbins</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Monro</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1951" />
			<biblScope unit="page" from="400" to="407" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Rosenblatt</surname></persName>
		</author>
		<title level="m">Principles of Neurodynamics. Spartan</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1962" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Normalized online learning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Ross</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Mineiro</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Langford</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 29th Conference on Uncertainty in Artificial Intelligence</title>
		<meeting>the 29th Conference on Uncertainty in Artificial Intelligence</meeting>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Learning internal representations by error propagation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">E</forename><surname>Rumelhart</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">E</forename><surname>Hinton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">J</forename><surname>Williams</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Parallel Distributed Processing</title>
		<imprint>
			<publisher>MIT Press</publisher>
			<date type="published" when="1986" />
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="318" to="362" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Prioritized experience replay</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Schaul</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Quan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Antonoglou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Silver</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Learning Representations</title>
		<meeting><address><addrLine>Puerto Rico</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Deep learning in neural networks: An overview</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Schmidhuber</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Neural Networks</title>
		<imprint>
			<biblScope unit="volume">61</biblScope>
			<biblScope unit="page" from="85" to="117" />
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Practical bayesian optimization of machine learning algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Snoek</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Larochelle</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">P</forename><surname>Adams</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in neural information processing systems</title>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="page" from="2951" to="2959" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Lecture 6.5-rmsprop: Divide the gradient by a running average of its recent magnitude</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Tieleman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Hinton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">COURSERA: Neural Networks for Machine Learning</title>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Double Q-learning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Van Hasselt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems</title>
		<imprint>
			<date type="published" when="2010" />
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="page" from="2613" to="2621" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">Insights in Reinforcement Learning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Van Hasselt</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
		<respStmt>
			<orgName>Utrecht University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title level="m" type="main">Deep reinforcement learning with Double Q-learning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Van Hasselt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Guez</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Silver</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2016" />
			<publisher>AAAI</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Dueling network architectures for deep reinforcement learning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Freitas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Schaul</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Hessel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Van Hasselt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Lanctot</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Machine Learning</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">Learning from delayed rewards</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">J C H</forename><surname>Watkins</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1989" />
		</imprint>
		<respStmt>
			<orgName>University of Cambridge England</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
