<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /nfs/home/kabenamualus/Research/task-dataset-metric-extraction/../grobid-0.6.0/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Dictionary Learning for Massive Matrix Factorization Arthur Mensch Ga?l Varoquaux</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2016">2016</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Arthur</forename><forename type="middle">Mensch@m4x</forename><surname>Org</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Parietal team</orgName>
								<orgName type="institution" key="instit2">CEA, Paris-Saclay University. Neurospin</orgName>
								<address>
									<settlement>Gif-sur-Yvette</settlement>
									<region>Inria</region>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Julien</forename><surname>Mairal</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">Thoth team, Inria</orgName>
								<address>
									<settlement>Grenoble</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Julien</forename><surname>Mairal@inria</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">Thoth team, Inria</orgName>
								<address>
									<settlement>Grenoble</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Fr</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">Thoth team, Inria</orgName>
								<address>
									<settlement>Grenoble</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bertrand</forename><surname>Thirion</surname></persName>
							<affiliation key="aff2">
								<orgName type="department">BETRAND.THIRION@INRIA.FR</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gael</forename><forename type="middle">Varoquaux@inria</forename><surname>Fr</surname></persName>
							<affiliation key="aff3">
								<orgName type="department">Parietal team, Inria</orgName>
								<orgName type="institution">CEA</orgName>
								<address>
									<addrLine>Paris-Saclay University. Neurospin</addrLine>
									<settlement>Gif-sur-Yvette</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Dictionary Learning for Massive Matrix Factorization Arthur Mensch Ga?l Varoquaux</title>
					</analytic>
					<monogr>
						<title level="m">Proceedings of the 33 rd International Conference on Machine Learning</title>
						<meeting>the 33 rd International Conference on Machine Learning <address><addrLine>New York, NY, USA</addrLine></address>
						</meeting>
						<imprint>
							<biblScope unit="volume">48</biblScope>
							<date type="published" when="2016">2016</date>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>

		<encodingDesc>
			<appInfo>
				<application version="0.6.0" ident="GROBID-SDO" when="2022-11-12T03:50+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid-sdo"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Sparse matrix factorization is a popular tool to obtain interpretable data decompositions, which are also effective to perform data completion or denoising. Its applicability to large datasets has been addressed with online and randomized methods, that reduce the complexity in one of the matrix dimension, but not in both of them. In this paper, we tackle very large matrices in both dimensions. We propose a new factorization method that scales gracefully to terabyte-scale datasets. Those could not be processed by previous algorithms in a reasonable amount of time. We demonstrate the efficiency of our approach on massive functional Magnetic Resonance Imaging (fMRI) data, and on matrix completion problems for recommender systems, where we obtain significant speed-ups compared to state-of-the art coordinate descent methods.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Matrix factorization is a flexible tool for uncovering latent factors in low-rank or sparse models. For instance, building on low-rank structure, it has proven very powerful for matrix completion, e.g. in recommender systems <ref type="bibr" target="#b19">(Srebro et al., 2004;</ref><ref type="bibr" target="#b5">Cand?s &amp; Recht, 2009</ref>). In signal processing and computer vision, matrix factorization with a sparse regularization is often called dictionary learning and has proven very effective for denoising and visual feature encoding (see <ref type="bibr">Mairal, 2014, for a review)</ref>. It is also flexible enough to accommodate a large set of constraints and regularizations, and has gained significant attention in scientific domains where interpretability is a key aspect, such as ge-Proceedings of the 33 rd International Conference on Machine Learning, New York, NY, USA, 2016. JMLR: W&amp;CP volume 48. Copyright 2016 by the author(s). netics and neuroscience .</p><p>As a widely-used model, the literature of matrix factorization is very rich and two main classes of formulations have emerged. The first one addresses an optimization problem involving a convex penalty, such as the trace or max norms <ref type="bibr" target="#b19">(Srebro et al., 2004)</ref>. These penalties promote lowrank structures, have strong theoretical guarantees <ref type="bibr" target="#b5">(Cand?s &amp; Recht, 2009</ref>), but they do not encourage sparse factors and lack scalability for very-large datasets. For these reasons, our paper is focused on a second type of approach, that relies on nonconvex optimization. Specifically, the motivation of our work originally came from the need to analyze huge-scale fMRI datasets, and the difficulty of current algorithms to process them.</p><p>To gain scalability, stochastic (or online) optimization methods have been developed; unlike classical alternate minimization procedures, they learn matrix decompositions by observing a single matrix column (or row) at each iteration. In other words, they stream data along one matrix dimension. Their cost per iteration is significantly reduced, leading to faster convergence in various practical contexts. More precisely, two approaches have been particularly successful: stochastic gradient descent (see <ref type="bibr" target="#b4">Bottou, 2010)</ref> has been widely used in recommender systems (see <ref type="bibr" target="#b1">Bell &amp; Koren, 2007;</ref><ref type="bibr" target="#b18">Rendle &amp; Schmidt-Thieme, 2008;</ref><ref type="bibr" target="#b17">Rendle, 2010;</ref><ref type="bibr">Blondel et al., 2015, and references therein)</ref>, and stochastic majorization-minimization methods for dictionary learning with sparse and/or structured regularization <ref type="bibr" target="#b13">(Mairal et al., 2010;</ref><ref type="bibr" target="#b11">Mairal, 2013</ref>). Yet, stochastic algorithms for dictionary learning are currently unable to deal efficiently with matrices that are large in both dimensions.</p><p>In a somehow orthogonal way, the growth of dataset size has proven to be manageable by randomized methods, that exploit random projections <ref type="bibr" target="#b10">(Johnson &amp; Lindenstrauss, 1984;</ref><ref type="bibr" target="#b2">Bingham &amp; Mannila, 2001)</ref> to reduce data dimension arXiv:1605.00937v2 [stat.ML] 26 May 2016 without deteriorating signal content. Due to the way they are generated, large-scale datasets generally have an intrinsic dimension that is significantly smaller than their ambient dimension. Biological datasets <ref type="bibr" target="#b14">(McKeown et al., 1998)</ref> and physical acquisitions with an underlying sparse structure enabling compressed sensing <ref type="bibr" target="#b6">(Cand?s &amp; Tao, 2006)</ref> are good examples. In this context, matrix factorization can be performed by using random summaries of coefficients. Recently, those have been used to compute PCA <ref type="bibr" target="#b8">(Halko et al., 2009</ref>), a classical matrix decomposition technique. Yet, using random projections as a pre-processing step is not appealing in our applicative context since the factors learned on reduced data loses interpretability.</p><p>Main contribution. In this paper, we propose a dictionary learning algorithm that (i) scales both in the signal dimension (number of rows) and number of signals (number of columns), (ii) deals with various structured sparse regularization penalties, (iii) handles missing values, and (iv) provides an explicit dictionary with easy interpretation. As such, it is non-trivial extension of the online dictionary learning method of <ref type="bibr" target="#b13">Mairal et al. (2010)</ref>, where, at every iteration, signals are partially observed with a random mask, and with low-complexity update rules that depend on the (small) mask size instead of the signal size.</p><p>To the best of our knowledge, our algorithm is the first that enjoys all aforementioned features; in particular, we are not aware of any other dictionary learning algorithm that is scalable in both matrix dimensions. For instance, <ref type="bibr" target="#b16">Pourkamali-Anaraki et al. (2015)</ref> use random projection with k-SVD, a batch dictionary learning algorithm <ref type="bibr" target="#b0">(Aharon et al., 2006)</ref> that does not scale well in the number of training signals. Online matrix decomposition in the context of missing values was also proposed by <ref type="bibr" target="#b20">Szab? et al. (2011)</ref>, but without scalability in the signal (row) size.</p><p>On a massive fMRI dataset (2TB, n = 2.4?10 6 , p = 2?10 5 ), we were able to learn interpretable dictionaries in about 10 hours on a single workstation, an order of magnitude faster than the online approach of <ref type="bibr" target="#b13">Mairal et al. (2010)</ref>. On collaborative filtering experiments, where sparsity is not needed, our algorithm performs favorably well compared to state-of-the-art coordinate descent methods. In both experiments, benefits for the practitioner were significant.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Background on Dictionary Learning</head><p>In this section, we introduce dictionary learning as a matrix factorization problem, and present stochastic algorithms that observe one column (or a minibatch) at every iteration.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1.">Problem Statement</head><p>The goal of matrix factorization is to decompose a matrix X ? R p?n -typically n signals of dimension p -as a product of two smaller matrices:</p><formula xml:id="formula_0">X ? DA with D ? R p?k , A ? R k?n ,<label>(1)</label></formula><p>with potential sparsity or structure requirements on D and A. In statistical signal applications, this is often a dictionary learning problem, enforcing sparse coefficients A.</p><p>In such a case, we call D the "dictionary" and A the sparse codes. We use this terminology throughout the paper.</p><p>Learning the dictionary is typically performed by minimizing a quadratic data-fitting term, with constraints and/or penalties over the code and the dictionary:</p><formula xml:id="formula_1">min D?C A=[?1,...,?n]?R k?n n i=1 1 2 x i ? D? i 2 2 + ? ?(? i ),<label>(2)</label></formula><p>where C is a convex set of R p?k , and a ? : R p ? R is a penalty over the code, to enforce structure or sparsity. In large n and large p settings, typical in recommender systems, this problem is solved via block coordinate descent, which boils down to alternating least squares if regularizations on D and ? are quadratic <ref type="bibr" target="#b9">(Hastie et al., 2014)</ref>.</p><p>Constraints and penalties. The constraint set C is traditionally a technical constraint ensuring that the coefficients ? do not vanish, making the effect of the penalty ? disappear. However, other constraints can also be used to enforce sparsity or structure on the dictionary (see <ref type="bibr" target="#b24">Varoquaux et al., 2013)</ref>. In our paper,C is the Cartesian product of a 1 or 2 norm ball:</p><formula xml:id="formula_2">C = {D ? R p?k s.t. ?(d j ) ? 1 ?j = 1, . . . , k},<label>(3)</label></formula><p>where D = [d 1 , . . . , d k ] and ? = ? 1 or ? = ? 2 . The choice of ? and ? typically offers some flexibility in the regularization effect that is desired for a specific problem; for instance, classical dictionary learning uses ? = ? 2 and ? = ? 1 , leading to sparse coefficients ?, whereas our experiments on fMRI uses ? = ? 1 and ? = ? 2 2 , leading to sparse dictionary elements d j that can be interpreted as brain activation maps.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2.">Streaming Signals with Online Algorithms</head><p>In stochastic optimization, the number of signals n is assumed to be large (or potentially infinite), and the dictionary D can be written as a solution of</p><formula xml:id="formula_3">min D?C f (D) where f (D) = E x l(x, D) (4) l(x, D) = min ??R k 1 2 x ? D? 2 2 + ? ?(?),</formula><p>where the signals x are assumed to be i.i.d. samples from an unknown probability distribution. Based on this formu-lation, <ref type="bibr" target="#b13">Mairal et al. (2010)</ref> have introduced an online dictionary learning approach that draws a single signal x t at iteration t (or a minibatch), and computes its sparse code ? t using the current dictionary D t?1 according to</p><formula xml:id="formula_4">? t ? argmin ??R k 1 2 x t ? D t?1 ? 2 2 + ? ?(?).<label>(5)</label></formula><p>Then, the dictionary is updated by approximately minimizing the following surrogate function</p><formula xml:id="formula_5">g t (D) = 1 t t i=1 1 2 x i ? D? i 2 2 + ? ?(? i ),<label>(6)</label></formula><p>which involves the sequence of past signals x 1 , . . . , x t and the sparse codes ? 1 , . . . , ? t that were computed in the past iterations of the algorithm. The function g t is called a "surrogate" in the sense that it only approximates the objective f . In fact, it is possible to show that it converges to a locally tight upper-bound of the objective, and that minimizing g t at each iteration asymptotically provides a stationary point of the original optimization problem. The underlying principle is that of majorization-minimization, used in a stochastic fashion <ref type="bibr" target="#b11">(Mairal, 2013)</ref>.</p><p>One key to obtain efficient dictionary updates is the observation that the surrogate g t can be summarized by a few sufficient statistics that are updated at every iteration. In other words, it is possible to describe g t without explicitly storing the past signals x i and codes ? i for i ? t. Indeed, we may define two matrices B t ? R p?k and C t ? R k?k</p><formula xml:id="formula_6">C t = 1 t t i=1 ? i ? i B t = 1 t t i=1 x i ? i ,<label>(7)</label></formula><p>and the surrogate function is then written:</p><formula xml:id="formula_7">g t (D) = 1 2 Tr(D DC t ? D B t ) + ? t t i=1 ?(? i ). (8)</formula><p>The gradient of g t can be computed as</p><formula xml:id="formula_8">? D g t (D) = DC t ? B t .<label>(9)</label></formula><p>Minimization of g t is performed using block coordinate descent on the columns of D. In practice, the following updates are successively performed by cycling over the dictionary elements d j for j = 1, . . . , k</p><formula xml:id="formula_9">d j ? Proj ?(.)?1 d j ? 1 C t [j, j] ? dj g t (D) ,<label>(10)</label></formula><p>where Proj denotes the Euclidean projection over the constraint norm constraint ?. It can be shown that this update corresponds to minimizing g t with respect to d j when fixing the other dictionary elements (see <ref type="bibr" target="#b13">Mairal et al., 2010)</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.3.">Handling Missing Values</head><p>Factorization of matrices with missing value have raised a significant interest in signal processing and machine learning, especially as a solution for recommender systems. In the context of dictionary learning, a similar effort has been made by <ref type="bibr" target="#b20">Szab? et al. (2011)</ref> to adapt the framework to missing values. Formally, a mask M, represented as a binary diagonal matrix in {0, 1} p?p , is associated with every signal x, such that the algorithm can only observe the product M t x t at iteration t instead of a full signal x t . In this setting, we naturally derive the following objective</p><formula xml:id="formula_10">min D?C f (D) where f (D) = E x,M l(x, M, D) (11) l(x, M, D) = min ??R k p 2Tr M M(x ? D?) 2 2 + ??(?),</formula><p>where the pairs (x, M) are drawn from the (unknown) data distribution. Adapting the online algorithm of <ref type="bibr" target="#b13">Mairal et al. (2010)</ref> would consist of drawing a sequence of pairs (x t , M t ), and building the surrogate</p><formula xml:id="formula_11">g t (D) = 1 t t i=1 p 2s i M i (x i ? D? i ) 2 2 + ? ?(? i ),<label>(12)</label></formula><p>where s i = Tr M i is the size of the mask and</p><formula xml:id="formula_12">? i ? argmin ??R k p 2s i M i (x i ? D i?1 ?) 2 2 + ? ?(?). (13)</formula><p>Unfortunately, this surrogate cannot be summarized by a few sufficient statistics due to the masks M i : some approximations are required. This is the approach chosen by Szab? et al. <ref type="bibr">(2011)</ref>. Nevertheless, the complexity of their update rules is linear in the full signal size p, which makes them unadapted to the large-p regime that we consider.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Dictionary Learning for Massive Data</head><p>Using the formalism exposed above, we now consider the problem of factorizing a large matrix X in R p?n into two factors D in R p?k and A in R k?n with the following setting: both n and p are large (greater than 100 000 up to several millions), whereas k is reasonable (smaller than 1 000 and often near 100), which is not the standard dictionarylearning setting; some entries of X may be missing. Our objective is to recover a good dictionary D taking into account appropriate regularization.</p><p>To achieve our goal, we propose to use an objective akin to (11), where the masks are now random variables independant from the samples. In other words, we want to combine ideas of online dictionary learning with random subsampling, in a principled manner. This leads us to consider an infinite stream of samples (M t x t ) t?0 , where the signals x t are i.i.d. samples from the data distribution -that is, a column of X selected at random -and M t "selects" a random subset of observed entries in X. This setting can accommodate missing entries, never selected by the mask, and only requires loading a subset of x t at each iteration.</p><p>The main justification for choosing this objective function is that in the large sample regime p k that we consider, computing the code ? i using only a random subset of the data x t according to <ref type="formula" target="#formula_0">(13)</ref> is a good approximation of the code that may be computed with the full vector x t in (5). This of course requires choosing a mask that is large enough; in the fMRI dataset, a subsampling factor of about r = 10 -that is only 10% of the entries of x t are observed -resulted in a similar 10? speed-up (see experimental section) to achieve the same accuracy as the original approach without subsampling. This point of view also justifies the natural scaling factor p Tr M introduced in (11). An efficient algorithm must address two challenges: (i) performing dictionary updates that do not depend on p but only on the mask size; (ii) finding an approximate surrogate function that can be summarized by a few sufficient statistics. We provide a solution to these two issues in the next subsections and present the method in Algorithm 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.">Approximate Surrogate Function</head><p>To approximate the surrogate (8) from ? t computed in (13), we consider h t defined by</p><formula xml:id="formula_13">h t (D) = 1 2 Tr(D DC t ?D B t )+ ? t t i=1 s i p ?(? i ) (14)</formula><p>with the same matrix C t as in <ref type="formula">(8)</ref>, which is updated as</p><formula xml:id="formula_14">C t ? 1 ? 1 t C t?1 + 1 t ? t ? t ,<label>(15)</label></formula><p>and to replace B t in (8) by the matrix</p><formula xml:id="formula_15">B t = t i=1 M i ?1 t i=1 M i x i ? i ,<label>(16)</label></formula><p>which is the same as <ref type="formula" target="#formula_6">(7)</ref> when</p><formula xml:id="formula_16">M i = I. Since M i is a diagonal matrix, t i=1</formula><p>M i is also diagonal and simply "counts" how many times a row has been seen by the algorithm. B t thus behaves like E x [x?(x, D t ) ] for large t, as in the fully-observed algorithm. By design, only rows of B t selected by the mask differ from B t?1 . The update can therefore be achieved in O(s i k) operations:</p><formula xml:id="formula_17">B t = B t?1 + t i=1 M i ?1 M t x t ? t ? M t B t?1 (17)</formula><p>This only requires keeping in memory the diagonal matrix t i=1 M i , and updating the rows of B t?1 selected by the mask. All operations only depend on the mask size s i instead of the signal size p.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.">Efficient Dictionary Update Rules</head><p>With a surrogate function in hand, we now describe how to update the codes ? and the dictionary D when only partial access to data is possible. The complexity for computing the sparse codes ? t is obviously independent from p since (13) consists in solving a reduced penalized linear regression of M t x t in R st on M t D t?1 in R st?k . Thus, we focus here on dictionary update rules.</p><p>The naive dictionary update (18) has complexity O(kp) due to the matrix-vector multiplication for computing ? dj g t (D). Reducing the single iteration complexity of a factor p st requires reducing the dimensionality of the dictionary update phase. We propose two strategies to achieve that, both using block coordinate descent, by considering</p><formula xml:id="formula_18">d j ? Proj ?(.)?1 d j ? 1 C t [j, j] M t ? dj h t (D) , (18) where M t ? dj h t (D)</formula><p>is the partial derivative of h t with respect to the j-th column and rows selected by the mask.</p><p>Gradient step. The update (18) represents a classical block coordinate descent step involving particular blocks. Following <ref type="bibr" target="#b13">Mairal et al. (2010)</ref>, we perform one cycle over the columns warm-started on D t?1 . Formally, the gradient step without projection for the j-th component consists of updating the vector d j</p><formula xml:id="formula_19">d j ? d j ? 1 C t [j, j] M t ? dj h t (D) = d j ? 1 C t [j, j] (M t Dc t j ? M t b t j ),<label>(19)</label></formula><p>where c t j , b t j are the j-th columns of C t , B t respectively. The update has complexity O(ks t ) since it only involves s t rows of D and only s t entries of d j have changed.</p><p>Projection step. Block coordinate descent algorithms require orthogonal projections onto the constraint set C. In our case, this amounts to the projection step on the unit ball corresponding to the norm ? in (18). The complexity of such a projection is usually O(p) both for 2 and 1 -norms (see <ref type="bibr" target="#b7">Duchi et al., 2008)</ref>. We consider here two strategies.</p><p>Exact lazy projection for 2 . When ? = 2 , it is possible to perform the projection implicitly with complexity O(s t ). The computational trick is to notice that the projection amounts to a simple rescaling operation</p><formula xml:id="formula_20">d j ? d j max(1, d j 2 ) ,<label>(20)</label></formula><p>which may have low complexity if the dictionary elements d j are stored in memory as a product</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Procedure 1 Dictionary Learning for Massive Data</head><p>Input: Initial dictionary: D 0 ? R p?k , tolerance:</p><formula xml:id="formula_21">C 0 ? 0 ? R k?k ; B 0 ? 0 ? R p?k ; E 0 ? 0 ? R p?p (diagonal); t ? 1; repeat Draw a pair (x t , M t ); ? t ?argmin ? 1 2 M t (x t ?D t?1 ?) 2 2 +? Tr Mt p ?(?); E t ? E t + M t ; A t ? (1 ? 1 t )A t?1 + 1 t ? t ? t ; B t ? B t?1 + E ?1 t (M t x t ? t ? M t B t?1 ); D t ? dictionary_update(B t , C t , D t?1 , M t ); until | ht?1(Dt?1) ht(Dt) ? 1| &lt; Output: D d j =f j / max(1, l j )</formula><p>where f j is in R p and l j is a rescaling coefficient such that l j = f j 2 . We code the gradient step (19) followed by 2 -ball projection by the updates</p><formula xml:id="formula_22">n j ? M j f j 2 2 f j ? f j ? max(1, l j ) C t [j, j] (M t Dc t j ? M t b t j ) l j ? l 2 j ? n j + M j f j 2 2 (21)</formula><p>Note that the update of f j corresponds to the gradient step without projection <ref type="formula" target="#formula_0">(19)</ref> which costs O(ks t ), whereas the norm of f j is updated in O(s t ) operations. The computational complexity is thus independent of p and the only price to pay is to rescale the dictionary elements on the fly, each time we need access to them.</p><p>Exact lazy projection for 1 . The case of 1 is slightly different but can be handled in a similar manner, by storing an additional scalar l j for each dictionary element d j . More precisely, we store a vector f j in R p such that d j = Proj ?(.)?1 [f j ], and a classical result (see <ref type="bibr" target="#b7">Duchi et al., 2008)</ref> states that there exists a scalar l j such that</p><formula xml:id="formula_23">d j = S lj [f j ], S ? (u) = sign(u). max(|u| ? ?, 0) (22)</formula><p>where S ? is the soft-thresholding operator, applied elementwise to the entries of f j . Similar to the case 2 , the "lazy" projection consists of tracking the coefficient l j for each dictionary element and updating it after each gradient step, which only involves s t coefficients. For such sparse updates followed by a projection onto the 1 -ball, <ref type="bibr" target="#b7">Duchi et al. (2008)</ref> proposed an algorithm to find the threshold l j in O(s t log(p)) operations. The lazy algorithm involves using particular data structures such as red-black trees and is not easy to implement; this motivated us to investigate another simple heuristic that also performs well in practice.</p><p>Approximate low-dimension projection. The heuristic consists in performing the projection by forcing the </p><formula xml:id="formula_24">on T t,j = {d s.t. ?(d) ? 1, (I ? M t )d = (I ? M t )d t?1 j },</formula><p>which is a subset of the original constraint set ?(?) ? 1.</p><p>All the computations require only 4 matrices kept in memory B, C, D, E with additional F, l matrices and vectors for the exact projection case, as summarized in Alg. 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.">Discussion</head><p>Relation to classical matrix completion formulation. Our model is related to the classical 2 -penalized matrix completion model (e.g. <ref type="bibr" target="#b1">Bell &amp; Koren, 2007)</ref> </p><formula xml:id="formula_25">we rewrite n i=1 M i (x i ? D ? i ) 2 2 + ?s i ? i 2 2 + ? ( n i=1 M i ) 1 2 D 2 2</formula><p>(23) With quadratic regularization on D and A -that is, using ? = . 2 2 and ? = . 2 -(11) only differs in that it uses a penalization on D instead of a constraint. <ref type="bibr" target="#b19">Srebro et al. (2004)</ref> introduced the trace-norm regularization to solve a convex problem equivalent to (23). The major difference is that we adopt a non-convex optimization strategy, thus losing the benefits of convexity, but gaining on the other hand the possibility of using stochastic optimization.</p><p>Practical considerations. Our algorithm can be slightly modified to use weights w t that differ from 1 t for B and C, as advocated by <ref type="bibr" target="#b11">Mairal (2013)</ref>. It also proves beneficial to perform code computation on mini-batches of masked samples. Update of the dictionary is performed on the rows that are seen at least once in the masks (M t ) batch .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Experiments</head><p>The proposed algorithm was designed to handle massive datasets: masking data enables streaming a sequence (M t x t ) t instead of (x t ) t , reducing single-iteration computational complexity and IO stress of a factor r = p E(Tr M) , while accessing an accurate description of the data. Hence,  <ref type="figure">Figure 1</ref>. Acceleration of sparse matrix factorization with random subsampling on the HCP dataset (2TB). Reducing streamed data with stochastic masks permits 10? speed-ups without deteriorating goodness of fit on test data nor alterating sparsity of final dictionary.</p><p>we analyze in detail how our algorithm improves performance for sparse decomposition of fMRI datasets. Moreover, as it relies on data masks, our algorithm is well suited for matrix completion, to reconstruct a data stream (x t ) t from the masked stream (M t x t ) t . We demonstrate the accuracy of our algorithm on explicit recommender systems and show considerable computational speed-ups compared to an efficient coordinate-descent based algorithm.</p><p>We use scikit-learn  in experiments, and have released a python package 1 for reproducibility.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">Sparse Matrix Factorization for fMRI</head><p>Context. Matrix factorization has long been used on functional Magnetic Resonance Imaging <ref type="bibr" target="#b14">(McKeown et al., 1998)</ref>. Data are temporal series of 3D images of brain activity, to decompose in spatial modes capturing regions that activate together. The matrices to decompose are dense and heavily redundant, both spatially and temporally: close voxels and successive records are correlated. Data can be huge: we use the whole HCP dataset <ref type="bibr" target="#b22">(Van Essen et al., 2013)</ref>, with n = 2.4 ? 10 6 (2000 records, 1 200 time points) and p = 2 ? 10 5 , totaling 2 TB of dense data.</p><p>Interesting dictionaries for neuroimaging capture spatiallylocalized components, with a few brain regions. This can be obtained by enforcing sparsity on the dictionary: in our formalism, this is achieved with 1 -ball projection for D.</p><p>We set C = B k 1 , and ? = ? 2 2 . Historically, such decomposition have been obtained with the classical dictionary learning objective on transposed data <ref type="bibr" target="#b24">(Varoquaux et al., 2013)</ref>: the code A holds sparse spatial maps and voxel time-series are streamed. However, given the size of n for our dataset, this method is not usable in practice.</p><p>Handling such volume of data sets new constraints. First, efficient disk access becomes critical for speed. In our case, learning the dictionary is done by accessing the data in row batches, which is coherent with fMRI data storage: no time is lost seeking data on disk. Second, reducing IO load on  the storage is also crucial, as it lifts bottlenecks that appear when many processes access the same storage at the same time, e.g. during cross-validation on ? within a supervised pipeline. Our approach reduces disk usage by a factor r.</p><p>Finally, parallel methods based on message passing, such as asynchronous coordinate descent, are unlikely to be efficient given the network / disk bandwidth that each process requires to load data. This makes it crucial to design efficient sequential algorithms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Experiment</head><p>We quantify the effect of random subsampling for sparse matrix factorization, in term of speed and accuracy. A natural performance evaluation is to measure an empirical estimate of the loss l defined in Eq. 4 from unseen data, to rule out any overfitting effect. For this, we evaluate l on a test set (x i ) i&lt;N . Pratically, we sample (x t ) t in a pseudo-random manner: we randomly select a record, from where we select a random batch of rows x t -we use a batch size of 40, empirically found to be efficient. We load M t x t in memory and perform an iteration of the algorithm. The mask sequence is sampled by breaking random permutation vectors into chunks of size p/r.</p><p>Results <ref type="figure">Fig. 1(a)</ref> compares our algorithm with subsampling ratios r in {4, 8, 12} to vanilla online dictionary learning algorithm (r = 1), plotting trajectories of the test objective against real CPU time. There is no obvious choice of ? due to the unsupervised nature of the problem: Middle: the reference algorithm on a twentieth of the dataset. Right: the proposed algorithm with a similar run time: half the dataset and r = 9. Compared to a full run of the baseline algorithm, the figure explore two possible strategies to decrease computation time: processing less data (middle), or our approach (right). Our approach achieves a result closer to the gold standard in a given time budget.</p><p>we use 10 ?3 and 10 ?4 , that bounds the range of ? providing interpretable dictionaries.</p><p>First, we observe the convergence of the objective function for all tested r, providing evidence that the approximations made in the derivation of update rules does not break convergence for such r. <ref type="figure">Fig. 1(b)</ref> shows the validity of the obtained dictionary relative to the reference output: both objective function and 1 / 2 ratio -the relevant value to measure sparsity in our setting -are comparable to the baseline values, up to r = 8. For high regularization and r = 12, our algorithm tends to yield somewhat sparser solutions (5% lower 1 / 2 ) than the original algorithm, due to the approximate 1 -projection we perform. Obtained maps still proves as interpretable as with baseline algorithm.</p><p>Our algorithm proves much faster than the original one in finding a good dictionary. Single iteration time is indeed reduced by a factor r, which enables our algorithm to go over a single epoch r times faster than the vanilla algorithm and capture the variability of the dataset earlier. To quantify speed-ups, we plot the empirical objective value of D against the number of observed records in <ref type="figure" target="#fig_0">Fig. 3</ref>. For r ? 12, increasing r little reduces convergence speed per epoch: random subsampling does not shrink much the quantity of information learned at each iteration.</p><p>This brings a near ?r speed-up factor: for high and low regularization respectively, our algorithm converges in 3 and 10 hours with subsampling factor r = 12, whereas the vanilla online algorithm requires about 30 and 100 hours.</p><p>Qualitatively, <ref type="figure" target="#fig_1">Fig. 2</ref> shows that with the same time budget, the proposed reduction approach with r = 12 on half of the data gives better results than processing a small fraction of the data without reduction: segmented regions are less noisy and closer to processing the full data.</p><p>These results advocates the use of a subsampling rate of r ? 10 in this setting. When sparse matrix decomposition is part of a supervised pipeline with scoring capabilities, it is possible to find r efficiently: start by setting it derea-sonably high and decrease it geometrically until supervised performance (e.g. in classification) ceases to improve.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.">Collaborative Filtering with Missing Data</head><p>We validate the performance of the proposed algorithm on recommender systems for explicit feedback, a well-studied matrix completion problem. We evaluate the scalability of our method on datasets of different dimension: MovieLens 1M, MovieLens 10M, and 140M ratings Netflix dataset.</p><p>We compare our algorithm to a coordinate-descent based method <ref type="bibr" target="#b25">(Yu et al., 2012)</ref>, that provides state-of-the art convergence time performance on our largest dataset. Although stochastic gradient descent methods for matrix factorization can provide slightly better single-run performance <ref type="bibr" target="#b21">(Tak?cs et al., 2009)</ref>, these are notoriously hard to tune and require a precise grid search to uncover a working schedule of learning rates. In contrast, coordinate descent methods do not require any hyper-parameter setting and are therefore more efficient in practice. We benchmarked various recommender-system codes (MyMediaLite, LibFM, SoftImpute, spira 2 ), and chose coordinate descent algorithm from spira as it was by far the fastest.</p><p>Completion from dictionary D t . We stream user ratings to our algorithm: p is the number of movies and n is the number of users. As n p on Netflix dataset, this increases the benefit of using an online method. We have observed comparable prediction performance streaming item ratings. Past the first epoch, at iteration t, every column i of X can be predicted by the last code ? l(i,t) that was computed from this column at iteration l(i, t). At iteration t, for all i &lt; [n], x pred i = D? l(i,t) . Prediction thus only requires an additional matrix computation after the factorization.</p><p>Preprocessing. Successful prediction should take into account user and item biases. We compute these biases  <ref type="figure">Figure 4</ref>. Learning speed for collaborative filtering for datasets of different size: the larger the dataset, the greater our speed-up. . We use them to center the samples (x t ) t that are streamed to the algorithm, and to perform final prediction.</p><p>Tools and experiments. Both baseline and proposed algorithm are implemented in a computationally optimal way, enabling fair comparison based on CPU time. Benchmarks were run using a single 2.7 GHz Xeon CPU, with a 30 components dictionary. For Movielens datasets, we use a random 25% of data for test and the rest for training. We average results on five train/test split for MovieLens in <ref type="table" target="#tab_4">Table 1</ref>. On Netflix, the probe dataset is used for testing. Regularization parameter ? is set by cross-validation on the training set: the training data is split 3 times, keeping 33% of Movielens datasets for evaluation and 1% for Netflix, and grid search is performed on 15 values of ? between 10 ?2 and 10. We assess the quality of obtained decomposition by measuring the root mean square error (RMSE) between prediction on the test set and ground truth. We use mini-batches of size n 100 .</p><p>Results. We report the evolution of test RMSE along time in <ref type="figure">Fig. 4</ref>, along with its value at convergence and numerical convergence time in <ref type="table" target="#tab_4">Table 1</ref>. Benchmarks are performed on the final run, after selection of parameter ?.</p><p>The two variants of the proposed method converge toward a solution that is at least as good as that of coordinate descent, and slightly better on Movielens 10M and Netflix. Our algorithm brings a substantial performance improvement on medium and large scale datasets. On Netflix, con-vergence is almost reached in 4 minutes (score under 0.1% deviation from final RMSE), which makes our method 6.8 times faster than coordinate descent. Moreover, the relative performance of our algorithm increases with dataset size. Indeed, as datasets grow, less epochs are needed for our algorithm to reach convergence <ref type="figure">(Fig. 4)</ref>. This is a significant advantage over coordinate descent, that requires a stable number of cycle on coordinates to reach convergence, regardless of dataset size. The algorithm with partial projection performs slightly better. This can be explained by the extra regularization on (D t ) t brought by this heuristic.</p><p>Learning weights. Unlike SGD, and similar to the vanilla online dictionary learning algorithm, our method does not critically suffer from hyper-parameter tuning. We tried weights w t = 1 t ? as described in Sec. 2.3, and observed that a range of ? yields fast convergence. Theoretically, <ref type="bibr" target="#b11">Mairal (2013)</ref> shows that stochastic majorizationminimization converges when ? ? (.75, 1]. We verify this empirically, and obtain optimal convergence speed for ? ? [.85, 0.95]. <ref type="figure">(Fig. 5)</ref>. We report results for ? = 0.9.  <ref type="figure">Figure 5</ref>. Learning weights: on two different datasets, optimal convergence is obtained for ? ? [.85, .95], predicted by theory.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Conclusion</head><p>Whether it is sensor data, as fMRI, or e-commerce databases, sample sizes and number of features are rapidly growing, rendering current matrix factorization approaches intractable. We have introduced a online algorithm that leverages random feature subsampling, giving up to 8-fold speed and memory gains on large data. Datasets are getting bigger, and they often come with more redundancies. Such approaches blending online and randomized methods will</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 3 .</head><label>3</label><figDesc>Evolution of objective function with epochs for three reduction factors. Learning speed per epoch is little reduced by stochastic subsampling, despite the speed-up factor it provides.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 .</head><label>2</label><figDesc>Brain atlases: outlines of each map at half the maximum value (? = 10 ?4 ). Left: the reference algorithm on the full dataset.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Procedure 2 Dictionary UpdateInput: B, C, D, M for j ? 1, . . . , k do d j ? d j ? 1 C[j,j] (MDc j ? Mb j ); if approximate projection then v j ? Proj Tj [Md j ], (see main text for the definition of T j ); d j ? d j + Mv j ? Md j ; else if exact (lazy) projection then or d j ? Proj ?(.)?1 [d j ];</figDesc><table><row><cell>end if end for</cell></row><row><cell>coefficients outside the mask not to change. This re-sults in the orthogonal projection of each d j</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 1 .</head><label>1</label><figDesc>Comparison of performance and convergence time</figDesc><table><row><cell cols="5">for online masked matrix factorization and coordinate descent</cell></row><row><cell cols="5">method. Convergence time: score is under 0.1% deviation from</cell></row><row><cell cols="5">final root mean squared error on test set -5 runs average. CD:</cell></row><row><cell cols="5">coordinate descent; MODL: masked online dictionary learning.</cell></row><row><cell>Dataset</cell><cell cols="2">Test RMSE</cell><cell cols="2">Convergence time Speed</cell></row><row><cell></cell><cell>CD</cell><cell cols="2">MODL CD</cell><cell>MODL</cell><cell>-up</cell></row><row><cell cols="5">ML 1M ML 10M NF (140M) 0.938 0.934 1714 s 256 s 0.872 0.866 6 s 8 s 0.802 0.799 223 s 60 s</cell><cell>?0.75 ?3.7 ?6.8</cell></row><row><cell cols="5">on train data following Hastie et al. (2014) (alternated de-biasing)</cell></row></table><note></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2">https://github.com/mblondel/spira</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>The research leading to these results was supported by the ANR (MACARON project, ANR-14-CE23-0003-01 -NiConnect project, ANR-11-BINF-0004NiConnect) and has received funding from the European Union Seventh Framework Programme (FP7/2007(FP7/ -2013 under grant agreement no. 604102 (HBP).</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">An algorithm for designing overcomplete dictionaries for sparse representation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michal</forename><surname>Aharon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Elad</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alfred</forename><surname>Bruckstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Signal Processing</title>
		<imprint>
			<biblScope unit="volume">54</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="4311" to="4322" />
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Lessons from the Netflix prize challenge</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robert</forename><forename type="middle">M</forename><surname>Bell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yehuda</forename><surname>Koren</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGKDD Explorations Newsletter</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="75" to="79" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Random projection in dimensionality reduction: applications to image and text data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ella</forename><surname>Bingham</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Heikki</forename><surname>Mannila</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM SIGKDD International Conference on Knowledge Discovery and Data Mining</title>
		<meeting>ACM SIGKDD International Conference on Knowledge Discovery and Data Mining</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2001" />
			<biblScope unit="page" from="245" to="250" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Convex factorization machines</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Blondel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Mathieu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Akinori</forename><surname>Fujino</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Naonori</forename><surname>Ueda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Machine Learning and Knowledge Discovery in Databases</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2015" />
			<biblScope unit="page" from="19" to="35" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Large-scale machine learning with stochastic gradient descent</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L?on</forename><surname>Bottou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of COMPSTAT</title>
		<meeting>COMPSTAT</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010" />
			<biblScope unit="page" from="177" to="186" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Exact matrix completion via convex optimization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Emmanuel</forename><forename type="middle">J</forename><surname>Cand?s</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Benjamin</forename><surname>Recht</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Foundations of Computational Mathematics</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="717" to="772" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Near-optimal signal recovery from random projections: Universal encoding strategies? Information Theory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Emmanuel</forename><forename type="middle">J</forename><surname>Cand?s</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Terence</forename><surname>Tao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on</title>
		<imprint>
			<biblScope unit="volume">52</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="5406" to="5425" />
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Efficient projections onto the l 1-ball for learning in high dimensions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><surname>Duchi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Shalev-Shwartz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Shai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yoram</forename><surname>Singer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tushar</forename><surname>Chandra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Machine Learning</title>
		<meeting>the International Conference on Machine Learning</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2008" />
			<biblScope unit="page" from="272" to="279" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Finding structure with randomness: Probabilistic algorithms for constructing approximate matrix decompositions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nathan</forename><surname>Halko</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Martinsson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tropp</forename><surname>Per-Gunnar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joel</forename><forename type="middle">A</forename></persName>
		</author>
		<idno type="arXiv">arXiv:0909.4061</idno>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Matrix completion and low-rank SVD via fast alternating least squares</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Trevor</forename><surname>Hastie</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Mazumder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Rahul</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jason</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Reza</forename><surname>Zadeh</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1410.2596</idno>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Extensions of Lipschitz mappings into a Hilbert space</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">William</forename><forename type="middle">B</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joram</forename><surname>Lindenstrauss</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Contemporary mathematics</title>
		<imprint>
			<date type="published" when="1984" />
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page">1</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Stochastic majorization-minimization algorithms for large-scale optimization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Julien</forename><surname>Mairal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems</title>
		<imprint>
			<date type="published" when="2013" />
			<biblScope unit="page" from="2283" to="2291" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Sparse Modeling for Image and Vision Processing. Foundations and Trends in Computer Graphics and Vision</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Julien</forename><surname>Mairal</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2014" />
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="85" to="283" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Online learning for matrix factorization and sparse coding</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Julien</forename><surname>Mairal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Bach</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Francis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jean</forename><surname>Ponce</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Guillermo</forename><surname>Sapiro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The Journal of Machine Learning Research</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="19" to="60" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Analysis of fMRI Data by Blind Separation into Independent Spatial Components</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">J</forename><surname>Mckeown</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Makeig</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">G</forename><surname>Brown</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">P</forename><surname>Jung</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">S</forename><surname>Kindermann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">J</forename><surname>Bell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">J</forename><surname>Sejnowski</surname></persName>
		</author>
		<idno>1065-9471</idno>
	</analytic>
	<monogr>
		<title level="j">Human Brain Mapping</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="160" to="188" />
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Scikit-learn: machine learning in Python</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fabian</forename><surname>Pedregosa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Varoquaux</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Ga?l</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alexandre</forename><surname>Gramfort</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Michel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Vincent</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Thirion</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Bertrand</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Olivier</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Blondel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Mathieu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Prettenhofer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Peter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ron</forename><surname>Weiss</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Dubourg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Vincent</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jake</forename><surname>Vanderplas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alexandre</forename><surname>Passos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Cournapeau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>David</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Brucher</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Matthieu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Matthieu</forename><surname>Perrot</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">?douard</forename><surname>Duchesnay</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Machine Learning Research</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="2825" to="2830" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Efficient dictionary learning via very sparse random projections</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Pourkamali-Anaraki</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Farhad</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stephen</forename><surname>Becker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Hughes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Shannon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE International Conference on Sampling Theory and Applications</title>
		<meeting>the IEEE International Conference on Sampling Theory and Applications</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2015" />
			<biblScope unit="page" from="478" to="482" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Factorization machines</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Steffen</forename><surname>Rendle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE International Conference on Data Mining</title>
		<meeting>the IEEE International Conference on Data Mining</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2010" />
			<biblScope unit="page" from="995" to="1000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Onlineupdating regularized kernel matrix factorization models for large-scale recommender systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Steffen</forename><surname>Rendle</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lars</forename><surname>Schmidt-Thieme</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM Conference on Recommender systems</title>
		<meeting>the ACM Conference on Recommender systems</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2008" />
			<biblScope unit="page" from="251" to="258" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Maximum-margin matrix factorization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nathan</forename><surname>Srebro</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jason</forename><surname>Rennie</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tommi</forename><forename type="middle">S</forename><surname>Jaakkola</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems</title>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page" from="1329" to="1336" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Online group-structured dictionary learning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zolt?n</forename><surname>Szab?</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Barnab?s</forename><surname>P?czos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andr?s</forename><surname>Lorincz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition</title>
		<meeting>the IEEE Conference on Computer Vision and Pattern Recognition</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2011" />
			<biblScope unit="page" from="2865" to="2872" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Scalable collaborative filtering approaches for large recommender systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G?bor</forename><surname>Tak?cs</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Pil?szy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Istv?n</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Botty?n</forename><surname>N?meth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Domonkos</forename><surname>Tikk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The Journal of Machine Learning Research</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="623" to="656" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">The WU-Minn Human Connectome Project: An overview</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Van Essen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>David</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Smith</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Stephen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Deanna</forename><forename type="middle">M</forename><surname>Barch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Timothy</forename><forename type="middle">E J</forename><surname>Behrens</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Essa</forename><surname>Yacoub</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kamil</forename><surname>Ugurbil</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">NeuroImage</title>
		<imprint>
			<biblScope unit="volume">80</biblScope>
			<biblScope unit="page" from="62" to="79" />
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Multi-subject dictionary learning to segment an atlas of brain spontaneous activity</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Varoquaux</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Ga?l</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alexandre</forename><surname>Gramfort</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Pedregosa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Fabian</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vincent</forename><surname>Michel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bertrand</forename><surname>Thirion</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Information Processing in Medical Imaging Conference</title>
		<meeting>the Information Processing in Medical Imaging Conference</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011" />
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="562" to="573" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Cohort-level brain mapping: learning cognitive atoms to single out specialized regions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Varoquaux</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Ga?l</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Schwartz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Yannick</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Philippe</forename><surname>Pinel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bertrand</forename><surname>Thirion</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Information Processing in Medical Imaging Conference</title>
		<meeting>the Information Processing in Medical Imaging Conference</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2013" />
			<biblScope unit="page" from="438" to="449" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Scalable coordinate descent approaches to parallel matrix factorization for recommender systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Yu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Hsiang-Fu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Hsieh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Cho-Jui</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Inderjit</forename><surname>Dhillon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Data Mining</title>
		<meeting>the International Conference on Data Mining</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2012" />
			<biblScope unit="page" from="765" to="774" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
