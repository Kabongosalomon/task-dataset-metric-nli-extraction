<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /nfs/home/kabenamualus/Research/task-dataset-metric-extraction/../grobid-0.6.0/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Benchmarking Graph Neural Networks Benchmarking Graph Neural Networks</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vijay</forename><forename type="middle">Prakash</forename><surname>Dwivedi</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Nanyang Technological University</orgName>
								<address>
									<settlement>Singapore</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chaitanya</forename><forename type="middle">K</forename><surname>Joshi</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">University of Cambridge</orgName>
								<address>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Anh</forename><forename type="middle">Tuan</forename><surname>Luu</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Nanyang Technological University</orgName>
								<address>
									<settlement>Singapore</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Laurent</surname></persName>
							<email>tlaurent@lmu.edu</email>
							<affiliation key="aff2">
								<orgName type="institution">Loyola Marymount University</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yoshua</forename><surname>Bengio</surname></persName>
							<email>yoshua.bengio@mila.quebec</email>
							<affiliation key="aff3">
								<orgName type="institution">University of Montr?al</orgName>
								<address>
									<settlement>Mila</settlement>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xavier</forename><surname>Bresson</surname></persName>
							<email>xavier@nus.edu.sg</email>
							<affiliation key="aff4">
								<orgName type="institution">National University of Singapore</orgName>
								<address>
									<country key="SG">Singapore</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Benchmarking Graph Neural Networks Benchmarking Graph Neural Networks</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>

		<encodingDesc>
			<appInfo>
				<application version="0.6.0" ident="GROBID-SDO" when="2022-11-12T09:42+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid-sdo"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Graph Neural Networks</term>
					<term>Benchmarking</term>
					<term>GitHub</term>
					<term>Graph Datasets</term>
					<term>Exploration Tool</term>
					<term>Positional Encodings</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>In the last few years, graph neural networks (GNNs) have become the standard toolkit for analyzing and learning from data on graphs. This emerging field has witnessed an extensive growth of promising techniques that have been applied with success to computer science, mathematics, biology, physics and chemistry. But for any successful field to become mainstream and reliable, benchmarks must be developed to quantify progress. This led us in March 2020 to release a benchmark framework that i) comprises of a diverse collection of mathematical and real-world graphs, ii) enables fair model comparison with the same parameter budget to identify key architectures, iii) has an open-source, easy-to-use and reproducible code infrastructure, and iv) is flexible for researchers to experiment with new theoretical ideas. As of May 2022, the GitHub repository 1 has reached 1,800 stars and 339 forks, which demonstrates the utility of the proposed open-source framework through the wide usage by the GNN community. In this paper, we present an updated version of our benchmark with a concise presentation of the aforementioned framework characteristics, an additional medium-sized molecular dataset AQSOL, similar to the popular ZINC, but with a real-world measured chemical target, and discuss how this framework can be leveraged to explore new GNN designs and insights. As a proof of value of our benchmark, we study the case of graph positional encoding (PE) in GNNs, which was introduced with this benchmark and has since spurred interest of exploring more powerful PE for Transformers and GNNs in a robust experimental setting.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Graph neural networks (GNNs) have benefitted from a great interest recently with numerous methods being developed for diverse domains including chemistry <ref type="bibr">(Duvenaud et al., 2015;</ref><ref type="bibr">Gilmer et al., 2017)</ref>, physics <ref type="bibr">(Cranmer et al., 2019;</ref><ref type="bibr">Sanchez-Gonzalez et al., 2020)</ref>, social sciences <ref type="bibr">(Kipf and Welling, 2017;</ref><ref type="bibr" target="#b5">Monti et al., 2019)</ref>, transportation <ref type="bibr">(Derrow-Pinion et al., 2021)</ref>, knowledge graphs <ref type="bibr">(Schlichtkrull et al., 2018;</ref><ref type="bibr">Chami et al., 2020)</ref>, recommendation <ref type="bibr" target="#b4">(Monti et al., 2017b;</ref><ref type="bibr" target="#b24">Ying et al., 2018)</ref>, and neuroscience <ref type="bibr">(Griffa et al., 2017)</ref>  <ref type="figure">Figure 1</ref>: Overview sketch of the proposed GNN benchmarking framework with different modular components. This benchmark is built upon DGL <ref type="bibr" target="#b17">(Wang et al., 2019)</ref> and PyTorch <ref type="bibr" target="#b9">(Paszke et al., 2019)</ref>. and theoretically expressive GNN architectures is a key concern towards practical applications and real-world adoption of graph machine learning. However, tracking progress is often challenging in the absence of a community-standard benchmark as models that are evaluated on traditionally-used datasets with inconsistent experimental comparisons make it difficult to differentiate complex, simple and graph-agnostic architectures <ref type="bibr">(Hoang and Maehara, 2019;</ref><ref type="bibr">Chen et al., 2019a;</ref><ref type="bibr">Errica et al., 2019;</ref><ref type="bibr">Hu et al., 2020)</ref>.</p><p>We introduce an open-source GNN benchmarking framework (see <ref type="figure">Figure 1</ref>) that brings forward a set of diverse medium-scale datasets which are discriminative to benchmark different GNN models when compared fairly on fixed parameter budgets. The existing collection of datasets, the protocol to use the same parameter budgets for comparison, and the modular coding infrastructure has been widely used to prototype powerful GNN ideas and develop new insights, as shown by 1800+ stars and 330+ forks of the GitHub repository from its first release in March 2020, and 330+ citations gathered by the ArXiv technical report according to Google Scholar. Aspects of the benchmark have led to facilitating several interesting studies for GNNs such as on (i) the aggregation functions and filters <ref type="bibr">(Corso et al., 2020;</ref><ref type="bibr">Tailor et al., 2021;</ref><ref type="bibr">Elhag et al., 2022)</ref>, (ii) improving expressive power of GNNs <ref type="bibr">(Valsesia et al., 2021;</ref><ref type="bibr">Bouritsas et al., 2022;</ref><ref type="bibr">Bevilacqua et al., 2021)</ref>, (iii) pooling mechanisms <ref type="bibr" target="#b1">(Mesquita et al., 2020)</ref>, (iv) graph-specific normalization and regularization <ref type="bibr">(Chen et al., 2022;</ref><ref type="bibr">Zhou et al., 2020;</ref><ref type="bibr">Zhang et al., 2021)</ref>, and (v) GNNs' robustness and efficiency <ref type="bibr" target="#b19">(Wei and Hu, 2022;</ref><ref type="bibr">Tailor et al., 2020)</ref> among other ideas contributed in the literature. In this paper, we provide an updated overview of the proposed framework that extends on the previous collection of datasets to (a) include a number of essential mathematical datasets which can be used to test specific theoretical graph properties, and (b) incorporate another molecular dataset, AQSOL <ref type="bibr">(Sorkun et al., 2019)</ref> that has real-world experimental solubility targets  <ref type="table">Table 1</ref>: Summary statistics of datasets included in the proposed benchmark. Additional information on these datasets in Appendix <ref type="table" target="#tab_6">Table 2</ref> and Section C.</p><p>unlike ZINC's computed targets, resulting in a collection of 12 datasets (see <ref type="table">Table 1</ref>). The remainder of the paper discusses a proof of concept of the benchmark that can be used to explore and develop new insights for GNNs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Overview of GNN Benchmarking Framework</head><p>Datasets. Collecting representative, realistic and medium-to-large scale graph datasets presents several challenges. It is unclear what theoretical tools can define the quality of a dataset or validate its statistical representativeness for a given task. Similarly, there are several arbitrary choices when preparing graphs, such as node and edge features. Finally, very large graph datasets also present a computational challenge and require extensive GPU resources to be studied <ref type="bibr">(Chiang et al., 2019;</ref><ref type="bibr" target="#b12">Rossi et al., 2020;</ref><ref type="bibr">Hu et al., 2021)</ref>. On account of such challenges, we present in our benchmark a collection of 12 graph datasets, listed in <ref type="table">Table 1</ref>, which are (i) collected from real-world sources and prepared from mathematical models, (ii) of medium-scale size suitable for academic research, (iii) representative of the three fundamental graph learning tasks at graph-level, node-level and edge-level, and (iv) from diverse end-application domains. These datasets are appropriate to statistically separate the performance of GNNs on specific graph properties, hence fulfilling the academic mission to identify first principles while carrying out GNN research. Notably, the Stochastic Block Model (SBM) (Abbe, 2017), which we utilized to benchmark GNNs for pattern matching and clustering in our March 2020 release, has recently been used on Google Cloud Platform as synthetic, yet diverse, graph data generators to overcome the low-variability of widely-used real-world graph datasets <ref type="bibr" target="#b8">(Palowitch et al., 2022;</ref><ref type="bibr">Hu et al., 2020)</ref>. Coding Infrastructure. Our benchmarking infrastructure builds upon PyTorch <ref type="bibr" target="#b9">(Paszke et al., 2019)</ref> and DGL <ref type="bibr" target="#b17">(Wang et al., 2019)</ref>, and has been developed with the following fundamental objectives: (a) Ease-of-use and modularity, enabling new users to experiment and study the building blocks of GNNs; (b) Experimental rigour and fairness for all models being benchmarked; and (c) Being future-proof and comprehensive for tracking the progress of graph machine learning tasks and new GNNs. At a high level as sketched in <ref type="figure">Figure 1</ref>, our benchmark unifies independent components for: (i) Data pipelines; (ii) GNN layers and models; (iii) Training and evaluation functions; (iv) Network and hyperparameter configurations; and (v) Scripts for reproducibility. This standardized framework has been of immense help to the community as aforementioned about its wide community usage. It has enabled researchers to explore new ideas at any stage of the pipeline without setting up everything else. We direct readers to the README user manual included in our GitHub repository for detailed instructions on using the coding infrastructure.</p><p>Parameter Budgets for Fair Comparison. One goal of this benchmark is not to find the optimal hyperparameters for a specific GNN model (which is computationally expensive), but to compare the model and/or their building blocks within a budget of parameters. Therefore, we decide on using two parameter budgets: (1) 100k parameters for each GNN for all the datasets, and (2) 500k parameters for GNNs for which the scalability of a model to larger parameters and deeper layers are investigated. The number of hidden layers and dimensions are selected accordingly to match these budgets.</p><p>3. How can the benchmark be used to explore new insights?</p><p>The proposed benchmarking framework can be used to test new research ideas at the level of data preprocessing, improving the GNN layers and normalization schemes, or even to substantiate the performance of a novel GNN model. Such studies are conveniently facilitated given the set of diverse datasets and the rigorous comparison of different experiments on same parameter budgets. At any stage, a modular component of the framework, such as data, layers, etc., can be modified and multiple experiments on the datasets can be conducted fairly and with ease. Indeed, we employ the framework to perform multiple studies, out of which we present here the insight of positional encodings for GNNs using Laplacian eigenvectors, for an example, while the remainder is included in the appendix.</p><p>Graph Positional Encoding. Nodes in a graph do not have any canonical positional information. In the absence of available features, nodes are anonymous, such as the nodes in CSL, CYCLES or GraphTheoryProp datasets in our benchmark. As such, message passing based GCNs perform either poorly or fail completely to detect the class of the graph, such as isomorphic class, or cycles <ref type="bibr" target="#b7">(Murphy et al., 2019;</ref><ref type="bibr">Loukas, 2020)</ref>. We proposed the use of Laplacian eigenvectors <ref type="bibr">(Belkin and Niyogi, 2003)</ref> as node positional encoding and we used the benchmark to validate and also quantified the improvement provided by this idea. The Laplacian PE effectively improved the MP-GCNs (message-passing based Graph Convolutional Networks) on the the 3 synthetics datasets mentioned previously and other real-world datasets, including the newly added AQSOL dataset. A detailed presentation of the PE with experiments are in Appendix E.1.</p><p>After the introduction of Laplacian PE through this benchmark, new ideas followed up in the literature along this line of research such as (i) Directional Graph Networks <ref type="bibr">(Beaini et al., 2021)</ref>, (ii) Equivariant and Stable PE <ref type="bibr" target="#b15">(Wang et al., 2022)</ref>, (iii) Sign-invariant Laplacian PE <ref type="bibr">(Lim et al., 2022)</ref>, (iv) Random-walk PE <ref type="bibr">(Dwivedi et al., 2022)</ref>, and (v) PEs for Graph Transformers <ref type="bibr">(Dwivedi and Bresson, 2021;</ref><ref type="bibr">Kreuzer et al., 2021;</ref><ref type="bibr">Ying et al., 2021;</ref><ref type="bibr" target="#b2">Mialon et al., 2021)</ref>, thus demonstrating how the identification of first principles using the proposed benchmark can steer GNN research.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Conclusion</head><p>This paper introduces an open-source benchmarking framework for Graph Neural Networks that is modular, easy-to-use, and can be leveraged to quickly yet robustly test new GNN ideas and explore insights that direct further research. The benchmark led us to propose graph PE that has remained an interesting avenue of exploration since the first release of our benchmark. We also perform additional studies on investigation of different GNN categories, and edge representations for link prediction, the details of which are included in the appendix for interested readers. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix A. Related Work</head><p>In the last few years, graph neural networks (GNNs) have seen a great surge of interest with promising methods being developed for myriad of domains including chemistry <ref type="bibr">(Duvenaud et al., 2015;</ref><ref type="bibr">Gilmer et al., 2017</ref><ref type="bibr">), physics (Cranmer et al., 2019</ref><ref type="bibr">Sanchez-Gonzalez et al., 2020)</ref>, social sciences <ref type="bibr">(Kipf and Welling, 2017;</ref><ref type="bibr" target="#b5">Monti et al., 2019)</ref>, knowledge graphs <ref type="bibr">(Schlichtkrull et al., 2018;</ref><ref type="bibr">Chami et al., 2020)</ref>, recommendation <ref type="bibr" target="#b4">(Monti et al., 2017b;</ref><ref type="bibr" target="#b24">Ying et al., 2018)</ref>, and neuroscience <ref type="bibr">(Griffa et al., 2017)</ref>. Historically, three classes of GNNs have been developed. The first models <ref type="bibr">(Scarselli et al., 2009;</ref><ref type="bibr">Bruna et al., 2013;</ref><ref type="bibr">Defferrard et al., 2016;</ref><ref type="bibr">Sukhbaatar et al., 2016;</ref><ref type="bibr">Kipf and Welling, 2017;</ref><ref type="bibr">Hamilton et al., 2017)</ref> aimed at extending the original convolutional neural networks <ref type="bibr">(LeCun et al., 1995</ref><ref type="bibr">(LeCun et al., , 1998</ref> to graphs. The second class enhanced the original models with anisotropic operations on graphs <ref type="bibr" target="#b11">(Perona and Malik, 1990)</ref>, such as attention and gating mechanisms <ref type="bibr">(Battaglia et al., 2016;</ref><ref type="bibr">Marcheggiani and Titov, 2017;</ref><ref type="bibr" target="#b3">Monti et al., 2017a;</ref><ref type="bibr">Veli?kovi? et al., 2018;</ref><ref type="bibr">Bresson and Laurent, 2017)</ref>. The recent third class has introduced GNNs that improve upon theoretical limitations of previous models <ref type="bibr" target="#b22">(Xu et al., 2019;</ref><ref type="bibr" target="#b6">Morris et al., 2019;</ref><ref type="bibr">Maron et al., 2019a;</ref><ref type="bibr">Chen et al., 2019b;</ref><ref type="bibr" target="#b7">Murphy et al., 2019;</ref><ref type="bibr">Srinivasan and Ribeiro, 2020)</ref>. Specifically, the first two classes can only differentiate simple non-isomorphic graphs and cannot separate automorphic nodes. Developing powerful and theoretically expressive GNN architectures is a key concern towards practical applications and real-world adoption of graph machine learning. However, tracking recent progress has been challenging as most models are evaluated on small datasets such as Cora, Citeseer and TU, which are inappropriate to differentiate complex, simple and graph-agnostic architectures <ref type="bibr">(Hoang and Maehara, 2019;</ref><ref type="bibr">Chen et al., 2019a)</ref>, and do not have consensus on a unifying experimental setting <ref type="bibr">(Errica et al., 2019;</ref><ref type="bibr">Hu et al., 2020)</ref>.</p><p>Consequently, our motivation is to benchmark GNNs to identify and quantify what types of architectures, first principles or mechanisms are universal, generalizable, and scalable when we move to larger and more challenging datasets. Benchmarking provides a strong paradigm to answer these fundamental questions. It has proved to be beneficial for driving progress, identifying essential ideas, and solving domain-specific problems in several areas of science <ref type="bibr" target="#b18">(Weber et al., 2019)</ref>. Recently, the famous 2012 ImageNet challenge <ref type="bibr">(Deng et al., 2009)</ref> has provided a benchmark dataset that has triggered the deep learning revolution <ref type="bibr">(Krizhevsky et al., 2012;</ref><ref type="bibr">Malik, 2017)</ref>. Nevertheless, designing successful benchmarks is highly challenging as it requires both a coding framework with a rigorous experimental setting for fair comparisons, all while being reproducible, as well as using appropriate datasets that can statistically separate model performance. The lack of benchmarks has been a major issue in GNN literature as the aforementioned requirements have not been rigorously enforced.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix B. Graph Neural Network Pipeline</head><p>In this section, we describe the experimental pipeline for the two broad classes of GNN architectures that are benchmarked in this framework as representative GNN classes -Message Passing Graph Convolutional Networks (MP-GCNs), which are based on the message passing framework formalized in <ref type="bibr">Gilmer et al. (2017)</ref>, and Weisfeiler Lehman GNNs (WL-GNNs), which improves the theoretical limitations of MP-GCNs and align expressivity power to the WL-tests to distinguish non-isomorphic graphs. The two pipelines are illustrated in <ref type="figure">Figure 2</ref> for GCNs and <ref type="figure">Figure 3</ref> for WL-GNNs.</p><p>In Section B.1, we describe the components of the setup of the GCN class with vanilla GCN (Kipf and Welling, 2017), <ref type="bibr">GraphSage (Hamilton et al., 2017)</ref>, MoNet <ref type="bibr" target="#b3">(Monti et al., 2017a)</ref>, <ref type="bibr">GAT (Veli?kovi? et al., 2018), and</ref><ref type="bibr">GatedGCN (Bresson and</ref><ref type="bibr">Laurent, 2017)</ref>, including the input layers, the GNN layers and the task based MLP classifier layers. We also include the description of GIN <ref type="bibr" target="#b22">(Xu et al., 2019)</ref> in this section as this model can be interpreted as a GCN, although it was designed to differentiate non-isomorphic graphs. In Section B.2, we present the GNN layers and the task based MLP classifier layers for the class of WL-GNN models with Ring-GNNs (Chen et al., 2019b) and <ref type="bibr">3WL-GNNs (Maron et al., 2019a)</ref>.    <ref type="figure">Figure 2</ref>: A standard experimental pipeline for GCNs, which embeds the graph node and edge features, performs several GNN layers to compute convolutional features, and finally makes a prediction through a task-specific MLP layer.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B.1 Message-Passing GCNs</head><p>For this class, we consider the widely used message passing-based graph convolutional networks (MP-GCNs), which update node representations from one layer to the other according to the formula:</p><formula xml:id="formula_0">h +1 i = f (h i , {h j } j?N i ).</formula><p>Note that the update equation is local, only depending on the neighborhood N i of node i, and independent of graph size, making the space/time complexity O(E) reducing to O(n) for sparse graphs. Thus, MP-GCNs are highly parallelizable on GPUs and are implemented via sparse matrix multiplications in modern graph machine learning frameworks <ref type="bibr" target="#b17">(Wang et al., 2019;</ref><ref type="bibr" target="#b6">Fey and Lenssen, 2019)</ref>. MP-GCNs draw parallels to ConvNets for computer vision <ref type="bibr">(LeCun et al., 1998)</ref> by considering a convolution operation with shared weights across the graph domain.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B.1.1 Input Layer</head><p>Given a graph, we are given node features ? i ? R a?1 for each node i and (optionally) edge features ? ij ? R b?1 for each edge connecting node i and node j. The input features ? i and ? ij are embedded to d-dimensional hidden features h =0 i and e =0 ij via a simple linear projection before passing them to a graph neural network:</p><formula xml:id="formula_1">h 0 i = U 0 ? i + u 0 ; e 0 ij = V 0 ? ij + v 0 ,<label>(1)</label></formula><p>Node feat.</p><p>Edge feat.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Input Tensor WL-GNN Layer Prediction Layer</head><p>Input <ref type="formula" target="#formula_4">3D</ref>   <ref type="figure">Figure 3</ref>: A standard experimental pipeline for WL-GNNs, which inputs to a GNN a graph with all node and edge information (if available) represented by a dense tensor, performs several GNN layer computations over the dense tensor, and finally makes a prediction through a task-specific MLP layer.</p><formula xml:id="formula_2">where U 0 ? R d?a , V 0 ? R d?b and u 0 , v 0 ? R d .</formula><p>If the input node/edge features are one-hot vectors of discrete variables, then biases u 0 , v 0 are not used.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B.1.2 GCN layers</head><p>Each GCN layer computes d-dimensional representations for the nodes/edges of the graph through recursive neighborhood diffusion (or message passing), where each graph node gathers features from its neighbors to represent local graph structure. Stacking L GCN layers allows the network to build node representations from the L-hop neighborhood of each node. Let h i denote the feature vector at layer associated with node i. The updated features h +1 i at the next layer + 1 are obtained by applying non-linear transformations to the central feature vector h i and the feature vectors h j for all nodes j in the neighborhood of node i (defined by the graph structure). This guarantees the transformation to build local reception fields, such as in standard ConvNets for computer vision, and be invariant to both graph size and vertex re-indexing.</p><p>Thus, the most generic version of a feature vector h +1 i at vertex i at the next layer in the GNN is:</p><formula xml:id="formula_3">h +1 i = f h i , {h j : j ? i} ,<label>(2)</label></formula><p>where {j ? i} denotes the set of neighboring nodes j pointed to node i, which can be replaced by {j ? N i }, the set of neighbors of node i, if the graph is undirected. In other words, a GNN is defined by a mapping f taking as input a vector h i (the feature vector of the center vertex) as well as an un-ordered set of vectors {h j } (the feature vectors of all neighboring vertices), see <ref type="figure" target="#fig_3">Figure 4</ref>. The arbitrary choice of the mapping f defines an instantiation of a class of GNNs.</p><p>Graph ConvNets (GCN) (Kipf and Welling, 2017) In the simplest formulation of GNNs, vanilla Graph ConvNets iteratively update node features via an isotropic averaging operation over the neighborhood node features, i.e.,</p><formula xml:id="formula_4">h +1 i = ReLU U Mean j?N i h j ,<label>(3)</label></formula><formula xml:id="formula_5">= ReLU U 1 deg i j?N i h j ,<label>(4)</label></formula><p>where U ? R d?d (a bias is also used, but omitted for clarity purpose), deg i is the in-degree of node i, see <ref type="figure">Figure 5</ref>. Eq. (3) is called a convolution as it is a linear approximation of a localized spectral convolution. Note that it is possible to add the central node features h i in the update (3) by using self-loops or residual connections. The GCN model in Kipf and Welling (2017) use symmetric normalization instead of the isotropic averaging, to result in the following node update equation:</p><formula xml:id="formula_6">h +1 i = ReLU U 1 deg i deg j j?N i h j ,<label>(5)</label></formula><p>GraphSage (Hamilton et al., 2017) GraphSage improves upon the simple GCN model by explicitly incorporating each node's own features from the previous layer in its update equation:?</p><formula xml:id="formula_7">+1 i = ReLU U Concat h i , Mean j?N i h j ,<label>(6)</label></formula><p>where U ? R d?2d , see <ref type="figure">Figure 6</ref>. Observe that the transformation applied to the central node features h i is different to the transformation carried out to the neighborhood features h j . The node features are then projected onto the 2 -unit ball before being passed to the next layer: The authors also define more sophisticated neighborhood aggregation functions, such as Max-pooling or LSTM aggregators:</p><formula xml:id="formula_8">h +1 i =? +1 i ? +1 i 2 .<label>(7)</label></formula><formula xml:id="formula_9">h +1 i = ReLU U Concat h i , Max j?N i ReLU V h j ,<label>(8)</label></formula><formula xml:id="formula_10">h +1 i = ReLU U Concat h i , LSTM j?N i h j ,<label>(9)</label></formula><p>where V ? R d?d and the LSTM cell also uses learnable weights. In our experiments, we use the Max-pooling version of GraphSage, Eq.(8).</p><p>Graph Attention Network (GAT) (Veli?kovi? et al., 2018) GAT uses an attention mechanism (Bahdanau et al., 2014) to introduce anisotropy in the neighborhood aggregation function. The network employs a multi-headed architecture to increase the learning capacity, similar to the Transformer <ref type="bibr">(Vaswani et al., 2017;</ref><ref type="bibr">Joshi, 2020)</ref>. The node update equation is given by:</p><formula xml:id="formula_11">h +1 i = Concat K k=1 ELU j?N i e k, ij U k, h j ,<label>(10)</label></formula><p>where U k, ? R d K ?d are the K linear projection heads, and e k, ij are the attention coefficients for each head defined as:</p><formula xml:id="formula_12">e k, ij = exp(? k, ij ) j ?N i exp(? k, ij ) ,<label>(11)</label></formula><formula xml:id="formula_13">e k, ij = LeakyReLU V k, Concat U k, h i , U k, h j ,<label>(12)</label></formula><p>where V k, ? R  <ref type="bibr">, 1977)</ref>. In the case of graphs, the node update equation is defined as:</p><formula xml:id="formula_14">h +1 i = ReLU K k=1 j?N i e k, ij U k, h j ,<label>(13)</label></formula><formula xml:id="formula_15">e k, ij = exp ? 1 2 (u ij ? ? k ) T (? k ) ?1 (u ij ? ? k ) ,<label>(14)</label></formula><formula xml:id="formula_16">u ij = Tanh A (deg ?1/2 i , deg ?1/2 j ) T + a ,<label>(15)</label></formula><p>where U k, ? R d?d , ? k , (? k ) ?1 , a ? R 2 and A ? R 2?2 are the (learnable) parameters of the GMM, see <ref type="figure">Figure 8</ref>.</p><p>Gated Graph ConvNet (GatedGCN) (Bresson and Laurent, 2017) GatedGCN considers residual connections, batch normalization and edge gates (Marcheggiani and Titov, 2017) to design another anisotropic variant of GCN. The authors propose to explicitly update edge features along with node features:</p><formula xml:id="formula_17">h +1 i = h i + ReLU BN U h i + j?N i e ij V h j ,<label>(16)</label></formula><p>where U , V ? R d?d , is the Hadamard product, and the edge gates e ij are defined as:</p><formula xml:id="formula_18">e ij = ?(? ij ) j ?N i ?(? ij ) + ? ,<label>(17)</label></formula><formula xml:id="formula_19">e ij =? ?1 ij + ReLU BN A h ?1 i + B h ?1 j + C ? ?1 ij ,<label>(18)</label></formula><p>where ? is the sigmoid function, ? is a small fixed constant for numerical stability, A , B , C ? R d?d , see <ref type="figure">Figure 9</ref>. Note that the edge gates <ref type="formula" target="#formula_1">(17)</ref> can be regarded as a soft attention process, Graph Isomorphism Networks (GIN) <ref type="bibr" target="#b22">(Xu et al., 2019)</ref> The GIN architecture is based the Weisfeiler-Lehman Isomorphism Test <ref type="bibr" target="#b20">(Weisfeiler and Lehman, 1968)</ref> to study the expressive power of GNNs. The node update equation is defined as:</p><formula xml:id="formula_20">h +1 i = ReLU U ReLU BN V ? +1 i ,<label>(19)</label></formula><formula xml:id="formula_21">h +1 i = (1 + ) h i + j?N i h j ,<label>(20)</label></formula><p>where is a learnable constant, U , V ? R d?d , BN denotes Batch Normalization. See <ref type="figure">Figure  10</ref> for illustration of the update equation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Normalization and Residual Connections</head><p>As a final note, we augment each messagepassing GCN layer with batch normalization (BN) (Ioffe and Szegedy, 2015) and residual connections <ref type="bibr">(He et al., 2016)</ref>. As such, we consider a more specific class of GCNs than <ref type="formula" target="#formula_3">(2)</ref>:</p><formula xml:id="formula_22">h +1 i = h i + ? BN ? +1 i ,<label>(21)</label></formula><formula xml:id="formula_23">h +1 i = g GCN h i , {h j : j ? i} ,<label>(22)</label></formula><p>where ? is a non-linear activation function and g GCN is a specific message-passing GCN layer.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B.1.3 Task-based Layer</head><p>The final component of each network is a prediction layer to compute task-dependent outputs, which are given to a loss function to train the network parameters in an end-to-end manner. The input of the prediction layer is the result of the final message-passing GCN layer for each node of the graph (except GIN, which uses features from all intermediate layers).</p><p>Graph classifier layer To perform graph classification, we first build a d-dimensional graph-level vector representation y G by averaging over all node features in the final GCN layer:</p><formula xml:id="formula_24">y G = 1 V V i=0 h L i ,<label>(23)</label></formula><p>The graph features are then passed to a MLP, which outputs un-normalized logits/scores y pred ? R C for each class:</p><formula xml:id="formula_25">y pred = P ReLU (Q y G ) ,<label>(24)</label></formula><p>where P ? R d?C , Q ? R d?d , C is the number of classes. Finally, we minimize the cross-entropy loss between the logits and groundtruth labels.</p><p>Graph regression layer For graph regression, we compute y G using Eq.(23) and pass it to a MLP which gives the prediction score y pred ? R:</p><formula xml:id="formula_26">y pred = P ReLU (Q y G ) ,<label>(25)</label></formula><p>where P ? R d?1 , Q ? R d?d . The L1-loss between the predicted score and the groundtruth score is minimized during the training.</p><p>Node classifier layer For node classification, we independently pass each node's feature vector to a MLP for computing the un-normalized logits y i,pred ? R C for each class:</p><formula xml:id="formula_27">y i,pred = P ReLU Q h L i ,<label>(26)</label></formula><p>where P ? R d?C , Q ? R d?d . The cross-entropy loss weighted inversely by the class size is used during training.</p><p>Edge classifier layer To make a prediction for each graph edge e ij , we first concatenate node features h i and h j from the final GNN layer. The concatenated edge features are then passed to a MLP for computing the un-normalized logits y ij,pred ? R C for each class:</p><formula xml:id="formula_28">y ij,pred = P ReLU Q Concat h L i , h L j ,<label>(27)</label></formula><p>where P ? R d?C , Q ? R d?2d . The standard cross-entropy loss between the logits and groundtruth labels is used.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B.2 Weisfeiler-Lehman GNNs</head><p>Weisfeiler-Lehman GNNs are the second GNN class we include in our benchmarking framework which are based on the WL test <ref type="bibr" target="#b20">(Weisfeiler and Lehman, 1968)</ref>. <ref type="bibr" target="#b22">Xu et al. (2019)</ref> introduced GIN-Graph Isomorphism Network, a provable 1-WL GNN, which can distinguish two nonisomorphic graphs w.r.t. the 1-WL test. Higher k-WL isomorphic tests lead to more </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B.2.1 Input Tensor</head><p>For a given graph with adjacency matrix A ? R n?n , node features h node ? R n?d and edge features h edge ? R n?n?de , the input tensor to the RingGNN and 3WL-GNN networks is defined as</p><formula xml:id="formula_29">h =0 ? R n?n?(1+d+de) ,<label>(28)</label></formula><p>where </p><formula xml:id="formula_30">h =0 i,j,1 = A ij ? R, ?i, j<label>(29)</label></formula><formula xml:id="formula_31">h =0 i,j,2:d+1 = h node i ? R d , ?i = j 0 , ?i = j (30) h =0 i,j,d+2:d+de+1 = h edge ij ? R de<label>(31)</label></formula><formula xml:id="formula_32">h +1 = Concat M W 1 (h ) . M W 2 (h ), M W 3 (h ) ,<label>(32)</label></formula><p>where h , h +1 ? R n?n?d , and M W are 2-layer MLPs applied along the feature dimension:</p><formula xml:id="formula_33">M W ={Wa,W b } (h) = ? h W a W b ,<label>(33)</label></formula><p>where W a , W b ? R d?d . As h ? R n?n?d , the MLP (33) is implemented with a standard 2D-convolutional layer with 1 ? 1 kernel size. Eventually, the matrix multiplication in <ref type="formula" target="#formula_3">(32)</ref> is carried out along the first and second dimensions such that:</p><formula xml:id="formula_34">M W 1 (h) . M W 2 (h) i,j,k = n p=1 M W 1 (h) i,p,k . M W 2 (h) p,j,k ,<label>(34)</label></formula><p>with complexity O(n 3 ). </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Ring</head><formula xml:id="formula_35">h +1 = ? w 1 L W 1 (h ) + w 2 L W 2 (h ).L W 3 (h ) ,<label>(35)</label></formula><p>where h , h +1 ? R n?n?d , w 1,2 ? R, and L W are the equivariant linear layers defined as</p><formula xml:id="formula_36">L W (h) i,j,k = 17 p=1 d q=1 W p,q,k L i (h) i,j,q ,<label>(36)</label></formula><p>where W ? R d?d?17 and {L i } 15 i=1 is the set of all basis functions for all linear equivariant functions from R n?n ? R n?n (see <ref type="bibr">Appendix A in Maron et al. (2019b)</ref> for the complete list of these 15 operations) and {L i } 17 i=16 are the basis for the bias terms. Matrix multiplication in (35) also implies a time complexity O(n 3 ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B.2.3 Task-based network layers</head><p>We describe the final network layers depending on the task at hand. The loss functions corresponding to the task are the same as the GCNs, and presented in Section B.1.3. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Graph classifier layer</head><formula xml:id="formula_37">y G = Concat L =1 n i,j=1 h ij ? R Ld ,<label>(37)</label></formula><formula xml:id="formula_38">y pred = P ReLU (Q y G ) ? R C ,<label>(38)</label></formula><p>where P ? R d?C , Q ? R Ld?d , C is the number of classes. For 3WL-GNNs, Eqn. (37) is replaced by a diagonal and off-diagonal max pooling readout <ref type="bibr">Maron et al. (2019a,b)</ref> at every layer:</p><formula xml:id="formula_39">y G = Concat max i h ii , max i =j h ij ? R 2d ,<label>(39)</label></formula><p>and the final prediction score is defined as:</p><formula xml:id="formula_40">y pred = L =1 P y G ? R C ,<label>(40)</label></formula><p>where P ? R 2d?C , C is the number of classes.</p><p>Graph regression layer Similar to the graph classifier layer with P ? R d?1 for Ring-GNNs, and P ? R 2d?1 for 3WL-GNNs.</p><p>Node classifier layer For node classification, the prediction in Ring-GNNs is done as follows:</p><formula xml:id="formula_41">y node i = Concat L =1 n j=1 h ij ? R Ld ,<label>(41)</label></formula><formula xml:id="formula_42">y i,pred = P ReLU Q y node i ? R C ,<label>(42)</label></formula><p>where P ? R d?C , Q ? R Ld?d , C is the number of classes.</p><p>In 3WL-GNNs, the final prediction score is defined as:</p><formula xml:id="formula_43">y node, i = n j=1 h ij ? R d ,<label>(43)</label></formula><formula xml:id="formula_44">y i,pred = L =1 P y node, i ? R C ,<label>(44)</label></formula><p>where P ? R d?C , C is the number of classes.</p><p>Edge classifier layer For link prediction, for both Ring-GNNs and 3WL-GNNs, the edge features are obtained by concatenating the node features such as:</p><formula xml:id="formula_45">y node i = Concat L =1 n j=1 h ij ? R Ld ,<label>(45)</label></formula><formula xml:id="formula_46">y ij,pred = P ReLU Q Concat y node i , y node j ? R C ,<label>(46)</label></formula><p>where P ? R d?C , Q ? R 2Ld?d , C is the number of classes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix C. Datasets and Benchmarking Experiments</head><p>In this section, we provide details on the datasets included in the benchmarking framework <ref type="table">(Table 1</ref>) and the numerical results of the experiments using the GNN described in Section B, which also consists experiments from a simple graph-agnostic baseline for every dataset that parallel-ly applies an MLP on each node's feature vector, independent of other nodes. For complete statistics of the data, see <ref type="table" target="#tab_6">Table 2</ref>. The experimental overview in terms of the training strategy, reporting of results and the parameter budget used for fair comparison are described first, as follows.  Training. We use the Adam optimizer (Kingma and Ba, 2014) with the same learning rate decay strategy for all models. An initial learning rate is selected in {10 ?2 , 10 ?3 , 10 ?4 } which is reduced by half if the validation loss does not improve after a fixed number of epochs, in the range 5-25. We do not set a maximum number of epochs -the training is stopped either when the learning rate has reached the small value of 10 ?6 , or the computational time reaches 12 hours. We run each experiment with 4 different seeds and report the statistics of the 4 results. More details are provided in each experimental sub-sections.</p><p>Task-based network layer. The node representations generated by the final layer of GCNs, or the dense tensor obtained at the final layer of the higher order WL-GNNs, are passed to a network suffix which is usually a downstream MLP of 3 layers. For GIN, RingGNN, and 3WL-GNN, we follow the original instructions of network suffixes to consider feature outputs from each layer of the network, similar to that of Jumping Knowledge Networks <ref type="bibr" target="#b21">(Xu et al., 2018)</ref>. Refer to the equations in the Sections B.1.3 and B.2.3 for more details.</p><p>Parameter budgets. Our goal is not to find the optimal set of hyperparameters for a specific GNN model (which is computationally expensive), but to compare and benchmark the model and/or their building blocks within a budget of parameters. Therefore, we decide on using two parameter budgets: (1) 100k parameters for each GNNs for all the tasks, and (2) 500k parameters for GNNs for which we investigate scaling a model to larger parameters and deeper layers. The number of hidden layers and hidden dimensions are selected accordingly to match these budgets. The configuration details of each single experiment can be found in our modular coding infrastructure on GitHub.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C.1 Graph Regression with ZINC dataset</head><p>For the ZINC dataset in our benchmark, we use a subset (12K) of ZINC molecular graphs (250K) dataset <ref type="bibr">(Irwin et al., 2012)</ref> to regress a molecular property known as the constrained solubility which is the term logP ? SA ? cycle (octanol-water partition coefficients, logP , penalized by the synthetic accessibility score, SA, and number of long cycles, cycle). For each molecular graph, the node features are the types of heavy atoms and the edge features  are the types of bonds between them. ZINC has been used popularly for research related to molecular graph generation <ref type="bibr">(Jin et al., 2018;</ref><ref type="bibr">Bresson and Laurent, 2019)</ref>.</p><p>Splitting. ZINC has 10, 000 train, 1, 000 validation and 1, 000 test graphs.</p><p>Training. For the learning rate strategy across all GNNs, an initial learning rate is set to 1 ? 10 ?3 , the reduce factor is 0.5, and the stopping learning rate is 1 ? 10 ?5 . The patience value is 5 for 3WLGNN and RingGNN, and 10 for all other GNNs. Performance Measure. The performance measure is the mean absolute error (MAE) between the predicted and the groundtruth constrained solubility for each molecular graph.</p><p>Results. The numerical results are presented in <ref type="table" target="#tab_8">Table 3</ref> and analysed in Section D collectively with other benchmarking results.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C.2 Graph Regression with AQSOL dataset</head><p>AQSOL dataset is based on AqSolDB (Sorkun et al., 2019) which is a standardized database of 9, 982 molecular graphs with their aqueous solubility values, collected from 9 different data sources. The aqueous solubility targets are collected from experimental measurements and standardized to LogS units in AqSolDB. We use these final values as the property to regress in the AQSOL dataset which is the resultant collection after we filter out few graphs with no edges (bonds) and a small number of graphs with missing node feature values. Thus, the total molecular graphs are 9, 823. For each molecular graph, the node features are the types of heavy atoms and the edge features are the types of bonds between them.</p><p>Splitting. We provide a scaffold splitting <ref type="bibr">(Hu et al., 2020)</ref> of the dataset in the ratio 8 : 1 : 1 to have 7, 831 train, 996 validation and 996 test graphs.</p><p>Training. For the learning rate strategy across all GNNs, an initial learning rate is set to 1 ? 10 ?3 , the reduce factor is 0.5, and the stopping learning rate is 1 ? 10 ?5 . The patience value is 5 for 3WLGNN and RingGNN, and 10 for all other GNNs. Performance Measure. Similar to ZINC, the performance measure is the mean absolute error (MAE) between the predicted and the actual aqueous solubility values.</p><p>Results. The numerical results are presented in <ref type="table" target="#tab_10">Table 4</ref> and analysed in Section D.   </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>AQSOL</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C.3 Link Prediction with OGBL-COLLAB dataset</head><p>OGBL-COLLAB is a link prediction dataset proposed by OGB (Hu et al., 2020) corresponding to a collaboration network between approximately 235K scientists, indexed by Microsoft Academic Graph <ref type="bibr" target="#b16">(Wang et al., 2020)</ref>. Nodes represent scientists and edges denote collaborations between them. For node features, OGB provides 128-dimensional vectors, obtained by averaging the word embeddings of a scientist's papers. The year and number of co-authored papers in a given year are concatenated to form edge features. The graph can also be viewed as a dynamic multi-graph, since two nodes may have multiple temporal edges between if they collaborate over multiple years. Splitting. We use the realistic training, validation and test edge splits provided by OGB. Specifically, they use collaborations until 2017 as training edges, those in 2018 as validation edges, and those in 2019 as test edges.</p><p>Training. All GNNs use a consistent learning rate strategy: an initial learning rate is set to 1 ? 10 ?3 , the reduce factor is 0.5, the patience value is 10, and the stopping learning rate is 1 ? 10 ?5 . Performance Measure. We use the evaluator provided by OGB, which aims to measure a model's ability to predict future collaboration relationships given past collaborations. Specifically, they rank each true collaboration among a set of 100,000 randomly-sampled negative collaborations, and count the ratio of positive edges that are ranked at K-place or above (Hits@K, with K = 50). Matrix Factorization Baseline. In addition to GNNs, we report performance for a simple matrix factorization baseline (Hu et al., 2020), which trains 256-dimensional embeddings for  each of the 235K nodes. Comparing GNNs to matrix factorization tells us whether models leverage node features in addition to graph structure, as matrix factorization can be thought of as feature-agnostic.</p><p>Results. The numerical results are presented in <ref type="table" target="#tab_11">Table 5</ref> and discussed in Section D.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C.4 Node Classification with WikiCS dataset</head><p>WikiCS is a node classification dataset based on an extracted subset of Wikipedia's Computer Science articles <ref type="bibr" target="#b0">(Mernyei and Cangea, 2020)</ref>. It is a single graph dataset with 11, 701 nodes and 216, 123 edges where each node corresponds to an article, and each edge corresponds to a hyperlink. Each node belongs to a label out of total 10 classes representing the article's category. The average of the article text's pre-trained GloVe word embeddings <ref type="bibr" target="#b10">(Pennington et al., 2014)</ref> is assigned as 300-dimensional node features. Compared to previous single-graph node classification benchmarks such as Cora and Citeseer, WikiCS dataset has denser node neighborhoods and each node's connectivity is spread across nodes from varying class labels. Additionally, as shown in <ref type="bibr" target="#b0">Mernyei and Cangea (2020)</ref>, the average shortest path length in WikiCS is smaller compared to Cora and Citeseer. Thus, on average, a larger node neighborhood and smaller shortest path length makes WikiCS an appropriate benchmark to test out neighborhood computation functions in GNNs' design.</p><p>Splitting. We follow the same splitting defined in <ref type="bibr" target="#b0">Mernyei and Cangea (2020)</ref> that has 20 different training and validation splits consisting of 5% nodes and 22.5% nodes of each class respectively. 50% nodes from each class, which are not in the training or validation split, are assigned as test splits.</p><p>Training. As consistent learning rate strategy across GNNs, an initial learning rate is set to 1 ? 10 ?2 , the reduce factor is 0.5, the patience value is 25, and the stopping learning rate is 1 ? 10 ?5 . Since there are 20 different training and validation splits, the training is done 20 times using these splits, and evaluated on the single test split. This is done for 4 times with 4 different seeds. Finally, the average of the 20 ? 4 = 80 runs is reported. Performance Measure. The performance measure is the classification accuracy between the predicted and groundtruth label for each node.</p><p>Results. The numerical results are presented in <ref type="table" target="#tab_13">Table 6</ref> and discussed in Section D.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C.5 Graph Classification with Super-pixel (MNIST/CIFAR10) datasets</head><p>The super-pixels datasets test graph classification using the popular MNIST and CIFAR10 image classification datasets. Our main motivation to use these datasets is as sanity-checks: we expect most GNNs to perform close to 100% for MNIST and well enough for CIFAR10. Besides, the use of super-pixel image datasets is suggestive of the way image datasets can be used for graph learning research. The original MNIST and CIFAR10 images are converted to graphs using super-pixels. Super-pixels represent small regions of homogeneous intensity in images, and can be extracted with the SLIC technique (Achanta et al., 2012). We use SLIC super-pixels from (Knyazev et al., 2019) 2 . For each sample, we build a k-nearest neighbor adjacency matrix with</p><formula xml:id="formula_47">W k?NN ij = exp ? x i ? x j 2 ? 2 x ,<label>(47)</label></formula><p>where x i , x j are the 2-D coordinates of super-pixels i, j, and ? x is the scale parameter defined as the averaged distance x k of the k nearest neighbors for each node. We use k = 8 for both MNIST and CIFAR10, whereas the maximum number of super-pixels (nodes) are 75 and 150 for MNIST and CIFAR10, respectively. The resultant graphs are of sizes 40-75 nodes for MNIST and 85-150 nodes for CIFAR10. <ref type="figure">Figure 13</ref> presents visualizations of the super-pixel graphs.</p><p>Splitting. We use the standard splits of MNIST and CIFAR10. MNIST has 55, 000 train, 5, 000 validation, 10, 000 test graphs and CIFAR10 has 45, 000 train, 5, 000 validation, 10, 000 test graphs. The 5, 000 graphs for validation set are randomly sampled from the training set and the same splits are used for every GNN.</p><p>Training. The learning decay rate strategy is adopted with an initial learning rate of 1 ? 10 ?3 , reduce factor 0.5, patience value 10, and the stopping learning rate 1 ? 10 ?5 for all GNNs, except for 3WLGNN and RingGNN where we experienced a difficulty in training, leading us to slightly adjust their learning rate schedule hyperparameters. For both 3WLGNN and RingGNN, the patience value is changed to 5. For RingGNN, the initial learning rate is changed to 1 ? 10 ?4 and the stopping learning rate is changed to 1 ? 10 ?6 . Performance Measure. The classification accuracy between the predicted and groundtruth label for each graph is the performance measure.</p><p>Results. The numerical results are presented in <ref type="table" target="#tab_15">Table 7</ref> and discussed in Section D.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C.6 Node Classification with SBM (PATTERN/CLUSTER) datasets</head><p>The SBM datasets consider node-level tasks of graph pattern recognition (Scarselli et al., 2009) -PATTERN and semi-supervised graph clustering -CLUSTER. The graphs are generated with the Stochastic Block Model (SBM) (Abbe, 2017), which is widely used to model communities in social networks by modulating the intra-and extra-communities connections, thereby controlling the difficulty of the task. A SBM is a random graph   which assigns communities to each node as follows: any two vertices are connected with the probability p if they belong to the same community, or they are connected with the probability q if they belong to different communities (the value of q acts as the noise level). PATTERN: The graph pattern recognition task, presented in <ref type="bibr">Scarselli et al. (2009)</ref>, aims at finding a fixed graph pattern P embedded in larger graphs G of variable sizes. For all data, we generate graphs G with 5 communities with sizes randomly selected between <ref type="bibr">[5,</ref><ref type="bibr">35]</ref>. The SBM of each community is p = 0.5, q = 0.35, and the node features on G are generated with a uniform random distribution with a vocabulary of size 3, i.e. {0, 1, 2}. We randomly generate 100 patterns P composed of 20 nodes with intra-probability p P = 0.5 and extra-probability q P = 0.5 (i.e., 50% of nodes in P are connected to G). The node features for P are also generated as a random signal with values {0, 1, 2}. The graphs are of sizes 44-188 nodes. The output node labels have value 1 if the node belongs to P and value 0 if it is in G.</p><p>CLUSTER: For the semi-supervised clustering task, we generate 6 SBM clusters with sizes randomly selected between <ref type="bibr">[5,</ref><ref type="bibr">35]</ref> and probabilities p = 0.55, q = 0.25. The graphs are of sizes 40-190 nodes. Each node can take an input feature value in {0, 1, 2, .., 6}. If the value is 1, the node belongs to class 0, value 2 corresponds to class 1, . . . , value 6 corresponds to class 5. Otherwise, if the value is 0, the class of the node is unknown and will be inferred by the GNN. There is only one labelled node that is randomly assigned to each community and most node features are set to 0. The output node labels are defined as the community/cluster class labels. Splitting. The PATTERN dataset has 10, 000 train, 2, 000 validation, 2, 000 test graphs and CLUSTER dataset has 10, 000 train, 1, 000 validation, 1, 000 test graphs. We save the generated splits and use the same sets in all models for fair comparison. Training. As presented in the standard experimental protocol in Section C, we use Adam optimizer with a learning rate decay strategy. For all GNNs, an initial learning rate is set to 1 ? 10 ?3 , the reduce factor is 0.5, the patience value is 5, and the stopping learning rate is 1 ? 10 ?5 . Performance Measure. The performance measure is the average node-level accuracy weighted with respect to the class sizes. Results. Our numerical results are presented in <ref type="table" target="#tab_16">Table 8</ref> and discussed in Section D together with other benchmark results.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C.7 Edge Classification/Link Prediction with TSP dataset</head><p>Leveraging machine learning for solving NP-hard combinatorial optimization problems (COPs) has been the focus of intense research in recent years <ref type="bibr" target="#b13">(Vinyals et al., 2015;</ref><ref type="bibr">Bengio et al., 2018)</ref>. Recently proposed learning-driven solvers for COPs <ref type="bibr">(Khalil et al., 2017;</ref><ref type="bibr">Kool et al., 2019;</ref><ref type="bibr">Joshi et al., 2019)</ref> combine GNNs with classical search to predict approximate solutions directly from problem instances (represented as graphs). Consider the intensively studied Travelling Salesman Problem (TSP), which asks the following question: "Given a list of cities and the distances between each pair of cities, what is the shortest possible route that visits each city and returns to the origin city?" Formally, given a 2D Euclidean graph, one needs to find an optimal sequence of nodes, called a tour, with minimal total edge weights (tour length). TSP's multi-scale nature makes it a challenging graph task which requires reasoning about both local node neighborhoods as well as global graph structure.</p><p>For our experiments with TSP, we follow the learning-based approach to COPs described in <ref type="bibr">Joshi et al. (2022)</ref>, where a GNN is the backbone architecture for assigning probabilities to each edge as belonging/not belonging to the predicted solution set. The probabilities are then converted into discrete decisions through graph search techniques. Each instance is a graph of n node locations sampled uniformly in the unit square S = {x i } n i=1 and x i ? [0, 1] 2 . We generate problems of varying size and complexity by uniformly sampling the number of nodes n ? [50, 500] for each instance.</p><p>In order to isolate the impact of the backbone GNN architectures from the search component, we pose TSP as a binary edge classification task, with the groundtruth value for each edge belonging to the TSP tour given by <ref type="bibr">Concorde (Applegate et al., 2006)</ref>. For scaling to large instances, we use sparse k = 25 nearest neighbor graphs instead of full graphs, following <ref type="bibr">(Khalil et al., 2017)</ref>. See <ref type="figure" target="#fig_3">Figure 14</ref> for sample TSP instances of various sizes.</p><p>Splitting. TSP has 10, 000 train, 1, 000 validation and 1, 000 test graphs. Training. All GNNs use a consistent learning rate strategy: an initial learning rate is set to 1 ? 10 ?3 , the reduce factor is 0.5, the patience value is 10, and the stopping learning rate is 1 ? 10 ?5 . Performance Measure. Given the high class imbalance, i.e., only the edges in the TSP tour have positive label, we use the F1 score for the positive class as our performance measure. Non-learnt Baseline. In addition to reporting performance of GNNs, we compare with a simple k-nearest neighbor heuristic baseline, defined as follows: Predict true for the edges corresponding to the k nearest neighbors of each node, and false for all other edges. We set k = 2 for optimal performance. Comparing GNNs to the non-learnt baseline tells us whether models learn something more sophisticated than identifying a node's nearest neighbors. Results. The numerical results are presented in <ref type="table" target="#tab_18">Table 9</ref> and analysed in Section D.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C.8 Graph Classification and Isomorphism Testing with CSL dataset</head><p>The Circular Skip Link dataset is a symmetric graph dataset introduced in <ref type="bibr" target="#b7">Murphy et al. (2019)</ref> to test the expressivity of GNNs. Each CSL graph is a 4-regular graph with edges connected to form a cycle and containing skip-links between nodes. Formally, it is denoted by G N,C where N is the number of nodes and C is the isomorphism class which is the skip-link length of the graph. We use the same dataset G 41,C with C ? {2, <ref type="bibr">3, 4, 5, 6, 9, 11, 12, 13, 16}</ref>. The dataset is class-balanced with 15 graphs for every C resulting in a total of 150 graphs. Splitting. We perform a 5-fold cross validation split, following <ref type="bibr" target="#b7">Murphy et al. (2019)</ref>, which gives 5 sets of train, validation and test data indices in the ratio 3 : 1 : 1. We use stratified sampling to ensure that the class distribution remains the same across splits. The indices are saved and used across all experiments for fair comparisons.</p><p>Training. For the learning rate strategy across all GNNs, an initial learning rate is set to 5 ? 10 ?4 , the reduce factor is 0.5, the patience value is 5, and the stopping learning rate is 1 ? 10 ?6 . We train on the 5-fold cross validation with 20 different seeds of initialization, following <ref type="bibr">Chen et al. (2019b)</ref>. Performance Measure. We use graph classification accuracy between the predicted labels and groundtruth labels as our performance measure. The model performance is evaluated on the test split of the 5 folds at every run, and following <ref type="bibr" target="#b7">Murphy et al. (2019)</ref>; Chen et al.</p><p>(2019b), we report the maximum, minimum, average and the standard deviation of the 100 scores, i.e., 20 runs of 5-folds.</p><p>Results. The numerical results are reported in <ref type="table" target="#tab_20">Table 10</ref> and analyzed in Section E.1. In this paper, we use CSL primarily to validate the impact of having Graph Positional Encodings  (Section E.1) that is proposed as a demonstration of our benchmarking framework to steer new GNN research.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C.9 Cycle Detection with CYCLES dataset</head><p>The CYCLES is a dataset synthetically generated by Loukas (2020) which contains equal number of graphs with and without cycles of fixed lengths. The task is a binary classification task to detect whether a graph has cycle or not. Though there are several forms of the dataset used in Loukas (2020) in terms of the number of nodes and cycle lengths, we select the dataset variant marked with having node size 56 and cycle length 6, based on the difficulty results shown by the author. The graphs have nodes in the range 37-65. Splitting. We use the same dataset splits as in Loukas <ref type="formula" target="#formula_3">(2020)</ref>. Originally there 10,000 graphs each in the training and test sets. We sample 1,000 class balanced graphs from the training set to be used as validation samples. Therefore, the resulting CYCLES dataset has 9,000 train/ 1,000 validation/10,000 test graphs with all the sets having class-balanced samples. We show results on different sizes of training samples following the original author of CYCLES dataset.</p><p>Training. For the learning rate strategy, an initial learning rate is set to 1 ? 10 ?4 , the reduce factor is 0.5, the patience value is 10, and the stopping learning rate is 1 ? 10 ?6 . Following Loukas (2020), we train using a varying sample size from 200 to 5, 000 out of the training graphs and report the results accordingly. The reported results are based on 4 runs with 4 different seeds.</p><p>Performance Measure. The classification accuracy between the predicted and groundtruth label for whether a graph has cycle or not is the performance measure.</p><p>Results. Similar to the CSL dataset (Section C.8), we use the CYCLES dataset mainly for the validation of the Graph Positional Encodings (Section E.1) proposed as an outcome of this benchmarking framework. As such, we train only a subset of MP-GCNs (GINs and GatedGCNs) and report the respective results. The numerical results are reported in <ref type="table" target="#tab_22">Table  11</ref> and analyzed in Section E.1.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C.10 Multi-task graph properties with GraphTheoryProp dataset</head><p>Corso et al. <ref type="formula" target="#formula_3">(2020)</ref> proposed a synthetic dataset of undirected and unweighted graphs of diverse types randomly generated for a multi-task benchmarking of 6 graph-theoretic properties, 3 at the node-level and 3 at the graph-level. We call this dataset as GraphTheoryProp.</p><p>The node-level tasks are to determine single source shortest paths (Dist.), node eccentricity (Ecc.), and Laplacian features LX given a node feature vector X (Lap.) The graph-level tasks are graph connectivity (Conn.), diameter (Diam.) and spectral radius (Rad.). The dataset has graph sizes in the range of 15-24 nodes which have random identifiers as input features. This dataset is crucial to benchmark the robustness of a GNN to predict specific or overall of all the 6 properties, as these may share subroutines such as graph traversals, despite the tasks being different graph properties <ref type="bibr">(Corso et al., 2020)</ref>.  <ref type="table" target="#tab_6">Table 12</ref>: Mean Log 10 MSE for each task over 4 runs with 4 different seeds. Average denotes the combined average of all the tasks. Log 10 MSE is on the test set (lower is better). Bold shows the best result out of a GNN's two model instances that use and not use PE. The dimension for PE is 12.</p><p>Splitting. We use the same splitting sets as in <ref type="bibr">Corso et al. (2020)</ref> which has 5,120 train, 640 validation, 1,280 test graphs. Training. For the learning rate strategy, an initial learning rate is set to 1 ? 10 ?3 , the reduce factor is 0.5, the patience value is 15, and the stopping learning rate is 1 ? 10 ?6 . The reported results are based on 4 runs with 4 different seeds. Performance Measure. For performance measure, Log 10 MSE is reported between the predicted and groundtruth values for each single task. Besides, an average performance measure is reported which is the combined average of all the 6 tasks. Results. As with the CSL and CYCLES datasets (Sections C.8, C.9), we use GraphThe-oryProp in this paper for the validation of Graph Positional Encodings, Section E.1. The numerical results are reported in <ref type="table" target="#tab_6">Table 12</ref> and analyzed in Section E.1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix D. Analysis and Discussion of Benchmarking Results</head><p>This section highlights the main take-home messages from the experiments in Section C on the datasets in the proposed framework, which evaluate the GNNs from Section B with the experimental setup described in Section C and respective sub-sections of each datasets.</p><p>Graph-agnostic NNs perform poorly. As a sanity check, we compare all GNNs to a simple graph-agnostic MLP baseline which updates each node independent of oneother, h +1 i = ? W h i , and passes these features to the task-based layer. MLP presents consistently low scores across all datasets <ref type="table" target="#tab_8">(Tables 3-10)</ref>, which shows the necessity to use graph structure for these tasks. All proposed datasets used in our study are appropriate to statistically separate GNN performance, which has remained an issue with the widely used but small graph datasets <ref type="bibr">(Errica et al., 2019;</ref><ref type="bibr">Luzhnica et al., 2019)</ref>.</p><p>GCNs outperform WL-GNNs on the proposed datasets. Although provably powerful in terms of graph isomorphism tests and invariant function approximation <ref type="bibr">(Maron et al., 2019c;</ref><ref type="bibr">Chen et al., 2019b;</ref><ref type="bibr" target="#b6">Morris et al., 2019)</ref>, the recent 3WLGNNs and RingGNNs were not able to outperform GCNs for our medium-scale datasets, as shown in Tables 3-5 and 7-9. These new models are limited in terms of space/time complexities, with O(n 2 )/O(n 3 ) respectively, not allowing them to scale to larger datasets. On the contrary, GCNs with linear complexity w.r.t. the number of nodes for sparse graphs, can scale conveniently to 16 layers and show the best performance on all datasets. 3WL-GNNs and RingGNNs face loss divergence and/or out-of-memory errors when trying to build deeper networks.</p><p>Anisotropic mechanisms improve GCNs. Among the models in the GCN class, the best results point towards the anisotropic models, particularly GAT and GatedGCN, which are based on sparse and dense attention mechanisms, respectively. For instance, results for ZINC, AQSOL, WikiCS, <ref type="bibr">MNIST,</ref><ref type="bibr">CIFAR10,</ref><ref type="bibr">PATTERN and CLUSTER in respective Tables 3,</ref><ref type="bibr">4,</ref><ref type="bibr">6,</ref><ref type="bibr">7,</ref><ref type="bibr">8</ref> show that the performance of the 100K-parameter anisotropic GNNs (GCN with symmetric normalization, GAT, MoNet, GatedGCN) are consistently better than the isotropic models (vanilla GCN, GraphSage), except for vanilla GCN-WikiCS, GraphSage-MNIST and MoNet-CIFAR10. <ref type="table" target="#tab_10">Table 14</ref>, discussed later, dissects and demonstrates the importance of anisotropy for the link prediction tasks, TSP and COLLAB. Overall, our results suggest that understanding the expressive power of attention-based neighborhood aggregation functions is a meaningful avenue of research.</p><p>Underlying challenges for training WL-GNNs. We consistently observe a relatively high standard deviation in the performance of WL-GNNs (recall that we average across 4 runs using 4 different seeds). We attribute this fluctuation to the absence of universal training procedures like batching and batch normalization, as these GNNs operate on dense rank-2 tensors of variable sizes. On the other hand, GCNs running on sparse tensors better leverage batched training and normalization for stable and fast training. Leading graph machine learning libraries represent batches of graphs as sparse block diagonal matrices, enabling batched training of GCNs through parallelized computation <ref type="bibr">(Jia et al., 2019)</ref>.</p><p>Dense tensors are incompatible with the prevalent approach, disabling the use of batch normalization for WL-GNNs. We experimented with layer normalization <ref type="bibr">(Ba et al., 2016)</ref> but without success. We were also unable to train WL-GNNs on CPU memory for the single COLLAB graph, see <ref type="table" target="#tab_11">Table 5</ref>. Practical applications of the new WL-GNNs may require redesigning the best practices and common building blocks of deep learning, i.e. batching of variable-sized data, normalization schemes, and residual connections.</p><p>3WL-GNNs perform the best among their class. Among the models in the WL-GNN class, 3WL-GNN provide better results than its similar counter-part RingGNN and achieves close to the best performance for AQSOL, see <ref type="table" target="#tab_10">Table 4</ref>. The GIN model, while being less expressive, is able to scale better and provides overall good performance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix E. Studies using the Benchmarking Framework</head><p>One of the primary goals of this benchmarking framework is to facilitate researchers to perform new explorations conveniently and develop insights that improve our overall understanding of graph neural networks. This section provides a demonstration of two such studies that we carry out by leveraging the datasets and the coding infrastructure which are part of this framework. First, we explore the absence of positional information in graphs for MP-GCNs which induces their low representation power. As a result, we develop a new insight that Laplacian eigenvectors can very simply be used as graph positional encodings and improve MP-GCNs. This insight has been received keenly in the recent literature and there are a number of works that propose positional encoding schemes with some addressing the challenges of using Laplacian eigenvectors <ref type="bibr">(Kreuzer et al., 2021;</ref><ref type="bibr" target="#b15">Wang et al., 2022;</ref><ref type="bibr">Lim et al., 2022)</ref>. Second, we study and show how the modification of existing MP-GCNs with joint edge representations help the models perform comparatively better than their vanilla counterparts.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E.1 Laplacian Positional Encodings</head><p>As discussed in Section D, MP-GCNs outperforms WL-GNNs on the diverse collection of datasets included in our proposed benchmark despite having theoretical limitations derived from the alignment of MP-GCNs to the WL-tests. Also, WL-GNNs were found to be computationally infeasible on medium and large scale datasets. Motivated by these results, we propose 'Graph Positional Encodings' using Laplacian eigenvectors, thus referred as Laplacian Positional Encodings, to improve the theoretical shortcomings of MP-GCNs, which allows us to retain the computationally efficiency offered by the message-passing framework and improve the MP-GCNs performance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E.1.1 Related Work</head><p>In <ref type="bibr" target="#b7">Murphy et al. (2019)</ref>; <ref type="bibr">Srinivasan and Ribeiro (2020)</ref>, it was pointed out that standard MP-GCNs might perform poorly when dealing with graphs that exhibit some symmetries in their structures, such as node or edge isomorphism. This is related to the limitation of MP-GCNs due to their equivalence to the 1-WL test <ref type="bibr" target="#b22">(Xu et al., 2019;</ref><ref type="bibr" target="#b6">Morris et al., 2019)</ref>.</p><p>The equivalence is based on the condition when MP-GCNs handle anonymous nodes (Loukas, 2020), i.e. nodes do not have unique node features. To address this issue of anonymous MP-GCNs, <ref type="bibr" target="#b7">Murphy et al. (2019)</ref> introduced a framework, called Graph Relational Pooling (GRP), that assigns to each node an identifier that depends on the index ordering. This approach can be computationally expensive as it requires to account for all n! node permutations, thus requiring some sampling in practice. <ref type="bibr" target="#b25">You et al. (2019)</ref> proposed learnable position-aware embeddings based on random anchor sets of nodes for pairwise node (or, link) tasks. However, the random selection of anchor sets has limitations and their approach is not applicable on inductive node tasks. Similarly, one could think of using full or partial random node identifiers for breaking node-anonymity. Yet, it suffers from generalization to unseen graphs <ref type="bibr" target="#b25">(You et al., 2019;</ref><ref type="bibr">Loukas, 2020)</ref>. <ref type="bibr">Li et al. (2020)</ref> proposed the use of distance encoding as node attributes which captures distances between nodes using power(s) of random walk matrix. However, their failure on distance regular graphs <ref type="bibr">(Li et al., 2020)</ref> and the cost of computing the power matrices may be limiting to scale to diverse and medium to large-scale graphs. We improve upon these works and propose the use of Laplacian eigenvectors as positional encodings.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E.1.2 Laplacian eigenvectors as Positional Encodings</head><p>We keep the overall MP-GCN architecture and simply add positional features to each node before processing the graph through the MP-GCN. Intuitively, the positional features should be chosen such that nodes which are far apart in the graph have different positional features whereas nodes which are nearby have similar positional features. As node positional features, we propose to use graph Laplacian eigenvectors <ref type="bibr">(Belkin and Niyogi, 2003)</ref>, which have less ambiguities and which better describe the distance between nodes on the graph. Formally, Laplacian eigenvectors are spectral techniques that embed the graphs into the Euclidean space. These vectors form a meaningful local coordinate system, while preserving the global graph structure. Mathematically, they are defined via the factorization of the graph Laplacian matrix;</p><formula xml:id="formula_48">? = I ? D ?1/2 AD ?1/2 = U T ?U,<label>(48)</label></formula><p>where A is the n ? n adjacency matrix, D is the degree matrix, and ?, U correspond respectively to the eigenvalues and eigenvectors. Laplacian eigenvectors also represent a natural generalization of the Transformer (Vaswani et al., 2017) positional encodings (PE) for graphs as the eigenvectors of a discrete line (NLP graph) are the cosine and sinusoidal functions. The computational complexity O(E 3/2 ), with E being the number of edges, can be improved with, e.g. the Nystrom method <ref type="bibr">(Fowlkes et al., 2004)</ref>. The eigenvectors are defined up to the factor ?1 (after being normalized to unit length), so the sign of eigenvectors will be randomly flipped during training. For the experiments, we use the k smallest non-trivial eigenvectors, where the k value is given in the respective experiment tables in Section C as the dimensions of the PE. The smallest eigenvectors provide smooth encoding coordinates of neighboring nodes. See Section E.1.4 for additional discussion about positional encodings and the reasoning behind our decision to use random sign flipping.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E.1.3 Experiments and Analysis</head><p>We first use the mathematical graphs such as CSL, CYCLES and GraphTheoryProp included in our benchmark (Sections C.8-C.10) to validate the proposed Laplacian PE as simple augmentations in MP-GCNs to improve their performance on the datasets. On CSL dataset, <ref type="table" target="#tab_20">Table 10</ref> compares the MP-GCNs using the Laplacian eigenvectors as PE and the WL-GNNs. The MP-GCN models were the most accurate with 99% of mean accuracy, while 3WL-GNN obtained 97% and RingGNN 25% with our experimental setting. Similarly, in <ref type="table" target="#tab_6">Table 11 for  CYCLES dataset and Table 12</ref> for GraphTheoryProp dataset, where we simply select 2 representative MP-GCNs (GINs and GatedGCNs), we observe a consistent improvement in the performance when GINs and GatedGCNs are augmented with Laplacian PE. This demonstrates the importance of positional features to successfully detect cycles in a graph, and also predict critical theoretical and geometric properties in a graph. Next, we study ZINC, AQSOL, WikiCS, PATTERN, CLUSTER and COLLAB with PE (note that MNIST, CIFAR10 and TSP do not need PE as the nodes in these graphs already have features describing their positions in R 2 ). We observe a boost of performance for ZINC, AQSOL and CLUSTER (it was expected as eigenvectors are good indicators of clusters <ref type="bibr" target="#b14">(Von Luxburg, 2007)</ref>), an improvement for PATTERN, and statistically the same result for COLLAB, see the respective tables in Section C. This way, MP-GCNs can be augmented with Laplacian PE to overcome their limitations of not being able to detect simple graph symmetries. Additionally, PEs also boost the models' performance on real-world graph learning tasks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E.1.4 Challenges with using Laplacian eigenvectors</head><p>Ideally, positional encodings (PEs) should be unique for each node, and nodes which are far apart in the graph should have different positional features whereas nodes which are nearby have similar positional features. Note that in a graph that has some symmetries, positional features cannot be assigned in a canonical way. For example, if node i and node j are structurally symmetric, and we have positional features p i = a, p j = b that differentiate them, then it is also possible to arbitrary choose p i = b, p j = a since i and j are completely symmetric by definition. In other words, the PE is always arbitrary up to the number of symmetries in the graph. As a consequence, the network will have to learn to deal with these ambiguities during training. The simplest possible positional encodings is to give an (arbitrary) ordering to the nodes, among n! possible orderings. During training, the orderings are uniformly sampled from the n! possible choices in order for the network to learn to be independent to these arbitrary choices <ref type="bibr" target="#b7">(Murphy et al., 2019)</ref>.</p><p>We propose an alternative to reduce the sampling space, and therefore the amount of ambiguities to be resolved by the network. Laplacian eigenvectors are hybrid positional and structural encodings, as they are invariant by node re-parametrization. However, they are also limited by natural symmetries such as the arbitrary sign of eigenvectors (after being normalized to have unit length). The number of possible sign flips is 2 k , where k is the number of eigenvectors. In practice we choose k n, and therefore 2 k is much smaller n! (the number of possible ordering of the nodes). During the training, the eigenvectors will be uniformly sampled at random between the 2 k possibilities. If we do not seek to learn the invariance w.r.t. all possible sign flips of eigenvectors, then we can remove the sign ambiguity  Numerical results for different positional encodings are reported in <ref type="table" target="#tab_8">Table 13</ref>. For all results, we use the GatedGCN model <ref type="bibr">(Bresson and Laurent, 2017)</ref>. We study 5 types of positional encodings; EigVecs-k corresponds to the smallest non-trivial k eigenvectors, Rand sign(EigVecs) randomly flips the sign of the k smallest non-trivial eigenvectors in each batch, Abs(EigVecs) takes the absolute value of the k eigenvectors, Fixed node ordering uses the original node ordering of graphs, and Rand node ordering randomly permutes ordering of nodes in each batch. We observed that the best results are consistently produced with the Laplacian PEs with random sign flipping at training. For index PEs, randomly permuting the ordering of nodes also improves significantly the performances over keeping fixed the original node ordering. However, Laplacian PEs clearly outperform index PEs. E.2 Edge representations for link prediction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E.2.1 With GatedGCN and GAT</head><p>The TSP and COLLAB edge classification tasks present an interesting empirical result for GCNs: Isotropic models (vanilla GCN, GraphSage) are consistently outperformed by their Anisotropic counterparts which use joint representations of adjacent nodes as edge features during aggregation <ref type="bibr">(GAT, GatedGCN)</ref>. In this section, we systematically study the impact of anisotropy by instantiating three variants of GAT and GatedGCN:</p><p>(1) Isotropic aggregation (such as vanilla GCNs (Kipf and Welling, 2017)) with node updates of the form: <ref type="table" target="#tab_10">Table 14</ref>;</p><formula xml:id="formula_49">h +1 i = ? j?N i W h j , identified by (E.Feat,E.Repr =x,x) in</formula><p>(2) Anisotropy using edge features (such as GAT by default (Veli?kovi? et al., 2018)) with node updates as:</p><formula xml:id="formula_51">h +1 i = ? j?N i f V (h i , h j ) ? W h j , with (E.Feat,E.Repr = ,x);<label>(50)</label></formula><p>and <ref type="formula" target="#formula_4">(3)</ref> Anisotropy with edge features and explicit edge representations updated at each layer with node/edge updates as (such as in GatedGCN by default (Bresson and Laurent, 2017)):</p><formula xml:id="formula_52">h +1 i = ? j?N i e ij ? W h j , e +1 ij = f V h i , h j , e ij ), with (E.Feat,E.Repr = , ). (51)</formula><p>The formal update equations of the three variants of GatedGCN are: Isotropic, similar to vanilla GCNs with sum aggregation:</p><formula xml:id="formula_53">h +1 i = h i + ReLU BN U h i + j?N i V h j , where U , V ? R d?d .<label>(52)</label></formula><p>Anisotropic with intermediate edge features computed as joint representations of adjacent node features at each layer:</p><formula xml:id="formula_54">h +1 i = h i + ReLU BN U h i + j?N i e ij V h j ,<label>(53)</label></formula><formula xml:id="formula_55">e ij = ?(? ij ) j ?N i ?(? ij ) + ? ,? ij = A h ?1 i + B h ?1 j ,<label>(54)</label></formula><p>where U , V ? R d?d , is the Hadamard product, and e ij are the edge gates.</p><p>Anisotropic with edge features as well as explicit edge representations updated across layers in addition to node features, as in GatedGCN by default, Eq.(16):</p><formula xml:id="formula_56">h +1 i = h i + ReLU BN U h i + j?N i e ij V h j ,<label>(55)</label></formula><formula xml:id="formula_57">e ij = ?(? ij ) j ?N i ?(? ij ) + ? ,<label>(56)</label></formula><formula xml:id="formula_58">e ij =? ?1 ij + ReLU BN A h ?1 i + B h ?1 j + C ? ?1 ij ,<label>(57)</label></formula><p>where U , V ? R d?d , is the Hadamard product, and e ij are the edge gates. The input edge features from the datasets (e.g. distances for TSP, collaboration year and frequency for COLLAB) can optionally be used to initialize the edge representations? =0 ij . Note that there may be a multitude of approaches to instantiating anisotropic GNNs and using edge features <ref type="bibr">(Battaglia et al., 2016;</ref><ref type="bibr">Sanchez-Gonzalez et al., 2018;</ref><ref type="bibr">Brockschmidt, 2019)</ref> besides the ones we consider.</p><p>The formal update equations of the three variants of GAT are: Isotropic, similar to multi-headed vanilla GCNs with sum aggregation:</p><formula xml:id="formula_59">h +1 i = Concat K k=1 ELU BN j?N i U k, h j , where U k, ? R d K ?d .<label>(58)</label></formula><p>Anisotropic with intermediate edge features computed as joint representations of adjacent node features at each layer, as in GAT by default, Eq. <ref type="formula" target="#formula_1">(10)</ref>:</p><formula xml:id="formula_60">h +1 i = h i + ELU BN Concat K k=1 j?N i e k, ij U k, h j ,<label>(59)</label></formula><formula xml:id="formula_61">e k, ij = exp(? k, ij ) j ?N i exp(? k, ij ) ,? k, ij = LeakyReLU V k, Concat U k, h i , U k, h j ,<label>(60)</label></formula><p>where U k, ? R d K ?d , V k, ? R 2d K are the K linear projection heads and e k, ij are the attention coefficients for each head. Anisotropic with edge features as well as explicit edge representations updated across layers in addition to node features: ,</p><formula xml:id="formula_62">h +1 i = h i + ELU BN Concat K k=1 j?N i a k, ij U k, h j ,<label>(61)</label></formula><formula xml:id="formula_63">a k, ij = LeakyReLU V k, Concat A k, e ij , U k, h i , U k, h j ,<label>(63)</label></formula><p>where</p><formula xml:id="formula_65">U k, ? R d K ?d , V k, ? R 3d K , A k, ? R d K ?d , B k, ? R d K ? 3d</formula><p>K are the K linear projection heads and a k, ij are the attention coefficients for each head. The input edge features from the datasets can optionally be used to initialize the edge representations e =0 ij .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Numerical Experiments and Analysis</head><p>In <ref type="table" target="#tab_10">Table 14</ref>, we show the experiments of the three variants of GatedGCN and GAT on TSP and COLLAB. GatedGCN-E and GAT-E in Table are models using input edge features from the datasets to initialize the edge representations e ij . As maintaining edge representations comes with a time and memory cost for the large COLLAB graph, all models use a reduced budget of 27K parameters to fit the GPU memory, and are allowed to train for a maximum of 24 hours for convergence.</p><p>On both TSP and COLLAB, upgrading isotropic models with edge features significantly boosts performance given the same model parameters (e.g. 0.75 vs. 0.64 F1 score on TSP, 50.6% vs. 35.9% Hits@50 on COLLAB for GatedGCN with edge features vs. the isotropic variant). Maintaining explicit edge representations across layers further improves F1 score for TSP, especially when initializing the edge representations with euclidean distances between nodes (e.g. 0.78 vs. 0.67 F1 score for GAT-E vs. standard GAT). On COLLAB, adding explicit edge representations and inputs degrades performance, suggesting that the features (collaboration frequency and year) are not useful for the link prediction task (e.g. 47.2 vs. 51.5 Hits@50 for GatedGCN-E vs. GatedGCN). As suggested by <ref type="bibr">Hu et al. (2020)</ref>, it would be interesting to treat COLLAB as a multi-graph with temporal edges, motivating the development of task-specific anisotropic edge representations beyond generic attention and gating mechanisms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E.2.2 With GraphSage</head><p>Interestingly, in <ref type="table" target="#tab_11">Table 5</ref> for COLLAB, we found that the isotropic GraphSage with max aggregation performs close to GAT and GatedGCN models, both of which perform anisotropic mean aggregation. On the other hand, models which use sum aggregation (GIN, MoNet) are unable to beat the simple matrix factorization baseline. This result indicates that aggregation functions which are invariant to node degree (max and mean) provide a powerful inductive bias for COLLAB.</p><p>We instantiate two anisotropic variants of GraphSage, as described in the following paragraphs, and compare them to GAT and GatedGCN on COLLAB in <ref type="table" target="#tab_11">Table 15</ref>. We find that upgrading max aggregators with edge features does not significantly boost performance. On the other hand, maintaining explicit edge representations across layers hurts the models, presumably due to using very small hidden dimensions. (As previously mentioned, maintaining representations for both 235K nodes and 2.3M edges leads to significant GPU memory usage and requires using smaller hidden dimensions.)  Isotropic, as in GraphSage by default, Eq. <ref type="formula" target="#formula_9">(8)</ref>:</p><formula xml:id="formula_66">h +1 i = h i + ReLU BN U Concat h i , Max j?N i ReLU V h j ,<label>(65)</label></formula><p>where U ? R d?2d , V ? R d?d . Anisotropic with intermediate edge features computed as joint representations of adjacent node features at each layer:</p><formula xml:id="formula_67">h +1 i = h i + ReLU BN U Concat h i , Max j?N i ReLU ? e ij V h j ,<label>(66)</label></formula><formula xml:id="formula_68">e ij = A h ?1 i + h ?1 j ,<label>(67)</label></formula><p>where U ? R d?2d , V , A ? R d?d , is the Hadamard product, and e ij are the edge gates. Anisotropic with edge features as well as explicit edge representations updated across layers in addition to node features:</p><formula xml:id="formula_69">h +1 i = h i + ReLU BN U Concat h i , Max j?N i ReLU ? ? ij V h j ,<label>(68)</label></formula><formula xml:id="formula_70">e ij = A h ?1 i + h ?1 j + B e ?1 ij , e +1 ij = e ij + ReLU BN ? ij ,<label>(69)</label></formula><p>where U ? R d?2d , V , A , B ? R d?d , is the Hadamard product, and? ij are the edge gates. The input edge features from the datasets can optionally be used to initialize the edge representations e =0 ij .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix F. Experiments on TU datasets</head><p>Apart from the proposed datasets in our benchmark (Section C), we perform experiments on 3 TU datasets for graph classification -ENZYMES, DD and PROTEINS. Our goal is to empirically highlight some of the challenges of using these conventional datasets for benchmarking GNNs. <ref type="table" target="#tab_13">Table 16</ref>: Performance on the TU datasets with 10-fold cross validation (higher is better). Two runs of all the experiments using the same hyperparameters but different random seeds are shown separately to note the differences in ranking and variation for reproducibility. The top 3 performance scores are highlighted as First, Second, Third.</p><p>Splitting. Since the 3 TU datasets that we use do not have standard splits, we perform a 10-fold cross validation split which gives 10 sets of train, validation and test data indices in the ratio 8 : 1 : 1. We use stratified sampling to ensure that the class distribution remains the same across splits. The indices are saved and used across all experiments for fair comparisons. There are 480 train/60 validation/60 test graphs for ENZYMES, 941 train/118 validation/119 test graphs for DD, and 889 train/112 validation/112 test graphs for PROTEINS datasets in each of the folds. Training. We use Adam optimizer with a similar learning rate strategy as used in our benchmark's experimental protocol. An initial learning rate is tuned from a range of 1 ? 10 ?3 to 7 ? 10 ?5 using grid search for every GNN models. The learning rate reduce factor is 0.5, the patience value is 25 and the stopping learning rate is 1 ? 10 ?6 . Performance Measure. We use classification accuracy between the predicted labels and groundtruth labels as our performance measure. The model performance is evaluated on the test split of the 10 folds for all TU datasets, and reported as the average and the standard deviation of the 10 scores.</p><p>Our numerical results on the TU datasets -ENZYMES, DD and PROTEINS are presented in <ref type="table" target="#tab_13">Table 16</ref>. We observe all NNs have similar statistical test performance as the standard deviation is quite large. We also report a second run of these experiments with the same experimental protocol, i.e. the same 10-fold splitting and hyperparameters but different initialization (seed). We observe a change of model ranking, which we attribute to the small size of the datasets and the non-determinism of gradient descent optimizers. We also observe that, for DD and PROTEINS, the graph-agnostic MLP baselines perform as good as</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 :</head><label>4</label><figDesc>A generic graph neural network layer. Figure adapted from Bresson and Laurent (2017).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>ReLUFigure</head><label></label><figDesc>Figure 5: GCN Layer</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>2dK</head><label></label><figDesc>, seeFigure 7. GAT learns a mean over each node's neighborhood features sparsely weighted by the importance of each neighbor.MoNet<ref type="bibr" target="#b3">(Monti et al., 2017a)</ref> The MoNet model introduces a general architecture to learn on graphs and manifolds using the Bayesian Gaussian Mixture Model (GMM) (Dempster</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>standard sparse attention mechanism (Bahdanau et al., 2014). Different from other anisotropic GNNs, the GatedGCN architecture explicitly maintains edge features? ij at each layer, following Bresson and Laurent (2019); Joshi et al. (2019).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>ConcatFigure 11 :</head><label>11</label><figDesc>3WL-GNN Layer ReLU + Figure 12: RingGNN Layer discriminative k-WL GNNs in (Morris et al., 2019; Maron et al., 2019a). However, k-WL GNNs require the use of tensors of rank k, which is intractable in practice for k &gt; 2. As a result, Maron et al. (2019a) proposed a model, namely 3-WL GNNs, that uses rank-2 tensors while being 3-WL provable. This 3-WL model improves the space/time complexities of Morris et al. (2019) from O(n 3 )/O(n 4 ) to O(n 2 )/O(n 3 ) respectively. We use 3WLGNNs (Maron et al., 2019a) and RingGNNs (Chen et al., 2019b) as the GNN instances in this class, the experimental pipeline of which are described as follows.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>-GNNs (Chen et al., 2019b) These models proposed to improve the order-2 equivariant GNNs of Maron et al. (2019b) with the multiplication of two equivariant linear layers. The layer update equation of Ring-GNNs is designed as:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>We have followed the original author implementations in Maron et al. (2019a,b); Chen et al. (2019b) to design the classifier layer for 3WL-GNNs and Ring-GNNs. Similar to Xu et al. (2018, 2019), the classifier layer for Ring-GNNs uses features from all intermediate layers and then passes the features to a MLP:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 14 :</head><label>14</label><figDesc>Sample graphs from the TSP dataset. Nodes are colored blue and edges on the groundtruth TSP tours are colored red.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head></head><label></label><figDesc>of eigenvectors by taking the absolute value. This choice seriously degrades the expressivity power of the positional features.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>. Developing powerful Benchmarking Graph Neural Networks Framework data configs layers nets train Main fileDGL graph learning library based on PyTorch</head><label></label><figDesc></figDesc><table><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>-Imports methods from other</cell></row><row><cell>-Data loading files -Customizable, eg. add positional encodings -Add custom dataset</cell><cell>-Config files for gnn, dataset, parameters and hyperparams. -Customizable, eg. tweak hyperparams.</cell><cell>-GNN network files of multiple layers -Customizable, eg. try combination of different layers</cell><cell>-Train and Eval scripts -Different scripts for sparse MP-GNNs and dense WL-GNNs -Customizable, eg.</cell><cell>modules: data, configs,nets, train -Executes 1 run of a single experiment -Selected config file decides</cell></row><row><cell></cell><cell>-Add custom configs</cell><cell></cell><cell>tweak eval metrics</cell><cell>which GNN network to run on</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>which dataset.</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>-Customizable, eg. execution</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>of a different set of modules.</cell></row><row><cell cols="2">Each module can be customized, and extended to add new datasets (in data module), or new GNNs (in layers module), as few examples.</cell><cell>-GNN layer definition -Customizable, eg. adjust aggregation fn, or activations.</cell><cell></cell><cell>-1 file per task-dataset, ensuring the same fair comparison of all GNNs for the task-dataset chosen.</cell></row><row><cell></cell><cell></cell><cell>-Add custom layer</cell><cell></cell><cell></cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>Beatrice Bevilacqua, Fabrizio Frasca, Derek Lim, Balasubramaniam Srinivasan, Chen Cai, Gopinath Balamurugan, Michael M Bronstein, and Haggai Maron. Equivariant subgraph aggregation networks. arXiv preprint arXiv:2110.02910, 2021. Laird, and Donald B Rubin. Maximum likelihood from incomplete data via the em algorithm. Journal of the Royal Statistical Society: Series B Kool, Herke van Hoof, and Max Welling. Attention, learn to solve routing problems! In International Conference on Learning Representations, 2019. Devin Kreuzer, Dominique Beaini, Will Hamilton, Vincent L?tourneau, and Prudencio Tossou. Rethinking graph transformers with spectral attention. Advances in Neural Information Processing Systems, 34, 2021.</figDesc><table><row><cell>Giorgos Bouritsas, Fabrizio Frasca, Stefanos P Zafeiriou, and Michael Bronstein. Improving graph neural network expressivity via subgraph isomorphism counting. IEEE Transactions on Pattern Analysis and Machine Intelligence, 2022. (Methodological), 39(1):1-22, 1977. J. Deng, W. Dong, R. Socher, L.-J. Li, K. Li, and L. Fei-Fei. ImageNet: A Large-Scale Hierarchical Image Database. In CVPR09, 2009. Austin Derrow-Pinion, Jennifer She, David Wong, Oliver Lange, Todd Hester, Luis Perez, Alvaro Sanchez-Gonzalez, Nicolas Heess, Jost Tobias Springenberg, Josh Merel, Martin Riedmiller, Raia Hadsell, and Peter Battaglia. Graph networks as learnable physics engines for inference and control. In International Conference on Machine Learning, pages 4470-4479, 2018. Alvaro Sanchez-Gonzalez, Jonathan Godwin, Tobias Pfaff, Rex Ying, Jure Leskovec, and preprint arXiv:2002.09405, 2020. Haimin Zhang, Min Xu, Guoqiang Zhang, and Kenta Niwa. Ssfg: Stochastically scaling features and gradients for regularizing graph convolutional networks. arXiv preprint arXiv:2102.10338, 2021. Kaixiong Zhou, Xiao Huang, Yuening Li, Daochen Zha, Rui Chen, and Xia Hu. Towards deeper graph neural networks with differentiable group normalization. Advances in Neural Wouter Alex Krizhevsky, Ilya Sutskever, and Geoffrey E. Hinton. Imagenet classification with deep Peter W Battaglia. Learning to simulate complex physics with graph networks. arXiv Information Processing Systems, 33:4917-4928, 2020.</cell></row><row><cell>Xavier Bresson and Thomas Laurent. Residual gated graph convnets. arXiv preprint Marc Nunkesser, Seongjae Lee, Xueying Guo, Brett Wiltshire, et al. Eta prediction with convolutional neural networks. In Advances in Neural Information Processing Systems 25:</cell></row><row><cell>arXiv:1711.07553, 2017. graph neural networks in google maps. In Proceedings of the 30th ACM International 26th Annual Conference on Neural Information Processing Systems 2012., pages 1106-1114, F. Scarselli, M. Gori, A. Tsoi, M. Hagenbuchner, and G. Monfardini. The Graph Neural</cell></row><row><cell>Xavier Bresson and Thomas Laurent. A two-step graph convolutional decoder for molecule Conference on Information &amp; Knowledge Management, pages 3767-3776, 2021. 2012. Network Model. IEEE Transactions on Neural Networks, 20(1):61-80, 2009.</cell></row><row><cell>generation. In NeurIPS Workshop on Machine Learning and the Physical Sciences, 2019. David K Duvenaud, Dougal Maclaurin, Jorge Iparraguirre, Rafael Bombarell, Timothy Yann LeCun, Yoshua Bengio, et al. Convolutional networks for images, speech, and time Michael Schlichtkrull, Thomas N Kipf, Peter Bloem, Rianne Van Den Berg, Ivan Titov, and</cell></row><row><cell>Hirzel, Al?n Aspuru-Guzik, and Ryan P Adams. Convolutional networks on graphs for series. 1995. Max Welling. Modeling relational data with graph convolutional networks. In European</cell></row><row><cell>learning molecular fingerprints. In Advances in neural information processing systems, Semantic Web Conference, pages 593-607. Springer, 2018.</cell></row><row><cell>pages 2224-2232, 2015. Murat Cihan Sorkun, Abhishek Khetan, and S?leyman Er. Aqsoldb, a curated reference set</cell></row><row><cell>of aqueous solubility and 2d descriptors for a diverse set of compounds. Scientific data, 6</cell></row><row><cell>(1):1-8, 2019.</cell></row><row><cell>Balasubramaniam Srinivasan and Bruno Ribeiro. On the equivalence between node em-</cell></row><row><cell>beddings and structural graph representations. International Conference on Learning</cell></row><row><cell>Representations, 2020.</cell></row><row><cell>Sainbayar Sukhbaatar, arthur szlam, and Rob Fergus. Learning multiagent communication</cell></row><row><cell>with backpropagation. In D. D. Lee, M. Sugiyama, U. V. Luxburg, I. Guyon, and R. Garnett,</cell></row><row><cell>editors, Advances in Neural Information Processing Systems 29, pages 2244-2252. 2016.</cell></row><row><cell>Shyam A Tailor, Javier Fernandez-Marques, and Nicholas D Lane. Degree-quant:</cell></row><row><cell>Quantization-aware training for graph neural networks. arXiv preprint arXiv:2008.05000,</cell></row><row><cell>2020.</cell></row><row><cell>Shyam A Tailor, Felix Opolka, Pietro Lio, and Nicholas Donald Lane. Do we need anisotropic</cell></row><row><cell>graph neural networks? In International Conference on Learning Representations, 2021.</cell></row><row><cell>Diego Valsesia, Giulia Fracastoro, and Enrico Magli. Ran-gnns: breaking the capacity limits</cell></row><row><cell>of graph neural networks. IEEE Transactions on Neural Networks and Learning Systems,</cell></row><row><cell>2021.</cell></row><row><cell>Gabriele Corso, Luca Cavalleri, Dominique Beaini, Pietro Li?, and Petar Veli?kovi?. Principal Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N Gomez,</cell></row><row><cell>neighbourhood aggregation for graph nets. Advances in Neural Information Processing Haggai Maron, Heli Ben-Hamu, Hadar Serviansky, and Yaron Lipman. Provably powerful ?ukasz Kaiser, and Illia Polosukhin. Attention is all you need. In Advances in neural</cell></row><row><cell>Systems, 33:13260-13271, 2020. graph networks. In Advances in Neural Information Processing Systems, pages 2153-2164, information processing systems, pages 5998-6008, 2017.</cell></row><row><cell>2019a.</cell></row><row><cell>Miles D Cranmer, Rui Xu, Peter Battaglia, and Shirley Ho. Learning symbolic physics with Petar Veli?kovi?, Guillem Cucurull, Arantxa Casanova, Adriana Romero, Pietro Li?, and</cell></row><row><cell>graph networks. arXiv preprint arXiv:1909.05862, 2019. Haggai Maron, Heli Ben-Hamu, Nadav Shamir, and Yaron Lipman. Invariant and equivariant Yoshua Bengio. Graph Attention Networks. International Conference on Learning Repre-</cell></row><row><cell>graph networks. International Conference on Learning Representations, 2019b. sentations, 2018.</cell></row><row><cell>Clement Vignac, Andreas Loukas, and Pascal Frossard. Building powerful and equivariant</cell></row><row><cell>graph neural networks with structural message-passing, 2020.</cell></row></table><note>Marc Brockschmidt. Gnn-film: Graph neural networks with feature-wise linear modulation. arXiv preprint arXiv:1906.12192, 2019. Joan Bruna, Wojciech Zaremba, Arthur Szlam, and Yann LeCun. Spectral networks and locally connected networks on graphs. arXiv preprint arXiv:1312.6203, 2013. Ines Chami, Adva Wolf, Da-Cheng Juan, Frederic Sala, Sujith Ravi, and Christopher R?. Low- dimensional hyperbolic knowledge graph embeddings. arXiv preprint arXiv:2005.00545, 2020. Ting Chen, Song Bian, and Yizhou Sun. Are powerful graph neural nets necessary? a dissection on graph classification, 2019a. Yihao Chen, Xin Tang, Xianbiao Qi, Chun-Guang Li, and Rong Xiao. Learning graph normalization for graph neural networks. Neurocomputing, 2022. Zhengdao Chen, Soledad Villar, Lei Chen, and Joan Bruna. On the equivalence between graph isomorphism testing and function approximation with gnns. In Advances in Neural Information Processing Systems, pages 15868-15876, 2019b. Wei-Lin Chiang, Xuanqing Liu, Si Si, Yang Li, Samy Bengio, and Cho-Jui Hsieh. Cluster- gcn: An efficient algorithm for training deep and large graph convolutional networks. In Proceedings of the 25th ACM SIGKDD International Conference on Knowledge Discovery &amp; Data Mining, pages 257-266, 2019.Micha?l Defferrard, Xavier Bresson, and Pierre Vandergheynst. Convolutional neural networks on graphs with fast localized spectral filtering. In Advances in Neural Information Processing Systems 29, pages 3844-3852. 2016. Arthur P Dempster, Nan MVijay Prakash Dwivedi and Xavier Bresson. A generalization of transformer networks to graphs. AAAI Workshop on Deep Learning on Graphs: Methods and Applications, 2021.Yann LeCun, L?on Bottou, Yoshua Bengio, and Patrick Haffner. Gradient-based learning applied to document recognition. Proceedings of the IEEE, 86(11):2278-2324, 1998. Pan Li, Yanbang Wang, Hongwei Wang, and Jure Leskovec. Distance encoding-design provably more powerful gnns for structural representation learning. arXiv preprint arXiv:2009.00142, 2020. Derek Lim, Joshua David Robinson, Lingxiao Zhao, Tess Smidt, Suvrit Sra, Haggai Maron, and Stefanie Jegelka. Sign and basis invariant networks for spectral graph representation learning. In ICLR 2022 Workshop on Geometrical and Topological Representation Learning, 2022. Andreas Loukas. What graph neural networks cannot learn: depth vs width. In International Conference on Learning Representations, 2020. URL https://openreview.net/forum? id=B1l2bp4YwS. Enxhell Luzhnica, Ben Day, and Pietro Li?. On graph classification networks, datasets and baselines. arXiv preprint arXiv:1905.04682, 2019. Jitendra Malik. Technical perspective: What led computer vision to deep learning? Commun. ACM, 60(6):82-83, May 2017. ISSN 0001-0782. Diego Marcheggiani and Ivan Titov. Encoding sentences with graph convolutional networks for semantic role labeling. arXiv preprint arXiv:1703.04826, 2017.Haggai Maron, Ethan Fetaya, Nimrod Segol, and Yaron Lipman. On the universality of invariant networks. International Conference on Machine Learning, 2019c.</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>Table 2 :</head><label>2</label><figDesc>Summary statistics of all datasets. Numbers in parentheses of Node features and Edge features are the dimensions. S.P. denotes shortest path.</figDesc><table /><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head></head><label></label><figDesc>ZINC Model L #Param Test MAE?s.d. Train MAE?s.d. #Epoch Epoch/Total</figDesc><table><row><cell>MLP</cell><cell>4</cell><cell>108975</cell><cell>0.706?0.006</cell><cell>0.644?0.005</cell><cell>116.75</cell><cell>1.01s/0.03hr</cell></row><row><cell>vanilla GCN</cell><cell>4</cell><cell>103077</cell><cell>0.459?0.006</cell><cell>0.343?0.011</cell><cell>196.25</cell><cell>2.89s/0.16hr</cell></row><row><cell></cell><cell>16</cell><cell>505079</cell><cell>0.367?0.011</cell><cell>0.128?0.019</cell><cell>197.00</cell><cell>12.78s/0.71hr</cell></row><row><cell>GraphSage</cell><cell>4</cell><cell>94977</cell><cell>0.468?0.003</cell><cell>0.251?0.004</cell><cell>147.25</cell><cell>3.74s/0.15hr</cell></row><row><cell></cell><cell>16</cell><cell>505341</cell><cell>0.398?0.002</cell><cell>0.081?0.009</cell><cell>145.50</cell><cell>16.61s/0.68hr</cell></row><row><cell>GCN</cell><cell>4</cell><cell>103077</cell><cell>0.416?0.006</cell><cell>0.313?0.011</cell><cell>159.50</cell><cell>1.53s/0.07hr</cell></row><row><cell></cell><cell>16</cell><cell>505079</cell><cell>0.278?0.003</cell><cell>0.101?0.011</cell><cell>159.25</cell><cell>3.66s/0.16hr</cell></row><row><cell>MoNet</cell><cell>4</cell><cell>106002</cell><cell>0.397?0.010</cell><cell>0.318?0.016</cell><cell>188.25</cell><cell>1.97s/0.10hr</cell></row><row><cell></cell><cell>16</cell><cell>504013</cell><cell>0.292?0.006</cell><cell>0.093?0.014</cell><cell>171.75</cell><cell>10.82s/0.52hr</cell></row><row><cell>GAT</cell><cell>4</cell><cell>102385</cell><cell>0.475?0.007</cell><cell>0.317?0.006</cell><cell>137.50</cell><cell>2.93s/0.11hr</cell></row><row><cell></cell><cell>16</cell><cell>531345</cell><cell>0.384?0.007</cell><cell>0.067?0.004</cell><cell>144.00</cell><cell>12.98s/0.53hr</cell></row><row><cell>GatedGCN</cell><cell>4</cell><cell>105735</cell><cell>0.435?0.011</cell><cell>0.287?0.014</cell><cell>173.50</cell><cell>5.76s/0.28hr</cell></row><row><cell>GatedGCN-E</cell><cell>4</cell><cell>105875</cell><cell>0.375?0.003</cell><cell>0.236?0.007</cell><cell>194.75</cell><cell>5.37s/0.29hr</cell></row><row><cell></cell><cell>16</cell><cell>504309</cell><cell>0.282?0.015</cell><cell>0.074?0.016</cell><cell>166.75</cell><cell>20.50s/0.96hr</cell></row><row><cell cols="2">GatedGCN-E-PE 16</cell><cell>505011</cell><cell>0.214?0.013</cell><cell>0.067?0.019</cell><cell>185.00</cell><cell>10.70s/0.56hr</cell></row><row><cell>GIN</cell><cell>4</cell><cell>103079</cell><cell>0.387?0.015</cell><cell>0.319?0.015</cell><cell>153.25</cell><cell>2.29s/0.10hr</cell></row><row><cell></cell><cell>16</cell><cell>509549</cell><cell>0.526?0.051</cell><cell>0.444?0.039</cell><cell>147.00</cell><cell>10.22s/0.42hr</cell></row><row><cell>RingGNN</cell><cell>2</cell><cell>97978</cell><cell>0.512?0.023</cell><cell>0.383?0.020</cell><cell>90.25</cell><cell>327.65s/8.32hr</cell></row><row><cell>RingGNN-E</cell><cell>2</cell><cell>104403</cell><cell>0.363?0.026</cell><cell>0.243?0.025</cell><cell>95.00</cell><cell>366.29s/9.76hr</cell></row><row><cell></cell><cell>2</cell><cell>527283</cell><cell>0.353?0.019</cell><cell>0.236?0.019</cell><cell>79.75</cell><cell>293.94s/6.63hr</cell></row><row><cell></cell><cell>8</cell><cell>510305</cell><cell>Diverged</cell><cell>Diverged</cell><cell>Diverged</cell><cell>Diverged</cell></row><row><cell>3WLGNN</cell><cell>3</cell><cell>102150</cell><cell>0.407?0.028</cell><cell>0.272?0.037</cell><cell>111.25</cell><cell>286.23s/8.88hr</cell></row><row><cell>3WLGNN-E</cell><cell>3</cell><cell>103098</cell><cell>0.256?0.054</cell><cell>0.140?0.044</cell><cell>117.25</cell><cell>334.69s/10.90hr</cell></row><row><cell></cell><cell>3</cell><cell>507603</cell><cell>0.303?0.068</cell><cell>0.173?0.041</cell><cell>120.25</cell><cell>329.49s/11.08hr</cell></row><row><cell></cell><cell>8</cell><cell>582824</cell><cell>0.303?0.057</cell><cell>0.246?0.043</cell><cell>52.50</cell><cell>811.27s/12.15hr</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head>Table 3 :</head><label>3</label><figDesc></figDesc><table /><note>Benchmarking results for ZINC for graph regression. Results (lower is better) are averaged over 4 runs with 4 different seeds. Red: the best model, Violet: good models. The suffix -E denotes the use of available edge features, and the suffix -PE denote the use of Laplacian Eigenvectors as node positional encodings with dimension 8.</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9"><head></head><label></label><figDesc>Model L #Param TestMAE?s.d. TrainMAE?s.d. Epochs Epoch/Total</figDesc><table><row><cell>MLP</cell><cell>4</cell><cell>114525</cell><cell>1.744?0.016</cell><cell>1.413?0.042</cell><cell>85.75</cell><cell>0.61s/0.02hr</cell></row><row><cell>vanilla GCN</cell><cell>4</cell><cell>108442</cell><cell>1.483?0.014</cell><cell>0.791?0.034</cell><cell>110.25</cell><cell>1.14s/0.04hr</cell></row><row><cell></cell><cell>16</cell><cell>511443</cell><cell>1.458?0.011</cell><cell>0.567?0.027</cell><cell>121.50</cell><cell>2.83s/0.10hr</cell></row><row><cell>GraphSage</cell><cell>4</cell><cell>109620</cell><cell>1.431?0.010</cell><cell>0.666?0.027</cell><cell>106.00</cell><cell>1.51s/0.05hr</cell></row><row><cell></cell><cell>16</cell><cell>509078</cell><cell>1.402?0.013</cell><cell>0.402?0.013</cell><cell>110.50</cell><cell>3.20s/0.10hr</cell></row><row><cell>GCN</cell><cell>4</cell><cell>108442</cell><cell>1.372?0.020</cell><cell>0.593?0.030</cell><cell>135.00</cell><cell>1.28s/0.05hr</cell></row><row><cell></cell><cell>16</cell><cell>511443</cell><cell>1.333?0.013</cell><cell>0.382?0.018</cell><cell>137.25</cell><cell>3.31s/0.13hr</cell></row><row><cell>MoNet</cell><cell>4</cell><cell>109332</cell><cell>1.395?0.027</cell><cell>0.557?0.022</cell><cell>125.50</cell><cell>1.68s/0.06hr</cell></row><row><cell></cell><cell>16</cell><cell>507750</cell><cell>1.501?0.056</cell><cell>0.444?0.024</cell><cell>110.00</cell><cell>3.62s/0.11hr</cell></row><row><cell>GAT</cell><cell>4</cell><cell>108289</cell><cell>1.441?0.023</cell><cell>0.678?0.021</cell><cell>104.50</cell><cell>1.92s/0.06hr</cell></row><row><cell></cell><cell>16</cell><cell>540673</cell><cell>1.403?0.008</cell><cell>0.386?0.014</cell><cell>111.75</cell><cell>4.44s/0.14hr</cell></row><row><cell>GatedGCN</cell><cell>4</cell><cell>108325</cell><cell>1.352?0.034</cell><cell>0.576?0.056</cell><cell>142.75</cell><cell>2.28s/0.09hr</cell></row><row><cell></cell><cell>16</cell><cell>507039</cell><cell>1.355?0.016</cell><cell>0.465?0.038</cell><cell>99.25</cell><cell>5.52s/0.16hr</cell></row><row><cell>GatedGCN-E</cell><cell>4</cell><cell>108535</cell><cell>1.295?0.016</cell><cell>0.544?0.033</cell><cell>116.25</cell><cell>2.29s/0.08hr</cell></row><row><cell></cell><cell>16</cell><cell>507273</cell><cell>1.308?0.013</cell><cell>0.367?0.012</cell><cell>110.25</cell><cell>5.61s/0.18hr</cell></row><row><cell cols="2">GatedGCN-E-PE 16</cell><cell>507663</cell><cell>0.996?0.008</cell><cell>0.372?0.016</cell><cell>105.25</cell><cell>5.70s/0.30hr</cell></row><row><cell>GIN</cell><cell>4</cell><cell>107149</cell><cell>1.894?0.024</cell><cell>0.660?0.027</cell><cell>115.75</cell><cell>1.55s/0.05hr</cell></row><row><cell></cell><cell>16</cell><cell>514137</cell><cell>1.962?0.058</cell><cell>0.850?0.054</cell><cell>128.50</cell><cell>3.97s/0.14hr</cell></row><row><cell>RingGNN</cell><cell>2</cell><cell>116643</cell><cell>20.264?7.549</cell><cell>0.625?0.018</cell><cell>54.25</cell><cell>113.99s/1.76hr</cell></row><row><cell>RingGNN-E</cell><cell>2</cell><cell>123157</cell><cell>3.769?1.012</cell><cell>0.470?0.022</cell><cell>63.75</cell><cell>125.17s/2.26hr</cell></row><row><cell></cell><cell>2</cell><cell>523935</cell><cell>Diverged</cell><cell>Diverged</cell><cell>Diverged</cell><cell>Diverged</cell></row><row><cell></cell><cell>8</cell><cell>-</cell><cell>Diverged</cell><cell>Diverged</cell><cell>Diverged</cell><cell>Diverged</cell></row><row><cell>3WLGNN</cell><cell>3</cell><cell>110919</cell><cell>1.154?0.050</cell><cell>0.434?0.026</cell><cell>66.75</cell><cell>130.92s/2.48hr</cell></row><row><cell></cell><cell>3</cell><cell>525423</cell><cell>1.108?0.036</cell><cell>0.405?0.031</cell><cell>70.75</cell><cell>131.12s/2.62hr</cell></row><row><cell>3WLGNN-E</cell><cell>3</cell><cell>112104</cell><cell>1.042?0.064</cell><cell>0.307?0.024</cell><cell>68.50</cell><cell>139.04s/2.70hr</cell></row><row><cell></cell><cell>3</cell><cell>528123</cell><cell>1.052?0.034</cell><cell>0.287?0.023</cell><cell>67.00</cell><cell>140.43s/2.67hr</cell></row><row><cell></cell><cell>8</cell><cell>-</cell><cell>Diverged</cell><cell>Diverged</cell><cell>Diverged</cell><cell>Diverged</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_10"><head>Table 4 :</head><label>4</label><figDesc>Benchmarking results for AQSOL for graph regression. Results (lower is better) are averaged over 4 runs with 4 different seeds. Red: the best model, Violet: good models. The suffix -E denotes the use of available edge features, and the suffix -PE denote the use of Laplacian Eigenvectors as node positional encodings with dimension 4. OGBL-COLLAB Model L #Param Test Hits?s.d. Train Hits?s.d. #Epoch Epoch/Total</figDesc><table><row><cell>MLP 3</cell><cell>39441</cell><cell>20.350?2.168</cell><cell>29.807?3.360</cell><cell>147.50</cell><cell>2.09s/0.09hr</cell></row><row><cell>vanilla GCN 3</cell><cell>40479</cell><cell>50.422?1.131</cell><cell>92.112?0.991</cell><cell>122.50</cell><cell>351.05s/12.04hr</cell></row><row><cell>GraphSage 3</cell><cell>39856</cell><cell>51.618?0.690</cell><cell>99.949?0.052</cell><cell>152.75</cell><cell>277.93s/11.87hr</cell></row><row><cell>GCN 3</cell><cell>40479</cell><cell>48.956?1.143</cell><cell>87.385?2.056</cell><cell>142.25</cell><cell>7.66s/0.31hr</cell></row><row><cell>MoNet 3</cell><cell>39751</cell><cell>36.144?2.191</cell><cell>61.156?3.973</cell><cell>167.50</cell><cell>26.69s/1.26hr</cell></row><row><cell>GAT 3</cell><cell>42637</cell><cell>51.501?0.962</cell><cell>97.851?1.114</cell><cell>157.00</cell><cell>18.12s/0.80hr</cell></row><row><cell>GatedGCN 3</cell><cell>40965</cell><cell>52.635?1.168</cell><cell>96.103?1.876</cell><cell>95.00</cell><cell>453.47s/12.09hr</cell></row><row><cell>GatedGCN-PE 3</cell><cell>41889</cell><cell>52.849?1.345</cell><cell>96.165?0.453</cell><cell>94.75</cell><cell>452.75s/12.08hr</cell></row><row><cell>GatedGCN-E 3</cell><cell>40965</cell><cell>49.212?1.560</cell><cell>88.747?1.058</cell><cell>95.00</cell><cell>451.21s/12.03hr</cell></row><row><cell>GIN 3</cell><cell>39544</cell><cell>41.730?2.284</cell><cell>70.555?4.444</cell><cell>140.25</cell><cell>8.66s/0.34hr</cell></row><row><cell>RingGNN -</cell><cell>-</cell><cell>OOM</cell><cell cols="3">RingGNN and 3WLGNN rely</cell></row><row><cell></cell><cell></cell><cell></cell><cell cols="3">on dense tensors which leads</cell></row><row><cell></cell><cell></cell><cell></cell><cell cols="3">to OOM on both GPU and</cell></row><row><cell>3WLGNN -</cell><cell>-</cell><cell>OOM</cell><cell cols="2">CPU memory.</cell><cell></cell></row><row><cell cols="2">Matrix Fact. -60546561</cell><cell>44.206?0.452</cell><cell>100.000?0.000</cell><cell>254.33</cell><cell>2.66s/0.21hr</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_11"><head>Table 5 :</head><label>5</label><figDesc></figDesc><table /><note>Benchmarking results for OGBL-COLLAB for link prediction. Results (higher is better) are averaged over 4 runs with 4 different seeds. Red: the best model, Violet: good models. The suffix -E denotes the use of available edge features, and the suffix -PE denote the use of Laplacian Eigenvectors as node positional encodings with dimension 20.</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_12"><head></head><label></label><figDesc>WikiCSModel L #Param Test Acc.?s.d. Train Acc.?s.d. #Epoch Epoch/Total</figDesc><table><row><cell>MLP 4</cell><cell>110710</cell><cell>59.359?0.619</cell><cell>85.332?1.456</cell><cell>321.18</cell><cell>0.01s/0.03hr</cell></row><row><cell>vanilla GCN 4</cell><cell>104560</cell><cell>77.096?0.086</cell><cell>98.950?0.089</cell><cell>294.77</cell><cell>0.05s/0.09hr</cell></row><row><cell>GraphSage 4</cell><cell>101775</cell><cell>74.862?0.147</cell><cell>99.976?0.011</cell><cell>303.85</cell><cell>0.06s/0.12hr</cell></row><row><cell>GCN 4</cell><cell>104560</cell><cell>77.457?0.127</cell><cell>98.959?0.119</cell><cell>300.24</cell><cell>0.06s/0.11hr</cell></row><row><cell>MoNet 4</cell><cell>106182</cell><cell>77.414?0.145</cell><cell>98.789?0.176</cell><cell>357.25</cell><cell>0.18s/0.36hr</cell></row><row><cell>MoNet-PE 4</cell><cell>107862</cell><cell>77.517?0.252</cell><cell>98.834?0.185</cell><cell>360.09</cell><cell>0.17s/0.73hr</cell></row><row><cell>GAT 4</cell><cell>105520</cell><cell>76.910?0.130</cell><cell>99.970?0.018</cell><cell>281.19</cell><cell>0.14s/0.23hr</cell></row><row><cell>GatedGCN 4</cell><cell>109280</cell><cell cols="2">OOM</cell><cell></cell><cell></cell></row><row><cell>GIN 4</cell><cell>109782</cell><cell>75.867?0.090</cell><cell>99.575?0.049</cell><cell>321.71</cell><cell>0.07s/0.13hr</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_13"><head>Table 6 :</head><label>6</label><figDesc>Benchmarking results for WikiCS for node classification. Results (higher is better) are averaged over 4 runs with 4 different seeds. Red: the best model, Violet: good models. The suffix -PE denote the use of Laplacian Eigenvectors as node positional encodings with dimension 20.</figDesc><table /><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_14"><head></head><label></label><figDesc>Figure 13: Sample images and their superpixel graphs. The graphs of SLIC superpixels (at most 75 nodes for MNIST and 150 nodes for CIFAR10) are 8-nearest neighbor graphs in the Euclidean space and node colors denote the mean pixel intensities.</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell>MNIST</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>CIFAR10</cell><cell></cell><cell></cell></row><row><cell cols="5">Model L #Param Test Acc.?s.d. Train Acc.?s.d. #Epoch</cell><cell>Epoch/Total</cell><cell cols="4">#Param Test Acc.?s.d. Train Acc.?s.d. #Epoch</cell><cell>Epoch/Total</cell></row><row><cell>MLP 4</cell><cell>104044</cell><cell>95.340?0.138</cell><cell>97.432?0.470</cell><cell>232.25</cell><cell>22.74s/1.48hr</cell><cell>104380</cell><cell>56.340?0.181</cell><cell>65.113?1.685</cell><cell>185.25</cell><cell>29.48s/1.53hr</cell></row><row><cell>vanilla GCN 4</cell><cell>101365</cell><cell>90.705?0.218</cell><cell>97.196?0.223</cell><cell>127.50</cell><cell>83.41s/2.99hr</cell><cell>101657</cell><cell>55.710?0.381</cell><cell>69.523?1.948</cell><cell>142.50</cell><cell>109.70s/4.39hr</cell></row><row><cell>GraphSage 4</cell><cell>104337</cell><cell>97.312?0.097</cell><cell>100.000?0.000</cell><cell>98.25</cell><cell>113.12s/3.13hr</cell><cell>104517</cell><cell>65.767?0.308</cell><cell>99.719?0.062</cell><cell>93.50</cell><cell>124.61s/3.29hr</cell></row><row><cell>GCN 4</cell><cell>101365</cell><cell>90.120?0.145</cell><cell>96.459?1.020</cell><cell>116.75</cell><cell>37.06s/1.22hr</cell><cell>101657</cell><cell>54.142?0.394</cell><cell>70.163?3.429</cell><cell>140.50</cell><cell>47.16s/1.86hr</cell></row><row><cell>MoNet 4</cell><cell>104049</cell><cell>90.805?0.032</cell><cell>96.609?0.440</cell><cell>146.25</cell><cell>93.19s/3.82hr</cell><cell>104229</cell><cell>54.655?0.518</cell><cell>65.911?2.515</cell><cell>141.50</cell><cell>97.13s/3.85hr</cell></row><row><cell>GAT 4</cell><cell>110400</cell><cell>95.535?0.205</cell><cell>99.994?0.008</cell><cell>104.75</cell><cell>42.26s/1.25hr</cell><cell>110704</cell><cell>64.223?0.455</cell><cell>89.114?0.499</cell><cell>103.75</cell><cell>55.27s/1.62hr</cell></row><row><cell>GatedGCN 4</cell><cell>104217</cell><cell>97.340?0.143</cell><cell>100.000?0.000</cell><cell>96.25</cell><cell>128.79s/3.50hr</cell><cell>104357</cell><cell>67.312?0.311</cell><cell>94.553?1.018</cell><cell>97.00</cell><cell>154.15s/4.22hr</cell></row><row><cell>GIN 4</cell><cell>105434</cell><cell>96.485?0.252</cell><cell>100.000?0.000</cell><cell>128.00</cell><cell>39.22s/1.41hr</cell><cell>105654</cell><cell>55.255?1.527</cell><cell>79.412?9.700</cell><cell>141.50</cell><cell>52.12s/2.07hr</cell></row><row><cell>RingGNN 2</cell><cell>105398</cell><cell>11.350?0.000</cell><cell>11.235?0.000</cell><cell>14.00</cell><cell>2945.69s/12.77hr</cell><cell>105165</cell><cell>19.300?16.108</cell><cell>19.556?16.397</cell><cell>13.50</cell><cell>3112.96s/13.00hr</cell></row><row><cell>2</cell><cell>505182</cell><cell>91.860?0.449</cell><cell>92.169?0.505</cell><cell>16.25</cell><cell>2575.99s/12.63hr</cell><cell>504949</cell><cell>39.165?17.114</cell><cell>40.209?17.790</cell><cell>13.75</cell><cell>2998.24s/12.60hr</cell></row><row><cell>8</cell><cell>506357</cell><cell>Diverged</cell><cell>Diverged</cell><cell>Diverged</cell><cell>Diverged</cell><cell>510439</cell><cell>Diverged</cell><cell>Diverged</cell><cell>Diverged</cell><cell>Diverged</cell></row><row><cell>3WLGNN 3</cell><cell>108024</cell><cell>95.075?0.961</cell><cell>95.830?1.338</cell><cell>27.75</cell><cell>1523.20s/12.40hr</cell><cell>108516</cell><cell>59.175?1.593</cell><cell>63.751?2.697</cell><cell>28.50</cell><cell>1506.29s/12.60hr</cell></row><row><cell>3</cell><cell>501690</cell><cell>95.002?0.419</cell><cell>95.692?0.677</cell><cell>26.25</cell><cell>1608.73s/12.42hr</cell><cell>502770</cell><cell>58.043?2.512</cell><cell>61.574?3.575</cell><cell>20.00</cell><cell>2091.22s/12.55hr</cell></row><row><cell>8</cell><cell>500816</cell><cell>Diverged</cell><cell>Diverged</cell><cell>Diverged</cell><cell>Diverged</cell><cell>501584</cell><cell>Diverged</cell><cell>Diverged</cell><cell>Diverged</cell><cell>Diverged</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_15"><head>Table 7 :</head><label>7</label><figDesc>Benchmarking results for Super-pixels datasets for graph classification. Results (higher is better) are averaged over 4 runs with 4 different seeds. Red: the best model, Violet: good models.</figDesc><table /><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_16"><head>Table 8 :</head><label>8</label><figDesc>Benchmarking results for SBMs datasets for node classification. Results (higher is better) are averaged over 4 runs with 4 different seeds. Red: the best model, Violet: good models. The suffix -PE denote the use of Laplacian Eigenvectors as node positional encodings with dimension 2 for PATTERN and 20 for CLUSTER.</figDesc><table /><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_17"><head></head><label></label><figDesc>TSPModel L #Param Test F1?s.d. Train F1?s.d. #Epoch   </figDesc><table><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>Epoch/Total</cell></row><row><cell>MLP</cell><cell>4</cell><cell>96956</cell><cell>0.544?0.001</cell><cell>0.544?0.001</cell><cell>164.25</cell><cell>50.15s/2.31hr</cell></row><row><cell>vanilla GCN</cell><cell>4</cell><cell>95702</cell><cell>0.630?0.001</cell><cell>0.631?0.001</cell><cell>261.00</cell><cell>152.89s/11.15hr</cell></row><row><cell>GraphSage</cell><cell>4</cell><cell>99263</cell><cell>0.665?0.003</cell><cell>0.669?0.003</cell><cell>266.00</cell><cell>157.26s/11.68hr</cell></row><row><cell>GCN</cell><cell>4</cell><cell>95702</cell><cell>0.643?0.001</cell><cell>0.645?0.002</cell><cell>261.67</cell><cell>57.84s/4.23hr</cell></row><row><cell>MoNet</cell><cell>4</cell><cell>99007</cell><cell>0.641?0.002</cell><cell>0.643?0.002</cell><cell>282.00</cell><cell>84.46s/6.65hr</cell></row><row><cell>GAT</cell><cell>4</cell><cell>96182</cell><cell>0.671?0.002</cell><cell>0.673?0.002</cell><cell>328.25</cell><cell>68.23s/6.25hr</cell></row><row><cell>GatedGCN</cell><cell>4</cell><cell>97858</cell><cell>0.791?0.003</cell><cell>0.793?0.003</cell><cell>159.00</cell><cell>218.20s/9.72hr</cell></row><row><cell>GatedGCN-E</cell><cell>4</cell><cell>97858</cell><cell>0.808?0.003</cell><cell>0.811?0.003</cell><cell>197.00</cell><cell>218.51s/12.04hr</cell></row><row><cell cols="2">GatedGCN-E 16</cell><cell>500770</cell><cell>0.838?0.002</cell><cell>0.850?0.001</cell><cell>53.00</cell><cell>807.23s/12.17hr</cell></row><row><cell>GIN</cell><cell>4</cell><cell>99002</cell><cell>0.656?0.003</cell><cell>0.660?0.003</cell><cell>273.50</cell><cell>72.73s/5.56hr</cell></row><row><cell>RingGNN</cell><cell>2</cell><cell>106862</cell><cell>0.643?0.024</cell><cell>0.644?0.024</cell><cell>2.00</cell><cell>17850.52s/17.19hr</cell></row><row><cell></cell><cell>2</cell><cell>507938</cell><cell>0.704?0.003</cell><cell>0.705?0.003</cell><cell>3.00</cell><cell>12835.53s/16.08hr</cell></row><row><cell></cell><cell>8</cell><cell>506564</cell><cell>Diverged</cell><cell>Diverged</cell><cell>Diverged</cell><cell>Diverged</cell></row><row><cell>3WLGNN</cell><cell>3</cell><cell>106366</cell><cell>0.694?0.073</cell><cell>0.695?0.073</cell><cell>2.00</cell><cell>17468.81s/16.59hr</cell></row><row><cell></cell><cell>3</cell><cell>506681</cell><cell>0.288?0.311</cell><cell>0.290?0.312</cell><cell>2.00</cell><cell>17190.17s/16.51hr</cell></row><row><cell></cell><cell>8</cell><cell>508832</cell><cell>OOM</cell><cell>OOM</cell><cell>OOM</cell><cell>OOM</cell></row><row><cell>k-NN Heuristic</cell><cell></cell><cell>k =2</cell><cell>Test F1: 0.693</cell><cell></cell><cell></cell><cell></cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_18"><head>Table 9 :</head><label>9</label><figDesc>Benchmarking results for TSP for edge classification. Results (higher is better) are averaged over 4 runs with 4 different seeds. Red: the best model, Violet: good models. The suffix -E denotes the use of available edge features.</figDesc><table /><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_20"><head>Table 10 :</head><label>10</label><figDesc>Results for the CSL dataset, with and without Laplacian Positional Encodings. Results are from 5-fold cross validation, run 20 times with different seeds. Red: the best model, Violet: good models. The dimension of node positional encoding with Laplacian eigenvectors is 20.</figDesc><table /><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_22"><head>Table 11 :</head><label>11</label><figDesc>Test accuracy on the CYCLES dataset. Results (higher is better) are averaged over 4 runs with 4 different seeds. The performance on test sets with models trained on varying train data size is show, followingVignac et al. (2020). Bold shows the best result out of a GNN's two model instances that use and not use PE. The dimension for PE is 20.</figDesc><table /><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_23"><head></head><label></label><figDesc>-3.51?0.11 -3.23?0.08 -3.35?0.08 -4.03?0.21 -2.60?0.12 -3.57?0.05 -4.32?0.13</figDesc><table><row><cell>Model L</cell><cell>Average</cell><cell>Dist.</cell><cell>Ecc.</cell><cell>Test Lap.</cell><cell>Conn.</cell><cell>Diam.</cell><cell>Rad.</cell></row><row><cell cols="2">GIN 8 -3.19?0.11</cell><cell>-2.81?0.11</cell><cell cols="5">-2.42?0.09 -4.39?0.18 -2.07?0.13 -3.06?0.11 -4.39?0.13</cell></row><row><cell cols="5">GIN-PE 8 -3.21?0.13 -2.87?0.03 -2.83?0.07 -3.99?0.04</cell><cell cols="3">-2.00?0.15 -3.27?0.07 -4.31?0.15</cell></row><row><cell cols="2">GatedGCN 8 -3.22?0.13</cell><cell>-2.76?0.17</cell><cell>-2.36?0.12</cell><cell cols="3">-3.92?0.15 -2.65?0.11 -3.35?0.16</cell><cell>-4.31?0.08</cell></row><row><cell>GatedGCN-PE 8</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_24"><head>Table 13 :</head><label>13</label><figDesc>Study of positional encodings (PEs) with the GatedGCN model(Bresson and Laurent,  2017). Performance reported on the test sets of CSL, ZINC, PATTERN, CLUSTER and COLLAB (higher is better, except for ZINC). Red: the best model.</figDesc><table /><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_25"><head></head><label></label><figDesc>e +1 ij = e ij + ELU BN Concat K k=1 B k, Concat A k, e ij , U k, h i , U k, h j ,(62)</figDesc><table><row><cell>a k, ij</cell><cell>=</cell><cell>exp(? k, ij ) j ?N i exp(? k, ij )</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_27"><head>Table 15 :</head><label>15</label><figDesc>Study of anisotropic edge features and representations for link prediction on COLLAB, including GraphSage models. Red: the best model, Violet: good models.</figDesc><table /><note></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2">. https://github.com/bknyaz/graph_attention_pool</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>XB is supported by NRF Fellowship NRFF2017-10 and NUS-R-252-000-B97-133.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>References</head></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix G. A Note on Graph Size Normalization</head><p>Intuitively, batching graphs of variable sizes may lead to node representation at different scales, making it difficult to learn the optimal statistics ? and ? for BatchNorm across irregular batch sizes and variable graphs. A preliminary version of this work introduced a graph size normalization technique called GraphNorm, which normalizes the node features h i w.r.t. the graph size, i.e.,h</p><p>where V is the number of graph nodes. The GraphNorm layer is placed before the BatchNorm layer.</p><p>We would like to note that GraphNorm does not have any concrete theoretical basis as of now, and was proposed based on initially promising empirical results on datasets such as ZINC and CLUSTER. Future work shall investigate more principled approaches towards designing normalization layers for graph structured data.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix H. Hardware Details</head><p>Timing research code can be tricky due to differences of implementations and hardware acceleration. Nonetheless, we take a practical view and report the average wall clock time per epoch and the total training time for each model. All experiments were implemented in DGL/PyTorch. We run experiments for MNIST, CIFAR10, ZINC, AQSOL, TSP, COLLAB, WikiCS, CSL, CYCLES, GraphTheoryProp and TUs on an Intel Xeon CPU E5-2690 v4 server with 4 Nvidia 1080Ti GPUs, and for PATTERN and CLUSTER on an Intel Xeon Gold 6132 CPU with 4 Nvidia 2080Ti GPUs. Each experiment was run on a single GPU and 4 experiments were run on the server at any given time (on different GPUs). We run each experiment for a maximum of 12 hours.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Wiki-cs: A wikipedia-based benchmark for graph neural networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P?ter</forename><surname>Mernyei</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C?t?lina</forename><surname>Cangea</surname></persName>
		</author>
		<idno type="arXiv">arXiv:2007.02901</idno>
		<imprint>
			<date type="published" when="2020" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Rethinking pooling in graph neural networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Diego</forename><surname>Mesquita</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Amauri</forename><surname>Souza</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Samuel</forename><surname>Kaski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems</title>
		<imprint>
			<date type="published" when="2020" />
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="page" from="2220" to="2231" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gr?goire</forename><surname>Mialon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dexiong</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Margot</forename><surname>Selosse</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Julien</forename><surname>Mairal</surname></persName>
		</author>
		<idno type="arXiv">arXiv:2106.05667</idno>
		<title level="m">Graphit: Encoding graph structure in transformers</title>
		<imprint>
			<date type="published" when="2021" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Geometric deep learning on graphs and manifolds using mixture model cnns</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Federico</forename><surname>Monti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Davide</forename><surname>Boscaini</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jonathan</forename><surname>Masci</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Emanuele</forename><surname>Rodola</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jan</forename><surname>Svoboda</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><forename type="middle">M</forename><surname>Bronstein</surname></persName>
		</author>
		<idno type="DOI">10.1109/cvpr.2017.576</idno>
	</analytic>
	<monogr>
		<title level="m">IEEE Conference on Computer Vision and Pattern Recognition (CVPR)</title>
		<imprint>
			<date type="published" when="2017-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Geometric matrix completion with recurrent multi-graph neural networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Federico</forename><surname>Monti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Bronstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xavier</forename><surname>Bresson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems</title>
		<imprint>
			<date type="published" when="2017" />
			<biblScope unit="page" from="3697" to="3707" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Fake news detection on social media using geometric deep learning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Federico</forename><surname>Monti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fabrizio</forename><surname>Frasca</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Davide</forename><surname>Eynard</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Damon</forename><surname>Mannion</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><forename type="middle">M</forename><surname>Bronstein</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1902.06673</idno>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Weisfeiler and leman go neural: Higher-order graph neural networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christopher</forename><surname>Morris</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Martin</forename><surname>Ritzert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Matthias</forename><surname>Fey</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>William</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jan</forename><forename type="middle">Eric</forename><surname>Hamilton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gaurav</forename><surname>Lenssen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Martin</forename><surname>Rattan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Grohe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the AAAI Conference on Artificial Intelligence</title>
		<meeting>the AAAI Conference on Artificial Intelligence</meeting>
		<imprint>
			<date type="published" when="2019" />
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="page" from="4602" to="4609" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Relational pooling for graph representations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ryan</forename><surname>Murphy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Balasubramaniam</forename><surname>Srinivasan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vinayak</forename><surname>Rao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bruno</forename><surname>Ribeiro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Machine Learning</title>
		<imprint>
			<date type="published" when="2019" />
			<biblScope unit="page" from="4663" to="4673" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><surname>Palowitch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Anton</forename><surname>Tsitsulin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brandon</forename><surname>Mayer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bryan</forename><surname>Perozzi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Graphworld</surname></persName>
		</author>
		<idno type="arXiv">arXiv:2203.00112</idno>
		<title level="m">Fake graphs bring real insights for gnns</title>
		<imprint>
			<date type="published" when="2022" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Pytorch: An imperative style</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Adam</forename><surname>Paszke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sam</forename><surname>Gross</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Francisco</forename><surname>Massa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Adam</forename><surname>Lerer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><surname>Bradbury</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gregory</forename><surname>Chanan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Trevor</forename><surname>Killeen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zeming</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Natalia</forename><surname>Gimelshein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Luca</forename><surname>Antiga</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alban</forename><surname>Desmaison</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andreas</forename><surname>K?pf</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Edward</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zach</forename><surname>Devito</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Martin</forename><surname>Raison</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alykhan</forename><surname>Tejani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sasank</forename><surname>Chilamkurthy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Benoit</forename><surname>Steiner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lu</forename><surname>Fang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Junjie</forename><surname>Bai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Soumith</forename><surname>Chintala</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
	<note>high-performance deep learning library</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Glove: Global vectors for word representation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jeffrey</forename><surname>Pennington</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Richard</forename><surname>Socher</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christopher D</forename><surname>Manning</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2014 conference on empirical methods in natural language processing (EMNLP)</title>
		<meeting>the 2014 conference on empirical methods in natural language processing (EMNLP)</meeting>
		<imprint>
			<date type="published" when="2014" />
			<biblScope unit="page" from="1532" to="1543" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Scale-space and edge detection using anisotropic diffusion</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pietro</forename><surname>Perona</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jitendra</forename><surname>Malik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on pattern analysis and machine intelligence</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="629" to="639" />
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Emanuele</forename><surname>Rossi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fabrizio</forename><surname>Frasca</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ben</forename><surname>Chamberlain</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Davide</forename><surname>Eynard</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Bronstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Federico</forename><surname>Monti</surname></persName>
		</author>
		<idno type="arXiv">arXiv:2004.11198</idno>
		<title level="m">Sign: Scalable inception graph neural networks</title>
		<imprint>
			<date type="published" when="2020" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Pointer networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Oriol</forename><surname>Vinyals</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Meire</forename><surname>Fortunato</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Navdeep</forename><surname>Jaitly</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems</title>
		<imprint>
			<date type="published" when="2015" />
			<biblScope unit="page" from="2692" to="2700" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">A tutorial on spectral clustering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ulrike</forename><surname>Von</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Luxburg</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Statistics and computing</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="395" to="416" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Equivariant and stable positional encoding for more powerful graph neural networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Haorui</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Haoteng</forename><surname>Yin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Muhan</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pan</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Learning Representations</title>
		<imprint>
			<date type="published" when="2022" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Microsoft academic graph: When experts are not enough</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kuansan</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhihong</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chiyuan</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chieh-Han</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuxiao</forename><surname>Dong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Anshul</forename><surname>Kanakia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Quantitative Science Studies</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="396" to="413" />
			<date type="published" when="2020" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Minjie</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lingfan</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Da</forename><surname>Zheng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Quan</forename><surname>Gan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yu</forename><surname>Gai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zihao</forename><surname>Ye</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mufei</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jinjing</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Qi</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chao</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ziyue</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Qipeng</forename><surname>Guo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hao</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Haibin</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Junbo</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jinyang</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alexander</forename><forename type="middle">J</forename><surname>Smola</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zheng</forename><surname>Zhang</surname></persName>
		</author>
		<title level="m">Deep graph library: Towards efficient and scalable deep learning on graphs. ICLR Workshop on Representation Learning on Graphs and Manifolds</title>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Essential guidelines for computational method benchmarking</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Lukas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wouter</forename><surname>Weber</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robrecht</forename><surname>Saelens</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Charlotte</forename><surname>Cannoodt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alexander</forename><surname>Soneson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Hapfelmeier</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Paul</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Anne-Laure</forename><surname>Gardner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yvan</forename><surname>Boulesteix</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mark D</forename><surname>Saeys</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Robinson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome biology</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page">125</biblScope>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Evaluating graph neural networks under graph sampling scenarios</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Qiang</forename><surname>Wei</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Guangmin</forename><surname>Hu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PeerJ Computer Science</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page">901</biblScope>
			<date type="published" when="2022" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">A reduction of a graph to a canonical form and an algebra arising during this reduction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Boris</forename><surname>Weisfeiler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrei</forename><forename type="middle">A</forename><surname>Lehman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1968" />
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="12" to="16" />
		</imprint>
	</monogr>
	<note type="report_type">Nauchno-Technicheskaya Informatsia</note>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Keyulu</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chengtao</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yonglong</forename><surname>Tian</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tomohiro</forename><surname>Sonobe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ken-Ichi</forename><surname>Kawarabayashi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stefanie</forename><surname>Jegelka</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1806.03536</idno>
		<title level="m">Representation learning on graphs with jumping knowledge networks</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">How powerful are graph neural networks?</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Keyulu</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Weihua</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jure</forename><surname>Leskovec</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stefanie</forename><surname>Jegelka</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Learning Representations</title>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Do transformers really perform badly for graph representation?</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chengxuan</forename><surname>Ying</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tianle</forename><surname>Cai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shengjie</forename><surname>Luo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shuxin</forename><surname>Zheng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Guolin</forename><surname>Ke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Di</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yanming</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tie-Yan</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="page">2021</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Graph convolutional neural networks for web-scale recommender systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rex</forename><surname>Ying</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ruining</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kaifeng</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pong</forename><surname>Eksombatchai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>William</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jure</forename><surname>Hamilton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Leskovec</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 24th ACM SIGKDD International Conference on Knowledge Discovery &amp; Data Mining</title>
		<meeting>the 24th ACM SIGKDD International Conference on Knowledge Discovery &amp; Data Mining</meeting>
		<imprint>
			<date type="published" when="2018" />
			<biblScope unit="page" from="974" to="983" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Position-aware graph neural networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jiaxuan</forename><surname>You</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rex</forename><surname>Ying</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jure</forename><surname>Leskovec</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Machine Learning</title>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Test Acc.?s.d. Train Acc.?s.d. #Epoch Epoch/Total Test Acc.?s.d. Train Acc.?s.d. #Epoch Epoch/Total</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">Our observations reiterate how experiments on the small TU datasets are difficult to determine which GNNs are powerful and robust</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Gnns</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
