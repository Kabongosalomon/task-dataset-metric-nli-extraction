<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /nfs/home/kabenamualus/Research/task-dataset-metric-extraction/../grobid-0.6.0/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A Structural Model for Contextual Code Changes</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><roleName>Technion, Israel</roleName><forename type="first">Shaked</forename><surname>Brody</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">URI ALON</orgName>
								<address>
									<settlement>Technion</settlement>
									<country key="IL">Israel</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">A Structural Model for Contextual Code Changes</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>

		<encodingDesc>
			<appInfo>
				<application version="0.6.0" ident="GROBID-SDO" when="2022-11-12T10:55+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid-sdo"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Additional Key Words and Phrases: Edit Completions</term>
					<term>Neural Models of Code</term>
					<term>Machine Learning</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ERAN YAHAV, Technion, Israel</head><p>We address the problem of predicting edit completions based on a learned model that was trained on past edits. Given a code snippet that is partially edited, our goal is to predict a completion of the edit for the rest of the snippet. We refer to this task as the EDITCOMPLETION task and present a novel approach for tackling it. The main idea is to directly represent structural edits. This allows us to model the likelihood of the edit itself, rather than learning the likelihood of the edited code. We represent an edit operation as a path in the program's Abstract Syntax Tree (AST), originating from the source of the edit to the target of the edit. Using this representation, we present a powerful and lightweight neural model for the EDITCOMPLETION task.</p><p>We conduct a thorough evaluation, comparing our approach to a variety of representation and modeling approaches that are driven by multiple strong models such as LSTMs, Transformers, and neural CRFs. Our experiments show that our model achieves a 28% relative gain over state-of-the-art sequential models and 2? higher accuracy than syntactic models that learn to generate the edited code, as opposed to modeling the edits directly.</p><p>Our code, dataset, and trained models are publicly available at https://github.com/tech-srl/c3po/ . -if(self.isDisabled()) + if(attack == null || attack.IsTraitDisabled) return false; -var targetPos = attack != null ? attack.GetTargetPosition(pos, target) : target.CenterPosition; + var targetPos = attack.GetTargetPosition(pos, target) ; Input Output</p><p>Edit Script (a)  The predicate of the if statement in C was edited to include a null check for attack. Thus, in P, the checking of attack != null and the ternary operator can be removed.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Software development is an evolutionary process. Programs are being maintained, refactored, fixed, and updated on a continuous basis. Program edits are therefore at the very core of software development. Poor edits can lead to bugs, security vulnerability, unreadable code, unexpected behavior, and more. The ability to suggest a good edit in code is therefore crucial. We introduce the EDITCOMPLETION task: predict edit completions based on a learned model that was trained on past edits. Given a code snippet that is partially edited, our goal is to predict an edit completion that completes the edit for the rest of the snippet. The edit completion is represented technically as a sequence of edit operations that we refer to as an edit script.</p><p>Problem Definition. Let P be a given program fragment and C be the surrounding context of P before any edits were applied. Let ? C denote the edits that were applied to C, and C ? = ? C (C) the resulting edited context. The goal in our EDITCOMPLETION task is to predict an edit function ? P , such that applying ? P to P results in the program fragment after the edit: ? P (P) = P ? . Our underlying assumption is that the distribution of edits in P can be inferred from the edits ? C that occurred in its context. We thus model the probability: (? P | ? C ). We present a new approach for representing and predicting ? P in the <ref type="bibr">EDITCOMPLETION</ref>  Edit Script <ref type="bibr">(b)</ref> The signature of GetFileCharacteristics in C was edited to return a FileCharacteristic object instead of modifying an output parameter. Thus, in P, the method should return a FileCharacteristic object instead of returning true. <ref type="figure">Fig. 1</ref>. Examples of EDITCOMPLETION. The input consists of a program fragment P and edits that occurred in the context that transformed C into C ? . The output is ? P -an edit script that describes the likely edit. Applying ? P to P results in P ? -the code after the edit. <ref type="figure">Figure 1a</ref> and <ref type="figure">Figure 1b</ref>. These illustrate the significance of edits in the context C and how they can help in suggesting a likely edit for P. In <ref type="figure">Figure 1a</ref>, the edit in the context consists of changing the if statement predicate, resulting in a null check for the variable attack. After the edit in the context, the value of attack in P cannot be null. Therefore, the ternary statement that checks attack for nullness in P can be removed. Our model successfully predicted the needed edit ? P , which is applied to P to yield P ? . <ref type="figure">Figure 1b</ref> shows another example, in which the edit in the context is a modification of a function signature. In C ? , the return type was changed to FileCharacteristics, and the output parameter fileCharacteristics for the function was removed. P consists of an assignment to the parameter fileCharacteristics, and a return statement of true value. The edit in the context implies a necessary edit in P, in which the assignment statement has to be removed (since (b) <ref type="figure">Fig. 2</ref>. An example of two edits. These examples are different and the edits operate on different values. However, observing the structure of these edits reveals the similarity between them and allows a learning model to generalize better. This similarity is expressed as almost identical AST paths. For simplicity, only the program fragment that should be edited P is shown, without the context C.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Motivating Examples. Consider the EDITCOMPLETION examples in</head><p>fileCharacteristics is no longer defined) and the return statement must include a variable of type FileCharacteristics. Our model successfully predicted the correct edit for P. P ? consists of returning an object of type FileCharacteristics.</p><p>Edit Completion vs. Code Completion. It is important to note that EDITCOMPLETION and code completion are completely different tasks. The goal of code completion is to predict missing fragments of a program, given a partial program as context. In contrast, the goal of EDITCOMPLETION is to predict additional edits in a partial sequence of edit operations. That is, while code completion operates on code, EDITCOMPLETION operates on code edits.</p><p>Representing Code Edits. The main design decision in learning code edits is how to represent the edit, i.e., how to represent the difference between the code in its original form and its desired, altered, form. Na?vely, differencing programs can be performed by treating the code as text and using text-diff algorithms for line differencing <ref type="bibr" target="#b24">[Hunt and McIlroy 1975]</ref> or inline differencing <ref type="bibr" target="#b10">[Birney et al. 1996]</ref>.</p><p>In contrast, we model the difference between the abstract syntax trees (ASTs) of the original and the edited code. This allows us to naturally use paths in the AST (AST paths) to model edits.</p><p>Our Approach. We present a novel approach for EDITCOMPLETION: predicting contextual code changes -C 3 . Code changes can be described as a sequence of edit operations, such as "move a node, along with its underlying subtree, to be a child of another node" or "update the value of a node to be identical to the value of another node". Such edit operations can be naturally represented as paths between the source node and the target node, along with the relationship between them and the edit command, i.e., "move" or "update". AST paths provide a natural way to express binary relationships between nodes (and thus subtrees) in the AST. We use AST paths to represent ? Cedits that occurred in the context and transformed C into C ? , such that ? C (C) = C ? . We also use AST paths to represent ? P -the edits that should be applied to P. We thus model the probability (? P | ? C ), where both the input ? C and the output ? P are represented as AST paths.</p><p>Representing edits as paths allows a learning model to generalize well across different examples. Consider the two examples in <ref type="figure">Figure 2</ref>. In <ref type="figure">Figure 2a</ref>, the edit modifies a series of LINQ calls, converting Where(&lt;predicate&gt;).FirstOrDefault() into FirstOrDefault(&lt;predicate&gt;). The edit in <ref type="figure">Figure 2b</ref> modifies Where(&lt;predicate&gt;).First() into First(&lt;predicate&gt;). We elaborate on the representation of edits as paths in Section 2 and Section 4. For now, it suffices to note that there is a sequence of three edit operations in each of the figures (numbered 1 ?, 2 ?, 3 ?). Although the predicates are different and these edits operate on different values, the structure of the edits in <ref type="figure">Figure 2a</ref> and <ref type="figure">Figure 2b</ref> is identical. This similarity is expressed in the AST paths that represent these edits. For example, consider the identical structure of the path 1 ? in the two figures, where it operates on a different value in each figure (FirstOrDefault and First).</p><p>Our use of AST paths allows the model to generalize these edits, even though these edits are not identical and their predicates are different.</p><p>We apply a Pointer Network <ref type="bibr" target="#b38">[Vinyals et al. 2015</ref>] to point to paths in the AST of P and create an edit operation sequence, i.e., an edit script. While prior work used AST paths to read programs and predict a label <ref type="bibr">[Alon et al. 2019a,c]</ref>, we generate an edit script by predicting AST paths, i.e., making AST paths the output of our model. Previous Approaches. In related tasks, such as bug fixing and program repair, previous approaches have mostly represented code as a flat token stream <ref type="bibr" target="#b35">Tufano et al. 2018;</ref><ref type="bibr" target="#b36">Vasic et al. 2019]</ref>; although this allows the use of NLP models out-of-the-box, such models do not leverage the rich syntax of programming languages. <ref type="bibr" target="#b39">Yin et al. [2019]</ref> suggested a system that learns to represent an edit and uses its representation to apply the edit to another code snippet. Although it sounds similar, the task that <ref type="bibr" target="#b39">Yin et al. [2019]</ref> addressed and our task are dramatically different. <ref type="bibr" target="#b39">Yin et al. [2019]</ref> addressed the (easier) variant and assume that the edit that needs to be applied is given as part of the input. This is done in the form of "before" and "after" versions of another code with the same edit applied; their task is only to apply the given edit on a given code. Thus, in the task of <ref type="bibr" target="#b39">Yin et al. [2019]</ref>, the assumption is that ? C = ? P . In contrast, we do not assume that the edit ? P is given; we condition on edits that occurred in the context (? C ), but these edits are different than the edits that need to be applied to P. Our model needs to predict the edit to P itself, i.e., predict what needs to be edited and how. Other work did use syntax but did not represent the structure of the edit itself. <ref type="bibr" target="#b16">Dinella et al. [2020]</ref> proposed a model for detecting and fixing bugs using graph transformations, without considering context changes (i.e., ? C = ?). Their method can predict unary edit operations on the AST. In contrast, we predict binary edit operations. Thus, our representation is much more expressive. For example, consider the edit of moving a subtree. This edit can be represented as a single binary operation; alternatively, this edit can require multiple unary operations.</p><p>Modeling Code Likelihood vs. Modeling Edit Likelihood. In general, there are two main approaches for learning to edit a given code snippet. Assume that we wish to model the probability of a code snippet Y given another code snippet X. Much prior work <ref type="bibr" target="#b31">Mesbah et al. 2019]</ref> followed the approach of generating Y directly. Attempting to model Y given X modeled the probability (Y | X). This approach is straightforward, but requires modeling the likelihood of Y, which is a problem that is more difficult than necessary. In contrast, it can be much more effective to model the likelihood of the edit, which transforms X into Y, without modeling the likelihood of Y itself; hence, (? X?Y | X). Our modeling of the edit follows the latter approach: (? P | ? C ). In this work, we learn to predict the edit (? P ) that transforms P into P ? , instead of predicting the entire program (P ? ). By applying ? P to P, generating P ? is straightforward: ? P (P) = P ? . Learning to predict the edit instead of learning to predict the edited code makes our learning task much easier and provides much higher accuracy, as we show in Section 6.</p><p>We show the effectiveness of C 3 on EDITCOMPLETION on a new dataset, scraped from over 300,000 commits in GitHub.</p><p>Our approach significantly outperforms textual and syntactic approaches that either model the code or model only the edit, and are driven by strong neural models.</p><p>Contributions. The main contributions of this paper are:</p><p>? We introduce the EDITCOMPLETION task: given a program P and edits that occurred in its context, predict the likely edits that should be applied to P.</p><p>? C 3 -a novel approach for representing and predicting contextual edits in code. This is the first approach that represents structural edits directly.</p><p>? Our technique directly captures the relationships between subtrees that are changed in an edit using paths in the AST. The output of our technique is an edit script that is executed to edit the program fragment P.</p><p>? A prototype implementation of our approach, called C 3 PO, for Contextual Code Changes via Path Operations. C 3 PO is implemented using a strong neural model that predicts the likely edit by pointing to an AST path that reflects that edit.</p><p>? A new EDITCOMPLETION dataset of source code edits and their surrounding context edits, scraped from over 300,000 commits in GitHub.</p><p>? An extensive empirical evaluation that compares our approach to a variety of representation and modeling approaches, driven by strong models such as LSTMs, Transformers, and neural CRFs. Our evaluation shows that our model achieves over 28% relative gain over state-of-the-art strong sequential models, and over 2? higher accuracy than syntactic models that do not model edits directly.</p><p>? A thorough ablation study that examines the contribution of syntactic and textual representations in different components of our model.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">OVERVIEW</head><p>In this section, we demonstrate our approach using a simple EDITCOMPLETION example. The main idea is to represent all valid edit operations in P as AST paths, and predict a sequence of these paths.</p><p>Since every path is associated with an edit operation, by pointing to a sequence of paths, we, in fact, predict an edit script.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Motivating Example</head><p>High-level Overview. Consider the edit that occurred in the context of <ref type="figure" target="#fig_1">Figure 3a</ref> -insertion of a new definition of the method AddNavigation, which overloads previous definitions. After applying this edit, it is possible to use this new signature when calling AddNavigation. Consider the original code snippet P at the top of <ref type="figure" target="#fig_1">Figure 3e</ref>. The edit in the context allows us to simplify the call to AddNavigation using the new signature, as shown in the "edited" code snippet P ? at the bottom of  <ref type="figure" target="#fig_1">Figure 3a</ref> shows the edit that transforms C into C ? -overloading the function AddNavigation. <ref type="figure" target="#fig_1">Figure 3e</ref> shows P and P ? as code in red and green, respectively. <ref type="figure" target="#fig_1">Figure 3b</ref> depicts the partial AST and the first three edit operations of the edit. <ref type="figure" target="#fig_1">Figure 3c</ref> shows the AST after applying the first three operations, and shows the next three operations as AST paths. <ref type="figure" target="#fig_1">Figure 3d</ref> illustrates the AST after performing all operations, resulting in an AST that corresponds to P ? . Every edit operation is represented by an AST path having the same color and number as the edit command. Dotted contours represent subtrees that will be affected by applying these operations. Already-affected subtrees are surrounded by dashed contours. <ref type="figure" target="#fig_1">Figure 3e</ref>. Consider the partial AST of P in <ref type="figure" target="#fig_1">Figure 3b</ref>. The desired edit can be described as an edit script consisting of six edit operations to the AST of P. Consider the first operation: 1 ? MOV. The meaning of this operation is to move the node Expr with its subtree to be the leftmost child of the node Unit. This edit operation can be represented by the red 1 ? path: Expr ? Arg ? ArgList ? Call ? Expr ? Unit. Note how this path directly captures the syntactic relationship between the node Expr and the node Unit, allowing our model to predict a MOV operation as part of the edit script.</p><p>In <ref type="figure" target="#fig_1">Figure 3c</ref> we can see the result of applying the following first three operations: 1 ? MOV, 2 ? MOV, 3 ? MOV, moving subtrees to new locations in the tree. The last three commands are DEL operations, expressing deletion of a node and its underlying subtree. These operations can be represented using paths as well. For instance, 4 ? DEL is represented by the green 4 ? path: Navigation ? Call ? Expr ? Unit ? DEL, where DEL is an artificial node that we add as a child of the AST's root. In <ref type="figure" target="#fig_1">Figure 3d</ref> we can see the AST after applying all six operations. After executing all six operations, our model produces P ? , shown in <ref type="figure" target="#fig_1">Figure 3e</ref>.</p><p>Path Extraction. To inform the model about the available edits it can use for prediction, we parse the AST of P to extract all AST paths that represent valid edits. Every path can represent different edit "commands" that use the same path. For example, consider the blue 2 ? path in <ref type="figure" target="#fig_1">Figure 3b</ref>: Name ? Call ? ArgList ? Arg ? Expr ? Call. This path can represent a move operation -MOV, i.e., moving the node Name with its subtree, to be the leftmost child of Call; alternatively, this path can represent an insertion operation -INS, i.e., copy Name with its subtree, and insert it as the leftmost child of Call. To distinguish between different edit operations that are represented using the same AST path, each path is encoded as a vector once, and projected into three vectors using different learned functions. Each resulting vector corresponds to a different kind of edit operation. For example, the orange 3 ? path in <ref type="figure" target="#fig_1">Figure 3b</ref> can represent either "move" (MOV), "update" (UPD) or "insert" (INS) operations. In this case, this path was projected using the learned function that represents "move".</p><p>Edit Script Prediction. We predict one edit operation at each step by pointing at a path and its associated operation from among the valid edit operations. This results in an edit script. For example, in <ref type="figure" target="#fig_1">Figure 3</ref>, our model finds that the red 1 ? path with MOV is most likely to be the first operation. Then, given this edit, our model finds that the blue 2 ? path with MOV is most likely to be the next operation, and so on, until we predict a special "end of sequence" (EOS) symbol.</p><p>Modeling Code Likelihood vs. Modeling Edit Likelihood. Modeling edits using AST paths provides an effective way to model only the difference between P and P ? . For example, consider the red 1 ? path that moves the subtree rooted at Expr from its original place to be the first child of Unit. To predict this edit, our model only needs to select the red 1 ? path out of the other available operations. In contrast, a model that attempts to generate P ? entirely , would need to generate the entire subtree from scratch in the new location.</p><p>Pairwise Edit Operations. Most edit operations, such as "move" and "update", can be described as pairwise operations, having the "source" and the "target" locations as their two arguments. AST paths provide a natural way to represent pairwise relations, originating from the "source" location, and reaching the "target" location through the shortest path between them in the tree. In contrast, prior work that used only unary edit operations such as HOPPITY <ref type="bibr" target="#b16">[Dinella et al. 2020</ref>] are limited to inserting each node individually, and thus use multiple edit commands to express the 1 ? MOV operation. Our model represents this edit operation as a single AST path -the red 1 ? path.</p><p>Key aspects. The example in <ref type="figure" target="#fig_1">Figure 3</ref> demonstrates several key aspects of our method:</p><p>? Edits applied to the context of P can provide useful information for the required edit to P.</p><p>? Pairwise edit operations can be naturally represented as AST paths.</p><p>? A neural model, trained on these paths, can generalize well to other programs, thanks to the direct modeling of code edits as paths.</p><p>? By pointing at the available edit operations, the task that the model addresses becomes choosing the most likely edit, rather than generating P ? from scratch, and thus significantly eases the learning task.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">BACKGROUND</head><p>In this section, we provide the necessary background. First we define abstract syntax trees (ASTs) and AST paths in Section 3.1. In Section 3.2, we use these definitions to describe how to represent code edits using AST paths and perform AST differencing. Finally, in Section 3.3 and Section 3.4, we describe the concept of attention and pointer networks, which are crucial components in our neural architecture (described in Section 5).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">AST Paths</head><p>Given a programming language L and its grammar, we use to denote the set of nonterminals, and to denote the set of terminals in the grammar. The Abstract Syntax Tree (AST) of a program can be constructed in the standard manner, defined as follows:</p><p>Definition 3.1. (Abstract Syntax Tree) Given a program P written in a programming language L, its Abstract Syntax Tree A is the tuple ( , , , , , ), where is the set of non-leaf nodes, such that each ? is of type that belongs to ; is the set of leaves such that each ? is of type that belongs to ; ? is the root of the tree; is a set of values taken from P; is a function : ? ( ? ) * that maps nonterminals nodes to their children; is a mapping : ? that maps a terminal node to a value.</p><p>An AST path is simply a sequence of nodes in the AST, formally:</p><p>Definition 3.2. (AST Path) Given an AST A = ( , , , , , ), an AST path is a sequence of nodes = 1 , 2 , ..., , where ? ? , such that for every consecutive pair of nodes and +1 , either ? ( +1 ) or +1 ? ( ). We follow <ref type="bibr" target="#b7">Alon et al. [2018]</ref> and associate each node's child index with its type.</p><p>For example, consider the blue 2 ? path in <ref type="figure" target="#fig_1">Figure 3b</ref>. The path starts in the node Name, goes up to its parent node Call, then goes down to its right-most child ArgList, an so on.</p><p>AST paths are a natural way to describe relationships between nodes in the AST, and can serve as a general representation of relationships between elements in programs. For example, <ref type="bibr" target="#b7">Alon et al. [2018</ref><ref type="bibr" target="#b8">Alon et al. [ , 2019c</ref> used paths between leaves in the AST as a way to create an aggregated representation of the AST.</p><p>In this work, we use AST paths to model relationships between arbitrary nodes in the tree (both terminals and nonterminals) to model the effect of edit operations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">AST Differencing</head><p>An edit in a program can be represented as a sequence of operations on its AST. To compute the difference between two programs, we compute the difference between the two ASTs using algorithms such as GumTree <ref type="bibr" target="#b17">[Falleri et al. 2014]</ref>. Given two programs P and P ? , along with their ASTs A and A ? , GumTree outputs an edit script, consisting of instructions to change A so it becomes A ? . Each operation in the script is either MOV, DEL, UPD, or INS and operates on one or two nodes. The command MOV , stands for moving a subtree inside the AST. This operation takes the source node to be moved and the target node, which will be the left sibling of after the move. The  <ref type="figure" target="#fig_2">Figure 4a</ref> depict the AST before the change. <ref type="figure" target="#fig_2">Figure 4b</ref> shows the result of MOV operation -moving C to be the right sibling of D. <ref type="figure" target="#fig_2">Figure 4c</ref> shows the result of DELremoving C. <ref type="figure" target="#fig_2">Figure 4d</ref> shows the result of UPD -updating C to Z. <ref type="figure" target="#fig_2">Figure 4e</ref> shows the result of INSinserting E to be the right sibling of D.</p><p>command DEL stands for removing the node from the tree. We use the command UPD , , to update the value of the node to become . Lastly, to represent insertion, we use INS , , where is the root of a subtree to be inserted and is the target node that will be the left sibling of after the insertion. <ref type="figure" target="#fig_2">Figure 4a</ref> illustrates the AST before the edits; <ref type="figure" target="#fig_2">Figure 4b</ref> shows the result of MOV C, D; <ref type="figure" target="#fig_2">Figure 4c</ref> depicts the command DEL C; <ref type="figure" target="#fig_2">Figure 4d</ref> shows the update of C to the value Z, i.e., UPD Z, C; <ref type="figure" target="#fig_2">Figure 4e</ref> illustrates the command INS E, D -the insertion of node E as a right sibling of D.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 4 demonstrates all operations:</head><p>In general, AST differencing algorithms consist of two steps. The first step maps nodes from A to A ? , where each node belongs to a single mapping at most and mapped nodes share the same type. The second step uses the mapping and aims to produce a short edit script. The GumTree algorithm focuses on the first step of mapping, since there are known quadratic optimal algorithms <ref type="bibr" target="#b14">[Chawathe et al. 1996</ref>] for the second step.</p><p>GumTree <ref type="bibr" target="#b17">[Falleri et al. 2014</ref>] breaks the mapping stage into three steps. The first step is a top-down algorithm that finds isomorphic subtrees across A and A ? . The roots of these subtrees are called anchors mapping. The second step is a bottom-up algorithm that looks for containers mapping; these are node pairs among A and A ? , such that their descendants share common anchors. Finally, the last step looks for additional mappings between the descendants of the containers mapping pairs.</p><p>Applying the GumTree algorithm for the mapping stage and using known techniques to produce the edit script results in an end-to-end efficient algorithm. The complexity of this algorithm is</p><p>( 2 ) in the worst case, where is the number of nodes in the larger among A and A ? , i.e., = (|A|, |A ? |).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Attention</head><p>An attention mechanism computes a learned weighted average of some input vectors, given another input query vector. Usually, attention is used by a neural model to align elements from different modalities. For example, in neural machine translation (NMT) <ref type="bibr" target="#b9">[Bahdanau et al. 2014]</ref>, attention allows the model to "focus" on different words from the source language while predicting every word in the target language, by computing a different weighted average at every step. This ability has shown a significant improvement across various tasks such as translation <ref type="bibr" target="#b9">[Bahdanau et al. 2014;</ref><ref type="bibr" target="#b28">Luong et al. 2015;</ref><ref type="bibr" target="#b37">Vaswani et al. 2017</ref>], speech recognition <ref type="bibr" target="#b13">[Chan et al. 2016]</ref>, and code summarization and captioning <ref type="bibr" target="#b5">[Alon et al. 2019a</ref>].</p><p>Formally, given a set of vectors = z 1 , z 2 , .., z k ? R (usually, an encoding of the input of the model) and a query vector q ? R (usually, the hidden state of a decoder at a certain time step ), attention performs the following computation. The first step computes a "score" for each input vector z . For example, <ref type="bibr" target="#b28">Luong et al. [2015]</ref> use a learned matrix ? R ? to compute the score of the vector z :</p><p>= z ? ? q ? (1) Next, all scores are normalized into a pseudo-probability using the softmax function:</p><formula xml:id="formula_0">= =1 (2)</formula><p>where every normalized score is between zero and one ? [0, 1], and their sum is one: = 1. Then, a context vector is computed as a weighted average of the inputs z 1 , z 2 , .., z k , such that the weights are the computed weights :</p><formula xml:id="formula_1">c = ?? ? z i</formula><p>This dynamic weighted average can be computed iteratively at different prediction time steps , producing different attention scores and thus a different context vector c t . This offers a decoder the ability to focus on different elements in the encoded inputs at each prediction step.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Pointer Networks</head><p>A pointer network <ref type="bibr" target="#b38">[Vinyals et al. 2015</ref>] is a variant of the seq2seq paradigm <ref type="bibr" target="#b33">[Sutskever et al. 2014]</ref>, where the output sequence is a series of pointers to the encoded inputs, rather than a sequence from a separate vocabulary of symbols. This mechanism is especially useful when the output sequence is composed only of elements from the input, possibly permutated and repeated. For example, the problem of sorting a sequence of numbers can be naturally addressed using pointer networks: the input for the model can be the unsorted sequence of numbers, and the output is the sorted sequence, where every output prediction is a pointer to an element in the input sequence.</p><p>Pointing can be performed in a manner similar to attention: at each decoding step, Equation <ref type="formula" target="#formula_4">(1)</ref> and Equation <ref type="formula" target="#formula_4">(2)</ref> compute input scores, similar to attention. Then, the resulting normalized scores can be used for classification over the encoded inputs, as the output probability of the model.</p><p>Pointer networks and attention share almost the same implementation, but they are different in principle. Attention computes a dynamic average c at each decoding iteration. Then, c is used in the prediction of this time step, among a different closed set of possible classes. For example, the possible classes can be the words in the target language. In pointer networks, on the other hand, the possible classes at each decoding step are the elements in the input sequence itself.</p><p>Another difference is that in pointer networks there is a label associated with each "pointing" step. Each "pointing" distribution is directly supervised by computing a cross-entropy loss with a reference label. In other words, each pointing can be measured for its correctness, and the mostlypointed input is either correct or incorrect. In contrast, attention is not directly supervised; the model's attention distribution is internal to the model. The attention distribution is usually neither "correct" nor "incorrect", because the attention is used for a follow-up prediction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">REPRESENTING EDITS WITH AST PATHS</head><p>In the EDITCOMPLETION task that we consider in this work, the input contains multiple edit operations that occurred in the context, and the output is a series of edit operations that should be performed. Representing edits using AST paths provides an expressive and generalizable solution. An edit operation, such as "move", can be represented as the path in the AST from the subtree that should be moved, up to its new destination. This path includes the syntactic relation between the source and the target of the move. Different move operations would result in different paths and thus, this representation is expressive. Similar moves will result in similar paths and thus, this representation is generalizable. In this section, we explain how AST paths can naturally represent such edit operations.</p><p>We represent edit operations as follows:</p><p>(1) The MOV (move) operation has two arguments: the first is the source node -the root of the subtree to be moved, and the second is the target node. The meaning of "MOV , " is that node moves to be the right sibling of node . To support moving a node to be the leftmost child, we augment the AST with Placeholder nodes, that are always present as the leftmost child nodes of all nonterminal nodes.</p><p>(2) The UPD (update) operation has two arguments: the first argument is a node with a source value, and the second argument is a node whose value needs to be updated. For instance, if the value of node needs to be updated to x, and the value of node is x, we denote this by: "UPD , ".</p><p>(3) The INS (insert) operation has two arguments: the first argument is the subtree to be copied, and the second is the target node. The operation "INS , " means that the subtree rooted at should be copied and inserted as the right sibling of . If should be inserted as a leftmost child, the target node will be the appropriate Placeholder node.</p><p>(4) The DEL (delete) operation has one argument, which is a subtree to be deleted. We represent DEL as a path that originates from the root of the subtree to be deleted, into a special DEL target node that we artificially add as a child of the AST's root. So in practice, we represent "DEL " as "MOV , DEL " where DEL is the DEL node.</p><p>Since all four operations can be represented using two nodes and from the AST of P, the AST path from to is a natural way to represent an edit operation. <ref type="figure" target="#fig_3">Figure 5</ref> demonstrates a MOV operation and its associated path representation. <ref type="figure" target="#fig_3">Figure 5a</ref> depicts the path Arg 1 ? ArgList ? Arg 3 , which can be associated with MOV and represent the operation MOV Arg 1 , Arg 3 , i.e., moving the first argument to be the last. <ref type="figure" target="#fig_3">Figure 5b</ref> shows the AST after the movement.</p><p>To represent insertions (INS) and updates (UPD) in the context that transformed C into C ? , we augment the AST with additional UPD and INS nodes. To represent all update operations UPD , , we add the necessary nodes as children of UPD. For example, in <ref type="figure" target="#fig_4">Figure 6</ref>, there are two update operations that involve two source nodes: y and Bar. Thus, we add these nodes as children of UPD and represent the operations with paths that originate from these nodes. The orange 1 ? path, for instance, represents the update of Foo to become Bar. In the case of insertion of a new subtree, we represent this operation with a path that originates from INS and ends in the root of the subtree. Consider the purple 3 ? path in <ref type="figure" target="#fig_4">Figure 6</ref>. This path represents that the subtree with the root Name  <ref type="figure" target="#fig_3">Figure 5a</ref> shows the path: Arg 1 ? ArgList ? Arg 3 that represents the edit of moving the first argument to be the last argument. A dotted contour represents the subtree that will be affected by applying the operations. <ref type="figure" target="#fig_3">Figure 5b</ref> shows the AST after applying the edit. The affected subtree is surrounded by a dashed contour. The orange 1 ? path represents that the node Foo has been updated to the value Bar. Similarly, the green 2 ? path represent that the node x has been updated to y. The purple 3 ? path represents the insertion of node Name along with its subtree.</p><p>was inserted as the leftmost child of Type. We augment the AST with additional UPD and INS nodes as additional children of the AST's root, along with the special DEL node.</p><p>These modifications allow us to represent any edit in the context. In this work, we focus on edits that can be represented as AST paths in P. Examples that require generating code from scratch require other, more heavyweight code completion models, and are beyond the scope of this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">MODEL ARCHITECTURE</head><p>In this section, we describe our model in detail. The design of our model is guided by the idea of allowing a neural model to consider multiple edits that occurred in the context (? C ), and predict a single path operation that should be applied to P at every time step. The major challenge is: how do we predict a single path operation? Classifying among a fixed vocabulary of path operations is combinatorially infeasible. Alternatively, decomposing the prediction of a path operation into a sequence of smaller atomic node predictions increases the chances of making a mistake, and can lead to predicting a path operation that is not even valid in the given example. We take a different Attention Pointer <ref type="figure">Fig. 7</ref>. A high-level overview of our architecture. On the left, the partial AST that represents the context C. The red paths represent the transformation from C to C ? . On the right, we can see the partial AST of P and its paths that represent possible valid predictions. The model attends to the paths that transform C to C ? to point to a path of P that corresponds to a edit operation.</p><p>approach. We encode all the path operations that are valid in a given example, and train the model to point to a single path operation, only among these valid operations. That is, in every example, the model predicts path operations among a different set of valid operations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">High-level View</head><p>At a high-level, our model reads the edits that occurred in the context and predicts edits that should be performed in the program. Since there may be multiple edits in the context, our model uses attention to compute their dynamic weighted average. To predict the edit in the program, our model enumerates all possible edits, expresses them as AST paths, and points to the most likely edit. Thus, the input of the model is a sequence of AST paths from the augmented C, and the output is a sequence of AST paths from P. Our model is illustrated in <ref type="figure">Figure 7</ref>.</p><p>Our model follows the encoder-decoder paradigm. The encoder encodes all valid paths of the input code (P) and the paths of the input context (transforming C to C ? ) into continuous vectors. The decoder generates an edit sequence by pointing to the set of paths in P while attending to the paths of C and C ? . First, to consider edits that occurred in the context, our model encodes the sequence of context paths that transformed C into C ? , as a set of vectors. Then, the model performs a series of predictions, where each such prediction is an edit that should be applied to P. At each prediction step, the model attends (as explained in Section 3.3) to the context paths. Using the resulting attention vector, the model points (as explained in Section 3.4) to a single path in P. The path in P that the model points to, is translated to the edit that should be applied in this step. In the next step, the chosen edit from the previous step is used to compute the attention query of the next step.</p><p>An edit operation that occurred in the context can be represented as an AST path (Section 4). We denote the sequence of paths that represent the edits in the context as ? C = ? (C, C ? ). The edit function that should be predicted is also represented as AST paths, where each path is associated with an edit operation. We denote the sequence of AST paths that represent the edits that should be predicted as ? P = ? (P, P ? ) ; we use these vectors as our classes from which we make predictions.</p><p>Using the above notations, we model the conditional probability: (? P | ? C ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Encoder</head><p>Given a sequence of paths ? (C, C ? ), we encode all paths using a Path Encoder (Section 5.2.1). Then, since it is a sequence that has a meaningful order, the context paths go through an LSTM <ref type="bibr" target="#b23">[Hochreiter and Schmidhuber 1997]</ref>, resulting in the sequence of vectors C .</p><p>We enumerate all valid edits that can be applied to P and denote this set as ? P, P . We then encode these paths using the Path Encoder (Section 5.2.1), which results in the set of vectors P .</p><p>Every path in ? P, P can represent different edit operations (Section 5.2.2), i.e., both "update" and "move". Thus, every path vector ? P is projected to represent different edit operations, resulting in the set of vectors , which represent the set of classes from which the model can predict.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.1">Path Encoder.</head><p>Given a set of AST paths, our goal is to create a vector representation for each path 1 ... . The vocabulary of nodes of the AST is limited to a fixed-size vocabulary from the grammar of the language. In contrast, the values of AST leaves correspond to the tokens in the textual representation of the program. Therefore, the vocabulary of these tokens is unbounded. To address the issue of the unbounded vocabulary of terminal values, we follow previous work <ref type="bibr" target="#b2">[Allamanis et al. 2015</ref><ref type="bibr" target="#b4">[Allamanis et al. , 2016</ref><ref type="bibr" target="#b5">Alon et al. 2019a]</ref>, and split these values into subtokens. For example, the value toString will be split into to and string. We represent each path as a sequence of node types using an LSTM, and use subtoken embeddings to represent terminal values (the tokens).</p><p>Node Representation. Each AST path is composed of nodes 1 , ..., . Each node is taken from a limited vocabulary of 88 symbols of the programming language. Terminal nodes also have a userdefined token value. Every node has an associated child index, i.e., its index among its sibling nodes <ref type="bibr" target="#b7">[Alon et al. 2018</ref>]. We represent each node using a learned embedding matrix and a learned embedding matrix for its child indices . We sum the vector of the node type with the vector of its child index to represent the node:</p><formula xml:id="formula_2">_ ( ) = +</formula><p>The first and the last node of an AST path may be terminals whose values are tokens in the code. <ref type="bibr">1</ref> We use a learned embedding matrix to represent each subtoken:</p><formula xml:id="formula_3">_ ( ) = ?? ? ( )<label>(3)</label></formula><p>where is a value associated with a terminal node.</p><p>Path Representation. We encode the path 1 , ..., by applying an LSTM:</p><formula xml:id="formula_4">? 1 , ..., ? = ? ( _ ( 1 ) , ...,<label>_ ( ))</label></formula><p>We concatenate the last state vector with an encoding of the values associated with the first and the last nodes in the path, and then pass them through a learned fully connected layer ? and a nonlinearity:</p><formula xml:id="formula_5">_ ? ( 1 ... ) = ? ? ? [? ; _ ( ( 1 )) ; _ ( ( ))]</formula><p>where is the function that retrieves a terminal node's associated value (Section 3.1). If 1 or are nonterminals, and thus do not have an associated value, we encode the first and the last nodes instead of their values; i.e., _ ( ) instead of _ ( ( )).</p><p>To express the order of context paths ? (C, C ? ), we pass these through another LSTM:</p><formula xml:id="formula_6">C = C ( ? ( ? (C, C ? )))<label>(4)</label></formula><p>Applying the path encoder on ? P, P results in P : P = ? ? P, P 5.2.2 Operation Encoder. To represent different operations (i.e., MOV, UPD, INS) that share the same path ? P , we project using different learned matrices , , :</p><formula xml:id="formula_7">= ? = ? = ?</formula><p>such that , , and are used for pointing to MOV, UPD, and INS edits, which are all described by the same encoded path . This creates our set of possible classes to point to:</p><formula xml:id="formula_8">= ? P { , , }<label>(5)</label></formula><p>We use as the representations of the classes over which our model outputs a distribution.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Decoder</head><p>The decoder generates an edit script given the outputs of the encoder. At each decoding time step, the decoder predicts a single edit operation, by pointing to a single vector from , while attending to the sequence of vectors C . The decoder consists of three main components: an LSTM <ref type="bibr" target="#b23">[Hochreiter and Schmidhuber 1997]</ref>, attention <ref type="bibr" target="#b9">[Bahdanau et al. 2014]</ref>, and a pointer <ref type="bibr" target="#b38">[Vinyals et al. 2015]</ref>.</p><p>The decoder LSTM operates by receiving an input vector at each time step; then, it uses this input vector to update the LSTM's internal state, and uses the updated state as the query for attention. Given the current state, we compute an attention vector of the vectors in C , and use the resulting vector to point to a (prediction) vector in . In the next time step, the input vector for the LSTM is the last pointed to vector from the previous step. The initial hidden state of the LSTM is an elementwise average of paths in P and in C .</p><p>Attention. We employ attention as described in Section 3.3, where the query is ? -the hidden state of the decoder LSTM at time step . At each time step, we compute a scalar score for every vector ? C . This score is computed by performing a dot product between each context vector ? C and a learned matrix and ? . We then normalize all scores with a softmax function to get the normalized weights :</p><p>= softmax C ? ? ? ? We then compute a weighted average of C to get the attention vector c c = ?? ? C ? Pointing. Given the vector c , we compute a pointing score for each valid edit that is represented as z ? . The resulting scores are normalized using softmax; these normalized scores constitute the model's output distribution.</p><p>We perform a dot product of every z ? with another learned weight matrix and c . This results in a scalar score for every valid prediction in . We then apply a softmax, resulting in a distribution over the vectors in :? = softmax ? ? c (6) We use this distribution? as the model's prediction at time step . At training time, we train all learnable weights to maximize the log-likelihood <ref type="bibr" target="#b32">[Rubinstein 1999</ref>] of? according to the true label. At test time, we compute the of^to get the prediction: our model predicts the edit operation that is correlated with the element having the highest pointing score. The output of the decoder across time steps can be (unambiguously) translated to an edit script.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">EXPERIMENTS</head><p>We implemented our approach for EDITCOMPLETION in a neural model called C 3 PO, short for Contextual Code Changes via Path Operations. The main contributions of our approach are (a) the syntactic representation of code edits; and (b) modeling of the likelihood of code edits, rather than modeling the likelihood of the edited code. Thus, these are the main ideas that we wish to evaluate. We compare our model with baselines that represent each of the different paradigms <ref type="table">(Table 2</ref>) on a new dataset. Our model shows significant performance improvement over the baselines.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Dataset</head><p>We introduce a new EDITCOMPLETION dataset of code edits in C#. We scraped the 53 most popular C# repositories from GitHub and extracted all commits since the beginning of the project's history. From each commit, we extracted edits in C# files along with the edits in their surrounding context. Note that a given edit can be part of the edits in the surrounding context (? C ) of one example and can be the edit to be predicted (? P ) of another example. In other words, the same edit can have different roles in different examples. We verified that both examples reside in the same split (i.e., either both examples are in the training set, or both examples are in the test set), without leakage between the sets.</p><p>For each edit, we considered a context radius of 10 lines, above and 10 lines below the edit. Representing long sequences is computationally difficult for baselines that use Transformers <ref type="bibr" target="#b37">[Vaswani et al. 2017</ref>] because Transformers have a quadratic time and space complexity. We thus limited the context to 10 lines before and after the edit for these baselines. To make a fair comparison, we limited this in our model as well. We filtered out examples having more than 50 nodes in the AST of P. Choosing 50 nodes at most captured the vast majority of examples (81%). While the technique works for any number of nodes, we picked a limit of 50 to keep the time and cost of experiments reasonable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Textual</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Syntactic</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Code Likelihood</head><p>SequenceR  Path2Tree <ref type="bibr" target="#b0">[Aharoni and Goldberg 2017]</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Edit Likelihood</head><p>LaserTagger+CRF <ref type="bibr" target="#b30">[Malmi et al. 2019]</ref> C 3 PO (this work) <ref type="table">Table 2</ref>. A high-level taxonomy of our model and the baselines.</p><p>To make the task even more challenging, we filtered out examples for which: (a) the edit in P consists of only DEL operations; and (b) edits that both P and its context contain only UPD operations such that all updates in P are included in the updates of C, since these usually reflect simple renaming that is easily predicted by modern IDEs. Following recent work on the adverse effects of code duplication <ref type="bibr" target="#b1">[Allamanis 2019;</ref><ref type="bibr" target="#b27">Lopes et al. 2017]</ref>, we split the dataset into training-validation-test by project. This resulted in a dataset containing 39.5K/4.4K/5.9K train/validation/test set examples, respectively. We trained all models and baselines on the training set, performed tuning and early-stopping using the validation set, and report final results on the test set. <ref type="table">Table 1</ref> shows a summary of the statistics of our dataset.A list of the repositories we used to create our dataset are shown in Appendix A. We make our new dataset publicly available at https://github.com/tech-srl/c3po/ .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Baselines</head><p>The two main contributions of our approach that we wish to examine are: (a) the syntactic representation of code edits; and (b) modeling edit likelihood, rather than modeling code likelihood. Since we define the new task of EDITCOMPLETION, we picked strong neural baselines and adapted them to this task, to examine the importance of these two main contributions. <ref type="table">Table 2</ref> shows a high-level comparison of our model and the baselines. Each model can be classified across two properties: whether it uses a syntactic or textual representation of the edit, and whether it models the likelihood of the code or models the likelihood of the edit. We put significant effort into performing a fair comparison to all baselines, including subtoken splitting as in our model, lowercasing the subtokens, and replacing generated UNK tokens with the tokens that were given the highest attention score.</p><p>LaserTagger <ref type="bibr" target="#b30">[Malmi et al. 2019]</ref> -is a textual model that models the edit likelihood. LaserTagger learns to apply textual edits to a given text. The model follows the framework of sequence tagging, i.e., classifying each token in the input sequence. Each input token is classified into one of: KEEP , DELETE and SWAP, where belongs to a vocabulary of all common phrases obtained from the training set. While LaserTagger leverages edit operations, it does not take advantage of the syntactic structure of the input. Since the original implementation of LaserTagger uses a pre-trained BERT NLP model, which cannot be used for code, we carefully re-implemented a model in their spirit, without BERT. We used the same preprocessing scripts and sequence tags as <ref type="bibr" target="#b30">Malmi et al. [2019]</ref>, and encoded the input using either a bidirectional LSTM or a Transformer <ref type="bibr" target="#b37">[Vaswani et al. 2017]</ref> (LaserTagger LSTM and LaserTagger Transformer , respectively). We further strengthened these models with neural Conditional Random Fields (CRFs) <ref type="bibr" target="#b29">[Ma and Hovy 2016]</ref>. To represent context edits, we employed a sequence alignment algorithm <ref type="bibr" target="#b10">[Birney et al. 1996</ref>] and extracted the textual edits. We encoded these context edits using a bidirectional LSTM and concatenated the resulting vector to the model's encoded input.</p><p>SequenceR is a re-implementation of . SequenceR follows the sequence-tosequence paradigm from Neural Machine Translation (NMT) with attention <ref type="bibr" target="#b28">[Luong et al. 2015</ref>] and a copy mechanism <ref type="bibr" target="#b19">[Gu et al. 2016</ref>]. The input is the subtokenized code snippet, along with the textual edits in the context. The output is the edited code. Hence, this method does not take advantage of syntax or edit operations. We carefully re-implemented this approach because SequenceR abstracts away identifier names, and replaces identifier names with generic names. For example int x = 0 becomes int varInt = 0. Since our model uses identifier names and we found that identifier names help our model, to perform a fair comparison -we kept identifier names in SequenceR as well. While the original SequenceR uses LSTMs with copy and attention (SequenceR LSTM ), our re-implementation allowed us to strengthen this baseline by replacing the LSTM with a Transformer <ref type="bibr" target="#b37">[Vaswani et al. 2017</ref>] and a copy mechanism (SequenceR Transformer ). We evaluated both SequenceR LSTM , which follows the original model of , and the strengthened SequenceR Transformer baseline.</p><p>Path2Tree follows <ref type="bibr" target="#b0">Aharoni and Goldberg [2017]</ref>. This baseline leverages the syntax and models the code likelihood. In this baseline, we performed a pre-order traversal of the AST and represented the AST as a serialized sequence of nodes. Using this sequential serialization of the AST, we could employ strong neural seq2seq models. The input consists of the paths that represent edits in the context (as in our model), along with a serialized sequence that represents the AST of P. The output of the model is the sequence that represents the AST of P ? . As the neural underlying seq2seq model, we used both a Transformer (Path2Tree Transformer ) with a copy mechanism and a BiLSTM with attention and copy mechanisms (Path2Tree LSTM ) .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Setup</head><p>From each sample in our dataset, we (a) extracted all paths of ? P, P that describe possible valid edit operations; and (b) extracted the paths that represent the transformation of C to C ? , i.e., ? (C, C ? ). We did not filter, discard any of these paths, or limited the paths lengths.</p><p>We used input embedding dimensions of 64, LSTM cells with a single layer, and 128 units. This resulted in a very lightweight model of only 750K learnable parameters. We trained our model on a Tesla V100 GPU using the Adam optimizer [Kingma and Ba 2014] with a learning rate of 0.001 to minimize the cross-entropy loss. We applied a dropout <ref type="bibr" target="#b21">[Hinton et al. 2012</ref>] of 0.25.</p><p>In the baselines, we used BiLSTMs with 2 layers having an embedding and hidden state of size 512; this resulted in 10M learned parameters in SequenceR LSTM and in Path2Tree LSTM resulting in 10M learned parameters. We used the original hyperparameters of the Transformer <ref type="bibr" target="#b37">[Vaswani et al. 2017</ref>] to train Transformers in SequenceR Transformer and Path2Tree Transformer , resulting in 45M learned parameters. LaserTagger LSTM uses BiLSTMs with 2 layers having a hidden state size of 128 and an embedding size of 64. This model contained 1M learned parameters. For LaserTagger Transformer , we used 4 layers of Transformer encoders, with 4 layers and 8 attention heads, an embedding size of 64, and a hidden state size of 512. For both, the context encoders use BiLSTMs with 2 layers having a hidden state size of 128 and an embedding size of 64. We experimented with LaserTaggers that contain a context encoder that uses Transformer and setups that contained larger dimensions, but they achieved slightly lower results. In the other baselines, larger dimensions contributed positively to the performance.</p><p>Evaluation Metric. To perform a fair comparison across all examined models, we had to use a metric that would be meaningful and measurable in all models and baselines. We thus measured exact-match accuracy across all models and baselines. The accuracy of each model is the percentage of examples in the test set for which the entire target sequence was predicted correctly.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">Results</head><p>Performance. <ref type="table">Table 3</ref> depicts the main results of our evaluation: C 3 PO gains more than 11% absolute accuracy over LaserTagger Transformer , which performed the best of all baselines. These results emphasize the need for structural representation of both edits and context. C 3 PO achieves accuracy that is twice that of the syntactic baseline Path2Tree. Although this baseline uses AST paths to represent the changes in the context of P and to represent P with its underlying AST, its performance is inferior compared to our C 3 PO. This is because Path2Tree does not model the edit operations directly and thus needs to generate the entire AST of P ? .</p><p>These results show the significance of our model's two main contributions. Modeling the edit has the most significant contribution as expressed in the advantage of our model over both versions of Path2Tree, and in the advantage of both versions of LaserTagger over both versions of SequenceR. Syntactic representation over textual representation also has a significant contribution, which is expressed in the superiority of our model over both versions of LaserTagger. Using these two key contributions, our model performs significantly better than all models, while being much more lightweight in terms of learnable parameters. The same results are visualized in <ref type="figure" target="#fig_5">Figure 8</ref>.  <ref type="table">Table 3</ref>. Our model achieves significantly higher accuracy than the baselines. Path2Tree Lower Performance Compared to SequenceR. Although Path2Tree represents the edits syntactically (which we believe to be a better representation, in general) and SequenceR represents edits textually, the results of Path2Tree are lower than those of SequenceR.</p><p>We believe that the main limitation of Path2Tree is that it cannot easily generalize between the program fragment P and the given context C. This occurs because C is represented as paths, while P ? is generated as a tree. In contrast, SequenceR represents all inputs and outputs the same, i.e., as sequences of tokens. We also performed initial experiments with a Tree2Tree baseline that encodes C, C ? , and P as trees and generates P ? as a tree, thus potentially having a better generalization ability than Path2Tree. However, Tree2Tree achieved much lower results than Path2Tree, because the tree encoding created very large inputs, especially in C. These, prevented the model from properly capturing the edits that occurred in the context (? C ), while the encoding of ? C as paths is much more succinct and focused (and performed better than Tree2Tree).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.5">Scalability Analysis</head><p>We conducted an analysis of our model that shows the performance of C 3 PO as a function of the context radius size and the number of nodes. <ref type="figure" target="#fig_6">Figure 9</ref> shows the accuracy of C 3 PO compared to the context radius size, i.e., the number of lines between the beginning of C and P. As shown, the accuracy of C 3 PO remains stable when the context radius increases. This hints that the context radius can be further increased without sacrificing accuracy. In our experiments, we put this limitation only to limit the size of the dataset.  <ref type="figure" target="#fig_7">Figure 10</ref> shows the accuracy of C 3 PO compared to the number of nodes in the AST of P. As the size of P increases, our model shows a natural descent, and the accuracy stabilizes for sizes of 31 nodes and above. As shown in the lower part of <ref type="figure" target="#fig_7">Figure 10</ref>, the number of examples also decreases with the size of the edit: the most common edits have 11 to 15 nodes, in which our model achieves an accuracy of 80%.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.6">Qualitative Analysis</head><p>We manually examined the predicted examples and discuss two representative cases. <ref type="figure">Figure 11</ref> shows an example in which the modification of a method signature in the context affects P, which lies in the method body. The context of P, shown in <ref type="figure">Figure 11a</ref>, includes a change in the signature of the method GetFileCharacteristic. The name of the method was changed to GetAppender and its return type was updated from FileCharacteristic to BaseFileAppender.</p><p>Consider P in <ref type="figure">Figure 11b</ref>. P is a return statement, located in the body of the changed method GetFileCharacteristic. Since the return type of the method was updated to BaseFileAppender, the return statements inside the method must be changed as well. The renaming of the method to GetAppender may have also hinted to our model that the appender object itself should be returned. Our model successfully predicted the desirable edit, altering the return statement from return appender.GetFileCharacteristic to return appender;. This example shows how context edits are important in predicting edits in a program, by providing information about (a) return type changes and (b) method renaming.  <ref type="figure">Fig. 11</ref>. An example where the edit of a method signature affects the edit of P which lies in the method body. <ref type="figure">Figure 11a</ref> illustrates the edit in the context and the paths that describe the transformation from C to C ? . <ref type="figure">Figure 11b</ref> shows the predicted edit operations along with their associated paths in P. <ref type="figure" target="#fig_9">Figure 12</ref> illustrates a case where the edit in the context is conceptually similar to the edit in P, but is not identical. <ref type="figure" target="#fig_9">Figure 12a</ref> shows a variable declaration statement, where part is cast to the type MethodCallExpression and assigned to the newly-declared variable methodExpression.</p><p>In the edited context, the keyword var was updated to an explicit type MethodCallExpression. <ref type="figure" target="#fig_9">Figure 12b</ref> shows an edit that is similar in spirit: P consists of an initialization statement, where the variable nameParts is assigned a new Stack&lt;string&gt;. Using the edit in the context, our model predicted the edit of var to Stack&lt;string&gt; in P. This edit consists of an insertion of a new subtree, since Stack&lt;string&gt; is represented as a subtree of five nodes. In contrast, the edit in the context is represented as an UPD edit, because it only needs to update the value of a single node. This example demonstrates a class of examples where the edit in the context hints edits that are similar in spirit in P, but are not identical and should be performed differently.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">ABLATION STUDY</head><p>We conducted an extensive ablation study to examine the importance of different components in our model. We focused on two axes: the representation of ? P and the representation of ? C . This allowed us to examine the origin for the advantage of our model over the strongest baselines, to understand whether it comes from the syntactic representation of the context or the syntactic representation of P.</p><p>In our model, P is represented using its syntactic structure, i.e., a path-based representation. Alternatively, P can be represented using its textual representation. The representation of P determines the representation of P ? . They must be represented similarly, otherwise the model would need to  <ref type="figure" target="#fig_9">Figure 12a</ref> illustrates the edit that occurred in the context and the paths that describe the transformation from C to C ? . <ref type="figure" target="#fig_9">Figure 12b</ref> shows the predicted edit operations along with their associated paths in P.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>No Context Textual Context Path-Based Context</head><p>Textual P 35.5 41.4 ? 39.5</p><p>Path-Based P 46.5 48.5 53.2 ? C 3 (this work) <ref type="table">Table 4</ref>. Variations on our model. ? marks results that are copied from <ref type="table">Table 3</ref>.</p><p>"translate" P into a different representation to predict P ? . However, the representation of the context C can theoretically be different than that of P.</p><p>We thus took our model and examined different representations of the context: path-based context (as in our original model), textual context, and "no context". For each type of context representation, we also experimented with different types of representations for P: syntactic representation, as in our original model, and textual representation of P. For textual representation of P we used LaserTagger Transformer <ref type="bibr" target="#b30">[Malmi et al. 2019</ref>], which we found to be the strongest textual baseline in Section 6. All the hybrid models were re-trained, and their performance is shown in <ref type="table">Table 4</ref>.</p><p>Contribution of Context. According to our observations, the contribution of the changes in the context is considerable, for both the textual and path-based representations of P. Ignoring changes in the context (the left "No Context" column of <ref type="table">Table 4</ref>) results in lower accuracy. This motivates our task of predicting edits given the context. Program edits are correlated with edits that occurred in the context and predicting edits should consider the context edits. P Representation. We observed that across all different settings of context representation, a syntactic representation of P performs better than a textual representation of P. That is, even if the context is textual (the right column of <ref type="table">Table 4</ref>), a model benefits from a syntactic representation of P. This advantage is even clearer in the case of "No context", where the path-based representation of P achieves more than 10% absolute accuracy over the textual representation of P. A path-based representation of P allows us to model the edit in P directly, which makes the learning task much easier and more generalizable.</p><p>Context Representation. As <ref type="table">Table 4</ref> shows, the representation of the context should be compatible with the representation of P. If P is textual, a textual context performs better; if P is syntactic, a syntactic context performs better. We hypothesize that matching the context representation to the program representation allows the model to better utilize the context and makes it easier to model the correlation between edits occurring in the context to edits that should be applied to P.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">RELATED WORK</head><p>Representing Programs in Learning Models. The representation of programs in learning models is a question that is even more imperative than the learning algorithm we employed or neural architecture. In the last few years, several approaches have been proposed. Early work used the straightforward textual representation, essentially learning from the flat token stream <ref type="bibr" target="#b4">[Allamanis et al. 2016;</ref><ref type="bibr" target="#b25">Iyer et al. 2016;</ref><ref type="bibr" target="#b35">Tufano et al. 2018;</ref><ref type="bibr" target="#b36">Vasic et al. 2019]</ref>. Although this leverages NLP learning approaches, such models do not leverage the rich syntax of programming languages, and eventually perform worse than other representations, despite their use of strong NLP models. Another line of work represent programs as graphs. These usually augment the AST of a program with additional semantic edges and use a graph neural network to learn from the resulting graph <ref type="bibr" target="#b18">Fernandes et al. 2019;</ref><ref type="bibr" target="#b20">Hellendoorn et al. 2020;</ref><ref type="bibr" target="#b39">Yin et al. 2019</ref>]. Graphs provide a natural way to represent programs and allow us to easily augment programs with domain knowledge such as semantic analysis. However, it is unclear how well can these models perform in the absence of full semantic information -given partial code, given code that cannot be compiled, or languages that are difficult to analyze semantically. As in <ref type="bibr" target="#b7">[Alon et al. 2018]</ref>, we leverage AST paths to represent programs. AST paths were shown to be an effective representation for predicting variable names, method names <ref type="bibr" target="#b8">[Alon et al. 2019c]</ref>, natural language descriptions <ref type="bibr" target="#b5">[Alon et al. 2019a]</ref>, and code completion <ref type="bibr" target="#b6">[Alon et al. 2019b]</ref>. In our task, AST paths allow us to model edits directly, along with the syntactic relationship between the source and the target node of the edits.</p><p>Representing Edits. Much work has been proposed on representing edits. <ref type="bibr" target="#b39">Yin et al. [2019]</ref> proposed a model that learns to apply a given code edit on another given code snippet. Although this sounds similar to the task we address; with EDITCOMPLETION there is no specific edit in our input that needs to be applied. In contrast to <ref type="bibr" target="#b39">Yin et al. [2019]</ref>, the model must predict what should be edited and how, instead of applying a given edit. In our work, there is no guarantee that the edit that needs to be predicted is included in the context. Furthermore, there could be several edits in the context. Thus, our model needs to choose and predict the most likely edit itself, while the edits that occurred in the context may only be related to the edit that needs to be predicted.</p><p>SequenceR ] used state-of-the-art NMT models to predict bug fixes on single-line buggy programs. Our work is different from their approach when it comes to the representation of the input and the output.  represent the code as a token stream, while our approach represents edits as AST paths. Further, their approach attempts to generate the entire edited program, whereas our model models only the edit. We demonstrated the advantage of our approach over SequenceR empirically in Section 6.</p><p>One problem connected to ours is the task of fixing compilation errors. <ref type="bibr" target="#b34">Tarlow et al. [2019]</ref> follows the encoder-decoder paradigm, using an encoder that consists of a graph neural network (GNN) that encodes a multi-graph built from the AST and the compilation error log messages. The decoder is a Transformer <ref type="bibr" target="#b37">[Vaswani et al. 2017</ref>] that outputs a sequence representing the predicted edit. DeepDelta <ref type="bibr" target="#b31">[Mesbah et al. 2019</ref>] used an NMT model in which the input consists of compilation errors and an AST path from the problematic symbol in the code to the root of the tree. The output of their model is a sequence that represents the edit script. In our work, pairwise AST paths allow us to model the desired edit directly, instead of predicting an edit using multiple predictions.</p><p>Recently, <ref type="bibr" target="#b16">Dinella et al. [2020]</ref> proposed a model called HOPPITY to detect and fix bugs in source code using graph transformations. The main difference between our approach and theirs is that HOPPITY does not model edit operations directly, as our model does. Rather, it models a graph that represents the input, and uses the resulting node representations to predict actions. This modeling makes their model predict unary edit operations, while our model predicts binary edits: HOPPITY can only predict single-node edits in each step, such as deleting a subtree root, inserting a single node, and changing a single node value. Thus, edits like moving large subtrees require multiple insertion operations of a single node at a time. In our approach, moving and inserting a subtree can be performed by a single edit operation. <ref type="bibr" target="#b16">Dinella et al. [2020]</ref> evaluated their model on examples that contain three single-node operations at most. However, as shown in Appendix A, the average size of moved subtrees in our train set is 3.48. Such edits would have required HOPPITY to generate the entire subtree in the new position (three operations) and delete the subtree in its original place (one operation), resulting in four operations in total. Hence, our average case is larger than the cases examined by HOPPITY.</p><p>CC2Vec <ref type="bibr" target="#b22">[Hoang et al. 2020</ref>] represent edits in version-control-systems (e.g., GitHub). However, their approach represents edits only textually. CC2Vec was demonstrated on the tasks of predicting commit messages, predicting bug fixes, and defect prediction; however, their model could not predict the edit itself the way we do in this paper. <ref type="bibr" target="#b12">Chakraborty et al. [2018]</ref> proposed a two-step model that aims to apply edits in code. The first step of their model encodes the sequence that represents a pre-order traversal of the AST of the original code and generates the sequence that represents the AST of the edited code. In the second step, they assign the values of terminal nodes to concrete values. Their approach predicts the edit by synthesizing the entire AST. In Section 6 we showed the advantage of modeling the likelihood of edits over modeling the likelihood of the code. Additionally, our model is trained end-to-end, while <ref type="bibr" target="#b12">Chakraborty et al. [2018]</ref> trains different components of their model separately.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">CONCLUSION</head><p>We presented a novel approach for representing and predicting edits in code. Our focus is on learning the likelihood of the edit itself, rather than learning the likelihood of the new program. We use paths from the Abstract Syntax Tree to represent code edits that occurred in a given context, and use these paths to point to edits that should be predicted.</p><p>We demonstrate the effectiveness of our approach by using the EDITCOMPLETION task to predict edits in a section of code, given edits in its surrounding context. We speculate that our direct modeling of the likelihood of edits, and use of the rich structure of code, are the main components that contribute to the strength of our model. We affirm this conjecture in a thorough evaluation and ablation study. Our method performs significantly better than strong neural baselines that leverage syntax but do not model edits directly, or those that model edits but do not leverage syntax.</p><p>We believe our approach can serve as a basis for a variety of models and tools that require the modeling and prediction of code edits. Examples include bug fixing, an EDITCOMPLETION assistant in the programmer's IDE, and automatically adapting client code to changes in public external APIs. Further, we believe our work can serve as the basis for a future "neural code reviewer", to save human effort and time. To these ends, we make all our code, dataset, and trained models publicly available at https://github.com/tech-srl/c3po/ .  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A DATASET</head></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>task, named C 3 : Contextual Code Changes.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 3 .</head><label>3</label><figDesc>An EDITCOMPLETION example from our test set.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 4 .</head><label>4</label><figDesc>Example of AST edit operations.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 5 .</head><label>5</label><figDesc>An example of a path that represents a MOV operation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 6 .</head><label>6</label><figDesc>An example of UPD (update) and INS (insert) operations in the context C.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 8 .</head><label>8</label><figDesc>Visualization of the accuracy score of our model compared to the baselines. The values are the same as in</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 9 .</head><label>9</label><figDesc>The upper figure depicts the accuracy as a function of the context radius size. The lower figure shows the number of examples per radius size in the test set.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 10 .</head><label>10</label><figDesc>The upper figure depicts the accuracy as a function of the number of nodes in P. The lower figure shows the number of examples compared to the number of nodes in P.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 12 .</head><label>12</label><figDesc>An example in which the edit in the context is conceptually similar to the edit of P.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>The main challenge is how to represent edits in a learning model? We look for a representation that is expressive and generalizable. The representation should be expressive, such that different edits are reflected differently; this would allow a model to consider the difference between examples. However, just representing every edit uniquely is not enough, because the representation should also be generalizable, such that similar edits would be reflected similarly. This would allow a model to generalize better, even if the edit that should be predicted at test time does not look exactly like an edit that was observed at training time.</figDesc><table /><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 5</head><label>5</label><figDesc>lists the GitHub repositories we used to create our dataset.</figDesc><table><row><cell>Repository</cell><cell>User</cell><cell>Split</cell></row><row><cell>corefx</cell><cell>dotnet</cell><cell>Train</cell></row><row><cell>shadowsocks-windows</cell><cell>shadowsocks</cell><cell>Train</cell></row><row><cell>CodeHub</cell><cell>CodeHubApp</cell><cell>Train</cell></row><row><cell>coreclr</cell><cell>dotnet</cell><cell>Train</cell></row><row><cell>roslyn</cell><cell>dotnet</cell><cell>Train</cell></row><row><cell>PowerShell</cell><cell>PowerShell</cell><cell>Train</cell></row><row><cell>WaveFunctionCollapse</cell><cell>mxgmn</cell><cell>Train</cell></row><row><cell>SignalR</cell><cell>SignalR</cell><cell>Train</cell></row><row><cell>ShareX</cell><cell>ShareX</cell><cell>Train</cell></row><row><cell>Nancy</cell><cell>NancyFx</cell><cell>Train</cell></row><row><cell>dapper-dot-net</cell><cell>StackExchange</cell><cell>Train</cell></row><row><cell>mono</cell><cell>mono</cell><cell>Train</cell></row><row><cell>Wox</cell><cell>Wox-launcher</cell><cell>Train</cell></row><row><cell>AutoMapper</cell><cell>AutoMapper</cell><cell>Train</cell></row><row><cell>RestSharp</cell><cell>restsharp</cell><cell>Train</cell></row><row><cell>BotBuilder</cell><cell>Microsoft</cell><cell>Train</cell></row><row><cell>SparkleShare</cell><cell>hbons</cell><cell>Train</cell></row><row><cell>Newtonsoft.Json</cell><cell>JamesNK</cell><cell>Train</cell></row><row><cell>MonoGame</cell><cell>MonoGame</cell><cell>Train</cell></row><row><cell cols="3">MaterialDesignInXamlToolkit MaterialDesignInXAML Train</cell></row><row><cell>ReactiveUI</cell><cell>reactiveui</cell><cell>Train</cell></row><row><cell>msbuild</cell><cell>Microsoft</cell><cell>Train</cell></row><row><cell>aspnetboilerplate</cell><cell>aspnetboilerplate</cell><cell>Train</cell></row><row><cell>orleans</cell><cell>dotnet</cell><cell>Train</cell></row><row><cell>Hangfire</cell><cell>HangfireIO</cell><cell>Train</cell></row><row><cell>Sonarr</cell><cell>Sonarr</cell><cell>Train</cell></row><row><cell>dnSpy</cell><cell>0xd4d</cell><cell>Train</cell></row><row><cell>Psychson</cell><cell>brandonlw</cell><cell>Train</cell></row><row><cell>acat</cell><cell>intel</cell><cell>Train</cell></row><row><cell>SpaceEngineers</cell><cell>KeenSoftwareHouse</cell><cell>Train</cell></row><row><cell>PushSharp</cell><cell>Redth</cell><cell>Train</cell></row><row><cell>cli</cell><cell>dotnet</cell><cell>Train</cell></row><row><cell>StackExchange.Redis</cell><cell>StackExchange</cell><cell>Train</cell></row><row><cell>akka.net</cell><cell>akkadotnet</cell><cell>Train</cell></row><row><cell>framework</cell><cell>accord-net</cell><cell>Train</cell></row><row><cell>monodevelop</cell><cell>mono</cell><cell>Train</cell></row><row><cell>Opserver</cell><cell>opserver</cell><cell>Train</cell></row><row><cell>ravendb</cell><cell>ravendb</cell><cell>Train</cell></row><row><cell>OpenLiveWriter</cell><cell>OpenLiveWriter</cell><cell>Validation</cell></row><row><cell>Mvc</cell><cell>aspnet</cell><cell>Validation</cell></row><row><cell>GVFS</cell><cell>Microsoft</cell><cell>Validation</cell></row><row><cell>OpenRA</cell><cell>OpenRA</cell><cell>Validation</cell></row><row><cell>Rx.NET</cell><cell>dotnet</cell><cell>Validation</cell></row><row><cell>MahApps.Metro</cell><cell>MahApps</cell><cell>Validation</cell></row><row><cell>FluentValidation</cell><cell>JeremySkinner</cell><cell>Validation</cell></row><row><cell>ILSpy</cell><cell>icsharpcode</cell><cell>Validation</cell></row><row><cell>ServiceStack</cell><cell>ServiceStack</cell><cell>Test</cell></row><row><cell>choco</cell><cell>chocolatey</cell><cell>Test</cell></row><row><cell>duplicati</cell><cell>duplicati</cell><cell>Test</cell></row><row><cell>CefSharp</cell><cell>cefsharp</cell><cell>Test</cell></row><row><cell>NLog</cell><cell>NLog</cell><cell>Test</cell></row><row><cell>JavaScriptServices</cell><cell>aspnet</cell><cell>Test</cell></row><row><cell>EntityFrameworkCore</cell><cell>aspnet</cell><cell>Test</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 5 .</head><label>5</label><figDesc>Our dataset repositories.</figDesc><table /><note></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1">As opposed to code2vec<ref type="bibr" target="#b8">[Alon et al. 2019c</ref>], our paths can originate from and end in nonterminal nodes.</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Towards String-To-Tree Neural Machine Translation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Roee</forename><surname>Aharoni</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yoav</forename><surname>Goldberg</surname></persName>
		</author>
		<idno type="DOI">10.18653/v1/P17-2021</idno>
		<ptr target="https://doi.org/10.18653/v1/P17-2021" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 55th Annual Meeting of the Association for Computational Linguistics</title>
		<meeting>the 55th Annual Meeting of the Association for Computational Linguistics<address><addrLine>Vancouver, Canada</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computational Linguistics</publisher>
			<date type="published" when="2017" />
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="132" to="140" />
		</imprint>
	</monogr>
	<note>Short Papers)</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">The Adverse Effects of Code Duplication in Machine Learning Models of Code</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Miltiadis</forename><surname>Allamanis</surname></persName>
		</author>
		<idno type="DOI">10.1145/3359591.3359735</idno>
		<ptr target="https://doi.org/10.1145/3359591.3359735" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2019 ACM SIGPLAN International Symposium on New Ideas, New Paradigms, and Reflections on Programming and Software</title>
		<meeting>the 2019 ACM SIGPLAN International Symposium on New Ideas, New Paradigms, and Reflections on Programming and Software<address><addrLine>Athens, Greece; New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2019" />
			<biblScope unit="page" from="143" to="153" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Suggesting Accurate Method and Class Names</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Miltiadis</forename><surname>Allamanis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Earl</forename><forename type="middle">T</forename><surname>Barr</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christian</forename><surname>Bird</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Charles</forename><surname>Sutton</surname></persName>
		</author>
		<idno type="DOI">10.1145/2786805.2786849</idno>
		<ptr target="https://doi.org/10.1145/2786805.2786849" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2015 10th Joint Meeting on Foundations of Software Engineering</title>
		<meeting>the 2015 10th Joint Meeting on Foundations of Software Engineering<address><addrLine>Bergamo, Italy; New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2015" />
			<biblScope unit="page" from="38" to="49" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Learning to Represent Programs with Graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Miltiadis</forename><surname>Allamanis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marc</forename><surname>Brockschmidt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mahmoud</forename><surname>Khademi</surname></persName>
		</author>
		<ptr target="https://openreview.net/forum?id=BJOFETxR-" />
	</analytic>
	<monogr>
		<title level="m">International Conference on Learning Representations</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">A Convolutional Attention Network for Extreme Summarization of Source Code</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Miltiadis</forename><surname>Allamanis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hao</forename><surname>Peng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Charles</forename><surname>Sutton</surname></persName>
		</author>
		<ptr target="http://proceedings.mlr.press/v48/allamanis16.html" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of The 33rd International Conference on Machine Learning (Proceedings of Machine Learning Research</title>
		<editor>Maria Florina Balcan and Kilian Q. Weinberger</editor>
		<meeting>The 33rd International Conference on Machine Learning ( Machine Learning Research<address><addrLine>New York, New York, USA</addrLine></address></meeting>
		<imprint>
			<publisher>PMLR</publisher>
			<date type="published" when="2016" />
			<biblScope unit="volume">48</biblScope>
			<biblScope unit="page" from="2091" to="2100" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Generating Sequences from Structured Representations of Code</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Uri</forename><surname>Alon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shaked</forename><surname>Brody</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Omer</forename><surname>Levy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eran</forename><surname>Yahav</surname></persName>
		</author>
		<ptr target="https://openreview.net/forum?id=H1gKYo09tX" />
	</analytic>
	<monogr>
		<title level="m">International Conference on Learning Representations</title>
		<imprint>
			<date type="published" when="2019" />
			<biblScope unit="volume">2</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Uri</forename><surname>Alon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Roy</forename><surname>Sadaka</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Omer</forename><surname>Levy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eran</forename><surname>Yahav</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1910.00577</idno>
		<title level="m">Structural Language Models of Code</title>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
	<note>cs.LG</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">A general path-based representation for predicting program properties</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Uri</forename><surname>Alon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Meital</forename><surname>Zilberstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Omer</forename><surname>Levy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eran</forename><surname>Yahav</surname></persName>
		</author>
		<idno type="DOI">10.1145/3192366.3192412</idno>
		<ptr target="https://doi.org/10.1145/3192366.3192412" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 39th ACM SIGPLAN Conference on Programming Language Design and Implementation -PLDI 2018</title>
		<meeting>the 39th ACM SIGPLAN Conference on Programming Language Design and Implementation -PLDI 2018</meeting>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Code2vec: Learning Distributed Representations of Code</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Uri</forename><surname>Alon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Meital</forename><surname>Zilberstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Omer</forename><surname>Levy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eran</forename><surname>Yahav</surname></persName>
		</author>
		<idno type="DOI">10.1145/3290353</idno>
		<ptr target="https://doi.org/10.1145/3290353" />
	</analytic>
	<monogr>
		<title level="m">Proc. ACM Program. Lang. 3, POPL, Article</title>
		<meeting>ACM Program. Lang. 3, POPL, Article</meeting>
		<imprint>
			<date type="published" when="2019-01" />
			<biblScope unit="volume">40</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Neural machine translation by jointly learning to align and translate</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dzmitry</forename><surname>Bahdanau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kyunghyun</forename><surname>Cho</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yoshua</forename><surname>Bengio</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1409.0473</idno>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">PairWise and SearchWise: Finding the Optimal Alignment in a Simultaneous Comparison of a</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ewan</forename><surname>Birney</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Julie</forename><forename type="middle">D</forename><surname>Thompson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Toby</forename><forename type="middle">J</forename><surname>Gibson</surname></persName>
		</author>
		<idno type="DOI">10.1093/nar/24.14.2730</idno>
		<ptr target="https://academic.oup.com/nar/article-pdf/24/14/2730/7064078/24-14-2730.pdf" />
	</analytic>
	<monogr>
		<title level="j">Protein Profile against All DNA Translation Frames. Nucleic Acids Research</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="2730" to="2739" />
			<date type="published" when="1996-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Generative Code Modeling with Graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marc</forename><surname>Brockschmidt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Miltiadis</forename><surname>Allamanis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alexander</forename><forename type="middle">L</forename><surname>Gaunt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Oleksandr</forename><surname>Polozov</surname></persName>
		</author>
		<ptr target="https://openreview.net/forum?id=Bke4KsA5FX" />
	</analytic>
	<monogr>
		<title level="m">International Conference on Learning Representations</title>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Tree2Tree Neural Translation Model for Learning Source Code Changes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Saikat</forename><surname>Chakraborty</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Miltiadis</forename><surname>Allamanis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Baishakhi</forename><surname>Ray</surname></persName>
		</author>
		<idno>abs/1810.00314</idno>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Listen, attend and spell: A neural network for large vocabulary conversational speech recognition</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">William</forename><surname>Chan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Navdeep</forename><surname>Jaitly</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Quoc</forename><surname>Le</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Oriol</forename><surname>Vinyals</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2016 IEEE International Conference on Acoustics, Speech and Signal Processing (ICASSP)</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2016" />
			<biblScope unit="page" from="4960" to="4964" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Sudarshan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Anand</forename><surname>Chawathe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hector</forename><surname>Rajaraman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jennifer</forename><surname>Garcia-Molina</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Widom</surname></persName>
		</author>
		<idno type="DOI">10.1145/235968.233366</idno>
		<ptr target="https://doi.org/10.1145/235968.233366" />
	</analytic>
	<monogr>
		<title level="j">Change Detection in Hierarchically Structured Information. SIGMOD Rec</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="493" to="504" />
			<date type="published" when="1996-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">SequenceR: Sequence-to-Sequence Learning for End-to-End Program Repair</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zimin</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Steve</forename><surname>Kommrusch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michele</forename><surname>Tufano</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1901.01808</idno>
		<ptr target="http://arxiv.org/abs/1901.01808" />
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
	<note>Louis-No?l Pouchet, Denys Poshyvanyk, and Martin Monperrus</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">HOPPITY: LEARNING GRAPH TRANSFORMATIONS TO DETECT AND FIX BUGS IN PROGRAMS</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Elizabeth</forename><surname>Dinella</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hanjun</forename><surname>Dai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ziyang</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mayur</forename><surname>Naik</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Le</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ke</forename><surname>Wang</surname></persName>
		</author>
		<ptr target="https://openreview.net/forum?id=SJeqs6EFvB" />
	</analytic>
	<monogr>
		<title level="m">International Conference on Learning Representations</title>
		<imprint>
			<date type="published" when="2020" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Fine-grained and accurate source code differencing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jean-R?my</forename><surname>Falleri</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Flor?al</forename><surname>Morandat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xavier</forename><surname>Blanc</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Matias</forename><surname>Martinez</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Martin</forename><surname>Monperrus</surname></persName>
		</author>
		<idno type="DOI">10.1145/2642937.2642982</idno>
		<ptr target="https://doi.org/10.1145/2642937.2642982" />
	</analytic>
	<monogr>
		<title level="m">ACM/IEEE International Conference on Automated Software Engineering, ASE &apos;14</title>
		<meeting><address><addrLine>Vasteras, Sweden</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014-09-15" />
			<biblScope unit="page" from="313" to="324" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Structured Neural Summarization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Patrick</forename><surname>Fernandes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Miltiadis</forename><surname>Allamanis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marc</forename><surname>Brockschmidt</surname></persName>
		</author>
		<ptr target="https://openreview.net/forum?id=H1ersoRqtm" />
	</analytic>
	<monogr>
		<title level="m">International Conference on Learning Representations</title>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Incorporating Copying Mechanism in Sequence-to-Sequence Learning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jiatao</forename><surname>Gu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhengdong</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hang</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><forename type="middle">K</forename><surname>Victor</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Li</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1603.06393</idno>
		<ptr target="http://arxiv.org/abs/1603.06393" />
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Global Relational Models of Source Code</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Vincent</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Charles</forename><surname>Hellendoorn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rishabh</forename><surname>Sutton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Petros</forename><surname>Singh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Maniatis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Bieber</surname></persName>
		</author>
		<ptr target="https://openreview.net/forum?id=B1lnbRNtwr" />
	</analytic>
	<monogr>
		<title level="m">International Conference on Learning Representations</title>
		<imprint>
			<date type="published" when="2020" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">Improving neural networks by preventing co-adaptation of feature detectors</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Geoffrey</forename><forename type="middle">E</forename><surname>Hinton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nitish</forename><surname>Srivastava</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alex</forename><surname>Krizhevsky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ilya</forename><surname>Sutskever</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ruslan</forename><surname>Salakhutdinov</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1207.0580</idno>
		<ptr target="http://arxiv.org/abs/1207.0580" />
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thong</forename><surname>Hoang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hong</forename><forename type="middle">Jin</forename><surname>Kang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Julia</forename><surname>Lawall</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Lo</surname></persName>
		</author>
		<idno type="arXiv">arXiv:2003.05620</idno>
		<title level="m">CC2Vec: Distributed Representations of Code Changes</title>
		<imprint>
			<date type="published" when="2020" />
		</imprint>
	</monogr>
	<note>cs.SE</note>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Long Short-Term Memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sepp</forename><surname>Hochreiter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J?rgen</forename><surname>Schmidhuber</surname></persName>
		</author>
		<idno type="DOI">10.1162/neco.1997.9.8.1735</idno>
		<ptr target="https://doi.org/10.1162/neco.1997.9.8.1735" />
	</analytic>
	<monogr>
		<title level="j">Neural Comput</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="1735" to="1780" />
			<date type="published" when="1997-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">An algorithm for differential file comparison</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><forename type="middle">W</forename><surname>Hunt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">Douglas</forename><surname>Mcilroy</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1975" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Summarizing Source Code using a Neural Attention Model</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Srinivasan</forename><surname>Iyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ioannis</forename><surname>Konstas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alvin</forename><surname>Cheung</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Luke</forename><surname>Zettlemoyer</surname></persName>
		</author>
		<idno type="DOI">10.18653/v1/P16-1195</idno>
		<ptr target="https://doi.org/10.18653/v1/P16-1195" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 54th Annual Meeting of the Association for Computational Linguistics</title>
		<meeting>the 54th Annual Meeting of the Association for Computational Linguistics<address><addrLine>Berlin, Germany</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computational Linguistics</publisher>
			<date type="published" when="2016" />
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="2073" to="2083" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Adam: A Method for Stochastic Optimization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Diederik</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jimmy</forename><surname>Kingma</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Ba</surname></persName>
		</author>
		<idno>arxiv:1412.6980Comment</idno>
		<ptr target="http://arxiv.org/abs/1412.6980cite" />
	</analytic>
	<monogr>
		<title level="m">the 3rd International Conference for Learning Representations</title>
		<meeting><address><addrLine>San Diego</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
	<note>Published as a conference paper at</note>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">D?j?Vu: a map of code duplicates on GitHub</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Cristina</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Petr</forename><surname>Lopes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pedro</forename><surname>Maj</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vaibhav</forename><surname>Martins</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Di</forename><surname>Saini</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jakub</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hitesh</forename><surname>Zitny</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Sajnani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proceedings of the ACM on Programming Languages</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="1" to="28" />
			<date type="published" when="2017-01" />
		</imprint>
	</monogr>
	<note>OOPSLA</note>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">Effective Approaches to Attention-based Neural Machine Translation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Minh-Thang</forename><surname>Luong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hieu</forename><surname>Pham</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christopher</forename><forename type="middle">D</forename><surname>Manning</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1508.04025</idno>
		<ptr target="http://arxiv.org/abs/1508.04025" />
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">End-to-end Sequence Labeling via Bi-directional LSTM-CNNs-CRF</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xuezhe</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eduard</forename><surname>Hovy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 54th Annual Meeting of the Association for Computational Linguistics</title>
		<meeting>the 54th Annual Meeting of the Association for Computational Linguistics</meeting>
		<imprint>
			<publisher>Long Papers</publisher>
			<date type="published" when="2016" />
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="1064" to="1074" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Encode, Tag, Realize: High-Precision Text Editing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eric</forename><surname>Malmi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sebastian</forename><surname>Krause</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sascha</forename><surname>Rothe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniil</forename><surname>Mirylenka</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Aliaksei</forename><surname>Severyn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EMNLP-IJCNLP</title>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">DeepDelta: learning to repair compilation errors</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ali</forename><surname>Mesbah</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrew</forename><surname>Rice</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Emily</forename><surname>Johnston</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nick</forename><surname>Glorioso</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Edward</forename><surname>Aftandilian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2019 27th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering</title>
		<meeting>the 2019 27th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering</meeting>
		<imprint>
			<date type="published" when="2019" />
			<biblScope unit="page" from="925" to="936" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">The cross-entropy method for combinatorial and continuous optimization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Reuven</forename><surname>Rubinstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Methodology and Computing in Applied Probability</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="127" to="190" />
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title level="m" type="main">Sequence to Sequence Learning with Neural Networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ilya</forename><surname>Sutskever</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Oriol</forename><surname>Vinyals</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Quoc</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Le</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1409.3215</idno>
		<ptr target="http://arxiv.org/abs/1409.3215" />
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Tarlow</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Subhodeep</forename><surname>Moitra</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrew</forename><surname>Rice</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zimin</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pierre-Antoine</forename><surname>Manzagol</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Charles</forename><surname>Sutton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Edward</forename><surname>Aftandilian</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1911.01205</idno>
		<title level="m">Learning to Fix Build Errors with Graph2Diff Neural Networks</title>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
	<note>cs.LG</note>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<title level="m" type="main">An Empirical Study on Learning Bug-Fixing Patches in the Wild via Neural Machine Translation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michele</forename><surname>Tufano</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cody</forename><surname>Watson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gabriele</forename><surname>Bavota</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Massimiliano</forename><forename type="middle">Di</forename><surname>Penta</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Martin</forename><surname>White</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Denys</forename><surname>Poshyvanyk</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1812.08693</idno>
		<ptr target="http://arxiv.org/abs/1812.08693" />
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Neural Program Repair by Jointly Learning to Localize and Repair</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marko</forename><surname>Vasic</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Aditya</forename><surname>Kanade</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Petros</forename><surname>Maniatis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Bieber</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rishabh</forename><surname>Singh</surname></persName>
		</author>
		<ptr target="https://openreview.net/forum?id=ByloJ20qtm" />
	</analytic>
	<monogr>
		<title level="m">International Conference on Learning Representations</title>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Attention is All you Need</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ashish</forename><surname>Vaswani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Noam</forename><surname>Shazeer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Niki</forename><surname>Parmar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jakob</forename><surname>Uszkoreit</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Llion</forename><surname>Jones</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Aidan</forename><forename type="middle">N</forename><surname>Gomez</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Illia</forename><surname>Kaiser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Polosukhin</surname></persName>
		</author>
		<ptr target="http://papers.nips.cc/paper/7181-attention-is-all-you-need.pdf" />
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems</title>
		<editor>I. Guyon, U. V. Luxburg, S. Bengio, H. Wallach, R. Fergus, S. Vishwanathan, and R. Garnett</editor>
		<imprint>
			<publisher>Curran Associates, Inc</publisher>
			<date type="published" when="2017" />
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="5998" to="6008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Oriol</forename><surname>Vinyals</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Meire</forename><surname>Fortunato</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Navdeep</forename><surname>Jaitly</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1506.03134</idno>
		<imprint>
			<date type="published" when="2015" />
			<publisher>Pointer Networks</publisher>
		</imprint>
	</monogr>
	<note>stat.ML</note>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Learning to Represent Edits</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pengcheng</forename><surname>Yin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Graham</forename><surname>Neubig</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Miltiadis</forename><surname>Allamanis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marc</forename><surname>Brockschmidt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alexander</forename><forename type="middle">L</forename><surname>Gaunt</surname></persName>
		</author>
		<ptr target="https://openreview.net/forum?id=BJl6AjC5F7" />
	</analytic>
	<monogr>
		<title level="m">International Conference on Learning Representations</title>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
